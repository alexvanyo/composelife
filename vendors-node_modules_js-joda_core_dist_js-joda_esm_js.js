"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(globalThis["webpackChunkweb_app"] = globalThis["webpackChunkweb_app"] || []).push([["vendors-node_modules_js-joda_core_dist_js-joda_esm_js"],{

/***/ "../../node_modules/@js-joda/core/dist/js-joda.esm.js":
/*!************************************************************!*\
  !*** ../../node_modules/@js-joda/core/dist/js-joda.esm.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ArithmeticException: () => (/* binding */ ArithmeticException),\n/* harmony export */   ChronoField: () => (/* binding */ ChronoField),\n/* harmony export */   ChronoLocalDate: () => (/* binding */ ChronoLocalDate),\n/* harmony export */   ChronoLocalDateTime: () => (/* binding */ ChronoLocalDateTime),\n/* harmony export */   ChronoUnit: () => (/* binding */ ChronoUnit),\n/* harmony export */   ChronoZonedDateTime: () => (/* binding */ ChronoZonedDateTime),\n/* harmony export */   Clock: () => (/* binding */ Clock),\n/* harmony export */   DateTimeException: () => (/* binding */ DateTimeException),\n/* harmony export */   DateTimeFormatter: () => (/* binding */ DateTimeFormatter),\n/* harmony export */   DateTimeFormatterBuilder: () => (/* binding */ DateTimeFormatterBuilder),\n/* harmony export */   DateTimeParseException: () => (/* binding */ DateTimeParseException),\n/* harmony export */   DayOfWeek: () => (/* binding */ DayOfWeek),\n/* harmony export */   DecimalStyle: () => (/* binding */ DecimalStyle),\n/* harmony export */   Duration: () => (/* binding */ Duration),\n/* harmony export */   IllegalArgumentException: () => (/* binding */ IllegalArgumentException),\n/* harmony export */   IllegalStateException: () => (/* binding */ IllegalStateException),\n/* harmony export */   Instant: () => (/* binding */ Instant),\n/* harmony export */   IsoChronology: () => (/* binding */ IsoChronology),\n/* harmony export */   IsoFields: () => (/* binding */ IsoFields),\n/* harmony export */   LocalDate: () => (/* binding */ LocalDate),\n/* harmony export */   LocalDateTime: () => (/* binding */ LocalDateTime),\n/* harmony export */   LocalTime: () => (/* binding */ LocalTime),\n/* harmony export */   Month: () => (/* binding */ Month),\n/* harmony export */   MonthDay: () => (/* binding */ MonthDay),\n/* harmony export */   NullPointerException: () => (/* binding */ NullPointerException),\n/* harmony export */   OffsetDateTime: () => (/* binding */ OffsetDateTime),\n/* harmony export */   OffsetTime: () => (/* binding */ OffsetTime),\n/* harmony export */   Period: () => (/* binding */ Period),\n/* harmony export */   ResolverStyle: () => (/* binding */ ResolverStyle),\n/* harmony export */   SignStyle: () => (/* binding */ SignStyle),\n/* harmony export */   Temporal: () => (/* binding */ Temporal),\n/* harmony export */   TemporalAccessor: () => (/* binding */ TemporalAccessor),\n/* harmony export */   TemporalAdjuster: () => (/* binding */ TemporalAdjuster),\n/* harmony export */   TemporalAdjusters: () => (/* binding */ TemporalAdjusters),\n/* harmony export */   TemporalAmount: () => (/* binding */ TemporalAmount),\n/* harmony export */   TemporalField: () => (/* binding */ TemporalField),\n/* harmony export */   TemporalQueries: () => (/* binding */ TemporalQueries),\n/* harmony export */   TemporalQuery: () => (/* binding */ TemporalQuery),\n/* harmony export */   TemporalUnit: () => (/* binding */ TemporalUnit),\n/* harmony export */   TextStyle: () => (/* binding */ TextStyle),\n/* harmony export */   UnsupportedTemporalTypeException: () => (/* binding */ UnsupportedTemporalTypeException),\n/* harmony export */   ValueRange: () => (/* binding */ ValueRange),\n/* harmony export */   Year: () => (/* binding */ Year),\n/* harmony export */   YearConstants: () => (/* binding */ YearConstants),\n/* harmony export */   YearMonth: () => (/* binding */ YearMonth),\n/* harmony export */   ZoneId: () => (/* binding */ ZoneId),\n/* harmony export */   ZoneOffset: () => (/* binding */ ZoneOffset),\n/* harmony export */   ZoneOffsetTransition: () => (/* binding */ ZoneOffsetTransition),\n/* harmony export */   ZoneRegion: () => (/* binding */ ZoneRegion),\n/* harmony export */   ZoneRules: () => (/* binding */ ZoneRules),\n/* harmony export */   ZoneRulesProvider: () => (/* binding */ ZoneRulesProvider),\n/* harmony export */   ZonedDateTime: () => (/* binding */ ZonedDateTime),\n/* harmony export */   _: () => (/* binding */ _),\n/* harmony export */   convert: () => (/* binding */ convert),\n/* harmony export */   nativeJs: () => (/* binding */ nativeJs),\n/* harmony export */   use: () => (/* binding */ use)\n/* harmony export */ });\n//! @version @js-joda/core - 3.2.0\n//! @copyright (c) 2015-present, Philipp Thürwächter, Pattrick Hüper & js-joda contributors\n//! @copyright (c) 2007-present, Stephen Colebourne & Michael Nascimento Santos\n//! @license BSD-3-Clause (see LICENSE in the root directory of this source tree)\n\n/**\n * @copyright (c) 2016, Philipp Thürwächter & Pattrick Hüper\n * @license BSD-3-Clause (see LICENSE in the root directory of this source tree)\n */\nfunction createErrorType(name, init, superErrorClass) {\n  if (superErrorClass === void 0) {\n    superErrorClass = Error;\n  }\n\n  function JsJodaException(message) {\n    if (!Error.captureStackTrace) {\n      this.stack = new Error().stack;\n    } else {\n      Error.captureStackTrace(this, this.constructor);\n    }\n\n    this.message = message;\n    init && init.apply(this, arguments);\n\n    this.toString = function () {\n      return this.name + \": \" + this.message;\n    };\n  }\n\n  JsJodaException.prototype = Object.create(superErrorClass.prototype);\n  JsJodaException.prototype.name = name;\n  JsJodaException.prototype.constructor = JsJodaException;\n  return JsJodaException;\n}\n\nvar DateTimeException = createErrorType('DateTimeException', messageWithCause);\nvar DateTimeParseException = createErrorType('DateTimeParseException', messageForDateTimeParseException);\nvar UnsupportedTemporalTypeException = createErrorType('UnsupportedTemporalTypeException', null, DateTimeException);\nvar ArithmeticException = createErrorType('ArithmeticException');\nvar IllegalArgumentException = createErrorType('IllegalArgumentException');\nvar IllegalStateException = createErrorType('IllegalStateException');\nvar NullPointerException = createErrorType('NullPointerException');\n\nfunction messageWithCause(message, cause) {\n  if (cause === void 0) {\n    cause = null;\n  }\n\n  var msg = message || this.name;\n\n  if (cause !== null && cause instanceof Error) {\n    msg += '\\n-------\\nCaused by: ' + cause.stack + '\\n-------\\n';\n  }\n\n  this.message = msg;\n}\n\nfunction messageForDateTimeParseException(message, text, index, cause) {\n  if (text === void 0) {\n    text = '';\n  }\n\n  if (index === void 0) {\n    index = 0;\n  }\n\n  if (cause === void 0) {\n    cause = null;\n  }\n\n  var msg = message || this.name;\n  msg += ': ' + text + ', at index: ' + index;\n\n  if (cause !== null && cause instanceof Error) {\n    msg += '\\n-------\\nCaused by: ' + cause.stack + '\\n-------\\n';\n  }\n\n  this.message = msg;\n\n  this.parsedString = function () {\n    return text;\n  };\n\n  this.errorIndex = function () {\n    return index;\n  };\n}\n\nfunction _inheritsLoose(subClass, superClass) {\n  subClass.prototype = Object.create(superClass.prototype);\n  subClass.prototype.constructor = subClass;\n  subClass.__proto__ = superClass;\n}\n\nfunction _assertThisInitialized(self) {\n  if (self === void 0) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return self;\n}\n\n/**\n * @copyright (c) 2016, Philipp Thürwächter & Pattrick Hüper\n * @license BSD-3-Clause (see LICENSE in the root directory of this source tree)\n */\nfunction assert(assertion, msg, error) {\n  if (!assertion) {\n    if (error) {\n      throw new error(msg);\n    } else {\n      throw new Error(msg);\n    }\n  }\n}\nfunction requireNonNull(value, parameterName) {\n  if (value == null) {\n    throw new NullPointerException(parameterName + ' must not be null');\n  }\n\n  return value;\n}\nfunction requireInstance(value, _class, parameterName) {\n  if (!(value instanceof _class)) {\n    throw new IllegalArgumentException(parameterName + ' must be an instance of ' + (_class.name ? _class.name : _class) + (value && value.constructor && value.constructor.name ? ', but is ' + value.constructor.name : ''));\n  }\n\n  return value;\n}\nfunction abstractMethodFail(methodName) {\n  throw new TypeError('abstract method \"' + methodName + '\" is not implemented');\n}\n\nvar assert$1 = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    assert: assert,\n    requireNonNull: requireNonNull,\n    requireInstance: requireInstance,\n    abstractMethodFail: abstractMethodFail\n});\n\n/**\n * @copyright (c) 2016, Philipp Thürwächter & Pattrick Hüper\n * @copyright (c) 2007-present, Stephen Colebourne & Michael Nascimento Santos\n * @license BSD-3-Clause (see LICENSE in the root directory of this source tree)\n */\nvar MAX_SAFE_INTEGER = 9007199254740991;\nvar MIN_SAFE_INTEGER = -9007199254740991;\nvar MathUtil = function () {\n  function MathUtil() {}\n\n  MathUtil.intDiv = function intDiv(x, y) {\n    var r = x / y;\n    r = MathUtil.roundDown(r);\n    return MathUtil.safeZero(r);\n  };\n\n  MathUtil.intMod = function intMod(x, y) {\n    var r = x - MathUtil.intDiv(x, y) * y;\n    r = MathUtil.roundDown(r);\n    return MathUtil.safeZero(r);\n  };\n\n  MathUtil.roundDown = function roundDown(r) {\n    if (r < 0) {\n      return Math.ceil(r);\n    } else {\n      return Math.floor(r);\n    }\n  };\n\n  MathUtil.floorDiv = function floorDiv(x, y) {\n    var r = Math.floor(x / y);\n    return MathUtil.safeZero(r);\n  };\n\n  MathUtil.floorMod = function floorMod(x, y) {\n    var r = x - MathUtil.floorDiv(x, y) * y;\n    return MathUtil.safeZero(r);\n  };\n\n  MathUtil.safeAdd = function safeAdd(x, y) {\n    MathUtil.verifyInt(x);\n    MathUtil.verifyInt(y);\n\n    if (x === 0) {\n      return MathUtil.safeZero(y);\n    }\n\n    if (y === 0) {\n      return MathUtil.safeZero(x);\n    }\n\n    var r = MathUtil.safeToInt(x + y);\n\n    if (r === x || r === y) {\n      throw new ArithmeticException('Invalid addition beyond MAX_SAFE_INTEGER!');\n    }\n\n    return r;\n  };\n\n  MathUtil.safeSubtract = function safeSubtract(x, y) {\n    MathUtil.verifyInt(x);\n    MathUtil.verifyInt(y);\n\n    if (x === 0 && y === 0) {\n      return 0;\n    } else if (x === 0) {\n      return MathUtil.safeZero(-1 * y);\n    } else if (y === 0) {\n      return MathUtil.safeZero(x);\n    }\n\n    return MathUtil.safeToInt(x - y);\n  };\n\n  MathUtil.safeMultiply = function safeMultiply(x, y) {\n    MathUtil.verifyInt(x);\n    MathUtil.verifyInt(y);\n\n    if (x === 1) {\n      return MathUtil.safeZero(y);\n    }\n\n    if (y === 1) {\n      return MathUtil.safeZero(x);\n    }\n\n    if (x === 0 || y === 0) {\n      return 0;\n    }\n\n    var r = MathUtil.safeToInt(x * y);\n\n    if (r / y !== x || x === MIN_SAFE_INTEGER && y === -1 || y === MIN_SAFE_INTEGER && x === -1) {\n      throw new ArithmeticException('Multiplication overflows: ' + x + ' * ' + y);\n    }\n\n    return r;\n  };\n\n  MathUtil.parseInt = function (_parseInt) {\n    function parseInt(_x) {\n      return _parseInt.apply(this, arguments);\n    }\n\n    parseInt.toString = function () {\n      return _parseInt.toString();\n    };\n\n    return parseInt;\n  }(function (value) {\n    var r = parseInt(value);\n    return MathUtil.safeToInt(r);\n  });\n\n  MathUtil.safeToInt = function safeToInt(value) {\n    MathUtil.verifyInt(value);\n    return MathUtil.safeZero(value);\n  };\n\n  MathUtil.verifyInt = function verifyInt(value) {\n    if (value == null) {\n      throw new ArithmeticException(\"Invalid value: '\" + value + \"', using null or undefined as argument\");\n    }\n\n    if (isNaN(value)) {\n      throw new ArithmeticException('Invalid int value, using NaN as argument');\n    }\n\n    if (value % 1 !== 0) {\n      throw new ArithmeticException(\"Invalid value: '\" + value + \"' is a float\");\n    }\n\n    if (value > MAX_SAFE_INTEGER || value < MIN_SAFE_INTEGER) {\n      throw new ArithmeticException('Calculation overflows an int: ' + value);\n    }\n  };\n\n  MathUtil.safeZero = function safeZero(value) {\n    return value === 0 ? 0 : +value;\n  };\n\n  MathUtil.compareNumbers = function compareNumbers(a, b) {\n    if (a < b) {\n      return -1;\n    }\n\n    if (a > b) {\n      return 1;\n    }\n\n    return 0;\n  };\n\n  MathUtil.smi = function smi(int) {\n    return int >>> 1 & 0x40000000 | int & 0xBFFFFFFF;\n  };\n\n  MathUtil.hash = function hash(number) {\n    if (number !== number || number === Infinity) {\n      return 0;\n    }\n\n    var result = number;\n\n    while (number > 0xFFFFFFFF) {\n      number /= 0xFFFFFFFF;\n      result ^= number;\n    }\n\n    return MathUtil.smi(result);\n  };\n\n  MathUtil.hashCode = function hashCode() {\n    var result = 17;\n\n    for (var _len = arguments.length, numbers = new Array(_len), _key = 0; _key < _len; _key++) {\n      numbers[_key] = arguments[_key];\n    }\n\n    for (var _i = 0, _numbers = numbers; _i < _numbers.length; _i++) {\n      var n = _numbers[_i];\n      result = (result << 5) - result + MathUtil.hash(n);\n    }\n\n    return MathUtil.hash(result);\n  };\n\n  return MathUtil;\n}();\nMathUtil.MAX_SAFE_INTEGER = MAX_SAFE_INTEGER;\nMathUtil.MIN_SAFE_INTEGER = MIN_SAFE_INTEGER;\n\n/**\n * @copyright (c) 2016, Philipp Thürwächter & Pattrick Hüper\n * @license BSD-3-Clause (see LICENSE in the root directory of this source tree)\n */\nvar Enum = function () {\n  function Enum(name) {\n    this._name = name;\n  }\n\n  var _proto = Enum.prototype;\n\n  _proto.equals = function equals(other) {\n    return this === other;\n  };\n\n  _proto.toString = function toString() {\n    return this._name;\n  };\n\n  _proto.toJSON = function toJSON() {\n    return this.toString();\n  };\n\n  return Enum;\n}();\n\n/*\n * @copyright (c) 2016, Philipp Thürwächter & Pattrick Hüper\n * @copyright (c) 2007-present, Stephen Colebourne & Michael Nascimento Santos\n * @license BSD-3-Clause (see LICENSE in the root directory of this source tree)\n */\nvar TemporalAmount = function () {\n  function TemporalAmount() {}\n\n  var _proto = TemporalAmount.prototype;\n\n  _proto.get = function get(unit) {\n    abstractMethodFail('get');\n  };\n\n  _proto.units = function units() {\n    abstractMethodFail('units');\n  };\n\n  _proto.addTo = function addTo(temporal) {\n    abstractMethodFail('addTo');\n  };\n\n  _proto.subtractFrom = function subtractFrom(temporal) {\n    abstractMethodFail('subtractFrom');\n  };\n\n  return TemporalAmount;\n}();\n\n/*\n * @copyright (c) 2016, Philipp Thürwächter & Pattrick Hüper\n * @copyright (c) 2007-present, Stephen Colebourne & Michael Nascimento Santos\n * @license BSD-3-Clause (see LICENSE in the root directory of this source tree)\n */\nvar TemporalUnit = function () {\n  function TemporalUnit() {}\n\n  var _proto = TemporalUnit.prototype;\n\n  _proto.duration = function duration() {\n    abstractMethodFail('duration');\n  };\n\n  _proto.isDurationEstimated = function isDurationEstimated() {\n    abstractMethodFail('isDurationEstimated');\n  };\n\n  _proto.isDateBased = function isDateBased() {\n    abstractMethodFail('isDateBased');\n  };\n\n  _proto.isTimeBased = function isTimeBased() {\n    abstractMethodFail('isTimeBased');\n  };\n\n  _proto.isSupportedBy = function isSupportedBy(temporal) {\n    abstractMethodFail('isSupportedBy');\n  };\n\n  _proto.addTo = function addTo(dateTime, periodToAdd) {\n    abstractMethodFail('addTo');\n  };\n\n  _proto.between = function between(temporal1, temporal2) {\n    abstractMethodFail('between');\n  };\n\n  return TemporalUnit;\n}();\n\nvar Duration = function (_TemporalAmount) {\n  _inheritsLoose(Duration, _TemporalAmount);\n\n  function Duration(seconds, nanos) {\n    var _this;\n\n    _this = _TemporalAmount.call(this) || this;\n    _this._seconds = MathUtil.safeToInt(seconds);\n    _this._nanos = MathUtil.safeToInt(nanos);\n    return _this;\n  }\n\n  Duration.ofDays = function ofDays(days) {\n    return Duration._create(MathUtil.safeMultiply(days, LocalTime.SECONDS_PER_DAY), 0);\n  };\n\n  Duration.ofHours = function ofHours(hours) {\n    return Duration._create(MathUtil.safeMultiply(hours, LocalTime.SECONDS_PER_HOUR), 0);\n  };\n\n  Duration.ofMinutes = function ofMinutes(minutes) {\n    return Duration._create(MathUtil.safeMultiply(minutes, LocalTime.SECONDS_PER_MINUTE), 0);\n  };\n\n  Duration.ofSeconds = function ofSeconds(seconds, nanoAdjustment) {\n    if (nanoAdjustment === void 0) {\n      nanoAdjustment = 0;\n    }\n\n    var secs = MathUtil.safeAdd(seconds, MathUtil.floorDiv(nanoAdjustment, LocalTime.NANOS_PER_SECOND));\n    var nos = MathUtil.floorMod(nanoAdjustment, LocalTime.NANOS_PER_SECOND);\n    return Duration._create(secs, nos);\n  };\n\n  Duration.ofMillis = function ofMillis(millis) {\n    var secs = MathUtil.intDiv(millis, 1000);\n    var mos = MathUtil.intMod(millis, 1000);\n\n    if (mos < 0) {\n      mos += 1000;\n      secs--;\n    }\n\n    return Duration._create(secs, mos * 1000000);\n  };\n\n  Duration.ofNanos = function ofNanos(nanos) {\n    var secs = MathUtil.intDiv(nanos, LocalTime.NANOS_PER_SECOND);\n    var nos = MathUtil.intMod(nanos, LocalTime.NANOS_PER_SECOND);\n\n    if (nos < 0) {\n      nos += LocalTime.NANOS_PER_SECOND;\n      secs--;\n    }\n\n    return this._create(secs, nos);\n  };\n\n  Duration.of = function of(amount, unit) {\n    return Duration.ZERO.plus(amount, unit);\n  };\n\n  Duration.from = function from(amount) {\n    requireNonNull(amount, 'amount');\n    requireInstance(amount, TemporalAmount);\n    var duration = Duration.ZERO;\n    amount.units().forEach(function (unit) {\n      duration = duration.plus(amount.get(unit), unit);\n    });\n    return duration;\n  };\n\n  Duration.between = function between(startInclusive, endExclusive) {\n    requireNonNull(startInclusive, 'startInclusive');\n    requireNonNull(endExclusive, 'endExclusive');\n    var secs = startInclusive.until(endExclusive, ChronoUnit.SECONDS);\n    var nanos = 0;\n\n    if (startInclusive.isSupported(ChronoField.NANO_OF_SECOND) && endExclusive.isSupported(ChronoField.NANO_OF_SECOND)) {\n      try {\n        var startNos = startInclusive.getLong(ChronoField.NANO_OF_SECOND);\n        nanos = endExclusive.getLong(ChronoField.NANO_OF_SECOND) - startNos;\n\n        if (secs > 0 && nanos < 0) {\n          nanos += LocalTime.NANOS_PER_SECOND;\n        } else if (secs < 0 && nanos > 0) {\n          nanos -= LocalTime.NANOS_PER_SECOND;\n        } else if (secs === 0 && nanos !== 0) {\n          var adjustedEnd = endExclusive.with(ChronoField.NANO_OF_SECOND, startNos);\n          secs = startInclusive.until(adjustedEnd, ChronoUnit.SECONDS);\n        }\n      } catch (e) {}\n    }\n\n    return this.ofSeconds(secs, nanos);\n  };\n\n  Duration.parse = function parse(text) {\n    requireNonNull(text, 'text');\n    var PATTERN = new RegExp('([-+]?)P(?:([-+]?[0-9]+)D)?(T(?:([-+]?[0-9]+)H)?(?:([-+]?[0-9]+)M)?(?:([-+]?[0-9]+)(?:[.,]([0-9]{0,9}))?S)?)?', 'i');\n    var matches = PATTERN.exec(text);\n\n    if (matches !== null) {\n      if ('T' === matches[3] === false) {\n        var negate = '-' === matches[1];\n        var dayMatch = matches[2];\n        var hourMatch = matches[4];\n        var minuteMatch = matches[5];\n        var secondMatch = matches[6];\n        var fractionMatch = matches[7];\n\n        if (dayMatch != null || hourMatch != null || minuteMatch != null || secondMatch != null) {\n          var daysAsSecs = Duration._parseNumber(text, dayMatch, LocalTime.SECONDS_PER_DAY, 'days');\n\n          var hoursAsSecs = Duration._parseNumber(text, hourMatch, LocalTime.SECONDS_PER_HOUR, 'hours');\n\n          var minsAsSecs = Duration._parseNumber(text, minuteMatch, LocalTime.SECONDS_PER_MINUTE, 'minutes');\n\n          var seconds = Duration._parseNumber(text, secondMatch, 1, 'seconds');\n\n          var negativeSecs = secondMatch != null && secondMatch.charAt(0) === '-';\n\n          var nanos = Duration._parseFraction(text, fractionMatch, negativeSecs ? -1 : 1);\n\n          try {\n            return Duration._create(negate, daysAsSecs, hoursAsSecs, minsAsSecs, seconds, nanos);\n          } catch (ex) {\n            throw new DateTimeParseException('Text cannot be parsed to a Duration: overflow', text, 0, ex);\n          }\n        }\n      }\n    }\n\n    throw new DateTimeParseException('Text cannot be parsed to a Duration', text, 0);\n  };\n\n  Duration._parseNumber = function _parseNumber(text, parsed, multiplier, errorText) {\n    if (parsed == null) {\n      return 0;\n    }\n\n    try {\n      if (parsed[0] === '+') {\n        parsed = parsed.substring(1);\n      }\n\n      return MathUtil.safeMultiply(parseFloat(parsed), multiplier);\n    } catch (ex) {\n      throw new DateTimeParseException('Text cannot be parsed to a Duration: ' + errorText, text, 0, ex);\n    }\n  };\n\n  Duration._parseFraction = function _parseFraction(text, parsed, negate) {\n    if (parsed == null || parsed.length === 0) {\n      return 0;\n    }\n\n    parsed = (parsed + '000000000').substring(0, 9);\n    return parseFloat(parsed) * negate;\n  };\n\n  Duration._create = function _create() {\n    if (arguments.length <= 2) {\n      return Duration._createSecondsNanos(arguments[0], arguments[1]);\n    } else {\n      return Duration._createNegateDaysHoursMinutesSecondsNanos(arguments[0], arguments[1], arguments[2], arguments[3], arguments[4], arguments[5]);\n    }\n  };\n\n  Duration._createNegateDaysHoursMinutesSecondsNanos = function _createNegateDaysHoursMinutesSecondsNanos(negate, daysAsSecs, hoursAsSecs, minsAsSecs, secs, nanos) {\n    var seconds = MathUtil.safeAdd(daysAsSecs, MathUtil.safeAdd(hoursAsSecs, MathUtil.safeAdd(minsAsSecs, secs)));\n\n    if (negate) {\n      return Duration.ofSeconds(seconds, nanos).negated();\n    }\n\n    return Duration.ofSeconds(seconds, nanos);\n  };\n\n  Duration._createSecondsNanos = function _createSecondsNanos(seconds, nanoAdjustment) {\n    if (seconds === void 0) {\n      seconds = 0;\n    }\n\n    if (nanoAdjustment === void 0) {\n      nanoAdjustment = 0;\n    }\n\n    if (seconds === 0 && nanoAdjustment === 0) {\n      return Duration.ZERO;\n    }\n\n    return new Duration(seconds, nanoAdjustment);\n  };\n\n  var _proto = Duration.prototype;\n\n  _proto.get = function get(unit) {\n    if (unit === ChronoUnit.SECONDS) {\n      return this._seconds;\n    } else if (unit === ChronoUnit.NANOS) {\n      return this._nanos;\n    } else {\n      throw new UnsupportedTemporalTypeException('Unsupported unit: ' + unit);\n    }\n  };\n\n  _proto.units = function units() {\n    return [ChronoUnit.SECONDS, ChronoUnit.NANOS];\n  };\n\n  _proto.isZero = function isZero() {\n    return this._seconds === 0 && this._nanos === 0;\n  };\n\n  _proto.isNegative = function isNegative() {\n    return this._seconds < 0;\n  };\n\n  _proto.seconds = function seconds() {\n    return this._seconds;\n  };\n\n  _proto.nano = function nano() {\n    return this._nanos;\n  };\n\n  _proto.withSeconds = function withSeconds(seconds) {\n    return Duration._create(seconds, this._nanos);\n  };\n\n  _proto.withNanos = function withNanos(nanoOfSecond) {\n    ChronoField.NANO_OF_SECOND.checkValidIntValue(nanoOfSecond);\n    return Duration._create(this._seconds, nanoOfSecond);\n  };\n\n  _proto.plusDuration = function plusDuration(duration) {\n    requireNonNull(duration, 'duration');\n    return this.plus(duration.seconds(), duration.nano());\n  };\n\n  _proto.plus = function plus(durationOrNumber, unitOrNumber) {\n    if (arguments.length === 1) {\n      return this.plusDuration(durationOrNumber);\n    } else if (arguments.length === 2 && unitOrNumber instanceof TemporalUnit) {\n      return this.plusAmountUnit(durationOrNumber, unitOrNumber);\n    } else {\n      return this.plusSecondsNanos(durationOrNumber, unitOrNumber);\n    }\n  };\n\n  _proto.plusAmountUnit = function plusAmountUnit(amountToAdd, unit) {\n    requireNonNull(amountToAdd, 'amountToAdd');\n    requireNonNull(unit, 'unit');\n\n    if (unit === ChronoUnit.DAYS) {\n      return this.plusSecondsNanos(MathUtil.safeMultiply(amountToAdd, LocalTime.SECONDS_PER_DAY), 0);\n    }\n\n    if (unit.isDurationEstimated()) {\n      throw new UnsupportedTemporalTypeException('Unit must not have an estimated duration');\n    }\n\n    if (amountToAdd === 0) {\n      return this;\n    }\n\n    if (unit instanceof ChronoUnit) {\n      switch (unit) {\n        case ChronoUnit.NANOS:\n          return this.plusNanos(amountToAdd);\n\n        case ChronoUnit.MICROS:\n          return this.plusSecondsNanos(MathUtil.intDiv(amountToAdd, 1000000 * 1000) * 1000, MathUtil.intMod(amountToAdd, 1000000 * 1000) * 1000);\n\n        case ChronoUnit.MILLIS:\n          return this.plusMillis(amountToAdd);\n\n        case ChronoUnit.SECONDS:\n          return this.plusSeconds(amountToAdd);\n      }\n\n      return this.plusSecondsNanos(MathUtil.safeMultiply(unit.duration().seconds(), amountToAdd), 0);\n    }\n\n    var duration = unit.duration().multipliedBy(amountToAdd);\n    return this.plusSecondsNanos(duration.seconds(), duration.nano());\n  };\n\n  _proto.plusDays = function plusDays(daysToAdd) {\n    return this.plusSecondsNanos(MathUtil.safeMultiply(daysToAdd, LocalTime.SECONDS_PER_DAY), 0);\n  };\n\n  _proto.plusHours = function plusHours(hoursToAdd) {\n    return this.plusSecondsNanos(MathUtil.safeMultiply(hoursToAdd, LocalTime.SECONDS_PER_HOUR), 0);\n  };\n\n  _proto.plusMinutes = function plusMinutes(minutesToAdd) {\n    return this.plusSecondsNanos(MathUtil.safeMultiply(minutesToAdd, LocalTime.SECONDS_PER_MINUTE), 0);\n  };\n\n  _proto.plusSeconds = function plusSeconds(secondsToAdd) {\n    return this.plusSecondsNanos(secondsToAdd, 0);\n  };\n\n  _proto.plusMillis = function plusMillis(millisToAdd) {\n    return this.plusSecondsNanos(MathUtil.intDiv(millisToAdd, 1000), MathUtil.intMod(millisToAdd, 1000) * 1000000);\n  };\n\n  _proto.plusNanos = function plusNanos(nanosToAdd) {\n    return this.plusSecondsNanos(0, nanosToAdd);\n  };\n\n  _proto.plusSecondsNanos = function plusSecondsNanos(secondsToAdd, nanosToAdd) {\n    requireNonNull(secondsToAdd, 'secondsToAdd');\n    requireNonNull(nanosToAdd, 'nanosToAdd');\n\n    if (secondsToAdd === 0 && nanosToAdd === 0) {\n      return this;\n    }\n\n    var epochSec = MathUtil.safeAdd(this._seconds, secondsToAdd);\n    epochSec = MathUtil.safeAdd(epochSec, MathUtil.intDiv(nanosToAdd, LocalTime.NANOS_PER_SECOND));\n    nanosToAdd = MathUtil.intMod(nanosToAdd, LocalTime.NANOS_PER_SECOND);\n    var nanoAdjustment = MathUtil.safeAdd(this._nanos, nanosToAdd);\n    return Duration.ofSeconds(epochSec, nanoAdjustment);\n  };\n\n  _proto.minus = function minus(durationOrNumber, unit) {\n    if (arguments.length === 1) {\n      return this.minusDuration(durationOrNumber);\n    } else {\n      return this.minusAmountUnit(durationOrNumber, unit);\n    }\n  };\n\n  _proto.minusDuration = function minusDuration(duration) {\n    requireNonNull(duration, 'duration');\n    var secsToSubtract = duration.seconds();\n    var nanosToSubtract = duration.nano();\n\n    if (secsToSubtract === MIN_SAFE_INTEGER) {\n      return this.plus(MAX_SAFE_INTEGER, -nanosToSubtract);\n    }\n\n    return this.plus(-secsToSubtract, -nanosToSubtract);\n  };\n\n  _proto.minusAmountUnit = function minusAmountUnit(amountToSubtract, unit) {\n    requireNonNull(amountToSubtract, 'amountToSubtract');\n    requireNonNull(unit, 'unit');\n    return amountToSubtract === MIN_SAFE_INTEGER ? this.plusAmountUnit(MAX_SAFE_INTEGER, unit) : this.plusAmountUnit(-amountToSubtract, unit);\n  };\n\n  _proto.minusDays = function minusDays(daysToSubtract) {\n    return daysToSubtract === MIN_SAFE_INTEGER ? this.plusDays(MAX_SAFE_INTEGER) : this.plusDays(-daysToSubtract);\n  };\n\n  _proto.minusHours = function minusHours(hoursToSubtract) {\n    return hoursToSubtract === MIN_SAFE_INTEGER ? this.plusHours(MAX_SAFE_INTEGER) : this.plusHours(-hoursToSubtract);\n  };\n\n  _proto.minusMinutes = function minusMinutes(minutesToSubtract) {\n    return minutesToSubtract === MIN_SAFE_INTEGER ? this.plusMinutes(MAX_SAFE_INTEGER) : this.plusMinutes(-minutesToSubtract);\n  };\n\n  _proto.minusSeconds = function minusSeconds(secondsToSubtract) {\n    return secondsToSubtract === MIN_SAFE_INTEGER ? this.plusSeconds(MAX_SAFE_INTEGER) : this.plusSeconds(-secondsToSubtract);\n  };\n\n  _proto.minusMillis = function minusMillis(millisToSubtract) {\n    return millisToSubtract === MIN_SAFE_INTEGER ? this.plusMillis(MAX_SAFE_INTEGER) : this.plusMillis(-millisToSubtract);\n  };\n\n  _proto.minusNanos = function minusNanos(nanosToSubtract) {\n    return nanosToSubtract === MIN_SAFE_INTEGER ? this.plusNanos(MAX_SAFE_INTEGER) : this.plusNanos(-nanosToSubtract);\n  };\n\n  _proto.multipliedBy = function multipliedBy(multiplicand) {\n    if (multiplicand === 0) {\n      return Duration.ZERO;\n    }\n\n    if (multiplicand === 1) {\n      return this;\n    }\n\n    var secs = MathUtil.safeMultiply(this._seconds, multiplicand);\n    var nos = MathUtil.safeMultiply(this._nanos, multiplicand);\n    secs = secs + MathUtil.intDiv(nos, LocalTime.NANOS_PER_SECOND);\n    nos = MathUtil.intMod(nos, LocalTime.NANOS_PER_SECOND);\n    return Duration.ofSeconds(secs, nos);\n  };\n\n  _proto.dividedBy = function dividedBy(divisor) {\n    if (divisor === 0) {\n      throw new ArithmeticException('Cannot divide by zero');\n    }\n\n    if (divisor === 1) {\n      return this;\n    }\n\n    var secs = MathUtil.intDiv(this._seconds, divisor);\n    var secsMod = MathUtil.roundDown((this._seconds / divisor - secs) * LocalTime.NANOS_PER_SECOND);\n    var nos = MathUtil.intDiv(this._nanos, divisor);\n    nos = secsMod + nos;\n    return Duration.ofSeconds(secs, nos);\n  };\n\n  _proto.negated = function negated() {\n    return this.multipliedBy(-1);\n  };\n\n  _proto.abs = function abs() {\n    return this.isNegative() ? this.negated() : this;\n  };\n\n  _proto.addTo = function addTo(temporal) {\n    requireNonNull(temporal, 'temporal');\n\n    if (this._seconds !== 0) {\n      temporal = temporal.plus(this._seconds, ChronoUnit.SECONDS);\n    }\n\n    if (this._nanos !== 0) {\n      temporal = temporal.plus(this._nanos, ChronoUnit.NANOS);\n    }\n\n    return temporal;\n  };\n\n  _proto.subtractFrom = function subtractFrom(temporal) {\n    requireNonNull(temporal, 'temporal');\n\n    if (this._seconds !== 0) {\n      temporal = temporal.minus(this._seconds, ChronoUnit.SECONDS);\n    }\n\n    if (this._nanos !== 0) {\n      temporal = temporal.minus(this._nanos, ChronoUnit.NANOS);\n    }\n\n    return temporal;\n  };\n\n  _proto.toDays = function toDays() {\n    return MathUtil.intDiv(this._seconds, LocalTime.SECONDS_PER_DAY);\n  };\n\n  _proto.toHours = function toHours() {\n    return MathUtil.intDiv(this._seconds, LocalTime.SECONDS_PER_HOUR);\n  };\n\n  _proto.toMinutes = function toMinutes() {\n    return MathUtil.intDiv(this._seconds, LocalTime.SECONDS_PER_MINUTE);\n  };\n\n  _proto.toMillis = function toMillis() {\n    var millis = Math.round(MathUtil.safeMultiply(this._seconds, 1000));\n    millis = MathUtil.safeAdd(millis, MathUtil.intDiv(this._nanos, 1000000));\n    return millis;\n  };\n\n  _proto.toNanos = function toNanos() {\n    var totalNanos = MathUtil.safeMultiply(this._seconds, LocalTime.NANOS_PER_SECOND);\n    totalNanos = MathUtil.safeAdd(totalNanos, this._nanos);\n    return totalNanos;\n  };\n\n  _proto.compareTo = function compareTo(otherDuration) {\n    requireNonNull(otherDuration, 'otherDuration');\n    requireInstance(otherDuration, Duration, 'otherDuration');\n    var cmp = MathUtil.compareNumbers(this._seconds, otherDuration.seconds());\n\n    if (cmp !== 0) {\n      return cmp;\n    }\n\n    return this._nanos - otherDuration.nano();\n  };\n\n  _proto.equals = function equals(otherDuration) {\n    if (this === otherDuration) {\n      return true;\n    }\n\n    if (otherDuration instanceof Duration) {\n      return this.seconds() === otherDuration.seconds() && this.nano() === otherDuration.nano();\n    }\n\n    return false;\n  };\n\n  _proto.toString = function toString() {\n    if (this === Duration.ZERO) {\n      return 'PT0S';\n    }\n\n    var hours = MathUtil.intDiv(this._seconds, LocalTime.SECONDS_PER_HOUR);\n    var minutes = MathUtil.intDiv(MathUtil.intMod(this._seconds, LocalTime.SECONDS_PER_HOUR), LocalTime.SECONDS_PER_MINUTE);\n    var secs = MathUtil.intMod(this._seconds, LocalTime.SECONDS_PER_MINUTE);\n    var rval = 'PT';\n\n    if (hours !== 0) {\n      rval += hours + 'H';\n    }\n\n    if (minutes !== 0) {\n      rval += minutes + 'M';\n    }\n\n    if (secs === 0 && this._nanos === 0 && rval.length > 2) {\n      return rval;\n    }\n\n    if (secs < 0 && this._nanos > 0) {\n      if (secs === -1) {\n        rval += '-0';\n      } else {\n        rval += secs + 1;\n      }\n    } else {\n      rval += secs;\n    }\n\n    if (this._nanos > 0) {\n      rval += '.';\n      var nanoString;\n\n      if (secs < 0) {\n        nanoString = '' + (2 * LocalTime.NANOS_PER_SECOND - this._nanos);\n      } else {\n        nanoString = '' + (LocalTime.NANOS_PER_SECOND + this._nanos);\n      }\n\n      nanoString = nanoString.slice(1, nanoString.length);\n      rval += nanoString;\n\n      while (rval.charAt(rval.length - 1) === '0') {\n        rval = rval.slice(0, rval.length - 1);\n      }\n    }\n\n    rval += 'S';\n    return rval;\n  };\n\n  _proto.toJSON = function toJSON() {\n    return this.toString();\n  };\n\n  return Duration;\n}(TemporalAmount);\nfunction _init() {\n  Duration.ZERO = new Duration(0, 0);\n}\n\n/*\n * @copyright (c) 2016, Philipp Thürwächter & Pattrick Hüper\n * @license BSD-3-Clause (see LICENSE.md in the root directory of this source tree)\n */\nvar YearConstants = function YearConstants() {};\nfunction _init$1() {\n  YearConstants.MIN_VALUE = -999999;\n  YearConstants.MAX_VALUE = 999999;\n}\n\nvar ChronoUnit = function (_TemporalUnit) {\n  _inheritsLoose(ChronoUnit, _TemporalUnit);\n\n  function ChronoUnit(name, estimatedDuration) {\n    var _this;\n\n    _this = _TemporalUnit.call(this) || this;\n    _this._name = name;\n    _this._duration = estimatedDuration;\n    return _this;\n  }\n\n  var _proto = ChronoUnit.prototype;\n\n  _proto.duration = function duration() {\n    return this._duration;\n  };\n\n  _proto.isDurationEstimated = function isDurationEstimated() {\n    return this.isDateBased() || this === ChronoUnit.FOREVER;\n  };\n\n  _proto.isDateBased = function isDateBased() {\n    return this.compareTo(ChronoUnit.DAYS) >= 0 && this !== ChronoUnit.FOREVER;\n  };\n\n  _proto.isTimeBased = function isTimeBased() {\n    return this.compareTo(ChronoUnit.DAYS) < 0;\n  };\n\n  _proto.isSupportedBy = function isSupportedBy(temporal) {\n    if (this === ChronoUnit.FOREVER) {\n      return false;\n    }\n\n    try {\n      temporal.plus(1, this);\n      return true;\n    } catch (e) {\n      try {\n        temporal.plus(-1, this);\n        return true;\n      } catch (e2) {\n        return false;\n      }\n    }\n  };\n\n  _proto.addTo = function addTo(temporal, amount) {\n    return temporal.plus(amount, this);\n  };\n\n  _proto.between = function between(temporal1, temporal2) {\n    return temporal1.until(temporal2, this);\n  };\n\n  _proto.toString = function toString() {\n    return this._name;\n  };\n\n  _proto.compareTo = function compareTo(other) {\n    return this.duration().compareTo(other.duration());\n  };\n\n  return ChronoUnit;\n}(TemporalUnit);\nfunction _init$2() {\n  ChronoUnit.NANOS = new ChronoUnit('Nanos', Duration.ofNanos(1));\n  ChronoUnit.MICROS = new ChronoUnit('Micros', Duration.ofNanos(1000));\n  ChronoUnit.MILLIS = new ChronoUnit('Millis', Duration.ofNanos(1000000));\n  ChronoUnit.SECONDS = new ChronoUnit('Seconds', Duration.ofSeconds(1));\n  ChronoUnit.MINUTES = new ChronoUnit('Minutes', Duration.ofSeconds(60));\n  ChronoUnit.HOURS = new ChronoUnit('Hours', Duration.ofSeconds(3600));\n  ChronoUnit.HALF_DAYS = new ChronoUnit('HalfDays', Duration.ofSeconds(43200));\n  ChronoUnit.DAYS = new ChronoUnit('Days', Duration.ofSeconds(86400));\n  ChronoUnit.WEEKS = new ChronoUnit('Weeks', Duration.ofSeconds(7 * 86400));\n  ChronoUnit.MONTHS = new ChronoUnit('Months', Duration.ofSeconds(31556952 / 12));\n  ChronoUnit.YEARS = new ChronoUnit('Years', Duration.ofSeconds(31556952));\n  ChronoUnit.DECADES = new ChronoUnit('Decades', Duration.ofSeconds(31556952 * 10));\n  ChronoUnit.CENTURIES = new ChronoUnit('Centuries', Duration.ofSeconds(31556952 * 100));\n  ChronoUnit.MILLENNIA = new ChronoUnit('Millennia', Duration.ofSeconds(31556952 * 1000));\n  ChronoUnit.ERAS = new ChronoUnit('Eras', Duration.ofSeconds(31556952 * (YearConstants.MAX_VALUE + 1)));\n  ChronoUnit.FOREVER = new ChronoUnit('Forever', Duration.ofSeconds(MathUtil.MAX_SAFE_INTEGER, 999999999));\n}\n\n/**\n * @copyright (c) 2016, Philipp Thürwächter & Pattrick Hüper\n * @copyright (c) 2007-present, Stephen Colebourne & Michael Nascimento Santos\n * @license BSD-3-Clause (see LICENSE in the root directory of this source tree)\n */\n\nvar TemporalField = function () {\n  function TemporalField() {}\n\n  var _proto = TemporalField.prototype;\n\n  _proto.isDateBased = function isDateBased() {\n    abstractMethodFail('isDateBased');\n  };\n\n  _proto.isTimeBased = function isTimeBased() {\n    abstractMethodFail('isTimeBased');\n  };\n\n  _proto.baseUnit = function baseUnit() {\n    abstractMethodFail('baseUnit');\n  };\n\n  _proto.rangeUnit = function rangeUnit() {\n    abstractMethodFail('rangeUnit');\n  };\n\n  _proto.range = function range() {\n    abstractMethodFail('range');\n  };\n\n  _proto.rangeRefinedBy = function rangeRefinedBy(temporal) {\n    abstractMethodFail('rangeRefinedBy');\n  };\n\n  _proto.getFrom = function getFrom(temporal) {\n    abstractMethodFail('getFrom');\n  };\n\n  _proto.adjustInto = function adjustInto(temporal, newValue) {\n    abstractMethodFail('adjustInto');\n  };\n\n  _proto.isSupportedBy = function isSupportedBy(temporal) {\n    abstractMethodFail('isSupportedBy');\n  };\n\n  _proto.displayName = function displayName() {\n    abstractMethodFail('displayName');\n  };\n\n  _proto.equals = function equals(other) {\n    abstractMethodFail('equals');\n  };\n\n  _proto.name = function name() {\n    abstractMethodFail('name');\n  };\n\n  return TemporalField;\n}();\n\n/**\n * @copyright (c) 2016, Philipp Thürwächter & Pattrick Hüper\n * @copyright (c) 2007-present, Stephen Colebourne & Michael Nascimento Santos\n * @license BSD-3-Clause (see LICENSE in the root directory of this source tree)\n */\nvar ValueRange = function () {\n  function ValueRange(minSmallest, minLargest, maxSmallest, maxLargest) {\n    assert(!(minSmallest > minLargest), 'Smallest minimum value \\'' + minSmallest + '\\' must be less than largest minimum value \\'' + minLargest + '\\'', IllegalArgumentException);\n    assert(!(maxSmallest > maxLargest), 'Smallest maximum value \\'' + maxSmallest + '\\' must be less than largest maximum value \\'' + maxLargest + '\\'', IllegalArgumentException);\n    assert(!(minLargest > maxLargest), 'Minimum value \\'' + minLargest + '\\' must be less than maximum value \\'' + maxLargest + '\\'', IllegalArgumentException);\n    this._minSmallest = minSmallest;\n    this._minLargest = minLargest;\n    this._maxLargest = maxLargest;\n    this._maxSmallest = maxSmallest;\n  }\n\n  var _proto = ValueRange.prototype;\n\n  _proto.isFixed = function isFixed() {\n    return this._minSmallest === this._minLargest && this._maxSmallest === this._maxLargest;\n  };\n\n  _proto.minimum = function minimum() {\n    return this._minSmallest;\n  };\n\n  _proto.largestMinimum = function largestMinimum() {\n    return this._minLargest;\n  };\n\n  _proto.maximum = function maximum() {\n    return this._maxLargest;\n  };\n\n  _proto.smallestMaximum = function smallestMaximum() {\n    return this._maxSmallest;\n  };\n\n  _proto.isValidValue = function isValidValue(value) {\n    return this.minimum() <= value && value <= this.maximum();\n  };\n\n  _proto.checkValidValue = function checkValidValue(value, field) {\n    var msg;\n\n    if (!this.isValidValue(value)) {\n      if (field != null) {\n        msg = 'Invalid value for ' + field + ' (valid values ' + this.toString() + '): ' + value;\n      } else {\n        msg = 'Invalid value (valid values ' + this.toString() + '): ' + value;\n      }\n\n      return assert(false, msg, DateTimeException);\n    }\n\n    return value;\n  };\n\n  _proto.checkValidIntValue = function checkValidIntValue(value, field) {\n    if (this.isValidIntValue(value) === false) {\n      throw new DateTimeException('Invalid int value for ' + field + ': ' + value);\n    }\n\n    return value;\n  };\n\n  _proto.isValidIntValue = function isValidIntValue(value) {\n    return this.isIntValue() && this.isValidValue(value);\n  };\n\n  _proto.isIntValue = function isIntValue() {\n    return this.minimum() >= MathUtil.MIN_SAFE_INTEGER && this.maximum() <= MathUtil.MAX_SAFE_INTEGER;\n  };\n\n  _proto.equals = function equals(other) {\n    if (other === this) {\n      return true;\n    }\n\n    if (other instanceof ValueRange) {\n      return this._minSmallest === other._minSmallest && this._minLargest === other._minLargest && this._maxSmallest === other._maxSmallest && this._maxLargest === other._maxLargest;\n    }\n\n    return false;\n  };\n\n  _proto.hashCode = function hashCode() {\n    return MathUtil.hashCode(this._minSmallest, this._minLargest, this._maxSmallest, this._maxLargest);\n  };\n\n  _proto.toString = function toString() {\n    var str = this.minimum() + (this.minimum() !== this.largestMinimum() ? '/' + this.largestMinimum() : '');\n    str += ' - ';\n    str += this.smallestMaximum() + (this.smallestMaximum() !== this.maximum() ? '/' + this.maximum() : '');\n    return str;\n  };\n\n  ValueRange.of = function of() {\n    if (arguments.length === 2) {\n      return new ValueRange(arguments[0], arguments[0], arguments[1], arguments[1]);\n    } else if (arguments.length === 3) {\n      return new ValueRange(arguments[0], arguments[0], arguments[1], arguments[2]);\n    } else if (arguments.length === 4) {\n      return new ValueRange(arguments[0], arguments[1], arguments[2], arguments[3]);\n    } else {\n      return assert(false, 'Invalid number of arguments ' + arguments.length, IllegalArgumentException);\n    }\n  };\n\n  return ValueRange;\n}();\n\nvar ChronoField = function (_TemporalField) {\n  _inheritsLoose(ChronoField, _TemporalField);\n\n  ChronoField.byName = function byName(fieldName) {\n    for (var prop in ChronoField) {\n      if (ChronoField[prop]) {\n        if (ChronoField[prop] instanceof ChronoField && ChronoField[prop].name() === fieldName) {\n          return ChronoField[prop];\n        }\n      }\n    }\n  };\n\n  function ChronoField(name, baseUnit, rangeUnit, range) {\n    var _this;\n\n    _this = _TemporalField.call(this) || this;\n    _this._name = name;\n    _this._baseUnit = baseUnit;\n    _this._rangeUnit = rangeUnit;\n    _this._range = range;\n    return _this;\n  }\n\n  var _proto = ChronoField.prototype;\n\n  _proto.name = function name() {\n    return this._name;\n  };\n\n  _proto.baseUnit = function baseUnit() {\n    return this._baseUnit;\n  };\n\n  _proto.rangeUnit = function rangeUnit() {\n    return this._rangeUnit;\n  };\n\n  _proto.range = function range() {\n    return this._range;\n  };\n\n  _proto.displayName = function displayName() {\n    return this.toString();\n  };\n\n  _proto.checkValidValue = function checkValidValue(value) {\n    return this.range().checkValidValue(value, this);\n  };\n\n  _proto.checkValidIntValue = function checkValidIntValue(value) {\n    return this.range().checkValidIntValue(value, this);\n  };\n\n  _proto.isDateBased = function isDateBased() {\n    var dateBased = this === ChronoField.DAY_OF_WEEK || this === ChronoField.ALIGNED_DAY_OF_WEEK_IN_MONTH || this === ChronoField.ALIGNED_DAY_OF_WEEK_IN_YEAR || this === ChronoField.DAY_OF_MONTH || this === ChronoField.DAY_OF_YEAR || this === ChronoField.EPOCH_DAY || this === ChronoField.ALIGNED_WEEK_OF_MONTH || this === ChronoField.ALIGNED_WEEK_OF_YEAR || this === ChronoField.MONTH_OF_YEAR || this === ChronoField.YEAR_OF_ERA || this === ChronoField.YEAR || this === ChronoField.ERA;\n    return dateBased;\n  };\n\n  _proto.isTimeBased = function isTimeBased() {\n    var timeBased = this === ChronoField.NANO_OF_SECOND || this === ChronoField.NANO_OF_DAY || this === ChronoField.MICRO_OF_SECOND || this === ChronoField.MICRO_OF_DAY || this === ChronoField.MILLI_OF_SECOND || this === ChronoField.MILLI_OF_DAY || this === ChronoField.SECOND_OF_MINUTE || this === ChronoField.SECOND_OF_DAY || this === ChronoField.MINUTE_OF_HOUR || this === ChronoField.MINUTE_OF_DAY || this === ChronoField.HOUR_OF_AMPM || this === ChronoField.CLOCK_HOUR_OF_AMPM || this === ChronoField.HOUR_OF_DAY || this === ChronoField.CLOCK_HOUR_OF_DAY || this === ChronoField.AMPM_OF_DAY;\n    return timeBased;\n  };\n\n  _proto.rangeRefinedBy = function rangeRefinedBy(temporal) {\n    return temporal.range(this);\n  };\n\n  _proto.getFrom = function getFrom(temporal) {\n    return temporal.getLong(this);\n  };\n\n  _proto.toString = function toString() {\n    return this.name();\n  };\n\n  _proto.equals = function equals(other) {\n    return this === other;\n  };\n\n  _proto.adjustInto = function adjustInto(temporal, newValue) {\n    return temporal.with(this, newValue);\n  };\n\n  _proto.isSupportedBy = function isSupportedBy(temporal) {\n    return temporal.isSupported(this);\n  };\n\n  return ChronoField;\n}(TemporalField);\nfunction _init$3() {\n  ChronoField.NANO_OF_SECOND = new ChronoField('NanoOfSecond', ChronoUnit.NANOS, ChronoUnit.SECONDS, ValueRange.of(0, 999999999));\n  ChronoField.NANO_OF_DAY = new ChronoField('NanoOfDay', ChronoUnit.NANOS, ChronoUnit.DAYS, ValueRange.of(0, 86400 * 1000000000 - 1));\n  ChronoField.MICRO_OF_SECOND = new ChronoField('MicroOfSecond', ChronoUnit.MICROS, ChronoUnit.SECONDS, ValueRange.of(0, 999999));\n  ChronoField.MICRO_OF_DAY = new ChronoField('MicroOfDay', ChronoUnit.MICROS, ChronoUnit.DAYS, ValueRange.of(0, 86400 * 1000000 - 1));\n  ChronoField.MILLI_OF_SECOND = new ChronoField('MilliOfSecond', ChronoUnit.MILLIS, ChronoUnit.SECONDS, ValueRange.of(0, 999));\n  ChronoField.MILLI_OF_DAY = new ChronoField('MilliOfDay', ChronoUnit.MILLIS, ChronoUnit.DAYS, ValueRange.of(0, 86400 * 1000 - 1));\n  ChronoField.SECOND_OF_MINUTE = new ChronoField('SecondOfMinute', ChronoUnit.SECONDS, ChronoUnit.MINUTES, ValueRange.of(0, 59));\n  ChronoField.SECOND_OF_DAY = new ChronoField('SecondOfDay', ChronoUnit.SECONDS, ChronoUnit.DAYS, ValueRange.of(0, 86400 - 1));\n  ChronoField.MINUTE_OF_HOUR = new ChronoField('MinuteOfHour', ChronoUnit.MINUTES, ChronoUnit.HOURS, ValueRange.of(0, 59));\n  ChronoField.MINUTE_OF_DAY = new ChronoField('MinuteOfDay', ChronoUnit.MINUTES, ChronoUnit.DAYS, ValueRange.of(0, 24 * 60 - 1));\n  ChronoField.HOUR_OF_AMPM = new ChronoField('HourOfAmPm', ChronoUnit.HOURS, ChronoUnit.HALF_DAYS, ValueRange.of(0, 11));\n  ChronoField.CLOCK_HOUR_OF_AMPM = new ChronoField('ClockHourOfAmPm', ChronoUnit.HOURS, ChronoUnit.HALF_DAYS, ValueRange.of(1, 12));\n  ChronoField.HOUR_OF_DAY = new ChronoField('HourOfDay', ChronoUnit.HOURS, ChronoUnit.DAYS, ValueRange.of(0, 23));\n  ChronoField.CLOCK_HOUR_OF_DAY = new ChronoField('ClockHourOfDay', ChronoUnit.HOURS, ChronoUnit.DAYS, ValueRange.of(1, 24));\n  ChronoField.AMPM_OF_DAY = new ChronoField('AmPmOfDay', ChronoUnit.HALF_DAYS, ChronoUnit.DAYS, ValueRange.of(0, 1));\n  ChronoField.DAY_OF_WEEK = new ChronoField('DayOfWeek', ChronoUnit.DAYS, ChronoUnit.WEEKS, ValueRange.of(1, 7));\n  ChronoField.ALIGNED_DAY_OF_WEEK_IN_MONTH = new ChronoField('AlignedDayOfWeekInMonth', ChronoUnit.DAYS, ChronoUnit.WEEKS, ValueRange.of(1, 7));\n  ChronoField.ALIGNED_DAY_OF_WEEK_IN_YEAR = new ChronoField('AlignedDayOfWeekInYear', ChronoUnit.DAYS, ChronoUnit.WEEKS, ValueRange.of(1, 7));\n  ChronoField.DAY_OF_MONTH = new ChronoField('DayOfMonth', ChronoUnit.DAYS, ChronoUnit.MONTHS, ValueRange.of(1, 28, 31), 'day');\n  ChronoField.DAY_OF_YEAR = new ChronoField('DayOfYear', ChronoUnit.DAYS, ChronoUnit.YEARS, ValueRange.of(1, 365, 366));\n  ChronoField.EPOCH_DAY = new ChronoField('EpochDay', ChronoUnit.DAYS, ChronoUnit.FOREVER, ValueRange.of(Math.floor(YearConstants.MIN_VALUE * 365.25), Math.floor(YearConstants.MAX_VALUE * 365.25)));\n  ChronoField.ALIGNED_WEEK_OF_MONTH = new ChronoField('AlignedWeekOfMonth', ChronoUnit.WEEKS, ChronoUnit.MONTHS, ValueRange.of(1, 4, 5));\n  ChronoField.ALIGNED_WEEK_OF_YEAR = new ChronoField('AlignedWeekOfYear', ChronoUnit.WEEKS, ChronoUnit.YEARS, ValueRange.of(1, 53));\n  ChronoField.MONTH_OF_YEAR = new ChronoField('MonthOfYear', ChronoUnit.MONTHS, ChronoUnit.YEARS, ValueRange.of(1, 12), 'month');\n  ChronoField.PROLEPTIC_MONTH = new ChronoField('ProlepticMonth', ChronoUnit.MONTHS, ChronoUnit.FOREVER, ValueRange.of(YearConstants.MIN_VALUE * 12, YearConstants.MAX_VALUE * 12 + 11));\n  ChronoField.YEAR_OF_ERA = new ChronoField('YearOfEra', ChronoUnit.YEARS, ChronoUnit.FOREVER, ValueRange.of(1, YearConstants.MAX_VALUE, YearConstants.MAX_VALUE + 1));\n  ChronoField.YEAR = new ChronoField('Year', ChronoUnit.YEARS, ChronoUnit.FOREVER, ValueRange.of(YearConstants.MIN_VALUE, YearConstants.MAX_VALUE), 'year');\n  ChronoField.ERA = new ChronoField('Era', ChronoUnit.ERAS, ChronoUnit.FOREVER, ValueRange.of(0, 1));\n  ChronoField.INSTANT_SECONDS = new ChronoField('InstantSeconds', ChronoUnit.SECONDS, ChronoUnit.FOREVER, ValueRange.of(MIN_SAFE_INTEGER, MAX_SAFE_INTEGER));\n  ChronoField.OFFSET_SECONDS = new ChronoField('OffsetSeconds', ChronoUnit.SECONDS, ChronoUnit.FOREVER, ValueRange.of(-18 * 3600, 18 * 3600));\n}\n\n/**\n * @copyright (c) 2016, Philipp Thürwächter & Pattrick Hüper\n * @copyright (c) 2007-present, Stephen Colebourne & Michael Nascimento Santos\n * @license BSD-3-Clause (see LICENSE in the root directory of this source tree)\n */\nvar TemporalQueries = function () {\n  function TemporalQueries() {}\n\n  TemporalQueries.zoneId = function zoneId() {\n    return TemporalQueries.ZONE_ID;\n  };\n\n  TemporalQueries.chronology = function chronology() {\n    return TemporalQueries.CHRONO;\n  };\n\n  TemporalQueries.precision = function precision() {\n    return TemporalQueries.PRECISION;\n  };\n\n  TemporalQueries.zone = function zone() {\n    return TemporalQueries.ZONE;\n  };\n\n  TemporalQueries.offset = function offset() {\n    return TemporalQueries.OFFSET;\n  };\n\n  TemporalQueries.localDate = function localDate() {\n    return TemporalQueries.LOCAL_DATE;\n  };\n\n  TemporalQueries.localTime = function localTime() {\n    return TemporalQueries.LOCAL_TIME;\n  };\n\n  return TemporalQueries;\n}();\n\n/**\n * @copyright (c) 2016, Philipp Thürwächter & Pattrick Hüper\n * @copyright (c) 2007-present, Stephen Colebourne & Michael Nascimento Santos\n * @license BSD-3-Clause (see LICENSE in the root directory of this source tree)\n */\nvar TemporalAccessor = function () {\n  function TemporalAccessor() {}\n\n  var _proto = TemporalAccessor.prototype;\n\n  _proto.query = function query(_query) {\n    if (_query === TemporalQueries.zoneId() || _query === TemporalQueries.chronology() || _query === TemporalQueries.precision()) {\n      return null;\n    }\n\n    return _query.queryFrom(this);\n  };\n\n  _proto.get = function get(field) {\n    return this.range(field).checkValidIntValue(this.getLong(field), field);\n  };\n\n  _proto.range = function range(field) {\n    if (field instanceof ChronoField) {\n      if (this.isSupported(field)) {\n        return field.range();\n      }\n\n      throw new UnsupportedTemporalTypeException('Unsupported field: ' + field);\n    }\n\n    return field.rangeRefinedBy(this);\n  };\n\n  return TemporalAccessor;\n}();\n\nvar TemporalQuery = function (_Enum) {\n  _inheritsLoose(TemporalQuery, _Enum);\n\n  function TemporalQuery() {\n    return _Enum.apply(this, arguments) || this;\n  }\n\n  var _proto = TemporalQuery.prototype;\n\n  _proto.queryFrom = function queryFrom(temporal) {\n    abstractMethodFail('queryFrom');\n  };\n\n  return TemporalQuery;\n}(Enum);\nfunction createTemporalQuery(name, queryFromFunction) {\n  var ExtendedTemporalQuery = function (_TemporalQuery) {\n    _inheritsLoose(ExtendedTemporalQuery, _TemporalQuery);\n\n    function ExtendedTemporalQuery() {\n      return _TemporalQuery.apply(this, arguments) || this;\n    }\n\n    return ExtendedTemporalQuery;\n  }(TemporalQuery);\n\n  ExtendedTemporalQuery.prototype.queryFrom = queryFromFunction;\n  return new ExtendedTemporalQuery(name);\n}\n\nvar DayOfWeek = function (_TemporalAccessor) {\n  _inheritsLoose(DayOfWeek, _TemporalAccessor);\n\n  function DayOfWeek(ordinal, name) {\n    var _this;\n\n    _this = _TemporalAccessor.call(this) || this;\n    _this._ordinal = ordinal;\n    _this._name = name;\n    return _this;\n  }\n\n  var _proto = DayOfWeek.prototype;\n\n  _proto.ordinal = function ordinal() {\n    return this._ordinal;\n  };\n\n  _proto.name = function name() {\n    return this._name;\n  };\n\n  DayOfWeek.values = function values() {\n    return ENUMS.slice();\n  };\n\n  DayOfWeek.valueOf = function valueOf(name) {\n    var ordinal = 0;\n\n    for (ordinal; ordinal < ENUMS.length; ordinal++) {\n      if (ENUMS[ordinal].name() === name) {\n        break;\n      }\n    }\n\n    return DayOfWeek.of(ordinal + 1);\n  };\n\n  DayOfWeek.of = function of(dayOfWeek) {\n    if (dayOfWeek < 1 || dayOfWeek > 7) {\n      throw new DateTimeException('Invalid value for DayOfWeek: ' + dayOfWeek);\n    }\n\n    return ENUMS[dayOfWeek - 1];\n  };\n\n  DayOfWeek.from = function from(temporal) {\n    assert(temporal != null, 'temporal', NullPointerException);\n\n    if (temporal instanceof DayOfWeek) {\n      return temporal;\n    }\n\n    try {\n      return DayOfWeek.of(temporal.get(ChronoField.DAY_OF_WEEK));\n    } catch (ex) {\n      if (ex instanceof DateTimeException) {\n        throw new DateTimeException('Unable to obtain DayOfWeek from TemporalAccessor: ' + temporal + ', type ' + (temporal.constructor != null ? temporal.constructor.name : ''), ex);\n      } else {\n        throw ex;\n      }\n    }\n  };\n\n  _proto.value = function value() {\n    return this._ordinal + 1;\n  };\n\n  _proto.displayName = function displayName(style, locale) {\n    throw new IllegalArgumentException('Pattern using (localized) text not implemented yet!');\n  };\n\n  _proto.isSupported = function isSupported(field) {\n    if (field instanceof ChronoField) {\n      return field === ChronoField.DAY_OF_WEEK;\n    }\n\n    return field != null && field.isSupportedBy(this);\n  };\n\n  _proto.range = function range(field) {\n    if (field === ChronoField.DAY_OF_WEEK) {\n      return field.range();\n    } else if (field instanceof ChronoField) {\n      throw new UnsupportedTemporalTypeException('Unsupported field: ' + field);\n    }\n\n    return field.rangeRefinedBy(this);\n  };\n\n  _proto.get = function get(field) {\n    if (field === ChronoField.DAY_OF_WEEK) {\n      return this.value();\n    }\n\n    return this.range(field).checkValidIntValue(this.getLong(field), field);\n  };\n\n  _proto.getLong = function getLong(field) {\n    if (field === ChronoField.DAY_OF_WEEK) {\n      return this.value();\n    } else if (field instanceof ChronoField) {\n      throw new UnsupportedTemporalTypeException('Unsupported field: ' + field);\n    }\n\n    return field.getFrom(this);\n  };\n\n  _proto.plus = function plus(days) {\n    var amount = MathUtil.floorMod(days, 7);\n    return ENUMS[MathUtil.floorMod(this._ordinal + (amount + 7), 7)];\n  };\n\n  _proto.minus = function minus(days) {\n    return this.plus(-1 * MathUtil.floorMod(days, 7));\n  };\n\n  _proto.query = function query(_query) {\n    if (_query === TemporalQueries.precision()) {\n      return ChronoUnit.DAYS;\n    } else if (_query === TemporalQueries.localDate() || _query === TemporalQueries.localTime() || _query === TemporalQueries.chronology() || _query === TemporalQueries.zone() || _query === TemporalQueries.zoneId() || _query === TemporalQueries.offset()) {\n      return null;\n    }\n\n    assert(_query != null, 'query', NullPointerException);\n    return _query.queryFrom(this);\n  };\n\n  _proto.adjustInto = function adjustInto(temporal) {\n    requireNonNull(temporal, 'temporal');\n    return temporal.with(ChronoField.DAY_OF_WEEK, this.value());\n  };\n\n  _proto.equals = function equals(other) {\n    return this === other;\n  };\n\n  _proto.toString = function toString() {\n    return this._name;\n  };\n\n  _proto.compareTo = function compareTo(other) {\n    requireNonNull(other, 'other');\n    requireInstance(other, DayOfWeek, 'other');\n    return this._ordinal - other._ordinal;\n  };\n\n  _proto.toJSON = function toJSON() {\n    return this.toString();\n  };\n\n  return DayOfWeek;\n}(TemporalAccessor);\nvar ENUMS;\nfunction _init$4() {\n  DayOfWeek.MONDAY = new DayOfWeek(0, 'MONDAY');\n  DayOfWeek.TUESDAY = new DayOfWeek(1, 'TUESDAY');\n  DayOfWeek.WEDNESDAY = new DayOfWeek(2, 'WEDNESDAY');\n  DayOfWeek.THURSDAY = new DayOfWeek(3, 'THURSDAY');\n  DayOfWeek.FRIDAY = new DayOfWeek(4, 'FRIDAY');\n  DayOfWeek.SATURDAY = new DayOfWeek(5, 'SATURDAY');\n  DayOfWeek.SUNDAY = new DayOfWeek(6, 'SUNDAY');\n  DayOfWeek.FROM = createTemporalQuery('DayOfWeek.FROM', function (temporal) {\n    return DayOfWeek.from(temporal);\n  });\n  ENUMS = [DayOfWeek.MONDAY, DayOfWeek.TUESDAY, DayOfWeek.WEDNESDAY, DayOfWeek.THURSDAY, DayOfWeek.FRIDAY, DayOfWeek.SATURDAY, DayOfWeek.SUNDAY];\n}\n\nvar Month = function (_TemporalAccessor) {\n  _inheritsLoose(Month, _TemporalAccessor);\n\n  function Month(value, name) {\n    var _this;\n\n    _this = _TemporalAccessor.call(this) || this;\n    _this._value = MathUtil.safeToInt(value);\n    _this._name = name;\n    return _this;\n  }\n\n  var _proto = Month.prototype;\n\n  _proto.value = function value() {\n    return this._value;\n  };\n\n  _proto.ordinal = function ordinal() {\n    return this._value - 1;\n  };\n\n  _proto.name = function name() {\n    return this._name;\n  };\n\n  _proto.displayName = function displayName(style, locale) {\n    throw new IllegalArgumentException('Pattern using (localized) text not implemented yet!');\n  };\n\n  _proto.isSupported = function isSupported(field) {\n    if (null === field) {\n      return false;\n    }\n\n    if (field instanceof ChronoField) {\n      return field === ChronoField.MONTH_OF_YEAR;\n    }\n\n    return field != null && field.isSupportedBy(this);\n  };\n\n  _proto.get = function get(field) {\n    if (field === ChronoField.MONTH_OF_YEAR) {\n      return this.value();\n    }\n\n    return this.range(field).checkValidIntValue(this.getLong(field), field);\n  };\n\n  _proto.getLong = function getLong(field) {\n    if (field === ChronoField.MONTH_OF_YEAR) {\n      return this.value();\n    } else if (field instanceof ChronoField) {\n      throw new UnsupportedTemporalTypeException('Unsupported field: ' + field);\n    }\n\n    return field.getFrom(this);\n  };\n\n  _proto.plus = function plus(months) {\n    var amount = MathUtil.intMod(months, 12) + 12;\n    var newMonthVal = MathUtil.intMod(this.value() + amount, 12);\n    newMonthVal = newMonthVal === 0 ? 12 : newMonthVal;\n    return Month.of(newMonthVal);\n  };\n\n  _proto.minus = function minus(months) {\n    return this.plus(-1 * MathUtil.intMod(months, 12));\n  };\n\n  _proto.length = function length(leapYear) {\n    switch (this) {\n      case Month.FEBRUARY:\n        return leapYear ? 29 : 28;\n\n      case Month.APRIL:\n      case Month.JUNE:\n      case Month.SEPTEMBER:\n      case Month.NOVEMBER:\n        return 30;\n\n      default:\n        return 31;\n    }\n  };\n\n  _proto.minLength = function minLength() {\n    switch (this) {\n      case Month.FEBRUARY:\n        return 28;\n\n      case Month.APRIL:\n      case Month.JUNE:\n      case Month.SEPTEMBER:\n      case Month.NOVEMBER:\n        return 30;\n\n      default:\n        return 31;\n    }\n  };\n\n  _proto.maxLength = function maxLength() {\n    switch (this) {\n      case Month.FEBRUARY:\n        return 29;\n\n      case Month.APRIL:\n      case Month.JUNE:\n      case Month.SEPTEMBER:\n      case Month.NOVEMBER:\n        return 30;\n\n      default:\n        return 31;\n    }\n  };\n\n  _proto.firstDayOfYear = function firstDayOfYear(leapYear) {\n    var leap = leapYear ? 1 : 0;\n\n    switch (this) {\n      case Month.JANUARY:\n        return 1;\n\n      case Month.FEBRUARY:\n        return 32;\n\n      case Month.MARCH:\n        return 60 + leap;\n\n      case Month.APRIL:\n        return 91 + leap;\n\n      case Month.MAY:\n        return 121 + leap;\n\n      case Month.JUNE:\n        return 152 + leap;\n\n      case Month.JULY:\n        return 182 + leap;\n\n      case Month.AUGUST:\n        return 213 + leap;\n\n      case Month.SEPTEMBER:\n        return 244 + leap;\n\n      case Month.OCTOBER:\n        return 274 + leap;\n\n      case Month.NOVEMBER:\n        return 305 + leap;\n\n      case Month.DECEMBER:\n      default:\n        return 335 + leap;\n    }\n  };\n\n  _proto.firstMonthOfQuarter = function firstMonthOfQuarter() {\n    switch (this) {\n      case Month.JANUARY:\n      case Month.FEBRUARY:\n      case Month.MARCH:\n        return Month.JANUARY;\n\n      case Month.APRIL:\n      case Month.MAY:\n      case Month.JUNE:\n        return Month.APRIL;\n\n      case Month.JULY:\n      case Month.AUGUST:\n      case Month.SEPTEMBER:\n        return Month.JULY;\n\n      case Month.OCTOBER:\n      case Month.NOVEMBER:\n      case Month.DECEMBER:\n      default:\n        return Month.OCTOBER;\n    }\n  };\n\n  _proto.query = function query(_query) {\n    assert(_query != null, 'query() parameter must not be null', DateTimeException);\n\n    if (_query === TemporalQueries.chronology()) {\n      return IsoChronology.INSTANCE;\n    } else if (_query === TemporalQueries.precision()) {\n      return ChronoUnit.MONTHS;\n    }\n\n    return _TemporalAccessor.prototype.query.call(this, _query);\n  };\n\n  _proto.toString = function toString() {\n    switch (this) {\n      case Month.JANUARY:\n        return 'JANUARY';\n\n      case Month.FEBRUARY:\n        return 'FEBRUARY';\n\n      case Month.MARCH:\n        return 'MARCH';\n\n      case Month.APRIL:\n        return 'APRIL';\n\n      case Month.MAY:\n        return 'MAY';\n\n      case Month.JUNE:\n        return 'JUNE';\n\n      case Month.JULY:\n        return 'JULY';\n\n      case Month.AUGUST:\n        return 'AUGUST';\n\n      case Month.SEPTEMBER:\n        return 'SEPTEMBER';\n\n      case Month.OCTOBER:\n        return 'OCTOBER';\n\n      case Month.NOVEMBER:\n        return 'NOVEMBER';\n\n      case Month.DECEMBER:\n        return 'DECEMBER';\n\n      default:\n        return 'unknown Month, value: ' + this.value();\n    }\n  };\n\n  _proto.toJSON = function toJSON() {\n    return this.toString();\n  };\n\n  _proto.adjustInto = function adjustInto(temporal) {\n    return temporal.with(ChronoField.MONTH_OF_YEAR, this.value());\n  };\n\n  _proto.compareTo = function compareTo(other) {\n    requireNonNull(other, 'other');\n    requireInstance(other, Month, 'other');\n    return this._value - other._value;\n  };\n\n  _proto.equals = function equals(other) {\n    return this === other;\n  };\n\n  Month.valueOf = function valueOf(name) {\n    var ordinal = 0;\n\n    for (ordinal; ordinal < MONTHS.length; ordinal++) {\n      if (MONTHS[ordinal].name() === name) {\n        break;\n      }\n    }\n\n    return Month.of(ordinal + 1);\n  };\n\n  Month.values = function values() {\n    return MONTHS.slice();\n  };\n\n  Month.of = function of(month) {\n    if (month < 1 || month > 12) {\n      assert(false, 'Invalid value for MonthOfYear: ' + month, DateTimeException);\n    }\n\n    return MONTHS[month - 1];\n  };\n\n  Month.from = function from(temporal) {\n    if (temporal instanceof Month) {\n      return temporal;\n    }\n\n    try {\n      return Month.of(temporal.get(ChronoField.MONTH_OF_YEAR));\n    } catch (ex) {\n      throw new DateTimeException('Unable to obtain Month from TemporalAccessor: ' + temporal + ' of type ' + (temporal && temporal.constructor != null ? temporal.constructor.name : ''), ex);\n    }\n  };\n\n  return Month;\n}(TemporalAccessor);\nvar MONTHS;\nfunction _init$5() {\n  Month.JANUARY = new Month(1, 'JANUARY');\n  Month.FEBRUARY = new Month(2, 'FEBRUARY');\n  Month.MARCH = new Month(3, 'MARCH');\n  Month.APRIL = new Month(4, 'APRIL');\n  Month.MAY = new Month(5, 'MAY');\n  Month.JUNE = new Month(6, 'JUNE');\n  Month.JULY = new Month(7, 'JULY');\n  Month.AUGUST = new Month(8, 'AUGUST');\n  Month.SEPTEMBER = new Month(9, 'SEPTEMBER');\n  Month.OCTOBER = new Month(10, 'OCTOBER');\n  Month.NOVEMBER = new Month(11, 'NOVEMBER');\n  Month.DECEMBER = new Month(12, 'DECEMBER');\n  MONTHS = [Month.JANUARY, Month.FEBRUARY, Month.MARCH, Month.APRIL, Month.MAY, Month.JUNE, Month.JULY, Month.AUGUST, Month.SEPTEMBER, Month.OCTOBER, Month.NOVEMBER, Month.DECEMBER];\n}\n\nvar PATTERN = /([-+]?)P(?:([-+]?[0-9]+)Y)?(?:([-+]?[0-9]+)M)?(?:([-+]?[0-9]+)W)?(?:([-+]?[0-9]+)D)?/;\nvar Period = function (_TemporalAmount) {\n  _inheritsLoose(Period, _TemporalAmount);\n\n  function Period(years, months, days) {\n    var _this;\n\n    _this = _TemporalAmount.call(this) || this;\n\n    var _years = MathUtil.safeToInt(years);\n\n    var _months = MathUtil.safeToInt(months);\n\n    var _days = MathUtil.safeToInt(days);\n\n    if (_years === 0 && _months === 0 && _days === 0) {\n      if (!Period.ZERO) {\n        _this._years = _years;\n        _this._months = _months;\n        _this._days = _days;\n        Period.ZERO = _assertThisInitialized(_this);\n      }\n\n      return Period.ZERO || _assertThisInitialized(_this);\n    }\n\n    _this._years = _years;\n    _this._months = _months;\n    _this._days = _days;\n    return _this;\n  }\n\n  Period.ofYears = function ofYears(years) {\n    return Period.create(years, 0, 0);\n  };\n\n  Period.ofMonths = function ofMonths(months) {\n    return Period.create(0, months, 0);\n  };\n\n  Period.ofWeeks = function ofWeeks(weeks) {\n    return Period.create(0, 0, MathUtil.safeMultiply(weeks, 7));\n  };\n\n  Period.ofDays = function ofDays(days) {\n    return Period.create(0, 0, days);\n  };\n\n  Period.of = function of(years, months, days) {\n    return Period.create(years, months, days);\n  };\n\n  Period.from = function from(amount) {\n    if (amount instanceof Period) {\n      return amount;\n    }\n\n    requireNonNull(amount, 'amount');\n    var years = 0;\n    var months = 0;\n    var days = 0;\n    var units = amount.units();\n\n    for (var i = 0; i < units.length; i++) {\n      var unit = units[i];\n      var unitAmount = amount.get(unit);\n\n      if (unit === ChronoUnit.YEARS) {\n        years = MathUtil.safeToInt(unitAmount);\n      } else if (unit === ChronoUnit.MONTHS) {\n        months = MathUtil.safeToInt(unitAmount);\n      } else if (unit === ChronoUnit.DAYS) {\n        days = MathUtil.safeToInt(unitAmount);\n      } else {\n        throw new DateTimeException('Unit must be Years, Months or Days, but was ' + unit);\n      }\n    }\n\n    return Period.create(years, months, days);\n  };\n\n  Period.between = function between(startDate, endDate) {\n    requireNonNull(startDate, 'startDate');\n    requireNonNull(endDate, 'endDate');\n    requireInstance(startDate, LocalDate, 'startDate');\n    requireInstance(endDate, LocalDate, 'endDate');\n    return startDate.until(endDate);\n  };\n\n  Period.parse = function parse(text) {\n    requireNonNull(text, 'text');\n\n    try {\n      return Period._parse(text);\n    } catch (ex) {\n      if (ex instanceof ArithmeticException) {\n        throw new DateTimeParseException('Text cannot be parsed to a Period', text, 0, ex);\n      } else {\n        throw ex;\n      }\n    }\n  };\n\n  Period._parse = function _parse(text) {\n    var matches = PATTERN.exec(text);\n\n    if (matches != null) {\n      var negate = '-' === matches[1] ? -1 : 1;\n      var yearMatch = matches[2];\n      var monthMatch = matches[3];\n      var weekMatch = matches[4];\n      var dayMatch = matches[5];\n\n      if (yearMatch != null || monthMatch != null || weekMatch != null || dayMatch != null) {\n        var years = Period._parseNumber(text, yearMatch, negate);\n\n        var months = Period._parseNumber(text, monthMatch, negate);\n\n        var weeks = Period._parseNumber(text, weekMatch, negate);\n\n        var days = Period._parseNumber(text, dayMatch, negate);\n\n        days = MathUtil.safeAdd(days, MathUtil.safeMultiply(weeks, 7));\n        return Period.create(years, months, days);\n      }\n    }\n\n    throw new DateTimeParseException('Text cannot be parsed to a Period', text, 0);\n  };\n\n  Period._parseNumber = function _parseNumber(text, str, negate) {\n    if (str == null) {\n      return 0;\n    }\n\n    var val = MathUtil.parseInt(str);\n    return MathUtil.safeMultiply(val, negate);\n  };\n\n  Period.create = function create(years, months, days) {\n    return new Period(years, months, days);\n  };\n\n  var _proto = Period.prototype;\n\n  _proto.units = function units() {\n    return [ChronoUnit.YEARS, ChronoUnit.MONTHS, ChronoUnit.DAYS];\n  };\n\n  _proto.chronology = function chronology() {\n    return IsoChronology.INSTANCE;\n  };\n\n  _proto.get = function get(unit) {\n    if (unit === ChronoUnit.YEARS) {\n      return this._years;\n    }\n\n    if (unit === ChronoUnit.MONTHS) {\n      return this._months;\n    }\n\n    if (unit === ChronoUnit.DAYS) {\n      return this._days;\n    }\n\n    throw new UnsupportedTemporalTypeException('Unsupported unit: ' + unit);\n  };\n\n  _proto.isZero = function isZero() {\n    return this === Period.ZERO;\n  };\n\n  _proto.isNegative = function isNegative() {\n    return this._years < 0 || this._months < 0 || this._days < 0;\n  };\n\n  _proto.years = function years() {\n    return this._years;\n  };\n\n  _proto.months = function months() {\n    return this._months;\n  };\n\n  _proto.days = function days() {\n    return this._days;\n  };\n\n  _proto.withYears = function withYears(years) {\n    if (years === this._years) {\n      return this;\n    }\n\n    return Period.create(years, this._months, this._days);\n  };\n\n  _proto.withMonths = function withMonths(months) {\n    if (months === this._months) {\n      return this;\n    }\n\n    return Period.create(this._years, months, this._days);\n  };\n\n  _proto.withDays = function withDays(days) {\n    if (days === this._days) {\n      return this;\n    }\n\n    return Period.create(this._years, this._months, days);\n  };\n\n  _proto.plus = function plus(amountToAdd) {\n    var amount = Period.from(amountToAdd);\n    return Period.create(MathUtil.safeAdd(this._years, amount._years), MathUtil.safeAdd(this._months, amount._months), MathUtil.safeAdd(this._days, amount._days));\n  };\n\n  _proto.plusYears = function plusYears(yearsToAdd) {\n    if (yearsToAdd === 0) {\n      return this;\n    }\n\n    return Period.create(MathUtil.safeToInt(MathUtil.safeAdd(this._years, yearsToAdd)), this._months, this._days);\n  };\n\n  _proto.plusMonths = function plusMonths(monthsToAdd) {\n    if (monthsToAdd === 0) {\n      return this;\n    }\n\n    return Period.create(this._years, MathUtil.safeToInt(MathUtil.safeAdd(this._months, monthsToAdd)), this._days);\n  };\n\n  _proto.plusDays = function plusDays(daysToAdd) {\n    if (daysToAdd === 0) {\n      return this;\n    }\n\n    return Period.create(this._years, this._months, MathUtil.safeToInt(MathUtil.safeAdd(this._days, daysToAdd)));\n  };\n\n  _proto.minus = function minus(amountToSubtract) {\n    var amount = Period.from(amountToSubtract);\n    return Period.create(MathUtil.safeSubtract(this._years, amount._years), MathUtil.safeSubtract(this._months, amount._months), MathUtil.safeSubtract(this._days, amount._days));\n  };\n\n  _proto.minusYears = function minusYears(yearsToSubtract) {\n    return this.plusYears(-1 * yearsToSubtract);\n  };\n\n  _proto.minusMonths = function minusMonths(monthsToSubtract) {\n    return this.plusMonths(-1 * monthsToSubtract);\n  };\n\n  _proto.minusDays = function minusDays(daysToSubtract) {\n    return this.plusDays(-1 * daysToSubtract);\n  };\n\n  _proto.multipliedBy = function multipliedBy(scalar) {\n    if (this === Period.ZERO || scalar === 1) {\n      return this;\n    }\n\n    return Period.create(MathUtil.safeMultiply(this._years, scalar), MathUtil.safeMultiply(this._months, scalar), MathUtil.safeMultiply(this._days, scalar));\n  };\n\n  _proto.negated = function negated() {\n    return this.multipliedBy(-1);\n  };\n\n  _proto.normalized = function normalized() {\n    var totalMonths = this.toTotalMonths();\n    var splitYears = MathUtil.intDiv(totalMonths, 12);\n    var splitMonths = MathUtil.intMod(totalMonths, 12);\n\n    if (splitYears === this._years && splitMonths === this._months) {\n      return this;\n    }\n\n    return Period.create(MathUtil.safeToInt(splitYears), splitMonths, this._days);\n  };\n\n  _proto.toTotalMonths = function toTotalMonths() {\n    return this._years * 12 + this._months;\n  };\n\n  _proto.addTo = function addTo(temporal) {\n    requireNonNull(temporal, 'temporal');\n\n    if (this._years !== 0) {\n      if (this._months !== 0) {\n        temporal = temporal.plus(this.toTotalMonths(), ChronoUnit.MONTHS);\n      } else {\n        temporal = temporal.plus(this._years, ChronoUnit.YEARS);\n      }\n    } else if (this._months !== 0) {\n      temporal = temporal.plus(this._months, ChronoUnit.MONTHS);\n    }\n\n    if (this._days !== 0) {\n      temporal = temporal.plus(this._days, ChronoUnit.DAYS);\n    }\n\n    return temporal;\n  };\n\n  _proto.subtractFrom = function subtractFrom(temporal) {\n    requireNonNull(temporal, 'temporal');\n\n    if (this._years !== 0) {\n      if (this._months !== 0) {\n        temporal = temporal.minus(this.toTotalMonths(), ChronoUnit.MONTHS);\n      } else {\n        temporal = temporal.minus(this._years, ChronoUnit.YEARS);\n      }\n    } else if (this._months !== 0) {\n      temporal = temporal.minus(this._months, ChronoUnit.MONTHS);\n    }\n\n    if (this._days !== 0) {\n      temporal = temporal.minus(this._days, ChronoUnit.DAYS);\n    }\n\n    return temporal;\n  };\n\n  _proto.equals = function equals(obj) {\n    if (this === obj) {\n      return true;\n    }\n\n    if (obj instanceof Period) {\n      var other = obj;\n      return this._years === other._years && this._months === other._months && this._days === other._days;\n    }\n\n    return false;\n  };\n\n  _proto.hashCode = function hashCode() {\n    return MathUtil.hashCode(this._years, this._months, this._days);\n  };\n\n  _proto.toString = function toString() {\n    if (this === Period.ZERO) {\n      return 'P0D';\n    } else {\n      var buf = 'P';\n\n      if (this._years !== 0) {\n        buf += '' + this._years + 'Y';\n      }\n\n      if (this._months !== 0) {\n        buf += '' + this._months + 'M';\n      }\n\n      if (this._days !== 0) {\n        buf += '' + this._days + 'D';\n      }\n\n      return buf;\n    }\n  };\n\n  _proto.toJSON = function toJSON() {\n    return this.toString();\n  };\n\n  return Period;\n}(TemporalAmount);\nfunction _init$6() {\n  Period.ofDays(0);\n}\n\n/*\n * @copyright (c) 2016, Philipp Thürwächter & Pattrick Hüper\n * @copyright (c) 2007-present, Stephen Colebourne & Michael Nascimento Santos\n * @license BSD-3-Clause (see LICENSE in the root directory of this source tree)\n */\nvar ParsePosition = function () {\n  function ParsePosition(index) {\n    this._index = index;\n    this._errorIndex = -1;\n  }\n\n  var _proto = ParsePosition.prototype;\n\n  _proto.getIndex = function getIndex() {\n    return this._index;\n  };\n\n  _proto.setIndex = function setIndex(index) {\n    this._index = index;\n  };\n\n  _proto.getErrorIndex = function getErrorIndex() {\n    return this._errorIndex;\n  };\n\n  _proto.setErrorIndex = function setErrorIndex(errorIndex) {\n    this._errorIndex = errorIndex;\n  };\n\n  return ParsePosition;\n}();\n\n/*\n * @copyright (c) 2016, Philipp Thürwächter & Pattrick Hüper\n * @license BSD-3-Clause (see LICENSE in the root directory of this source tree)\n */\nvar EnumMap = function () {\n  function EnumMap() {\n    this._map = {};\n  }\n\n  var _proto = EnumMap.prototype;\n\n  _proto.putAll = function putAll(otherMap) {\n    for (var key in otherMap._map) {\n      this._map[key] = otherMap._map[key];\n    }\n\n    return this;\n  };\n\n  _proto.containsKey = function containsKey(key) {\n    return this._map.hasOwnProperty(key.name()) && this.get(key) !== undefined;\n  };\n\n  _proto.get = function get(key) {\n    return this._map[key.name()];\n  };\n\n  _proto.put = function put(key, val) {\n    return this.set(key, val);\n  };\n\n  _proto.set = function set(key, val) {\n    this._map[key.name()] = val;\n    return this;\n  };\n\n  _proto.retainAll = function retainAll(keyList) {\n    var map = {};\n\n    for (var i = 0; i < keyList.length; i++) {\n      var key = keyList[i].name();\n      map[key] = this._map[key];\n    }\n\n    this._map = map;\n    return this;\n  };\n\n  _proto.remove = function remove(key) {\n    var keyName = key.name();\n    var val = this._map[keyName];\n    this._map[keyName] = undefined;\n    return val;\n  };\n\n  _proto.keySet = function keySet() {\n    return this._map;\n  };\n\n  _proto.clear = function clear() {\n    this._map = {};\n  };\n\n  return EnumMap;\n}();\n\nvar ResolverStyle = function (_Enum) {\n  _inheritsLoose(ResolverStyle, _Enum);\n\n  function ResolverStyle() {\n    return _Enum.apply(this, arguments) || this;\n  }\n\n  return ResolverStyle;\n}(Enum);\nResolverStyle.STRICT = new ResolverStyle('STRICT');\nResolverStyle.SMART = new ResolverStyle('SMART');\nResolverStyle.LENIENT = new ResolverStyle('LENIENT');\n\n/*\n * @copyright (c) 2016, Philipp Thürwächter & Pattrick Hüper\n * @copyright (c) 2007-present, Stephen Colebourne & Michael Nascimento Santos\n * @license BSD-3-Clause (see LICENSE in the root directory of this source tree)\n */\nvar TemporalAdjuster = function () {\n  function TemporalAdjuster() {}\n\n  var _proto = TemporalAdjuster.prototype;\n\n  _proto.adjustInto = function adjustInto(temporal) {\n    abstractMethodFail('adjustInto');\n  };\n\n  return TemporalAdjuster;\n}();\n\nvar Temporal = function (_TemporalAccessor) {\n  _inheritsLoose(Temporal, _TemporalAccessor);\n\n  function Temporal() {\n    return _TemporalAccessor.apply(this, arguments) || this;\n  }\n\n  var _proto = Temporal.prototype;\n\n  _proto.isSupported = function isSupported(unit) {\n    abstractMethodFail('isSupported');\n  };\n\n  _proto.minus = function minus(p1, p2) {\n    if (arguments.length < 2) {\n      return this.minusAmount(p1);\n    } else {\n      return this.minusAmountUnit(p1, p2);\n    }\n  };\n\n  _proto.minusAmount = function minusAmount(amount) {\n    abstractMethodFail('minusAmount');\n  };\n\n  _proto.minusAmountUnit = function minusAmountUnit(amountToSubtract, unit) {\n    abstractMethodFail('minusAmountUnit');\n  };\n\n  _proto.plus = function plus(p1, p2) {\n    if (arguments.length < 2) {\n      return this.plusAmount(p1);\n    } else {\n      return this.plusAmountUnit(p1, p2);\n    }\n  };\n\n  _proto.plusAmount = function plusAmount(amount) {\n    abstractMethodFail('plusAmount');\n  };\n\n  _proto.plusAmountUnit = function plusAmountUnit(amountToAdd, unit) {\n    abstractMethodFail('plusAmountUnit');\n  };\n\n  _proto.until = function until(endTemporal, unit) {\n    abstractMethodFail('until');\n  };\n\n  _proto.with = function _with(p1, p2) {\n    if (arguments.length < 2) {\n      return this.withAdjuster(p1);\n    } else {\n      return this.withFieldValue(p1, p2);\n    }\n  };\n\n  _proto.withAdjuster = function withAdjuster(adjuster) {\n    abstractMethodFail('withAdjuster');\n  };\n\n  _proto.withFieldValue = function withFieldValue(field, newValue) {\n    abstractMethodFail('withFieldValue');\n  };\n\n  return Temporal;\n}(TemporalAccessor);\n\nvar DefaultInterfaceTemporal = function (_Temporal) {\n  _inheritsLoose(DefaultInterfaceTemporal, _Temporal);\n\n  function DefaultInterfaceTemporal() {\n    return _Temporal.apply(this, arguments) || this;\n  }\n\n  var _proto = DefaultInterfaceTemporal.prototype;\n\n  _proto.withAdjuster = function withAdjuster(adjuster) {\n    requireNonNull(adjuster, 'adjuster');\n    requireInstance(adjuster, TemporalAdjuster, 'adjuster');\n    return adjuster.adjustInto(this);\n  };\n\n  _proto.plusAmount = function plusAmount(amount) {\n    requireNonNull(amount, 'amount');\n    requireInstance(amount, TemporalAmount, 'amount');\n    return amount.addTo(this);\n  };\n\n  _proto.minusAmount = function minusAmount(amount) {\n    requireNonNull(amount, 'amount');\n    requireInstance(amount, TemporalAmount, 'amount');\n    return amount.subtractFrom(this);\n  };\n\n  _proto.minusAmountUnit = function minusAmountUnit(amountToSubtract, unit) {\n    requireNonNull(amountToSubtract, 'amountToSubtract');\n    requireNonNull(unit, 'unit');\n    requireInstance(unit, TemporalUnit, 'unit');\n    return amountToSubtract === MIN_SAFE_INTEGER ? this.plusAmountUnit(MAX_SAFE_INTEGER, unit).plusAmountUnit(1, unit) : this.plusAmount(-amountToSubtract, unit);\n  };\n\n  return DefaultInterfaceTemporal;\n}(Temporal);\n\nvar ChronoLocalDate = function (_DefaultInterfaceTemp) {\n  _inheritsLoose(ChronoLocalDate, _DefaultInterfaceTemp);\n\n  function ChronoLocalDate() {\n    return _DefaultInterfaceTemp.apply(this, arguments) || this;\n  }\n\n  var _proto = ChronoLocalDate.prototype;\n\n  _proto.isSupported = function isSupported(fieldOrUnit) {\n    if (fieldOrUnit instanceof ChronoField) {\n      return fieldOrUnit.isDateBased();\n    } else if (fieldOrUnit instanceof ChronoUnit) {\n      return fieldOrUnit.isDateBased();\n    }\n\n    return fieldOrUnit != null && fieldOrUnit.isSupportedBy(this);\n  };\n\n  _proto.query = function query(_query) {\n    if (_query === TemporalQueries.chronology()) {\n      return this.chronology();\n    } else if (_query === TemporalQueries.precision()) {\n      return ChronoUnit.DAYS;\n    } else if (_query === TemporalQueries.localDate()) {\n      return LocalDate.ofEpochDay(this.toEpochDay());\n    } else if (_query === TemporalQueries.localTime() || _query === TemporalQueries.zone() || _query === TemporalQueries.zoneId() || _query === TemporalQueries.offset()) {\n      return null;\n    }\n\n    return _DefaultInterfaceTemp.prototype.query.call(this, _query);\n  };\n\n  _proto.adjustInto = function adjustInto(temporal) {\n    return temporal.with(ChronoField.EPOCH_DAY, this.toEpochDay());\n  };\n\n  _proto.format = function format(formatter) {\n    requireNonNull(formatter, 'formatter');\n    requireInstance(formatter, DateTimeFormatter, 'formatter');\n    return formatter.format(this);\n  };\n\n  return ChronoLocalDate;\n}(DefaultInterfaceTemporal);\n\n/*\n * @copyright (c) 2016, Philipp Thürwächter & Pattrick Hüper\n * @license BSD-3-Clause (see LICENSE in the root directory of this source tree)\n */\nvar StringUtil = function () {\n  function StringUtil() {}\n\n  StringUtil.startsWith = function startsWith(text, pattern) {\n    return text.indexOf(pattern) === 0;\n  };\n\n  StringUtil.hashCode = function hashCode(text) {\n    var len = text.length;\n\n    if (len === 0) {\n      return 0;\n    }\n\n    var hash = 0;\n\n    for (var i = 0; i < len; i++) {\n      var chr = text.charCodeAt(i);\n      hash = (hash << 5) - hash + chr;\n      hash |= 0;\n    }\n\n    return MathUtil.smi(hash);\n  };\n\n  return StringUtil;\n}();\n\n/*\n * @copyright (c) 2016, Philipp Thürwächter & Pattrick Hüper\n * @copyright (c) 2007-present, Stephen Colebourne & Michael Nascimento Santos\n * @license BSD-3-Clause (see LICENSE in the root directory of this source tree)\n */\nvar ZoneId = function () {\n  function ZoneId() {}\n\n  ZoneId.systemDefault = function systemDefault() {\n    throw new DateTimeException('not supported operation');\n  };\n\n  ZoneId.getAvailableZoneIds = function getAvailableZoneIds() {\n    throw new DateTimeException('not supported operation');\n  };\n\n  ZoneId.of = function of(zoneId) {\n    throw new DateTimeException('not supported operation' + zoneId);\n  };\n\n  ZoneId.ofOffset = function ofOffset(prefix, offset) {\n    throw new DateTimeException('not supported operation' + prefix + offset);\n  };\n\n  ZoneId.from = function from(temporal) {\n    throw new DateTimeException('not supported operation' + temporal);\n  };\n\n  var _proto = ZoneId.prototype;\n\n  _proto.id = function id() {\n    abstractMethodFail('ZoneId.id');\n  };\n\n  _proto.rules = function rules() {\n    abstractMethodFail('ZoneId.rules');\n  };\n\n  _proto.normalized = function normalized() {\n    var rules = this.rules();\n\n    if (rules.isFixedOffset()) {\n      return rules.offset(Instant.EPOCH);\n    }\n\n    return this;\n  };\n\n  _proto.equals = function equals(other) {\n    if (this === other) {\n      return true;\n    }\n\n    if (other instanceof ZoneId) {\n      return this.id() === other.id();\n    }\n\n    return false;\n  };\n\n  _proto.hashCode = function hashCode() {\n    return StringUtil.hashCode(this.id());\n  };\n\n  _proto.toString = function toString() {\n    return this.id();\n  };\n\n  _proto.toJSON = function toJSON() {\n    return this.toString();\n  };\n\n  return ZoneId;\n}();\n\nvar ZoneRules = function () {\n  function ZoneRules() {}\n\n  ZoneRules.of = function of(offset) {\n    requireNonNull(offset, 'offset');\n    return new Fixed(offset);\n  };\n\n  var _proto = ZoneRules.prototype;\n\n  _proto.isFixedOffset = function isFixedOffset() {\n    abstractMethodFail('ZoneRules.isFixedOffset');\n  };\n\n  _proto.offset = function offset(instantOrLocalDateTime) {\n    if (instantOrLocalDateTime instanceof Instant) {\n      return this.offsetOfInstant(instantOrLocalDateTime);\n    } else {\n      return this.offsetOfLocalDateTime(instantOrLocalDateTime);\n    }\n  };\n\n  _proto.offsetOfInstant = function offsetOfInstant(instant) {\n    abstractMethodFail('ZoneRules.offsetInstant');\n  };\n\n  _proto.offsetOfEpochMilli = function offsetOfEpochMilli(epochMilli) {\n    abstractMethodFail('ZoneRules.offsetOfEpochMilli');\n  };\n\n  _proto.offsetOfLocalDateTime = function offsetOfLocalDateTime(localDateTime) {\n    abstractMethodFail('ZoneRules.offsetLocalDateTime');\n  };\n\n  _proto.validOffsets = function validOffsets(localDateTime) {\n    abstractMethodFail('ZoneRules.validOffsets');\n  };\n\n  _proto.transition = function transition(localDateTime) {\n    abstractMethodFail('ZoneRules.transition');\n  };\n\n  _proto.standardOffset = function standardOffset(instant) {\n    abstractMethodFail('ZoneRules.standardOffset');\n  };\n\n  _proto.daylightSavings = function daylightSavings(instant) {\n    abstractMethodFail('ZoneRules.daylightSavings');\n  };\n\n  _proto.isDaylightSavings = function isDaylightSavings(instant) {\n    abstractMethodFail('ZoneRules.isDaylightSavings');\n  };\n\n  _proto.isValidOffset = function isValidOffset(localDateTime, offset) {\n    abstractMethodFail('ZoneRules.isValidOffset');\n  };\n\n  _proto.nextTransition = function nextTransition(instant) {\n    abstractMethodFail('ZoneRules.nextTransition');\n  };\n\n  _proto.previousTransition = function previousTransition(instant) {\n    abstractMethodFail('ZoneRules.previousTransition');\n  };\n\n  _proto.transitions = function transitions() {\n    abstractMethodFail('ZoneRules.transitions');\n  };\n\n  _proto.transitionRules = function transitionRules() {\n    abstractMethodFail('ZoneRules.transitionRules');\n  };\n\n  _proto.toString = function toString() {\n    abstractMethodFail('ZoneRules.toString');\n  };\n\n  _proto.toJSON = function toJSON() {\n    return this.toString();\n  };\n\n  return ZoneRules;\n}();\n\nvar Fixed = function (_ZoneRules) {\n  _inheritsLoose(Fixed, _ZoneRules);\n\n  function Fixed(offset) {\n    var _this;\n\n    _this = _ZoneRules.call(this) || this;\n    _this._offset = offset;\n    return _this;\n  }\n\n  var _proto2 = Fixed.prototype;\n\n  _proto2.isFixedOffset = function isFixedOffset() {\n    return true;\n  };\n\n  _proto2.offsetOfInstant = function offsetOfInstant() {\n    return this._offset;\n  };\n\n  _proto2.offsetOfEpochMilli = function offsetOfEpochMilli() {\n    return this._offset;\n  };\n\n  _proto2.offsetOfLocalDateTime = function offsetOfLocalDateTime() {\n    return this._offset;\n  };\n\n  _proto2.validOffsets = function validOffsets() {\n    return [this._offset];\n  };\n\n  _proto2.transition = function transition() {\n    return null;\n  };\n\n  _proto2.standardOffset = function standardOffset() {\n    return this._offset;\n  };\n\n  _proto2.daylightSavings = function daylightSavings() {\n    return Duration.ZERO;\n  };\n\n  _proto2.isDaylightSavings = function isDaylightSavings() {\n    return false;\n  };\n\n  _proto2.isValidOffset = function isValidOffset(localDateTime, offset) {\n    return this._offset.equals(offset);\n  };\n\n  _proto2.nextTransition = function nextTransition() {\n    return null;\n  };\n\n  _proto2.previousTransition = function previousTransition() {\n    return null;\n  };\n\n  _proto2.transitions = function transitions() {\n    return [];\n  };\n\n  _proto2.transitionRules = function transitionRules() {\n    return [];\n  };\n\n  _proto2.equals = function equals(other) {\n    if (this === other) {\n      return true;\n    }\n\n    if (other instanceof Fixed) {\n      return this._offset.equals(other._offset);\n    }\n\n    return false;\n  };\n\n  _proto2.toString = function toString() {\n    return 'FixedRules:' + this._offset.toString();\n  };\n\n  return Fixed;\n}(ZoneRules);\n\nvar SECONDS_CACHE = {};\nvar ID_CACHE = {};\nvar ZoneOffset = function (_ZoneId) {\n  _inheritsLoose(ZoneOffset, _ZoneId);\n\n  function ZoneOffset(totalSeconds) {\n    var _this;\n\n    _this = _ZoneId.call(this) || this;\n\n    ZoneOffset._validateTotalSeconds(totalSeconds);\n\n    _this._totalSeconds = MathUtil.safeToInt(totalSeconds);\n    _this._rules = ZoneRules.of(_assertThisInitialized(_this));\n    _this._id = ZoneOffset._buildId(totalSeconds);\n    return _this;\n  }\n\n  var _proto = ZoneOffset.prototype;\n\n  _proto.totalSeconds = function totalSeconds() {\n    return this._totalSeconds;\n  };\n\n  _proto.id = function id() {\n    return this._id;\n  };\n\n  ZoneOffset._buildId = function _buildId(totalSeconds) {\n    if (totalSeconds === 0) {\n      return 'Z';\n    } else {\n      var absTotalSeconds = Math.abs(totalSeconds);\n      var absHours = MathUtil.intDiv(absTotalSeconds, LocalTime.SECONDS_PER_HOUR);\n      var absMinutes = MathUtil.intMod(MathUtil.intDiv(absTotalSeconds, LocalTime.SECONDS_PER_MINUTE), LocalTime.MINUTES_PER_HOUR);\n      var buf = '' + (totalSeconds < 0 ? '-' : '+') + (absHours < 10 ? '0' : '') + absHours + (absMinutes < 10 ? ':0' : ':') + absMinutes;\n      var absSeconds = MathUtil.intMod(absTotalSeconds, LocalTime.SECONDS_PER_MINUTE);\n\n      if (absSeconds !== 0) {\n        buf += (absSeconds < 10 ? ':0' : ':') + absSeconds;\n      }\n\n      return buf;\n    }\n  };\n\n  ZoneOffset._validateTotalSeconds = function _validateTotalSeconds(totalSeconds) {\n    if (Math.abs(totalSeconds) > ZoneOffset.MAX_SECONDS) {\n      throw new DateTimeException('Zone offset not in valid range: -18:00 to +18:00');\n    }\n  };\n\n  ZoneOffset._validate = function _validate(hours, minutes, seconds) {\n    if (hours < -18 || hours > 18) {\n      throw new DateTimeException('Zone offset hours not in valid range: value ' + hours + ' is not in the range -18 to 18');\n    }\n\n    if (hours > 0) {\n      if (minutes < 0 || seconds < 0) {\n        throw new DateTimeException('Zone offset minutes and seconds must be positive because hours is positive');\n      }\n    } else if (hours < 0) {\n      if (minutes > 0 || seconds > 0) {\n        throw new DateTimeException('Zone offset minutes and seconds must be negative because hours is negative');\n      }\n    } else if (minutes > 0 && seconds < 0 || minutes < 0 && seconds > 0) {\n      throw new DateTimeException('Zone offset minutes and seconds must have the same sign');\n    }\n\n    if (Math.abs(minutes) > 59) {\n      throw new DateTimeException('Zone offset minutes not in valid range: abs(value) ' + Math.abs(minutes) + ' is not in the range 0 to 59');\n    }\n\n    if (Math.abs(seconds) > 59) {\n      throw new DateTimeException('Zone offset seconds not in valid range: abs(value) ' + Math.abs(seconds) + ' is not in the range 0 to 59');\n    }\n\n    if (Math.abs(hours) === 18 && (Math.abs(minutes) > 0 || Math.abs(seconds) > 0)) {\n      throw new DateTimeException('Zone offset not in valid range: -18:00 to +18:00');\n    }\n  };\n\n  ZoneOffset.of = function of(offsetId) {\n    requireNonNull(offsetId, 'offsetId');\n    var offset = ID_CACHE[offsetId];\n\n    if (offset != null) {\n      return offset;\n    }\n\n    var hours, minutes, seconds;\n\n    switch (offsetId.length) {\n      case 2:\n        offsetId = offsetId[0] + '0' + offsetId[1];\n\n      case 3:\n        hours = ZoneOffset._parseNumber(offsetId, 1, false);\n        minutes = 0;\n        seconds = 0;\n        break;\n\n      case 5:\n        hours = ZoneOffset._parseNumber(offsetId, 1, false);\n        minutes = ZoneOffset._parseNumber(offsetId, 3, false);\n        seconds = 0;\n        break;\n\n      case 6:\n        hours = ZoneOffset._parseNumber(offsetId, 1, false);\n        minutes = ZoneOffset._parseNumber(offsetId, 4, true);\n        seconds = 0;\n        break;\n\n      case 7:\n        hours = ZoneOffset._parseNumber(offsetId, 1, false);\n        minutes = ZoneOffset._parseNumber(offsetId, 3, false);\n        seconds = ZoneOffset._parseNumber(offsetId, 5, false);\n        break;\n\n      case 9:\n        hours = ZoneOffset._parseNumber(offsetId, 1, false);\n        minutes = ZoneOffset._parseNumber(offsetId, 4, true);\n        seconds = ZoneOffset._parseNumber(offsetId, 7, true);\n        break;\n\n      default:\n        throw new DateTimeException('Invalid ID for ZoneOffset, invalid format: ' + offsetId);\n    }\n\n    var first = offsetId[0];\n\n    if (first !== '+' && first !== '-') {\n      throw new DateTimeException('Invalid ID for ZoneOffset, plus/minus not found when expected: ' + offsetId);\n    }\n\n    if (first === '-') {\n      return ZoneOffset.ofHoursMinutesSeconds(-hours, -minutes, -seconds);\n    } else {\n      return ZoneOffset.ofHoursMinutesSeconds(hours, minutes, seconds);\n    }\n  };\n\n  ZoneOffset._parseNumber = function _parseNumber(offsetId, pos, precededByColon) {\n    if (precededByColon && offsetId[pos - 1] !== ':') {\n      throw new DateTimeException('Invalid ID for ZoneOffset, colon not found when expected: ' + offsetId);\n    }\n\n    var ch1 = offsetId[pos];\n    var ch2 = offsetId[pos + 1];\n\n    if (ch1 < '0' || ch1 > '9' || ch2 < '0' || ch2 > '9') {\n      throw new DateTimeException('Invalid ID for ZoneOffset, non numeric characters found: ' + offsetId);\n    }\n\n    return (ch1.charCodeAt(0) - 48) * 10 + (ch2.charCodeAt(0) - 48);\n  };\n\n  ZoneOffset.ofHours = function ofHours(hours) {\n    return ZoneOffset.ofHoursMinutesSeconds(hours, 0, 0);\n  };\n\n  ZoneOffset.ofHoursMinutes = function ofHoursMinutes(hours, minutes) {\n    return ZoneOffset.ofHoursMinutesSeconds(hours, minutes, 0);\n  };\n\n  ZoneOffset.ofHoursMinutesSeconds = function ofHoursMinutesSeconds(hours, minutes, seconds) {\n    ZoneOffset._validate(hours, minutes, seconds);\n\n    var totalSeconds = hours * LocalTime.SECONDS_PER_HOUR + minutes * LocalTime.SECONDS_PER_MINUTE + seconds;\n    return ZoneOffset.ofTotalSeconds(totalSeconds);\n  };\n\n  ZoneOffset.ofTotalMinutes = function ofTotalMinutes(totalMinutes) {\n    var totalSeconds = totalMinutes * LocalTime.SECONDS_PER_MINUTE;\n    return ZoneOffset.ofTotalSeconds(totalSeconds);\n  };\n\n  ZoneOffset.ofTotalSeconds = function ofTotalSeconds(totalSeconds) {\n    if (totalSeconds % (15 * LocalTime.SECONDS_PER_MINUTE) === 0) {\n      var totalSecs = totalSeconds;\n      var result = SECONDS_CACHE[totalSecs];\n\n      if (result == null) {\n        result = new ZoneOffset(totalSeconds);\n        SECONDS_CACHE[totalSecs] = result;\n        ID_CACHE[result.id()] = result;\n      }\n\n      return result;\n    } else {\n      return new ZoneOffset(totalSeconds);\n    }\n  };\n\n  _proto.rules = function rules() {\n    return this._rules;\n  };\n\n  _proto.get = function get(field) {\n    return this.getLong(field);\n  };\n\n  _proto.getLong = function getLong(field) {\n    if (field === ChronoField.OFFSET_SECONDS) {\n      return this._totalSeconds;\n    } else if (field instanceof ChronoField) {\n      throw new DateTimeException('Unsupported field: ' + field);\n    }\n\n    return field.getFrom(this);\n  };\n\n  _proto.query = function query(_query) {\n    requireNonNull(_query, 'query');\n\n    if (_query === TemporalQueries.offset() || _query === TemporalQueries.zone()) {\n      return this;\n    } else if (_query === TemporalQueries.localDate() || _query === TemporalQueries.localTime() || _query === TemporalQueries.precision() || _query === TemporalQueries.chronology() || _query === TemporalQueries.zoneId()) {\n      return null;\n    }\n\n    return _query.queryFrom(this);\n  };\n\n  _proto.adjustInto = function adjustInto(temporal) {\n    return temporal.with(ChronoField.OFFSET_SECONDS, this._totalSeconds);\n  };\n\n  _proto.compareTo = function compareTo(other) {\n    requireNonNull(other, 'other');\n    return other._totalSeconds - this._totalSeconds;\n  };\n\n  _proto.equals = function equals(obj) {\n    if (this === obj) {\n      return true;\n    }\n\n    if (obj instanceof ZoneOffset) {\n      return this._totalSeconds === obj._totalSeconds;\n    }\n\n    return false;\n  };\n\n  _proto.hashCode = function hashCode() {\n    return this._totalSeconds;\n  };\n\n  _proto.toString = function toString() {\n    return this._id;\n  };\n\n  return ZoneOffset;\n}(ZoneId);\nfunction _init$7() {\n  ZoneOffset.MAX_SECONDS = 18 * LocalTime.SECONDS_PER_HOUR;\n  ZoneOffset.UTC = ZoneOffset.ofTotalSeconds(0);\n  ZoneOffset.MIN = ZoneOffset.ofTotalSeconds(-ZoneOffset.MAX_SECONDS);\n  ZoneOffset.MAX = ZoneOffset.ofTotalSeconds(ZoneOffset.MAX_SECONDS);\n}\n\nvar DateTimeBuilder = function (_TemporalAccessor) {\n  _inheritsLoose(DateTimeBuilder, _TemporalAccessor);\n\n  DateTimeBuilder.create = function create(field, value) {\n    var dtb = new DateTimeBuilder();\n\n    dtb._addFieldValue(field, value);\n\n    return dtb;\n  };\n\n  function DateTimeBuilder() {\n    var _this;\n\n    _this = _TemporalAccessor.call(this) || this;\n    _this.fieldValues = new EnumMap();\n    _this.chrono = null;\n    _this.zone = null;\n    _this.date = null;\n    _this.time = null;\n    _this.leapSecond = false;\n    _this.excessDays = null;\n    return _this;\n  }\n\n  var _proto = DateTimeBuilder.prototype;\n\n  _proto.getFieldValue0 = function getFieldValue0(field) {\n    return this.fieldValues.get(field);\n  };\n\n  _proto._addFieldValue = function _addFieldValue(field, value) {\n    requireNonNull(field, 'field');\n    var old = this.getFieldValue0(field);\n\n    if (old != null && old !== value) {\n      throw new DateTimeException('Conflict found: ' + field + ' ' + old + ' differs from ' + field + ' ' + value + ': ' + this);\n    }\n\n    return this._putFieldValue0(field, value);\n  };\n\n  _proto._putFieldValue0 = function _putFieldValue0(field, value) {\n    this.fieldValues.put(field, value);\n    return this;\n  };\n\n  _proto.resolve = function resolve(resolverStyle, resolverFields) {\n    if (resolverFields != null) {\n      this.fieldValues.retainAll(resolverFields);\n    }\n\n    this._mergeDate(resolverStyle);\n\n    this._mergeTime(resolverStyle);\n\n    this._resolveTimeInferZeroes(resolverStyle);\n\n    if (this.excessDays != null && this.excessDays.isZero() === false && this.date != null && this.time != null) {\n      this.date = this.date.plus(this.excessDays);\n      this.excessDays = Period.ZERO;\n    }\n\n    this._resolveInstant();\n\n    return this;\n  };\n\n  _proto._mergeDate = function _mergeDate(resolverStyle) {\n    this._checkDate(IsoChronology.INSTANCE.resolveDate(this.fieldValues, resolverStyle));\n  };\n\n  _proto._checkDate = function _checkDate(date) {\n    if (date != null) {\n      this._addObject(date);\n\n      for (var fieldName in this.fieldValues.keySet()) {\n        var field = ChronoField.byName(fieldName);\n\n        if (field) {\n          if (this.fieldValues.get(field) !== undefined) {\n            if (field.isDateBased()) {\n              var val1 = void 0;\n\n              try {\n                val1 = date.getLong(field);\n              } catch (ex) {\n                if (ex instanceof DateTimeException) {\n                  continue;\n                } else {\n                  throw ex;\n                }\n              }\n\n              var val2 = this.fieldValues.get(field);\n\n              if (val1 !== val2) {\n                throw new DateTimeException('Conflict found: Field ' + field + ' ' + val1 + ' differs from ' + field + ' ' + val2 + ' derived from ' + date);\n              }\n            }\n          }\n        }\n      }\n    }\n  };\n\n  _proto._mergeTime = function _mergeTime(resolverStyle) {\n    if (this.fieldValues.containsKey(ChronoField.CLOCK_HOUR_OF_DAY)) {\n      var ch = this.fieldValues.remove(ChronoField.CLOCK_HOUR_OF_DAY);\n\n      if (resolverStyle !== ResolverStyle.LENIENT) {\n        if (resolverStyle === ResolverStyle.SMART && ch === 0) ; else {\n          ChronoField.CLOCK_HOUR_OF_DAY.checkValidValue(ch);\n        }\n      }\n\n      this._addFieldValue(ChronoField.HOUR_OF_DAY, ch === 24 ? 0 : ch);\n    }\n\n    if (this.fieldValues.containsKey(ChronoField.CLOCK_HOUR_OF_AMPM)) {\n      var _ch = this.fieldValues.remove(ChronoField.CLOCK_HOUR_OF_AMPM);\n\n      if (resolverStyle !== ResolverStyle.LENIENT) {\n        if (resolverStyle === ResolverStyle.SMART && _ch === 0) ; else {\n          ChronoField.CLOCK_HOUR_OF_AMPM.checkValidValue(_ch);\n        }\n      }\n\n      this._addFieldValue(ChronoField.HOUR_OF_AMPM, _ch === 12 ? 0 : _ch);\n    }\n\n    if (resolverStyle !== ResolverStyle.LENIENT) {\n      if (this.fieldValues.containsKey(ChronoField.AMPM_OF_DAY)) {\n        ChronoField.AMPM_OF_DAY.checkValidValue(this.fieldValues.get(ChronoField.AMPM_OF_DAY));\n      }\n\n      if (this.fieldValues.containsKey(ChronoField.HOUR_OF_AMPM)) {\n        ChronoField.HOUR_OF_AMPM.checkValidValue(this.fieldValues.get(ChronoField.HOUR_OF_AMPM));\n      }\n    }\n\n    if (this.fieldValues.containsKey(ChronoField.AMPM_OF_DAY) && this.fieldValues.containsKey(ChronoField.HOUR_OF_AMPM)) {\n      var ap = this.fieldValues.remove(ChronoField.AMPM_OF_DAY);\n      var hap = this.fieldValues.remove(ChronoField.HOUR_OF_AMPM);\n\n      this._addFieldValue(ChronoField.HOUR_OF_DAY, ap * 12 + hap);\n    }\n\n    if (this.fieldValues.containsKey(ChronoField.NANO_OF_DAY)) {\n      var nod = this.fieldValues.remove(ChronoField.NANO_OF_DAY);\n\n      if (resolverStyle !== ResolverStyle.LENIENT) {\n        ChronoField.NANO_OF_DAY.checkValidValue(nod);\n      }\n\n      this._addFieldValue(ChronoField.SECOND_OF_DAY, MathUtil.intDiv(nod, 1000000000));\n\n      this._addFieldValue(ChronoField.NANO_OF_SECOND, MathUtil.intMod(nod, 1000000000));\n    }\n\n    if (this.fieldValues.containsKey(ChronoField.MICRO_OF_DAY)) {\n      var cod = this.fieldValues.remove(ChronoField.MICRO_OF_DAY);\n\n      if (resolverStyle !== ResolverStyle.LENIENT) {\n        ChronoField.MICRO_OF_DAY.checkValidValue(cod);\n      }\n\n      this._addFieldValue(ChronoField.SECOND_OF_DAY, MathUtil.intDiv(cod, 1000000));\n\n      this._addFieldValue(ChronoField.MICRO_OF_SECOND, MathUtil.intMod(cod, 1000000));\n    }\n\n    if (this.fieldValues.containsKey(ChronoField.MILLI_OF_DAY)) {\n      var lod = this.fieldValues.remove(ChronoField.MILLI_OF_DAY);\n\n      if (resolverStyle !== ResolverStyle.LENIENT) {\n        ChronoField.MILLI_OF_DAY.checkValidValue(lod);\n      }\n\n      this._addFieldValue(ChronoField.SECOND_OF_DAY, MathUtil.intDiv(lod, 1000));\n\n      this._addFieldValue(ChronoField.MILLI_OF_SECOND, MathUtil.intMod(lod, 1000));\n    }\n\n    if (this.fieldValues.containsKey(ChronoField.SECOND_OF_DAY)) {\n      var sod = this.fieldValues.remove(ChronoField.SECOND_OF_DAY);\n\n      if (resolverStyle !== ResolverStyle.LENIENT) {\n        ChronoField.SECOND_OF_DAY.checkValidValue(sod);\n      }\n\n      this._addFieldValue(ChronoField.HOUR_OF_DAY, MathUtil.intDiv(sod, 3600));\n\n      this._addFieldValue(ChronoField.MINUTE_OF_HOUR, MathUtil.intMod(MathUtil.intDiv(sod, 60), 60));\n\n      this._addFieldValue(ChronoField.SECOND_OF_MINUTE, MathUtil.intMod(sod, 60));\n    }\n\n    if (this.fieldValues.containsKey(ChronoField.MINUTE_OF_DAY)) {\n      var mod = this.fieldValues.remove(ChronoField.MINUTE_OF_DAY);\n\n      if (resolverStyle !== ResolverStyle.LENIENT) {\n        ChronoField.MINUTE_OF_DAY.checkValidValue(mod);\n      }\n\n      this._addFieldValue(ChronoField.HOUR_OF_DAY, MathUtil.intDiv(mod, 60));\n\n      this._addFieldValue(ChronoField.MINUTE_OF_HOUR, MathUtil.intMod(mod, 60));\n    }\n\n    if (resolverStyle !== ResolverStyle.LENIENT) {\n      if (this.fieldValues.containsKey(ChronoField.MILLI_OF_SECOND)) {\n        ChronoField.MILLI_OF_SECOND.checkValidValue(this.fieldValues.get(ChronoField.MILLI_OF_SECOND));\n      }\n\n      if (this.fieldValues.containsKey(ChronoField.MICRO_OF_SECOND)) {\n        ChronoField.MICRO_OF_SECOND.checkValidValue(this.fieldValues.get(ChronoField.MICRO_OF_SECOND));\n      }\n    }\n\n    if (this.fieldValues.containsKey(ChronoField.MILLI_OF_SECOND) && this.fieldValues.containsKey(ChronoField.MICRO_OF_SECOND)) {\n      var los = this.fieldValues.remove(ChronoField.MILLI_OF_SECOND);\n      var cos = this.fieldValues.get(ChronoField.MICRO_OF_SECOND);\n\n      this._putFieldValue0(ChronoField.MICRO_OF_SECOND, los * 1000 + MathUtil.intMod(cos, 1000));\n    }\n\n    if (this.fieldValues.containsKey(ChronoField.MICRO_OF_SECOND) && this.fieldValues.containsKey(ChronoField.NANO_OF_SECOND)) {\n      var nos = this.fieldValues.get(ChronoField.NANO_OF_SECOND);\n\n      this._putFieldValue0(ChronoField.MICRO_OF_SECOND, MathUtil.intDiv(nos, 1000));\n\n      this.fieldValues.remove(ChronoField.MICRO_OF_SECOND);\n    }\n\n    if (this.fieldValues.containsKey(ChronoField.MILLI_OF_SECOND) && this.fieldValues.containsKey(ChronoField.NANO_OF_SECOND)) {\n      var _nos = this.fieldValues.get(ChronoField.NANO_OF_SECOND);\n\n      this._putFieldValue0(ChronoField.MILLI_OF_SECOND, MathUtil.intDiv(_nos, 1000000));\n\n      this.fieldValues.remove(ChronoField.MILLI_OF_SECOND);\n    }\n\n    if (this.fieldValues.containsKey(ChronoField.MICRO_OF_SECOND)) {\n      var _cos = this.fieldValues.remove(ChronoField.MICRO_OF_SECOND);\n\n      this._putFieldValue0(ChronoField.NANO_OF_SECOND, _cos * 1000);\n    } else if (this.fieldValues.containsKey(ChronoField.MILLI_OF_SECOND)) {\n      var _los = this.fieldValues.remove(ChronoField.MILLI_OF_SECOND);\n\n      this._putFieldValue0(ChronoField.NANO_OF_SECOND, _los * 1000000);\n    }\n  };\n\n  _proto._resolveTimeInferZeroes = function _resolveTimeInferZeroes(resolverStyle) {\n    var hod = this.fieldValues.get(ChronoField.HOUR_OF_DAY);\n    var moh = this.fieldValues.get(ChronoField.MINUTE_OF_HOUR);\n    var som = this.fieldValues.get(ChronoField.SECOND_OF_MINUTE);\n    var nos = this.fieldValues.get(ChronoField.NANO_OF_SECOND);\n\n    if (hod == null) {\n      return;\n    }\n\n    if (moh == null && (som != null || nos != null)) {\n      return;\n    }\n\n    if (moh != null && som == null && nos != null) {\n      return;\n    }\n\n    if (resolverStyle !== ResolverStyle.LENIENT) {\n      if (hod != null) {\n        if (resolverStyle === ResolverStyle.SMART && hod === 24 && (moh == null || moh === 0) && (som == null || som === 0) && (nos == null || nos === 0)) {\n          hod = 0;\n          this.excessDays = Period.ofDays(1);\n        }\n\n        var hodVal = ChronoField.HOUR_OF_DAY.checkValidIntValue(hod);\n\n        if (moh != null) {\n          var mohVal = ChronoField.MINUTE_OF_HOUR.checkValidIntValue(moh);\n\n          if (som != null) {\n            var somVal = ChronoField.SECOND_OF_MINUTE.checkValidIntValue(som);\n\n            if (nos != null) {\n              var nosVal = ChronoField.NANO_OF_SECOND.checkValidIntValue(nos);\n\n              this._addObject(LocalTime.of(hodVal, mohVal, somVal, nosVal));\n            } else {\n              this._addObject(LocalTime.of(hodVal, mohVal, somVal));\n            }\n          } else {\n            if (nos == null) {\n              this._addObject(LocalTime.of(hodVal, mohVal));\n            }\n          }\n        } else {\n          if (som == null && nos == null) {\n            this._addObject(LocalTime.of(hodVal, 0));\n          }\n        }\n      }\n    } else {\n      if (hod != null) {\n        var _hodVal = hod;\n\n        if (moh != null) {\n          if (som != null) {\n            if (nos == null) {\n              nos = 0;\n            }\n\n            var totalNanos = MathUtil.safeMultiply(_hodVal, 3600000000000);\n            totalNanos = MathUtil.safeAdd(totalNanos, MathUtil.safeMultiply(moh, 60000000000));\n            totalNanos = MathUtil.safeAdd(totalNanos, MathUtil.safeMultiply(som, 1000000000));\n            totalNanos = MathUtil.safeAdd(totalNanos, nos);\n            var excessDays = MathUtil.floorDiv(totalNanos, 86400000000000);\n            var nod = MathUtil.floorMod(totalNanos, 86400000000000);\n\n            this._addObject(LocalTime.ofNanoOfDay(nod));\n\n            this.excessDays = Period.ofDays(excessDays);\n          } else {\n            var totalSecs = MathUtil.safeMultiply(_hodVal, 3600);\n            totalSecs = MathUtil.safeAdd(totalSecs, MathUtil.safeMultiply(moh, 60));\n\n            var _excessDays = MathUtil.floorDiv(totalSecs, 86400);\n\n            var sod = MathUtil.floorMod(totalSecs, 86400);\n\n            this._addObject(LocalTime.ofSecondOfDay(sod));\n\n            this.excessDays = Period.ofDays(_excessDays);\n          }\n        } else {\n          var _excessDays2 = MathUtil.safeToInt(MathUtil.floorDiv(_hodVal, 24));\n\n          _hodVal = MathUtil.floorMod(_hodVal, 24);\n\n          this._addObject(LocalTime.of(_hodVal, 0));\n\n          this.excessDays = Period.ofDays(_excessDays2);\n        }\n      }\n    }\n\n    this.fieldValues.remove(ChronoField.HOUR_OF_DAY);\n    this.fieldValues.remove(ChronoField.MINUTE_OF_HOUR);\n    this.fieldValues.remove(ChronoField.SECOND_OF_MINUTE);\n    this.fieldValues.remove(ChronoField.NANO_OF_SECOND);\n  };\n\n  _proto._addObject = function _addObject(dateOrTime) {\n    if (dateOrTime instanceof ChronoLocalDate) {\n      this.date = dateOrTime;\n    } else if (dateOrTime instanceof LocalTime) {\n      this.time = dateOrTime;\n    }\n  };\n\n  _proto._resolveInstant = function _resolveInstant() {\n    if (this.date != null && this.time != null) {\n      var offsetSecs = this.fieldValues.get(ChronoField.OFFSET_SECONDS);\n\n      if (offsetSecs != null) {\n        var offset = ZoneOffset.ofTotalSeconds(offsetSecs);\n        var instant = this.date.atTime(this.time).atZone(offset).getLong(ChronoField.INSTANT_SECONDS);\n        this.fieldValues.put(ChronoField.INSTANT_SECONDS, instant);\n      } else if (this.zone != null) {\n        var _instant = this.date.atTime(this.time).atZone(this.zone).getLong(ChronoField.INSTANT_SECONDS);\n\n        this.fieldValues.put(ChronoField.INSTANT_SECONDS, _instant);\n      }\n    }\n  };\n\n  _proto.build = function build(type) {\n    return type.queryFrom(this);\n  };\n\n  _proto.isSupported = function isSupported(field) {\n    if (field == null) {\n      return false;\n    }\n\n    return this.fieldValues.containsKey(field) && this.fieldValues.get(field) !== undefined || this.date != null && this.date.isSupported(field) || this.time != null && this.time.isSupported(field);\n  };\n\n  _proto.getLong = function getLong(field) {\n    requireNonNull(field, 'field');\n    var value = this.getFieldValue0(field);\n\n    if (value == null) {\n      if (this.date != null && this.date.isSupported(field)) {\n        return this.date.getLong(field);\n      }\n\n      if (this.time != null && this.time.isSupported(field)) {\n        return this.time.getLong(field);\n      }\n\n      throw new DateTimeException('Field not found: ' + field);\n    }\n\n    return value;\n  };\n\n  _proto.query = function query(_query) {\n    if (_query === TemporalQueries.zoneId()) {\n      return this.zone;\n    } else if (_query === TemporalQueries.chronology()) {\n      return this.chrono;\n    } else if (_query === TemporalQueries.localDate()) {\n      return this.date != null ? LocalDate.from(this.date) : null;\n    } else if (_query === TemporalQueries.localTime()) {\n      return this.time;\n    } else if (_query === TemporalQueries.zone() || _query === TemporalQueries.offset()) {\n      return _query.queryFrom(this);\n    } else if (_query === TemporalQueries.precision()) {\n      return null;\n    }\n\n    return _query.queryFrom(this);\n  };\n\n  return DateTimeBuilder;\n}(TemporalAccessor);\n\nvar DateTimeParseContext = function () {\n  function DateTimeParseContext() {\n    if (arguments.length === 1) {\n      if (arguments[0] instanceof DateTimeParseContext) {\n        this._constructorSelf.apply(this, arguments);\n\n        return;\n      } else {\n        this._constructorFormatter.apply(this, arguments);\n      }\n    } else {\n      this._constructorParam.apply(this, arguments);\n    }\n\n    this._caseSensitive = true;\n    this._strict = true;\n    this._parsed = [new Parsed(this)];\n  }\n\n  var _proto = DateTimeParseContext.prototype;\n\n  _proto._constructorParam = function _constructorParam(locale, symbols, chronology) {\n    this._locale = locale;\n    this._symbols = symbols;\n    this._overrideChronology = chronology;\n  };\n\n  _proto._constructorFormatter = function _constructorFormatter(formatter) {\n    this._locale = formatter.locale();\n    this._symbols = formatter.decimalStyle();\n    this._overrideChronology = formatter.chronology();\n  };\n\n  _proto._constructorSelf = function _constructorSelf(other) {\n    this._locale = other._locale;\n    this._symbols = other._symbols;\n    this._overrideChronology = other._overrideChronology;\n    this._overrideZone = other._overrideZone;\n    this._caseSensitive = other._caseSensitive;\n    this._strict = other._strict;\n    this._parsed = [new Parsed(this)];\n  };\n\n  _proto.copy = function copy() {\n    return new DateTimeParseContext(this);\n  };\n\n  _proto.symbols = function symbols() {\n    return this._symbols;\n  };\n\n  _proto.isStrict = function isStrict() {\n    return this._strict;\n  };\n\n  _proto.setStrict = function setStrict(strict) {\n    this._strict = strict;\n  };\n\n  _proto.locale = function locale() {\n    return this._locale;\n  };\n\n  _proto.setLocale = function setLocale(locale) {\n    this._locale = locale;\n  };\n\n  _proto.startOptional = function startOptional() {\n    this._parsed.push(this.currentParsed().copy());\n  };\n\n  _proto.endOptional = function endOptional(successful) {\n    if (successful) {\n      this._parsed.splice(this._parsed.length - 2, 1);\n    } else {\n      this._parsed.splice(this._parsed.length - 1, 1);\n    }\n  };\n\n  _proto.isCaseSensitive = function isCaseSensitive() {\n    return this._caseSensitive;\n  };\n\n  _proto.setCaseSensitive = function setCaseSensitive(caseSensitive) {\n    this._caseSensitive = caseSensitive;\n  };\n\n  _proto.subSequenceEquals = function subSequenceEquals(cs1, offset1, cs2, offset2, length) {\n    if (offset1 + length > cs1.length || offset2 + length > cs2.length) {\n      return false;\n    }\n\n    if (!this.isCaseSensitive()) {\n      cs1 = cs1.toLowerCase();\n      cs2 = cs2.toLowerCase();\n    }\n\n    for (var i = 0; i < length; i++) {\n      var ch1 = cs1[offset1 + i];\n      var ch2 = cs2[offset2 + i];\n\n      if (ch1 !== ch2) {\n        return false;\n      }\n    }\n\n    return true;\n  };\n\n  _proto.charEquals = function charEquals(ch1, ch2) {\n    if (this.isCaseSensitive()) {\n      return ch1 === ch2;\n    }\n\n    return this.charEqualsIgnoreCase(ch1, ch2);\n  };\n\n  _proto.charEqualsIgnoreCase = function charEqualsIgnoreCase(c1, c2) {\n    return c1 === c2 || c1.toLowerCase() === c2.toLowerCase();\n  };\n\n  _proto.setParsedField = function setParsedField(field, value, errorPos, successPos) {\n    var currentParsedFieldValues = this.currentParsed().fieldValues;\n    var old = currentParsedFieldValues.get(field);\n    currentParsedFieldValues.set(field, value);\n    return old != null && old !== value ? ~errorPos : successPos;\n  };\n\n  _proto.setParsedZone = function setParsedZone(zone) {\n    requireNonNull(zone, 'zone');\n    this.currentParsed().zone = zone;\n  };\n\n  _proto.getParsed = function getParsed(field) {\n    return this.currentParsed().fieldValues.get(field);\n  };\n\n  _proto.toParsed = function toParsed() {\n    return this.currentParsed();\n  };\n\n  _proto.currentParsed = function currentParsed() {\n    return this._parsed[this._parsed.length - 1];\n  };\n\n  _proto.setParsedLeapSecond = function setParsedLeapSecond() {\n    this.currentParsed().leapSecond = true;\n  };\n\n  _proto.getEffectiveChronology = function getEffectiveChronology() {\n    var chrono = this.currentParsed().chrono;\n\n    if (chrono == null) {\n      chrono = this._overrideChronology;\n\n      if (chrono == null) {\n        chrono = IsoChronology.INSTANCE;\n      }\n    }\n\n    return chrono;\n  };\n\n  return DateTimeParseContext;\n}();\n\nvar Parsed = function (_Temporal) {\n  _inheritsLoose(Parsed, _Temporal);\n\n  function Parsed(dateTimeParseContext) {\n    var _this;\n\n    _this = _Temporal.call(this) || this;\n    _this.chrono = null;\n    _this.zone = null;\n    _this.fieldValues = new EnumMap();\n    _this.leapSecond = false;\n    _this.dateTimeParseContext = dateTimeParseContext;\n    return _this;\n  }\n\n  var _proto2 = Parsed.prototype;\n\n  _proto2.copy = function copy() {\n    var cloned = new Parsed();\n    cloned.chrono = this.chrono;\n    cloned.zone = this.zone;\n    cloned.fieldValues.putAll(this.fieldValues);\n    cloned.leapSecond = this.leapSecond;\n    cloned.dateTimeParseContext = this.dateTimeParseContext;\n    return cloned;\n  };\n\n  _proto2.toString = function toString() {\n    return this.fieldValues + \", \" + this.chrono + \", \" + this.zone;\n  };\n\n  _proto2.isSupported = function isSupported(field) {\n    return this.fieldValues.containsKey(field);\n  };\n\n  _proto2.get = function get(field) {\n    var val = this.fieldValues.get(field);\n    assert(val != null);\n    return val;\n  };\n\n  _proto2.query = function query(_query) {\n    if (_query === TemporalQueries.chronology()) {\n      return this.chrono;\n    }\n\n    if (_query === TemporalQueries.zoneId() || _query === TemporalQueries.zone()) {\n      return this.zone;\n    }\n\n    return _Temporal.prototype.query.call(this, _query);\n  };\n\n  _proto2.toBuilder = function toBuilder() {\n    var builder = new DateTimeBuilder();\n    builder.fieldValues.putAll(this.fieldValues);\n    builder.chrono = this.dateTimeParseContext.getEffectiveChronology();\n\n    if (this.zone != null) {\n      builder.zone = this.zone;\n    } else {\n      builder.zone = this.overrideZone;\n    }\n\n    builder.leapSecond = this.leapSecond;\n    builder.excessDays = this.excessDays;\n    return builder;\n  };\n\n  return Parsed;\n}(Temporal);\n\n/*\n * @copyright (c) 2016, Philipp Thürwächter & Pattrick Hüper\n * @copyright (c) 2007-present, Stephen Colebourne & Michael Nascimento Santos\n * @license BSD-3-Clause (see LICENSE in the root directory of this source tree)\n */\nvar DateTimePrintContext = function () {\n  function DateTimePrintContext(temporal, localeOrFormatter, symbols) {\n    if (arguments.length === 2 && arguments[1] instanceof DateTimeFormatter) {\n      this._temporal = DateTimePrintContext.adjust(temporal, localeOrFormatter);\n      this._locale = localeOrFormatter.locale();\n      this._symbols = localeOrFormatter.decimalStyle();\n    } else {\n      this._temporal = temporal;\n      this._locale = localeOrFormatter;\n      this._symbols = symbols;\n    }\n\n    this._optional = 0;\n  }\n\n  DateTimePrintContext.adjust = function adjust(temporal, formatter) {\n    return temporal;\n  };\n\n  var _proto = DateTimePrintContext.prototype;\n\n  _proto.symbols = function symbols() {\n    return this._symbols;\n  };\n\n  _proto.startOptional = function startOptional() {\n    this._optional++;\n  };\n\n  _proto.endOptional = function endOptional() {\n    this._optional--;\n  };\n\n  _proto.getValueQuery = function getValueQuery(query) {\n    var result = this._temporal.query(query);\n\n    if (result == null && this._optional === 0) {\n      throw new DateTimeException('Unable to extract value: ' + this._temporal);\n    }\n\n    return result;\n  };\n\n  _proto.getValue = function getValue(field) {\n    try {\n      return this._temporal.getLong(field);\n    } catch (ex) {\n      if (ex instanceof DateTimeException && this._optional > 0) {\n        return null;\n      }\n\n      throw ex;\n    }\n  };\n\n  _proto.temporal = function temporal() {\n    return this._temporal;\n  };\n\n  _proto.locale = function locale() {\n    return this._locale;\n  };\n\n  _proto.setDateTime = function setDateTime(temporal) {\n    this._temporal = temporal;\n  };\n\n  _proto.setLocale = function setLocale(locale) {\n    this._locale = locale;\n  };\n\n  return DateTimePrintContext;\n}();\n\nvar IsoFields = {};\nvar QUARTER_DAYS = [0, 90, 181, 273, 0, 91, 182, 274];\n\nvar Field = function (_TemporalField) {\n  _inheritsLoose(Field, _TemporalField);\n\n  function Field() {\n    return _TemporalField.apply(this, arguments) || this;\n  }\n\n  var _proto = Field.prototype;\n\n  _proto.isDateBased = function isDateBased() {\n    return true;\n  };\n\n  _proto.isTimeBased = function isTimeBased() {\n    return false;\n  };\n\n  _proto._isIso = function _isIso() {\n    return true;\n  };\n\n  Field._getWeekRangeByLocalDate = function _getWeekRangeByLocalDate(date) {\n    var wby = Field._getWeekBasedYear(date);\n\n    return ValueRange.of(1, Field._getWeekRangeByYear(wby));\n  };\n\n  Field._getWeekRangeByYear = function _getWeekRangeByYear(wby) {\n    var date = LocalDate.of(wby, 1, 1);\n\n    if (date.dayOfWeek() === DayOfWeek.THURSDAY || date.dayOfWeek() === DayOfWeek.WEDNESDAY && date.isLeapYear()) {\n      return 53;\n    }\n\n    return 52;\n  };\n\n  Field._getWeek = function _getWeek(date) {\n    var dow0 = date.dayOfWeek().ordinal();\n    var doy0 = date.dayOfYear() - 1;\n    var doyThu0 = doy0 + (3 - dow0);\n    var alignedWeek = MathUtil.intDiv(doyThu0, 7);\n    var firstThuDoy0 = doyThu0 - alignedWeek * 7;\n    var firstMonDoy0 = firstThuDoy0 - 3;\n\n    if (firstMonDoy0 < -3) {\n      firstMonDoy0 += 7;\n    }\n\n    if (doy0 < firstMonDoy0) {\n      return Field._getWeekRangeByLocalDate(date.withDayOfYear(180).minusYears(1)).maximum();\n    }\n\n    var week = MathUtil.intDiv(doy0 - firstMonDoy0, 7) + 1;\n\n    if (week === 53) {\n      if ((firstMonDoy0 === -3 || firstMonDoy0 === -2 && date.isLeapYear()) === false) {\n        week = 1;\n      }\n    }\n\n    return week;\n  };\n\n  Field._getWeekBasedYear = function _getWeekBasedYear(date) {\n    var year = date.year();\n    var doy = date.dayOfYear();\n\n    if (doy <= 3) {\n      var dow = date.dayOfWeek().ordinal();\n\n      if (doy - dow < -2) {\n        year--;\n      }\n    } else if (doy >= 363) {\n      var _dow = date.dayOfWeek().ordinal();\n\n      doy = doy - 363 - (date.isLeapYear() ? 1 : 0);\n\n      if (doy - _dow >= 0) {\n        year++;\n      }\n    }\n\n    return year;\n  };\n\n  _proto.displayName = function displayName() {\n    return this.toString();\n  };\n\n  _proto.resolve = function resolve() {\n    return null;\n  };\n\n  _proto.name = function name() {\n    return this.toString();\n  };\n\n  return Field;\n}(TemporalField);\n\nvar DAY_OF_QUARTER_FIELD = function (_Field) {\n  _inheritsLoose(DAY_OF_QUARTER_FIELD, _Field);\n\n  function DAY_OF_QUARTER_FIELD() {\n    return _Field.apply(this, arguments) || this;\n  }\n\n  var _proto2 = DAY_OF_QUARTER_FIELD.prototype;\n\n  _proto2.toString = function toString() {\n    return 'DayOfQuarter';\n  };\n\n  _proto2.baseUnit = function baseUnit() {\n    return ChronoUnit.DAYS;\n  };\n\n  _proto2.rangeUnit = function rangeUnit() {\n    return QUARTER_YEARS;\n  };\n\n  _proto2.range = function range() {\n    return ValueRange.of(1, 90, 92);\n  };\n\n  _proto2.isSupportedBy = function isSupportedBy(temporal) {\n    return temporal.isSupported(ChronoField.DAY_OF_YEAR) && temporal.isSupported(ChronoField.MONTH_OF_YEAR) && temporal.isSupported(ChronoField.YEAR) && this._isIso(temporal);\n  };\n\n  _proto2.rangeRefinedBy = function rangeRefinedBy(temporal) {\n    if (temporal.isSupported(this) === false) {\n      throw new UnsupportedTemporalTypeException('Unsupported field: DayOfQuarter');\n    }\n\n    var qoy = temporal.getLong(QUARTER_OF_YEAR);\n\n    if (qoy === 1) {\n      var year = temporal.getLong(ChronoField.YEAR);\n      return IsoChronology.isLeapYear(year) ? ValueRange.of(1, 91) : ValueRange.of(1, 90);\n    } else if (qoy === 2) {\n      return ValueRange.of(1, 91);\n    } else if (qoy === 3 || qoy === 4) {\n      return ValueRange.of(1, 92);\n    }\n\n    return this.range();\n  };\n\n  _proto2.getFrom = function getFrom(temporal) {\n    if (temporal.isSupported(this) === false) {\n      throw new UnsupportedTemporalTypeException('Unsupported field: DayOfQuarter');\n    }\n\n    var doy = temporal.get(ChronoField.DAY_OF_YEAR);\n    var moy = temporal.get(ChronoField.MONTH_OF_YEAR);\n    var year = temporal.getLong(ChronoField.YEAR);\n    return doy - QUARTER_DAYS[MathUtil.intDiv(moy - 1, 3) + (IsoChronology.isLeapYear(year) ? 4 : 0)];\n  };\n\n  _proto2.adjustInto = function adjustInto(temporal, newValue) {\n    var curValue = this.getFrom(temporal);\n    this.range().checkValidValue(newValue, this);\n    return temporal.with(ChronoField.DAY_OF_YEAR, temporal.getLong(ChronoField.DAY_OF_YEAR) + (newValue - curValue));\n  };\n\n  _proto2.resolve = function resolve(fieldValues, partialTemporal, resolverStyle) {\n    var yearLong = fieldValues.get(ChronoField.YEAR);\n    var qoyLong = fieldValues.get(QUARTER_OF_YEAR);\n\n    if (yearLong == null || qoyLong == null) {\n      return null;\n    }\n\n    var y = ChronoField.YEAR.checkValidIntValue(yearLong);\n    var doq = fieldValues.get(DAY_OF_QUARTER);\n    var date;\n\n    if (resolverStyle === ResolverStyle.LENIENT) {\n      var qoy = qoyLong;\n      date = LocalDate.of(y, 1, 1);\n      date = date.plusMonths(MathUtil.safeMultiply(MathUtil.safeSubtract(qoy, 1), 3));\n      date = date.plusDays(MathUtil.safeSubtract(doq, 1));\n    } else {\n      var _qoy = QUARTER_OF_YEAR.range().checkValidIntValue(qoyLong, QUARTER_OF_YEAR);\n\n      if (resolverStyle === ResolverStyle.STRICT) {\n        var max = 92;\n\n        if (_qoy === 1) {\n          max = IsoChronology.isLeapYear(y) ? 91 : 90;\n        } else if (_qoy === 2) {\n          max = 91;\n        }\n\n        ValueRange.of(1, max).checkValidValue(doq, this);\n      } else {\n        this.range().checkValidValue(doq, this);\n      }\n\n      date = LocalDate.of(y, (_qoy - 1) * 3 + 1, 1).plusDays(doq - 1);\n    }\n\n    fieldValues.remove(this);\n    fieldValues.remove(ChronoField.YEAR);\n    fieldValues.remove(QUARTER_OF_YEAR);\n    return date;\n  };\n\n  return DAY_OF_QUARTER_FIELD;\n}(Field);\n\nvar QUARTER_OF_YEAR_FIELD = function (_Field2) {\n  _inheritsLoose(QUARTER_OF_YEAR_FIELD, _Field2);\n\n  function QUARTER_OF_YEAR_FIELD() {\n    return _Field2.apply(this, arguments) || this;\n  }\n\n  var _proto3 = QUARTER_OF_YEAR_FIELD.prototype;\n\n  _proto3.toString = function toString() {\n    return 'QuarterOfYear';\n  };\n\n  _proto3.baseUnit = function baseUnit() {\n    return QUARTER_YEARS;\n  };\n\n  _proto3.rangeUnit = function rangeUnit() {\n    return ChronoUnit.YEARS;\n  };\n\n  _proto3.range = function range() {\n    return ValueRange.of(1, 4);\n  };\n\n  _proto3.isSupportedBy = function isSupportedBy(temporal) {\n    return temporal.isSupported(ChronoField.MONTH_OF_YEAR) && this._isIso(temporal);\n  };\n\n  _proto3.rangeRefinedBy = function rangeRefinedBy(temporal) {\n    return this.range();\n  };\n\n  _proto3.getFrom = function getFrom(temporal) {\n    if (temporal.isSupported(this) === false) {\n      throw new UnsupportedTemporalTypeException('Unsupported field: QuarterOfYear');\n    }\n\n    var moy = temporal.getLong(ChronoField.MONTH_OF_YEAR);\n    return MathUtil.intDiv(moy + 2, 3);\n  };\n\n  _proto3.adjustInto = function adjustInto(temporal, newValue) {\n    var curValue = this.getFrom(temporal);\n    this.range().checkValidValue(newValue, this);\n    return temporal.with(ChronoField.MONTH_OF_YEAR, temporal.getLong(ChronoField.MONTH_OF_YEAR) + (newValue - curValue) * 3);\n  };\n\n  return QUARTER_OF_YEAR_FIELD;\n}(Field);\n\nvar WEEK_OF_WEEK_BASED_YEAR_FIELD = function (_Field3) {\n  _inheritsLoose(WEEK_OF_WEEK_BASED_YEAR_FIELD, _Field3);\n\n  function WEEK_OF_WEEK_BASED_YEAR_FIELD() {\n    return _Field3.apply(this, arguments) || this;\n  }\n\n  var _proto4 = WEEK_OF_WEEK_BASED_YEAR_FIELD.prototype;\n\n  _proto4.toString = function toString() {\n    return 'WeekOfWeekBasedYear';\n  };\n\n  _proto4.baseUnit = function baseUnit() {\n    return ChronoUnit.WEEKS;\n  };\n\n  _proto4.rangeUnit = function rangeUnit() {\n    return WEEK_BASED_YEARS;\n  };\n\n  _proto4.range = function range() {\n    return ValueRange.of(1, 52, 53);\n  };\n\n  _proto4.isSupportedBy = function isSupportedBy(temporal) {\n    return temporal.isSupported(ChronoField.EPOCH_DAY) && this._isIso(temporal);\n  };\n\n  _proto4.rangeRefinedBy = function rangeRefinedBy(temporal) {\n    if (temporal.isSupported(this) === false) {\n      throw new UnsupportedTemporalTypeException('Unsupported field: WeekOfWeekBasedYear');\n    }\n\n    return Field._getWeekRangeByLocalDate(LocalDate.from(temporal));\n  };\n\n  _proto4.getFrom = function getFrom(temporal) {\n    if (temporal.isSupported(this) === false) {\n      throw new UnsupportedTemporalTypeException('Unsupported field: WeekOfWeekBasedYear');\n    }\n\n    return Field._getWeek(LocalDate.from(temporal));\n  };\n\n  _proto4.adjustInto = function adjustInto(temporal, newValue) {\n    this.range().checkValidValue(newValue, this);\n    return temporal.plus(MathUtil.safeSubtract(newValue, this.getFrom(temporal)), ChronoUnit.WEEKS);\n  };\n\n  _proto4.resolve = function resolve(fieldValues, partialTemporal, resolverStyle) {\n    var wbyLong = fieldValues.get(WEEK_BASED_YEAR);\n    var dowLong = fieldValues.get(ChronoField.DAY_OF_WEEK);\n\n    if (wbyLong == null || dowLong == null) {\n      return null;\n    }\n\n    var wby = WEEK_BASED_YEAR.range().checkValidIntValue(wbyLong, WEEK_BASED_YEAR);\n    var wowby = fieldValues.get(WEEK_OF_WEEK_BASED_YEAR);\n    var date;\n\n    if (resolverStyle === ResolverStyle.LENIENT) {\n      var dow = dowLong;\n      var weeks = 0;\n\n      if (dow > 7) {\n        weeks = MathUtil.intDiv(dow - 1, 7);\n        dow = MathUtil.intMod(dow - 1, 7) + 1;\n      } else if (dow < 1) {\n        weeks = MathUtil.intDiv(dow, 7) - 1;\n        dow = MathUtil.intMod(dow, 7) + 7;\n      }\n\n      date = LocalDate.of(wby, 1, 4).plusWeeks(wowby - 1).plusWeeks(weeks).with(ChronoField.DAY_OF_WEEK, dow);\n    } else {\n      var _dow2 = ChronoField.DAY_OF_WEEK.checkValidIntValue(dowLong);\n\n      if (resolverStyle === ResolverStyle.STRICT) {\n        var temp = LocalDate.of(wby, 1, 4);\n\n        var range = Field._getWeekRangeByLocalDate(temp);\n\n        range.checkValidValue(wowby, this);\n      } else {\n        this.range().checkValidValue(wowby, this);\n      }\n\n      date = LocalDate.of(wby, 1, 4).plusWeeks(wowby - 1).with(ChronoField.DAY_OF_WEEK, _dow2);\n    }\n\n    fieldValues.remove(this);\n    fieldValues.remove(WEEK_BASED_YEAR);\n    fieldValues.remove(ChronoField.DAY_OF_WEEK);\n    return date;\n  };\n\n  _proto4.displayName = function displayName() {\n    return 'Week';\n  };\n\n  return WEEK_OF_WEEK_BASED_YEAR_FIELD;\n}(Field);\n\nvar WEEK_BASED_YEAR_FIELD = function (_Field4) {\n  _inheritsLoose(WEEK_BASED_YEAR_FIELD, _Field4);\n\n  function WEEK_BASED_YEAR_FIELD() {\n    return _Field4.apply(this, arguments) || this;\n  }\n\n  var _proto5 = WEEK_BASED_YEAR_FIELD.prototype;\n\n  _proto5.toString = function toString() {\n    return 'WeekBasedYear';\n  };\n\n  _proto5.baseUnit = function baseUnit() {\n    return WEEK_BASED_YEARS;\n  };\n\n  _proto5.rangeUnit = function rangeUnit() {\n    return ChronoUnit.FOREVER;\n  };\n\n  _proto5.range = function range() {\n    return ChronoField.YEAR.range();\n  };\n\n  _proto5.isSupportedBy = function isSupportedBy(temporal) {\n    return temporal.isSupported(ChronoField.EPOCH_DAY) && this._isIso(temporal);\n  };\n\n  _proto5.rangeRefinedBy = function rangeRefinedBy(temporal) {\n    return ChronoField.YEAR.range();\n  };\n\n  _proto5.getFrom = function getFrom(temporal) {\n    if (temporal.isSupported(this) === false) {\n      throw new UnsupportedTemporalTypeException('Unsupported field: WeekBasedYear');\n    }\n\n    return Field._getWeekBasedYear(LocalDate.from(temporal));\n  };\n\n  _proto5.adjustInto = function adjustInto(temporal, newValue) {\n    if (this.isSupportedBy(temporal) === false) {\n      throw new UnsupportedTemporalTypeException('Unsupported field: WeekBasedYear');\n    }\n\n    var newWby = this.range().checkValidIntValue(newValue, WEEK_BASED_YEAR);\n    var date = LocalDate.from(temporal);\n    var dow = date.get(ChronoField.DAY_OF_WEEK);\n\n    var week = Field._getWeek(date);\n\n    if (week === 53 && Field._getWeekRangeByYear(newWby) === 52) {\n      week = 52;\n    }\n\n    var resolved = LocalDate.of(newWby, 1, 4);\n    var days = dow - resolved.get(ChronoField.DAY_OF_WEEK) + (week - 1) * 7;\n    resolved = resolved.plusDays(days);\n    return temporal.with(resolved);\n  };\n\n  return WEEK_BASED_YEAR_FIELD;\n}(Field);\n\nvar Unit = function (_TemporalUnit) {\n  _inheritsLoose(Unit, _TemporalUnit);\n\n  function Unit(name, estimatedDuration) {\n    var _this;\n\n    _this = _TemporalUnit.call(this) || this;\n    _this._name = name;\n    _this._duration = estimatedDuration;\n    return _this;\n  }\n\n  var _proto6 = Unit.prototype;\n\n  _proto6.duration = function duration() {\n    return this._duration;\n  };\n\n  _proto6.isDurationEstimated = function isDurationEstimated() {\n    return true;\n  };\n\n  _proto6.isDateBased = function isDateBased() {\n    return true;\n  };\n\n  _proto6.isTimeBased = function isTimeBased() {\n    return false;\n  };\n\n  _proto6.isSupportedBy = function isSupportedBy(temporal) {\n    return temporal.isSupported(ChronoField.EPOCH_DAY);\n  };\n\n  _proto6.addTo = function addTo(temporal, periodToAdd) {\n    switch (this) {\n      case WEEK_BASED_YEARS:\n        {\n          var added = MathUtil.safeAdd(temporal.get(WEEK_BASED_YEAR), periodToAdd);\n          return temporal.with(WEEK_BASED_YEAR, added);\n        }\n\n      case QUARTER_YEARS:\n        return temporal.plus(MathUtil.intDiv(periodToAdd, 256), ChronoUnit.YEARS).plus(MathUtil.intMod(periodToAdd, 256) * 3, ChronoUnit.MONTHS);\n\n      default:\n        throw new IllegalStateException('Unreachable');\n    }\n  };\n\n  _proto6.between = function between(temporal1, temporal2) {\n    switch (this) {\n      case WEEK_BASED_YEARS:\n        return MathUtil.safeSubtract(temporal2.getLong(WEEK_BASED_YEAR), temporal1.getLong(WEEK_BASED_YEAR));\n\n      case QUARTER_YEARS:\n        return MathUtil.intDiv(temporal1.until(temporal2, ChronoUnit.MONTHS), 3);\n\n      default:\n        throw new IllegalStateException('Unreachable');\n    }\n  };\n\n  _proto6.toString = function toString() {\n    return name;\n  };\n\n  return Unit;\n}(TemporalUnit);\n\nvar DAY_OF_QUARTER = null;\nvar QUARTER_OF_YEAR = null;\nvar WEEK_OF_WEEK_BASED_YEAR = null;\nvar WEEK_BASED_YEAR = null;\nvar WEEK_BASED_YEARS = null;\nvar QUARTER_YEARS = null;\nfunction _init$8() {\n  DAY_OF_QUARTER = new DAY_OF_QUARTER_FIELD();\n  QUARTER_OF_YEAR = new QUARTER_OF_YEAR_FIELD();\n  WEEK_OF_WEEK_BASED_YEAR = new WEEK_OF_WEEK_BASED_YEAR_FIELD();\n  WEEK_BASED_YEAR = new WEEK_BASED_YEAR_FIELD();\n  WEEK_BASED_YEARS = new Unit('WeekBasedYears', Duration.ofSeconds(31556952));\n  QUARTER_YEARS = new Unit('QuarterYears', Duration.ofSeconds(31556952 / 4));\n  IsoFields.DAY_OF_QUARTER = DAY_OF_QUARTER;\n  IsoFields.QUARTER_OF_YEAR = QUARTER_OF_YEAR;\n  IsoFields.WEEK_OF_WEEK_BASED_YEAR = WEEK_OF_WEEK_BASED_YEAR;\n  IsoFields.WEEK_BASED_YEAR = WEEK_BASED_YEAR;\n  IsoFields.WEEK_BASED_YEARS = WEEK_BASED_YEARS;\n  IsoFields.QUARTER_YEARS = QUARTER_YEARS;\n\n  LocalDate.prototype.isoWeekOfWeekyear = function () {\n    return this.get(IsoFields.WEEK_OF_WEEK_BASED_YEAR);\n  };\n\n  LocalDate.prototype.isoWeekyear = function () {\n    return this.get(IsoFields.WEEK_BASED_YEAR);\n  };\n}\n\n/**\n * @copyright (c) 2016, Philipp Thürwächter & Pattrick Hüper\n * @copyright (c) 2007-present, Stephen Colebourne & Michael Nascimento Santos\n * @license BSD-3-Clause (see LICENSE in the root directory of this source tree)\n */\nvar DecimalStyle = function () {\n  function DecimalStyle(zeroChar, positiveSignChar, negativeSignChar, decimalPointChar) {\n    this._zeroDigit = zeroChar;\n    this._zeroDigitCharCode = zeroChar.charCodeAt(0);\n    this._positiveSign = positiveSignChar;\n    this._negativeSign = negativeSignChar;\n    this._decimalSeparator = decimalPointChar;\n  }\n\n  var _proto = DecimalStyle.prototype;\n\n  _proto.positiveSign = function positiveSign() {\n    return this._positiveSign;\n  };\n\n  _proto.withPositiveSign = function withPositiveSign(positiveSign) {\n    if (positiveSign === this._positiveSign) {\n      return this;\n    }\n\n    return new DecimalStyle(this._zeroDigit, positiveSign, this._negativeSign, this._decimalSeparator);\n  };\n\n  _proto.negativeSign = function negativeSign() {\n    return this._negativeSign;\n  };\n\n  _proto.withNegativeSign = function withNegativeSign(negativeSign) {\n    if (negativeSign === this._negativeSign) {\n      return this;\n    }\n\n    return new DecimalStyle(this._zeroDigit, this._positiveSign, negativeSign, this._decimalSeparator);\n  };\n\n  _proto.zeroDigit = function zeroDigit() {\n    return this._zeroDigit;\n  };\n\n  _proto.withZeroDigit = function withZeroDigit(zeroDigit) {\n    if (zeroDigit === this._zeroDigit) {\n      return this;\n    }\n\n    return new DecimalStyle(zeroDigit, this._positiveSign, this._negativeSign, this._decimalSeparator);\n  };\n\n  _proto.decimalSeparator = function decimalSeparator() {\n    return this._decimalSeparator;\n  };\n\n  _proto.withDecimalSeparator = function withDecimalSeparator(decimalSeparator) {\n    if (decimalSeparator === this._decimalSeparator) {\n      return this;\n    }\n\n    return new DecimalStyle(this._zeroDigit, this._positiveSign, this._negativeSign, decimalSeparator);\n  };\n\n  _proto.convertToDigit = function convertToDigit(char) {\n    var val = char.charCodeAt(0) - this._zeroDigitCharCode;\n\n    return val >= 0 && val <= 9 ? val : -1;\n  };\n\n  _proto.convertNumberToI18N = function convertNumberToI18N(numericText) {\n    if (this._zeroDigit === '0') {\n      return numericText;\n    }\n\n    var diff = this._zeroDigitCharCode - '0'.charCodeAt(0);\n    var convertedText = '';\n\n    for (var i = 0; i < numericText.length; i++) {\n      convertedText += String.fromCharCode(numericText.charCodeAt(i) + diff);\n    }\n\n    return convertedText;\n  };\n\n  _proto.equals = function equals(other) {\n    if (this === other) {\n      return true;\n    }\n\n    if (other instanceof DecimalStyle) {\n      return this._zeroDigit === other._zeroDigit && this._positiveSign === other._positiveSign && this._negativeSign === other._negativeSign && this._decimalSeparator === other._decimalSeparator;\n    }\n\n    return false;\n  };\n\n  _proto.hashCode = function hashCode() {\n    return this._zeroDigit + this._positiveSign + this._negativeSign + this._decimalSeparator;\n  };\n\n  _proto.toString = function toString() {\n    return 'DecimalStyle[' + this._zeroDigit + this._positiveSign + this._negativeSign + this._decimalSeparator + ']';\n  };\n\n  DecimalStyle.of = function of() {\n    throw new Error('not yet supported');\n  };\n\n  DecimalStyle.availableLocales = function availableLocales() {\n    throw new Error('not yet supported');\n  };\n\n  return DecimalStyle;\n}();\nDecimalStyle.STANDARD = new DecimalStyle('0', '+', '-', '.');\n\nvar SignStyle = function (_Enum) {\n  _inheritsLoose(SignStyle, _Enum);\n\n  function SignStyle() {\n    return _Enum.apply(this, arguments) || this;\n  }\n\n  var _proto = SignStyle.prototype;\n\n  _proto.parse = function parse(positive, strict, fixedWidth) {\n    switch (this) {\n      case SignStyle.NORMAL:\n        return !positive || !strict;\n\n      case SignStyle.ALWAYS:\n      case SignStyle.EXCEEDS_PAD:\n        return true;\n\n      default:\n        return !strict && !fixedWidth;\n    }\n  };\n\n  return SignStyle;\n}(Enum);\nSignStyle.NORMAL = new SignStyle('NORMAL');\nSignStyle.NEVER = new SignStyle('NEVER');\nSignStyle.ALWAYS = new SignStyle('ALWAYS');\nSignStyle.EXCEEDS_PAD = new SignStyle('EXCEEDS_PAD');\nSignStyle.NOT_NEGATIVE = new SignStyle('NOT_NEGATIVE');\n\nvar TextStyle = function (_Enum) {\n  _inheritsLoose(TextStyle, _Enum);\n\n  function TextStyle() {\n    return _Enum.apply(this, arguments) || this;\n  }\n\n  var _proto = TextStyle.prototype;\n\n  _proto.isStandalone = function isStandalone() {\n    switch (this) {\n      case TextStyle.FULL_STANDALONE:\n      case TextStyle.SHORT_STANDALONE:\n      case TextStyle.NARROW_STANDALONE:\n        return true;\n\n      default:\n        return false;\n    }\n  };\n\n  _proto.asStandalone = function asStandalone() {\n    switch (this) {\n      case TextStyle.FULL:\n        return TextStyle.FULL_STANDALONE;\n\n      case TextStyle.SHORT:\n        return TextStyle.SHORT_STANDALONE;\n\n      case TextStyle.NARROW:\n        return TextStyle.NARROW_STANDALONE;\n\n      default:\n        return this;\n    }\n  };\n\n  _proto.asNormal = function asNormal() {\n    switch (this) {\n      case TextStyle.FULL_STANDALONE:\n        return TextStyle.FULL;\n\n      case TextStyle.SHORT_STANDALONE:\n        return TextStyle.SHORT;\n\n      case TextStyle.NARROW_STANDALONE:\n        return TextStyle.NARROW;\n\n      default:\n        return this;\n    }\n  };\n\n  return TextStyle;\n}(Enum);\nTextStyle.FULL = new TextStyle('FULL');\nTextStyle.FULL_STANDALONE = new TextStyle('FULL_STANDALONE');\nTextStyle.SHORT = new TextStyle('SHORT');\nTextStyle.SHORT_STANDALONE = new TextStyle('SHORT_STANDALONE');\nTextStyle.NARROW = new TextStyle('NARROW');\nTextStyle.NARROW_STANDALONE = new TextStyle('NARROW_STANDALONE');\n\n/**\n * @copyright (c) 2016, Philipp Thürwächter & Pattrick Hüper\n * @copyright (c) 2007-present, Stephen Colebourne & Michael Nascimento Santos\n * @license BSD-3-Clause (see LICENSE in the root directory of this source tree)\n */\nvar CharLiteralPrinterParser = function () {\n  function CharLiteralPrinterParser(literal) {\n    if (literal.length > 1) {\n      throw new IllegalArgumentException('invalid literal, too long: \"' + literal + '\"');\n    }\n\n    this._literal = literal;\n  }\n\n  var _proto = CharLiteralPrinterParser.prototype;\n\n  _proto.print = function print(context, buf) {\n    buf.append(this._literal);\n    return true;\n  };\n\n  _proto.parse = function parse(context, text, position) {\n    var length = text.length;\n\n    if (position === length) {\n      return ~position;\n    }\n\n    var ch = text.charAt(position);\n\n    if (context.charEquals(this._literal, ch) === false) {\n      return ~position;\n    }\n\n    return position + this._literal.length;\n  };\n\n  _proto.toString = function toString() {\n    if (this._literal === '\\'') {\n      return \"''\";\n    }\n\n    return \"'\" + this._literal + \"'\";\n  };\n\n  return CharLiteralPrinterParser;\n}();\n\n/**\n * @copyright (c) 2016, Philipp Thürwächter & Pattrick Hüper\n * @copyright (c) 2007-present, Stephen Colebourne & Michael Nascimento Santos\n * @license BSD-3-Clause (see LICENSE in the root directory of this source tree)\n */\nvar CompositePrinterParser = function () {\n  function CompositePrinterParser(printerParsers, optional) {\n    this._printerParsers = printerParsers;\n    this._optional = optional;\n  }\n\n  var _proto = CompositePrinterParser.prototype;\n\n  _proto.withOptional = function withOptional(optional) {\n    if (optional === this._optional) {\n      return this;\n    }\n\n    return new CompositePrinterParser(this._printerParsers, optional);\n  };\n\n  _proto.print = function print(context, buf) {\n    var length = buf.length();\n\n    if (this._optional) {\n      context.startOptional();\n    }\n\n    try {\n      for (var i = 0; i < this._printerParsers.length; i++) {\n        var pp = this._printerParsers[i];\n\n        if (pp.print(context, buf) === false) {\n          buf.setLength(length);\n          return true;\n        }\n      }\n    } finally {\n      if (this._optional) {\n        context.endOptional();\n      }\n    }\n\n    return true;\n  };\n\n  _proto.parse = function parse(context, text, position) {\n    if (this._optional) {\n      context.startOptional();\n      var pos = position;\n\n      for (var i = 0; i < this._printerParsers.length; i++) {\n        var pp = this._printerParsers[i];\n        pos = pp.parse(context, text, pos);\n\n        if (pos < 0) {\n          context.endOptional(false);\n          return position;\n        }\n      }\n\n      context.endOptional(true);\n      return pos;\n    } else {\n      for (var _i = 0; _i < this._printerParsers.length; _i++) {\n        var _pp = this._printerParsers[_i];\n        position = _pp.parse(context, text, position);\n\n        if (position < 0) {\n          break;\n        }\n      }\n\n      return position;\n    }\n  };\n\n  _proto.toString = function toString() {\n    var buf = '';\n\n    if (this._printerParsers != null) {\n      buf += this._optional ? '[' : '(';\n\n      for (var i = 0; i < this._printerParsers.length; i++) {\n        var pp = this._printerParsers[i];\n        buf += pp.toString();\n      }\n\n      buf += this._optional ? ']' : ')';\n    }\n\n    return buf;\n  };\n\n  return CompositePrinterParser;\n}();\n\n/**\n * @copyright (c) 2016, Philipp Thürwächter & Pattrick Hüper\n * @copyright (c) 2007-present, Stephen Colebourne & Michael Nascimento Santos\n * @license BSD-3-Clause (see LICENSE in the root directory of this source tree)\n */\nvar FractionPrinterParser = function () {\n  function FractionPrinterParser(field, minWidth, maxWidth, decimalPoint) {\n    requireNonNull(field, 'field');\n\n    if (field.range().isFixed() === false) {\n      throw new IllegalArgumentException('Field must have a fixed set of values: ' + field);\n    }\n\n    if (minWidth < 0 || minWidth > 9) {\n      throw new IllegalArgumentException('Minimum width must be from 0 to 9 inclusive but was ' + minWidth);\n    }\n\n    if (maxWidth < 1 || maxWidth > 9) {\n      throw new IllegalArgumentException('Maximum width must be from 1 to 9 inclusive but was ' + maxWidth);\n    }\n\n    if (maxWidth < minWidth) {\n      throw new IllegalArgumentException('Maximum width must exceed or equal the minimum width but ' + maxWidth + ' < ' + minWidth);\n    }\n\n    this.field = field;\n    this.minWidth = minWidth;\n    this.maxWidth = maxWidth;\n    this.decimalPoint = decimalPoint;\n  }\n\n  var _proto = FractionPrinterParser.prototype;\n\n  _proto.print = function print(context, buf) {\n    var value = context.getValue(this.field);\n\n    if (value === null) {\n      return false;\n    }\n\n    var symbols = context.symbols();\n\n    if (value === 0) {\n      if (this.minWidth > 0) {\n        if (this.decimalPoint) {\n          buf.append(symbols.decimalSeparator());\n        }\n\n        for (var i = 0; i < this.minWidth; i++) {\n          buf.append(symbols.zeroDigit());\n        }\n      }\n    } else {\n      var fraction = this.convertToFraction(value, symbols.zeroDigit());\n      var outputScale = Math.min(Math.max(fraction.length, this.minWidth), this.maxWidth);\n      fraction = fraction.substr(0, outputScale);\n\n      if (fraction * 1 > 0) {\n        while (fraction.length > this.minWidth && fraction[fraction.length - 1] === '0') {\n          fraction = fraction.substr(0, fraction.length - 1);\n        }\n      }\n\n      var str = fraction;\n      str = symbols.convertNumberToI18N(str);\n\n      if (this.decimalPoint) {\n        buf.append(symbols.decimalSeparator());\n      }\n\n      buf.append(str);\n    }\n\n    return true;\n  };\n\n  _proto.parse = function parse(context, text, position) {\n    var effectiveMin = context.isStrict() ? this.minWidth : 0;\n    var effectiveMax = context.isStrict() ? this.maxWidth : 9;\n    var length = text.length;\n\n    if (position === length) {\n      return effectiveMin > 0 ? ~position : position;\n    }\n\n    if (this.decimalPoint) {\n      if (text[position] !== context.symbols().decimalSeparator()) {\n        return effectiveMin > 0 ? ~position : position;\n      }\n\n      position++;\n    }\n\n    var minEndPos = position + effectiveMin;\n\n    if (minEndPos > length) {\n      return ~position;\n    }\n\n    var maxEndPos = Math.min(position + effectiveMax, length);\n    var total = 0;\n    var pos = position;\n\n    while (pos < maxEndPos) {\n      var ch = text.charAt(pos++);\n      var digit = context.symbols().convertToDigit(ch);\n\n      if (digit < 0) {\n        if (pos < minEndPos) {\n          return ~position;\n        }\n\n        pos--;\n        break;\n      }\n\n      total = total * 10 + digit;\n    }\n\n    var moveLeft = pos - position;\n    var scale = Math.pow(10, moveLeft);\n    var value = this.convertFromFraction(total, scale);\n    return context.setParsedField(this.field, value, position, pos);\n  };\n\n  _proto.convertToFraction = function convertToFraction(value, zeroDigit) {\n    var range = this.field.range();\n    range.checkValidValue(value, this.field);\n\n    var _min = range.minimum();\n\n    var _range = range.maximum() - _min + 1;\n\n    var _value = value - _min;\n\n    var _scaled = MathUtil.intDiv(_value * 1000000000, _range);\n\n    var fraction = '' + _scaled;\n\n    while (fraction.length < 9) {\n      fraction = zeroDigit + fraction;\n    }\n\n    return fraction;\n  };\n\n  _proto.convertFromFraction = function convertFromFraction(total, scale) {\n    var range = this.field.range();\n\n    var _min = range.minimum();\n\n    var _range = range.maximum() - _min + 1;\n\n    var _value = MathUtil.intDiv(total * _range, scale);\n\n    return _value;\n  };\n\n  _proto.toString = function toString() {\n    var decimal = this.decimalPoint ? ',DecimalPoint' : '';\n    return 'Fraction(' + this.field + ',' + this.minWidth + ',' + this.maxWidth + decimal + ')';\n  };\n\n  return FractionPrinterParser;\n}();\n\nvar MAX_WIDTH = 15;\nvar EXCEED_POINTS = [0, 10, 100, 1000, 10000, 100000, 1000000, 10000000, 100000000, 1000000000];\nvar NumberPrinterParser = function () {\n  function NumberPrinterParser(field, minWidth, maxWidth, signStyle, subsequentWidth) {\n    if (subsequentWidth === void 0) {\n      subsequentWidth = 0;\n    }\n\n    this._field = field;\n    this._minWidth = minWidth;\n    this._maxWidth = maxWidth;\n    this._signStyle = signStyle;\n    this._subsequentWidth = subsequentWidth;\n  }\n\n  var _proto = NumberPrinterParser.prototype;\n\n  _proto.field = function field() {\n    return this._field;\n  };\n\n  _proto.minWidth = function minWidth() {\n    return this._minWidth;\n  };\n\n  _proto.maxWidth = function maxWidth() {\n    return this._maxWidth;\n  };\n\n  _proto.signStyle = function signStyle() {\n    return this._signStyle;\n  };\n\n  _proto.withFixedWidth = function withFixedWidth() {\n    if (this._subsequentWidth === -1) {\n      return this;\n    }\n\n    return new NumberPrinterParser(this._field, this._minWidth, this._maxWidth, this._signStyle, -1);\n  };\n\n  _proto.withSubsequentWidth = function withSubsequentWidth(subsequentWidth) {\n    return new NumberPrinterParser(this._field, this._minWidth, this._maxWidth, this._signStyle, this._subsequentWidth + subsequentWidth);\n  };\n\n  _proto._isFixedWidth = function _isFixedWidth() {\n    return this._subsequentWidth === -1 || this._subsequentWidth > 0 && this._minWidth === this._maxWidth && this._signStyle === SignStyle.NOT_NEGATIVE;\n  };\n\n  _proto.print = function print(context, buf) {\n    var contextValue = context.getValue(this._field);\n\n    if (contextValue == null) {\n      return false;\n    }\n\n    var value = this._getValue(context, contextValue);\n\n    var symbols = context.symbols();\n    var str = '' + Math.abs(value);\n\n    if (str.length > this._maxWidth) {\n      throw new DateTimeException('Field ' + this._field + ' cannot be printed as the value ' + value + ' exceeds the maximum print width of ' + this._maxWidth);\n    }\n\n    str = symbols.convertNumberToI18N(str);\n\n    if (value >= 0) {\n      switch (this._signStyle) {\n        case SignStyle.EXCEEDS_PAD:\n          if (this._minWidth < MAX_WIDTH && value >= EXCEED_POINTS[this._minWidth]) {\n            buf.append(symbols.positiveSign());\n          }\n\n          break;\n\n        case SignStyle.ALWAYS:\n          buf.append(symbols.positiveSign());\n          break;\n      }\n    } else {\n      switch (this._signStyle) {\n        case SignStyle.NORMAL:\n        case SignStyle.EXCEEDS_PAD:\n        case SignStyle.ALWAYS:\n          buf.append(symbols.negativeSign());\n          break;\n\n        case SignStyle.NOT_NEGATIVE:\n          throw new DateTimeException('Field ' + this._field + ' cannot be printed as the value ' + value + ' cannot be negative according to the SignStyle');\n      }\n    }\n\n    for (var i = 0; i < this._minWidth - str.length; i++) {\n      buf.append(symbols.zeroDigit());\n    }\n\n    buf.append(str);\n    return true;\n  };\n\n  _proto.parse = function parse(context, text, position) {\n    var length = text.length;\n\n    if (position === length) {\n      return ~position;\n    }\n\n    assert(position >= 0 && position < length);\n    var sign = text.charAt(position);\n    var negative = false;\n    var positive = false;\n\n    if (sign === context.symbols().positiveSign()) {\n      if (this._signStyle.parse(true, context.isStrict(), this._minWidth === this._maxWidth) === false) {\n        return ~position;\n      }\n\n      positive = true;\n      position++;\n    } else if (sign === context.symbols().negativeSign()) {\n      if (this._signStyle.parse(false, context.isStrict(), this._minWidth === this._maxWidth) === false) {\n        return ~position;\n      }\n\n      negative = true;\n      position++;\n    } else {\n      if (this._signStyle === SignStyle.ALWAYS && context.isStrict()) {\n        return ~position;\n      }\n    }\n\n    var effMinWidth = context.isStrict() || this._isFixedWidth() ? this._minWidth : 1;\n    var minEndPos = position + effMinWidth;\n\n    if (minEndPos > length) {\n      return ~position;\n    }\n\n    var effMaxWidth = (context.isStrict() || this._isFixedWidth() ? this._maxWidth : 9) + Math.max(this._subsequentWidth, 0);\n    var total = 0;\n    var pos = position;\n\n    for (var pass = 0; pass < 2; pass++) {\n      var maxEndPos = Math.min(pos + effMaxWidth, length);\n\n      while (pos < maxEndPos) {\n        var ch = text.charAt(pos++);\n        var digit = context.symbols().convertToDigit(ch);\n\n        if (digit < 0) {\n          pos--;\n\n          if (pos < minEndPos) {\n            return ~position;\n          }\n\n          break;\n        }\n\n        if (pos - position > MAX_WIDTH) {\n          throw new ArithmeticException('number text exceeds length');\n        } else {\n          total = total * 10 + digit;\n        }\n      }\n\n      if (this._subsequentWidth > 0 && pass === 0) {\n        var parseLen = pos - position;\n        effMaxWidth = Math.max(effMinWidth, parseLen - this._subsequentWidth);\n        pos = position;\n        total = 0;\n      } else {\n        break;\n      }\n    }\n\n    if (negative) {\n      if (total === 0 && context.isStrict()) {\n        return ~(position - 1);\n      }\n\n      if (total !== 0) {\n        total = -total;\n      }\n    } else if (this._signStyle === SignStyle.EXCEEDS_PAD && context.isStrict()) {\n      var _parseLen = pos - position;\n\n      if (positive) {\n        if (_parseLen <= this._minWidth) {\n          return ~(position - 1);\n        }\n      } else {\n        if (_parseLen > this._minWidth) {\n          return ~position;\n        }\n      }\n    }\n\n    return this._setValue(context, total, position, pos);\n  };\n\n  _proto._getValue = function _getValue(context, value) {\n    return value;\n  };\n\n  _proto._setValue = function _setValue(context, value, errorPos, successPos) {\n    return context.setParsedField(this._field, value, errorPos, successPos);\n  };\n\n  _proto.toString = function toString() {\n    if (this._minWidth === 1 && this._maxWidth === MAX_WIDTH && this._signStyle === SignStyle.NORMAL) {\n      return 'Value(' + this._field + ')';\n    }\n\n    if (this._minWidth === this._maxWidth && this._signStyle === SignStyle.NOT_NEGATIVE) {\n      return 'Value(' + this._field + ',' + this._minWidth + ')';\n    }\n\n    return 'Value(' + this._field + ',' + this._minWidth + ',' + this._maxWidth + ',' + this._signStyle + ')';\n  };\n\n  return NumberPrinterParser;\n}();\nvar ReducedPrinterParser = function (_NumberPrinterParser) {\n  _inheritsLoose(ReducedPrinterParser, _NumberPrinterParser);\n\n  function ReducedPrinterParser(field, width, maxWidth, baseValue, baseDate) {\n    var _this;\n\n    _this = _NumberPrinterParser.call(this, field, width, maxWidth, SignStyle.NOT_NEGATIVE) || this;\n\n    if (width < 1 || width > 10) {\n      throw new IllegalArgumentException('The width must be from 1 to 10 inclusive but was ' + width);\n    }\n\n    if (maxWidth < 1 || maxWidth > 10) {\n      throw new IllegalArgumentException('The maxWidth must be from 1 to 10 inclusive but was ' + maxWidth);\n    }\n\n    if (maxWidth < width) {\n      throw new IllegalArgumentException('The maxWidth must be greater than the width');\n    }\n\n    if (baseDate === null) {\n      if (field.range().isValidValue(baseValue) === false) {\n        throw new IllegalArgumentException('The base value must be within the range of the field');\n      }\n\n      if (baseValue + EXCEED_POINTS[width] > MathUtil.MAX_SAFE_INTEGER) {\n        throw new DateTimeException('Unable to add printer-parser as the range exceeds the capacity of an int');\n      }\n    }\n\n    _this._baseValue = baseValue;\n    _this._baseDate = baseDate;\n    return _this;\n  }\n\n  var _proto2 = ReducedPrinterParser.prototype;\n\n  _proto2._getValue = function _getValue(context, value) {\n    var absValue = Math.abs(value);\n    var baseValue = this._baseValue;\n\n    if (this._baseDate !== null) {\n      context.temporal();\n      var chrono = IsoChronology.INSTANCE;\n      baseValue = chrono.date(this._baseDate).get(this._field);\n    }\n\n    if (value >= baseValue && value < baseValue + EXCEED_POINTS[this._minWidth]) {\n      return absValue % EXCEED_POINTS[this._minWidth];\n    }\n\n    return absValue % EXCEED_POINTS[this._maxWidth];\n  };\n\n  _proto2._setValue = function _setValue(context, value, errorPos, successPos) {\n    var baseValue = this._baseValue;\n\n    if (this._baseDate != null) {\n      var chrono = context.getEffectiveChronology();\n      baseValue = chrono.date(this._baseDate).get(this._field);\n    }\n\n    var parseLen = successPos - errorPos;\n\n    if (parseLen === this._minWidth && value >= 0) {\n      var range = EXCEED_POINTS[this._minWidth];\n      var lastPart = baseValue % range;\n      var basePart = baseValue - lastPart;\n\n      if (baseValue > 0) {\n        value = basePart + value;\n      } else {\n        value = basePart - value;\n      }\n\n      if (value < baseValue) {\n        value += range;\n      }\n    }\n\n    return context.setParsedField(this._field, value, errorPos, successPos);\n  };\n\n  _proto2.withFixedWidth = function withFixedWidth() {\n    if (this._subsequentWidth === -1) {\n      return this;\n    }\n\n    return new ReducedPrinterParser(this._field, this._minWidth, this._maxWidth, this._baseValue, this._baseDate, -1);\n  };\n\n  _proto2.withSubsequentWidth = function withSubsequentWidth(subsequentWidth) {\n    return new ReducedPrinterParser(this._field, this._minWidth, this._maxWidth, this._baseValue, this._baseDate, this._subsequentWidth + subsequentWidth);\n  };\n\n  _proto2.isFixedWidth = function isFixedWidth(context) {\n    if (context.isStrict() === false) {\n      return false;\n    }\n\n    return _NumberPrinterParser.prototype.isFixedWidth.call(this, context);\n  };\n\n  _proto2.toString = function toString() {\n    return 'ReducedValue(' + this._field + ',' + this._minWidth + ',' + this._maxWidth + ',' + (this._baseDate != null ? this._baseDate : this._baseValue) + ')';\n  };\n\n  return ReducedPrinterParser;\n}(NumberPrinterParser);\n\n/**\n * @copyright (c) 2016, Philipp Thürwächter & Pattrick Hüper\n * @copyright (c) 2007-present, Stephen Colebourne & Michael Nascimento Santos\n * @license BSD-3-Clause (see LICENSE in the root directory of this source tree)\n */\nvar PATTERNS = ['+HH', '+HHmm', '+HH:mm', '+HHMM', '+HH:MM', '+HHMMss', '+HH:MM:ss', '+HHMMSS', '+HH:MM:SS'];\nvar OffsetIdPrinterParser = function () {\n  function OffsetIdPrinterParser(noOffsetText, pattern) {\n    requireNonNull(noOffsetText, 'noOffsetText');\n    requireNonNull(pattern, 'pattern');\n    this.noOffsetText = noOffsetText;\n    this.type = this._checkPattern(pattern);\n  }\n\n  var _proto = OffsetIdPrinterParser.prototype;\n\n  _proto._checkPattern = function _checkPattern(pattern) {\n    for (var i = 0; i < PATTERNS.length; i++) {\n      if (PATTERNS[i] === pattern) {\n        return i;\n      }\n    }\n\n    throw new IllegalArgumentException('Invalid zone offset pattern: ' + pattern);\n  };\n\n  _proto.print = function print(context, buf) {\n    var offsetSecs = context.getValue(ChronoField.OFFSET_SECONDS);\n\n    if (offsetSecs == null) {\n      return false;\n    }\n\n    var totalSecs = MathUtil.safeToInt(offsetSecs);\n\n    if (totalSecs === 0) {\n      buf.append(this.noOffsetText);\n    } else {\n      var absHours = Math.abs(MathUtil.intMod(MathUtil.intDiv(totalSecs, 3600), 100));\n      var absMinutes = Math.abs(MathUtil.intMod(MathUtil.intDiv(totalSecs, 60), 60));\n      var absSeconds = Math.abs(MathUtil.intMod(totalSecs, 60));\n      var bufPos = buf.length();\n      var output = absHours;\n      buf.append(totalSecs < 0 ? '-' : '+').appendChar(MathUtil.intDiv(absHours, 10) + '0').appendChar(MathUtil.intMod(absHours, 10) + '0');\n\n      if (this.type >= 3 || this.type >= 1 && absMinutes > 0) {\n        buf.append(this.type % 2 === 0 ? ':' : '').appendChar(MathUtil.intDiv(absMinutes, 10) + '0').appendChar(absMinutes % 10 + '0');\n        output += absMinutes;\n\n        if (this.type >= 7 || this.type >= 5 && absSeconds > 0) {\n          buf.append(this.type % 2 === 0 ? ':' : '').appendChar(MathUtil.intDiv(absSeconds, 10) + '0').appendChar(absSeconds % 10 + '0');\n          output += absSeconds;\n        }\n      }\n\n      if (output === 0) {\n        buf.setLength(bufPos);\n        buf.append(this.noOffsetText);\n      }\n    }\n\n    return true;\n  };\n\n  _proto.parse = function parse(context, text, position) {\n    var length = text.length;\n    var noOffsetLen = this.noOffsetText.length;\n\n    if (noOffsetLen === 0) {\n      if (position === length) {\n        return context.setParsedField(ChronoField.OFFSET_SECONDS, 0, position, position);\n      }\n    } else {\n      if (position === length) {\n        return ~position;\n      }\n\n      if (context.subSequenceEquals(text, position, this.noOffsetText, 0, noOffsetLen)) {\n        return context.setParsedField(ChronoField.OFFSET_SECONDS, 0, position, position + noOffsetLen);\n      }\n    }\n\n    var sign = text[position];\n\n    if (sign === '+' || sign === '-') {\n      var negative = sign === '-' ? -1 : 1;\n      var array = [0, 0, 0, 0];\n      array[0] = position + 1;\n\n      if ((this._parseNumber(array, 1, text, true) || this._parseNumber(array, 2, text, this.type >= 3) || this._parseNumber(array, 3, text, false)) === false) {\n        var offsetSecs = MathUtil.safeZero(negative * (array[1] * 3600 + array[2] * 60 + array[3]));\n        return context.setParsedField(ChronoField.OFFSET_SECONDS, offsetSecs, position, array[0]);\n      }\n    }\n\n    if (noOffsetLen === 0) {\n      return context.setParsedField(ChronoField.OFFSET_SECONDS, 0, position, position + noOffsetLen);\n    }\n\n    return ~position;\n  };\n\n  _proto._parseNumber = function _parseNumber(array, arrayIndex, parseText, required) {\n    if ((this.type + 3) / 2 < arrayIndex) {\n      return false;\n    }\n\n    var pos = array[0];\n\n    if (this.type % 2 === 0 && arrayIndex > 1) {\n      if (pos + 1 > parseText.length || parseText[pos] !== ':') {\n        return required;\n      }\n\n      pos++;\n    }\n\n    if (pos + 2 > parseText.length) {\n      return required;\n    }\n\n    var ch1 = parseText[pos++];\n    var ch2 = parseText[pos++];\n\n    if (ch1 < '0' || ch1 > '9' || ch2 < '0' || ch2 > '9') {\n      return required;\n    }\n\n    var value = (ch1.charCodeAt(0) - 48) * 10 + (ch2.charCodeAt(0) - 48);\n\n    if (value < 0 || value > 59) {\n      return required;\n    }\n\n    array[arrayIndex] = value;\n    array[0] = pos;\n    return false;\n  };\n\n  _proto.toString = function toString() {\n    var converted = this.noOffsetText.replace('\\'', '\\'\\'');\n    return 'Offset(' + PATTERNS[this.type] + ',\\'' + converted + '\\')';\n  };\n\n  return OffsetIdPrinterParser;\n}();\nOffsetIdPrinterParser.INSTANCE_ID = new OffsetIdPrinterParser('Z', '+HH:MM:ss');\nOffsetIdPrinterParser.PATTERNS = PATTERNS;\n\n/**\n * @copyright (c) 2016, Philipp Thürwächter & Pattrick Hüper\n * @copyright (c) 2007-present, Stephen Colebourne & Michael Nascimento Santos\n * @license BSD-3-Clause (see LICENSE in the root directory of this source tree)\n */\nvar PadPrinterParserDecorator = function () {\n  function PadPrinterParserDecorator(printerParser, padWidth, padChar) {\n    this._printerParser = printerParser;\n    this._padWidth = padWidth;\n    this._padChar = padChar;\n  }\n\n  var _proto = PadPrinterParserDecorator.prototype;\n\n  _proto.print = function print(context, buf) {\n    var preLen = buf.length();\n\n    if (this._printerParser.print(context, buf) === false) {\n      return false;\n    }\n\n    var len = buf.length() - preLen;\n\n    if (len > this._padWidth) {\n      throw new DateTimeException(\"Cannot print as output of \" + len + \" characters exceeds pad width of \" + this._padWidth);\n    }\n\n    for (var i = 0; i < this._padWidth - len; i++) {\n      buf.insert(preLen, this._padChar);\n    }\n\n    return true;\n  };\n\n  _proto.parse = function parse(context, text, position) {\n    var strict = context.isStrict();\n    var caseSensitive = context.isCaseSensitive();\n    assert(!(position > text.length));\n    assert(position >= 0);\n\n    if (position === text.length) {\n      return ~position;\n    }\n\n    var endPos = position + this._padWidth;\n\n    if (endPos > text.length) {\n      if (strict) {\n        return ~position;\n      }\n\n      endPos = text.length;\n    }\n\n    var pos = position;\n\n    while (pos < endPos && (caseSensitive ? text[pos] === this._padChar : context.charEquals(text[pos], this._padChar))) {\n      pos++;\n    }\n\n    text = text.substring(0, endPos);\n\n    var resultPos = this._printerParser.parse(context, text, pos);\n\n    if (resultPos !== endPos && strict) {\n      return ~(position + pos);\n    }\n\n    return resultPos;\n  };\n\n  _proto.toString = function toString() {\n    return \"Pad(\" + this._printerParser + \",\" + this._padWidth + (this._padChar === ' ' ? ')' : ',\\'' + this._padChar + '\\')');\n  };\n\n  return PadPrinterParserDecorator;\n}();\n\nvar SettingsParser = function (_Enum) {\n  _inheritsLoose(SettingsParser, _Enum);\n\n  function SettingsParser() {\n    return _Enum.apply(this, arguments) || this;\n  }\n\n  var _proto = SettingsParser.prototype;\n\n  _proto.print = function print() {\n    return true;\n  };\n\n  _proto.parse = function parse(context, text, position) {\n    switch (this) {\n      case SettingsParser.SENSITIVE:\n        context.setCaseSensitive(true);\n        break;\n\n      case SettingsParser.INSENSITIVE:\n        context.setCaseSensitive(false);\n        break;\n\n      case SettingsParser.STRICT:\n        context.setStrict(true);\n        break;\n\n      case SettingsParser.LENIENT:\n        context.setStrict(false);\n        break;\n    }\n\n    return position;\n  };\n\n  _proto.toString = function toString() {\n    switch (this) {\n      case SettingsParser.SENSITIVE:\n        return 'ParseCaseSensitive(true)';\n\n      case SettingsParser.INSENSITIVE:\n        return 'ParseCaseSensitive(false)';\n\n      case SettingsParser.STRICT:\n        return 'ParseStrict(true)';\n\n      case SettingsParser.LENIENT:\n        return 'ParseStrict(false)';\n    }\n  };\n\n  return SettingsParser;\n}(Enum);\nSettingsParser.SENSITIVE = new SettingsParser('SENSITIVE');\nSettingsParser.INSENSITIVE = new SettingsParser('INSENSITIVE');\nSettingsParser.STRICT = new SettingsParser('STRICT');\nSettingsParser.LENIENT = new SettingsParser('LENIENT');\n\n/**\n * @copyright (c) 2016, Philipp Thürwächter & Pattrick Hüper\n * @copyright (c) 2007-present, Stephen Colebourne & Michael Nascimento Santos\n * @license BSD-3-Clause (see LICENSE in the root directory of this source tree)\n */\nvar StringLiteralPrinterParser = function () {\n  function StringLiteralPrinterParser(literal) {\n    this._literal = literal;\n  }\n\n  var _proto = StringLiteralPrinterParser.prototype;\n\n  _proto.print = function print(context, buf) {\n    buf.append(this._literal);\n    return true;\n  };\n\n  _proto.parse = function parse(context, text, position) {\n    var length = text.length;\n    assert(!(position > length || position < 0));\n\n    if (context.subSequenceEquals(text, position, this._literal, 0, this._literal.length) === false) {\n      return ~position;\n    }\n\n    return position + this._literal.length;\n  };\n\n  _proto.toString = function toString() {\n    var converted = this._literal.replace(\"'\", \"''\");\n\n    return '\\'' + converted + '\\'';\n  };\n\n  return StringLiteralPrinterParser;\n}();\n\n/*\n * @copyright (c) 2016, Philipp Thürwächter, Pattrick Hüper\n * @copyright (c) 2007-present, Stephen Colebourne & Michael Nascimento Santos\n * @license BSD-3-Clause (see LICENSE in the root directory of this source tree)\n */\nvar ZoneRulesProvider = function () {\n  function ZoneRulesProvider() {}\n\n  ZoneRulesProvider.getRules = function getRules(zoneId) {\n    throw new DateTimeException('unsupported ZoneId:' + zoneId);\n  };\n\n  ZoneRulesProvider.getAvailableZoneIds = function getAvailableZoneIds() {\n    return [];\n  };\n\n  return ZoneRulesProvider;\n}();\n\nvar ZoneRegion = function (_ZoneId) {\n  _inheritsLoose(ZoneRegion, _ZoneId);\n\n  ZoneRegion.ofId = function ofId(zoneId) {\n    var rules = ZoneRulesProvider.getRules(zoneId);\n    return new ZoneRegion(zoneId, rules);\n  };\n\n  function ZoneRegion(id, rules) {\n    var _this;\n\n    _this = _ZoneId.call(this) || this;\n    _this._id = id;\n    _this._rules = rules;\n    return _this;\n  }\n\n  var _proto = ZoneRegion.prototype;\n\n  _proto.id = function id() {\n    return this._id;\n  };\n\n  _proto.rules = function rules() {\n    return this._rules;\n  };\n\n  return ZoneRegion;\n}(ZoneId);\n\n/**\n * @copyright (c) 2016, Philipp Thürwächter & Pattrick Hüper\n * @copyright (c) 2007-present, Stephen Colebourne & Michael Nascimento Santos\n * @license BSD-3-Clause (see LICENSE in the root directory of this source tree)\n */\nvar ZoneIdPrinterParser = function () {\n  function ZoneIdPrinterParser(query, description) {\n    this.query = query;\n    this.description = description;\n  }\n\n  var _proto = ZoneIdPrinterParser.prototype;\n\n  _proto.print = function print(context, buf) {\n    var zone = context.getValueQuery(this.query);\n\n    if (zone == null) {\n      return false;\n    }\n\n    buf.append(zone.id());\n    return true;\n  };\n\n  _proto.parse = function parse(context, text, position) {\n    var length = text.length;\n\n    if (position > length) {\n      return ~position;\n    }\n\n    if (position === length) {\n      return ~position;\n    }\n\n    var nextChar = text.charAt(position);\n\n    if (nextChar === '+' || nextChar === '-') {\n      var newContext = context.copy();\n      var endPos = OffsetIdPrinterParser.INSTANCE_ID.parse(newContext, text, position);\n\n      if (endPos < 0) {\n        return endPos;\n      }\n\n      var offset = newContext.getParsed(ChronoField.OFFSET_SECONDS);\n      var zone = ZoneOffset.ofTotalSeconds(offset);\n      context.setParsedZone(zone);\n      return endPos;\n    } else if (length >= position + 2) {\n      var nextNextChar = text.charAt(position + 1);\n\n      if (context.charEquals(nextChar, 'U') && context.charEquals(nextNextChar, 'T')) {\n        if (length >= position + 3 && context.charEquals(text.charAt(position + 2), 'C')) {\n          return this._parsePrefixedOffset(context, text, position, position + 3);\n        }\n\n        return this._parsePrefixedOffset(context, text, position, position + 2);\n      } else if (context.charEquals(nextChar, 'G') && length >= position + 3 && context.charEquals(nextNextChar, 'M') && context.charEquals(text.charAt(position + 2), 'T')) {\n        return this._parsePrefixedOffset(context, text, position, position + 3);\n      }\n    }\n\n    if (text.substr(position, 6) === 'SYSTEM') {\n      context.setParsedZone(ZoneId.systemDefault());\n      return position + 6;\n    }\n\n    if (context.charEquals(nextChar, 'Z')) {\n      context.setParsedZone(ZoneOffset.UTC);\n      return position + 1;\n    }\n\n    var availableZoneIds = ZoneRulesProvider.getAvailableZoneIds();\n\n    if (zoneIdTree.size !== availableZoneIds.length) {\n      zoneIdTree = ZoneIdTree.createTreeMap(availableZoneIds);\n    }\n\n    var maxParseLength = length - position;\n    var treeMap = zoneIdTree.treeMap;\n    var parsedZoneId = null;\n    var parseLength = 0;\n\n    while (treeMap != null) {\n      var parsedSubZoneId = text.substr(position, Math.min(treeMap.length, maxParseLength));\n      treeMap = treeMap.get(parsedSubZoneId);\n\n      if (treeMap != null && treeMap.isLeaf) {\n        parsedZoneId = parsedSubZoneId;\n        parseLength = treeMap.length;\n      }\n    }\n\n    if (parsedZoneId != null) {\n      context.setParsedZone(ZoneRegion.ofId(parsedZoneId));\n      return position + parseLength;\n    }\n\n    return ~position;\n  };\n\n  _proto._parsePrefixedOffset = function _parsePrefixedOffset(context, text, prefixPos, position) {\n    var prefix = text.substring(prefixPos, position).toUpperCase();\n    var newContext = context.copy();\n\n    if (position < text.length && context.charEquals(text.charAt(position), 'Z')) {\n      context.setParsedZone(ZoneId.ofOffset(prefix, ZoneOffset.UTC));\n      return position;\n    }\n\n    var endPos = OffsetIdPrinterParser.INSTANCE_ID.parse(newContext, text, position);\n\n    if (endPos < 0) {\n      context.setParsedZone(ZoneId.ofOffset(prefix, ZoneOffset.UTC));\n      return position;\n    }\n\n    var offsetSecs = newContext.getParsed(ChronoField.OFFSET_SECONDS);\n    var offset = ZoneOffset.ofTotalSeconds(offsetSecs);\n    context.setParsedZone(ZoneId.ofOffset(prefix, offset));\n    return endPos;\n  };\n\n  _proto.toString = function toString() {\n    return this.description;\n  };\n\n  return ZoneIdPrinterParser;\n}();\n\nvar ZoneIdTree = function () {\n  ZoneIdTree.createTreeMap = function createTreeMap(availableZoneIds) {\n    var sortedZoneIds = availableZoneIds.sort(function (a, b) {\n      return a.length - b.length;\n    });\n    var treeMap = new ZoneIdTreeMap(sortedZoneIds[0].length, false);\n\n    for (var i = 0; i < sortedZoneIds.length; i++) {\n      treeMap.add(sortedZoneIds[i]);\n    }\n\n    return new ZoneIdTree(sortedZoneIds.length, treeMap);\n  };\n\n  function ZoneIdTree(size, treeMap) {\n    this.size = size;\n    this.treeMap = treeMap;\n  }\n\n  return ZoneIdTree;\n}();\n\nvar ZoneIdTreeMap = function () {\n  function ZoneIdTreeMap(length, isLeaf) {\n    if (length === void 0) {\n      length = 0;\n    }\n\n    if (isLeaf === void 0) {\n      isLeaf = false;\n    }\n\n    this.length = length;\n    this.isLeaf = isLeaf;\n    this._treeMap = {};\n  }\n\n  var _proto2 = ZoneIdTreeMap.prototype;\n\n  _proto2.add = function add(zoneId) {\n    var idLength = zoneId.length;\n\n    if (idLength === this.length) {\n      this._treeMap[zoneId] = new ZoneIdTreeMap(idLength, true);\n    } else if (idLength > this.length) {\n      var subZoneId = zoneId.substr(0, this.length);\n      var subTreeMap = this._treeMap[subZoneId];\n\n      if (subTreeMap == null) {\n        subTreeMap = new ZoneIdTreeMap(idLength, false);\n        this._treeMap[subZoneId] = subTreeMap;\n      }\n\n      subTreeMap.add(zoneId);\n    }\n  };\n\n  _proto2.get = function get(zoneId) {\n    return this._treeMap[zoneId];\n  };\n\n  return ZoneIdTreeMap;\n}();\n\nvar zoneIdTree = new ZoneIdTree([]);\n\n/**\n * @copyright (c) 2016, Philipp Thürwächter & Pattrick Hüper\n * @copyright (c) 2007-present, Stephen Colebourne & Michael Nascimento Santos\n * @license BSD-3-Clause (see LICENSE in the root directory of this source tree)\n */\nvar MAX_WIDTH$1 = 15;\nvar DateTimeFormatterBuilder = function () {\n  function DateTimeFormatterBuilder() {\n    this._active = this;\n    this._parent = null;\n    this._printerParsers = [];\n    this._optional = false;\n    this._padNextWidth = 0;\n    this._padNextChar = null;\n    this._valueParserIndex = -1;\n  }\n\n  DateTimeFormatterBuilder._of = function _of(parent, optional) {\n    requireNonNull(parent, 'parent');\n    requireNonNull(optional, 'optional');\n    var dtFormatterBuilder = new DateTimeFormatterBuilder();\n    dtFormatterBuilder._parent = parent;\n    dtFormatterBuilder._optional = optional;\n    return dtFormatterBuilder;\n  };\n\n  var _proto = DateTimeFormatterBuilder.prototype;\n\n  _proto.parseCaseSensitive = function parseCaseSensitive() {\n    this._appendInternalPrinterParser(SettingsParser.SENSITIVE);\n\n    return this;\n  };\n\n  _proto.parseCaseInsensitive = function parseCaseInsensitive() {\n    this._appendInternalPrinterParser(SettingsParser.INSENSITIVE);\n\n    return this;\n  };\n\n  _proto.parseStrict = function parseStrict() {\n    this._appendInternalPrinterParser(SettingsParser.STRICT);\n\n    return this;\n  };\n\n  _proto.parseLenient = function parseLenient() {\n    this._appendInternalPrinterParser(SettingsParser.LENIENT);\n\n    return this;\n  };\n\n  _proto.appendValue = function appendValue() {\n    if (arguments.length === 1) {\n      return this._appendValue1.apply(this, arguments);\n    } else if (arguments.length === 2) {\n      return this._appendValue2.apply(this, arguments);\n    } else {\n      return this._appendValue4.apply(this, arguments);\n    }\n  };\n\n  _proto._appendValue1 = function _appendValue1(field) {\n    requireNonNull(field);\n\n    this._appendValuePrinterParser(new NumberPrinterParser(field, 1, MAX_WIDTH$1, SignStyle.NORMAL));\n\n    return this;\n  };\n\n  _proto._appendValue2 = function _appendValue2(field, width) {\n    requireNonNull(field);\n\n    if (width < 1 || width > MAX_WIDTH$1) {\n      throw new IllegalArgumentException(\"The width must be from 1 to \" + MAX_WIDTH$1 + \" inclusive but was \" + width);\n    }\n\n    var pp = new NumberPrinterParser(field, width, width, SignStyle.NOT_NEGATIVE);\n\n    this._appendValuePrinterParser(pp);\n\n    return this;\n  };\n\n  _proto._appendValue4 = function _appendValue4(field, minWidth, maxWidth, signStyle) {\n    requireNonNull(field);\n    requireNonNull(signStyle);\n\n    if (minWidth === maxWidth && signStyle === SignStyle.NOT_NEGATIVE) {\n      return this._appendValue2(field, maxWidth);\n    }\n\n    if (minWidth < 1 || minWidth > MAX_WIDTH$1) {\n      throw new IllegalArgumentException(\"The minimum width must be from 1 to \" + MAX_WIDTH$1 + \" inclusive but was \" + minWidth);\n    }\n\n    if (maxWidth < 1 || maxWidth > MAX_WIDTH$1) {\n      throw new IllegalArgumentException(\"The minimum width must be from 1 to \" + MAX_WIDTH$1 + \" inclusive but was \" + maxWidth);\n    }\n\n    if (maxWidth < minWidth) {\n      throw new IllegalArgumentException(\"The maximum width must exceed or equal the minimum width but \" + maxWidth + \" < \" + minWidth);\n    }\n\n    var pp = new NumberPrinterParser(field, minWidth, maxWidth, signStyle);\n\n    this._appendValuePrinterParser(pp);\n\n    return this;\n  };\n\n  _proto.appendValueReduced = function appendValueReduced() {\n    if (arguments.length === 4 && arguments[3] instanceof ChronoLocalDate) {\n      return this._appendValueReducedFieldWidthMaxWidthBaseDate.apply(this, arguments);\n    } else {\n      return this._appendValueReducedFieldWidthMaxWidthBaseValue.apply(this, arguments);\n    }\n  };\n\n  _proto._appendValueReducedFieldWidthMaxWidthBaseValue = function _appendValueReducedFieldWidthMaxWidthBaseValue(field, width, maxWidth, baseValue) {\n    requireNonNull(field, 'field');\n    var pp = new ReducedPrinterParser(field, width, maxWidth, baseValue, null);\n\n    this._appendValuePrinterParser(pp);\n\n    return this;\n  };\n\n  _proto._appendValueReducedFieldWidthMaxWidthBaseDate = function _appendValueReducedFieldWidthMaxWidthBaseDate(field, width, maxWidth, baseDate) {\n    requireNonNull(field, 'field');\n    requireNonNull(baseDate, 'baseDate');\n    requireInstance(baseDate, ChronoLocalDate, 'baseDate');\n    var pp = new ReducedPrinterParser(field, width, maxWidth, 0, baseDate);\n\n    this._appendValuePrinterParser(pp);\n\n    return this;\n  };\n\n  _proto._appendValuePrinterParser = function _appendValuePrinterParser(pp) {\n    assert(pp != null);\n\n    if (this._active._valueParserIndex >= 0 && this._active._printerParsers[this._active._valueParserIndex] instanceof NumberPrinterParser) {\n      var activeValueParser = this._active._valueParserIndex;\n      var basePP = this._active._printerParsers[activeValueParser];\n\n      if (pp.minWidth() === pp.maxWidth() && pp.signStyle() === SignStyle.NOT_NEGATIVE) {\n        basePP = basePP.withSubsequentWidth(pp.maxWidth());\n\n        this._appendInternal(pp.withFixedWidth());\n\n        this._active._valueParserIndex = activeValueParser;\n      } else {\n        basePP = basePP.withFixedWidth();\n        this._active._valueParserIndex = this._appendInternal(pp);\n      }\n\n      this._active._printerParsers[activeValueParser] = basePP;\n    } else {\n      this._active._valueParserIndex = this._appendInternal(pp);\n    }\n\n    return this;\n  };\n\n  _proto.appendFraction = function appendFraction(field, minWidth, maxWidth, decimalPoint) {\n    this._appendInternal(new FractionPrinterParser(field, minWidth, maxWidth, decimalPoint));\n\n    return this;\n  };\n\n  _proto.appendInstant = function appendInstant(fractionalDigits) {\n    if (fractionalDigits === void 0) {\n      fractionalDigits = -2;\n    }\n\n    if (fractionalDigits < -2 || fractionalDigits > 9) {\n      throw new IllegalArgumentException('Invalid fractional digits: ' + fractionalDigits);\n    }\n\n    this._appendInternal(new InstantPrinterParser(fractionalDigits));\n\n    return this;\n  };\n\n  _proto.appendOffsetId = function appendOffsetId() {\n    this._appendInternal(OffsetIdPrinterParser.INSTANCE_ID);\n\n    return this;\n  };\n\n  _proto.appendOffset = function appendOffset(pattern, noOffsetText) {\n    this._appendInternalPrinterParser(new OffsetIdPrinterParser(noOffsetText, pattern));\n\n    return this;\n  };\n\n  _proto.appendZoneId = function appendZoneId() {\n    this._appendInternal(new ZoneIdPrinterParser(TemporalQueries.zoneId(), 'ZoneId()'));\n\n    return this;\n  };\n\n  _proto.appendPattern = function appendPattern(pattern) {\n    requireNonNull(pattern, 'pattern');\n\n    this._parsePattern(pattern);\n\n    return this;\n  };\n\n  _proto.appendZoneText = function appendZoneText() {\n    throw new IllegalArgumentException('Pattern using (localized) text not implemented, use js-joda-locale plugin!');\n  };\n\n  _proto.appendText = function appendText() {\n    throw new IllegalArgumentException('Pattern using (localized) text not implemented, use js-joda-locale plugin!');\n  };\n\n  _proto.appendLocalizedOffset = function appendLocalizedOffset() {\n    throw new IllegalArgumentException('Pattern using (localized) text not implemented, use js-joda-locale plugin!');\n  };\n\n  _proto.appendWeekField = function appendWeekField() {\n    throw new IllegalArgumentException('Pattern using (localized) text not implemented, use js-joda-locale plugin!');\n  };\n\n  _proto._parsePattern = function _parsePattern(pattern) {\n    var FIELD_MAP = {\n      'G': ChronoField.ERA,\n      'y': ChronoField.YEAR_OF_ERA,\n      'u': ChronoField.YEAR,\n      'Q': IsoFields.QUARTER_OF_YEAR,\n      'q': IsoFields.QUARTER_OF_YEAR,\n      'M': ChronoField.MONTH_OF_YEAR,\n      'L': ChronoField.MONTH_OF_YEAR,\n      'D': ChronoField.DAY_OF_YEAR,\n      'd': ChronoField.DAY_OF_MONTH,\n      'F': ChronoField.ALIGNED_DAY_OF_WEEK_IN_MONTH,\n      'E': ChronoField.DAY_OF_WEEK,\n      'c': ChronoField.DAY_OF_WEEK,\n      'e': ChronoField.DAY_OF_WEEK,\n      'a': ChronoField.AMPM_OF_DAY,\n      'H': ChronoField.HOUR_OF_DAY,\n      'k': ChronoField.CLOCK_HOUR_OF_DAY,\n      'K': ChronoField.HOUR_OF_AMPM,\n      'h': ChronoField.CLOCK_HOUR_OF_AMPM,\n      'm': ChronoField.MINUTE_OF_HOUR,\n      's': ChronoField.SECOND_OF_MINUTE,\n      'S': ChronoField.NANO_OF_SECOND,\n      'A': ChronoField.MILLI_OF_DAY,\n      'n': ChronoField.NANO_OF_SECOND,\n      'N': ChronoField.NANO_OF_DAY\n    };\n\n    for (var pos = 0; pos < pattern.length; pos++) {\n      var cur = pattern.charAt(pos);\n\n      if (cur >= 'A' && cur <= 'Z' || cur >= 'a' && cur <= 'z') {\n        var start = pos++;\n\n        for (; pos < pattern.length && pattern.charAt(pos) === cur; pos++) {\n        }\n\n        var count = pos - start;\n\n        if (cur === 'p') {\n          var pad = 0;\n\n          if (pos < pattern.length) {\n            cur = pattern.charAt(pos);\n\n            if (cur >= 'A' && cur <= 'Z' || cur >= 'a' && cur <= 'z') {\n              pad = count;\n              start = pos++;\n\n              for (; pos < pattern.length && pattern.charAt(pos) === cur; pos++) {\n              }\n\n              count = pos - start;\n            }\n          }\n\n          if (pad === 0) {\n            throw new IllegalArgumentException('Pad letter \\'p\\' must be followed by valid pad pattern: ' + pattern);\n          }\n\n          this.padNext(pad);\n        }\n\n        var field = FIELD_MAP[cur];\n\n        if (field != null) {\n          this._parseField(cur, count, field);\n        } else if (cur === 'z') {\n          if (count > 4) {\n            throw new IllegalArgumentException('Too many pattern letters: ' + cur);\n          } else if (count === 4) {\n            this.appendZoneText(TextStyle.FULL);\n          } else {\n            this.appendZoneText(TextStyle.SHORT);\n          }\n        } else if (cur === 'V') {\n          if (count !== 2) {\n            throw new IllegalArgumentException('Pattern letter count must be 2: ' + cur);\n          }\n\n          this.appendZoneId();\n        } else if (cur === 'Z') {\n          if (count < 4) {\n            this.appendOffset('+HHMM', '+0000');\n          } else if (count === 4) {\n            this.appendLocalizedOffset(TextStyle.FULL);\n          } else if (count === 5) {\n            this.appendOffset('+HH:MM:ss', 'Z');\n          } else {\n            throw new IllegalArgumentException('Too many pattern letters: ' + cur);\n          }\n        } else if (cur === 'O') {\n          if (count === 1) {\n            this.appendLocalizedOffset(TextStyle.SHORT);\n          } else if (count === 4) {\n            this.appendLocalizedOffset(TextStyle.FULL);\n          } else {\n            throw new IllegalArgumentException('Pattern letter count must be 1 or 4: ' + cur);\n          }\n        } else if (cur === 'X') {\n          if (count > 5) {\n            throw new IllegalArgumentException('Too many pattern letters: ' + cur);\n          }\n\n          this.appendOffset(OffsetIdPrinterParser.PATTERNS[count + (count === 1 ? 0 : 1)], 'Z');\n        } else if (cur === 'x') {\n          if (count > 5) {\n            throw new IllegalArgumentException('Too many pattern letters: ' + cur);\n          }\n\n          var zero = count === 1 ? '+00' : count % 2 === 0 ? '+0000' : '+00:00';\n          this.appendOffset(OffsetIdPrinterParser.PATTERNS[count + (count === 1 ? 0 : 1)], zero);\n        } else if (cur === 'W') {\n          if (count > 1) {\n            throw new IllegalArgumentException('Too many pattern letters: ' + cur);\n          }\n\n          this.appendWeekField('W', count);\n        } else if (cur === 'w') {\n          if (count > 2) {\n            throw new IllegalArgumentException('Too many pattern letters: ' + cur);\n          }\n\n          this.appendWeekField('w', count);\n        } else if (cur === 'Y') {\n          this.appendWeekField('Y', count);\n        } else {\n          throw new IllegalArgumentException('Unknown pattern letter: ' + cur);\n        }\n\n        pos--;\n      } else if (cur === '\\'') {\n        var _start = pos++;\n\n        for (; pos < pattern.length; pos++) {\n          if (pattern.charAt(pos) === '\\'') {\n            if (pos + 1 < pattern.length && pattern.charAt(pos + 1) === '\\'') {\n              pos++;\n            } else {\n              break;\n            }\n          }\n        }\n\n        if (pos >= pattern.length) {\n          throw new IllegalArgumentException('Pattern ends with an incomplete string literal: ' + pattern);\n        }\n\n        var str = pattern.substring(_start + 1, pos);\n\n        if (str.length === 0) {\n          this.appendLiteral('\\'');\n        } else {\n          this.appendLiteral(str.replace('\\'\\'', '\\''));\n        }\n      } else if (cur === '[') {\n        this.optionalStart();\n      } else if (cur === ']') {\n        if (this._active._parent === null) {\n          throw new IllegalArgumentException('Pattern invalid as it contains ] without previous [');\n        }\n\n        this.optionalEnd();\n      } else if (cur === '{' || cur === '}' || cur === '#') {\n        throw new IllegalArgumentException('Pattern includes reserved character: \\'' + cur + '\\'');\n      } else {\n        this.appendLiteral(cur);\n      }\n    }\n  };\n\n  _proto._parseField = function _parseField(cur, count, field) {\n    switch (cur) {\n      case 'u':\n      case 'y':\n        if (count === 2) {\n          this.appendValueReduced(field, 2, 2, ReducedPrinterParser.BASE_DATE);\n        } else if (count < 4) {\n          this.appendValue(field, count, MAX_WIDTH$1, SignStyle.NORMAL);\n        } else {\n          this.appendValue(field, count, MAX_WIDTH$1, SignStyle.EXCEEDS_PAD);\n        }\n\n        break;\n\n      case 'M':\n      case 'Q':\n        switch (count) {\n          case 1:\n            this.appendValue(field);\n            break;\n\n          case 2:\n            this.appendValue(field, 2);\n            break;\n\n          case 3:\n            this.appendText(field, TextStyle.SHORT);\n            break;\n\n          case 4:\n            this.appendText(field, TextStyle.FULL);\n            break;\n\n          case 5:\n            this.appendText(field, TextStyle.NARROW);\n            break;\n\n          default:\n            throw new IllegalArgumentException('Too many pattern letters: ' + cur);\n        }\n\n        break;\n\n      case 'L':\n      case 'q':\n        switch (count) {\n          case 1:\n            this.appendValue(field);\n            break;\n\n          case 2:\n            this.appendValue(field, 2);\n            break;\n\n          case 3:\n            this.appendText(field, TextStyle.SHORT_STANDALONE);\n            break;\n\n          case 4:\n            this.appendText(field, TextStyle.FULL_STANDALONE);\n            break;\n\n          case 5:\n            this.appendText(field, TextStyle.NARROW_STANDALONE);\n            break;\n\n          default:\n            throw new IllegalArgumentException('Too many pattern letters: ' + cur);\n        }\n\n        break;\n\n      case 'e':\n        switch (count) {\n          case 1:\n          case 2:\n            this.appendWeekField('e', count);\n            break;\n\n          case 3:\n            this.appendText(field, TextStyle.SHORT);\n            break;\n\n          case 4:\n            this.appendText(field, TextStyle.FULL);\n            break;\n\n          case 5:\n            this.appendText(field, TextStyle.NARROW);\n            break;\n\n          default:\n            throw new IllegalArgumentException('Too many pattern letters: ' + cur);\n        }\n\n        break;\n\n      case 'c':\n        switch (count) {\n          case 1:\n            this.appendWeekField('c', count);\n            break;\n\n          case 2:\n            throw new IllegalArgumentException('Invalid number of pattern letters: ' + cur);\n\n          case 3:\n            this.appendText(field, TextStyle.SHORT_STANDALONE);\n            break;\n\n          case 4:\n            this.appendText(field, TextStyle.FULL_STANDALONE);\n            break;\n\n          case 5:\n            this.appendText(field, TextStyle.NARROW_STANDALONE);\n            break;\n\n          default:\n            throw new IllegalArgumentException('Too many pattern letters: ' + cur);\n        }\n\n        break;\n\n      case 'a':\n        if (count === 1) {\n          this.appendText(field, TextStyle.SHORT);\n        } else {\n          throw new IllegalArgumentException('Too many pattern letters: ' + cur);\n        }\n\n        break;\n\n      case 'E':\n      case 'G':\n        switch (count) {\n          case 1:\n          case 2:\n          case 3:\n            this.appendText(field, TextStyle.SHORT);\n            break;\n\n          case 4:\n            this.appendText(field, TextStyle.FULL);\n            break;\n\n          case 5:\n            this.appendText(field, TextStyle.NARROW);\n            break;\n\n          default:\n            throw new IllegalArgumentException('Too many pattern letters: ' + cur);\n        }\n\n        break;\n\n      case 'S':\n        this.appendFraction(ChronoField.NANO_OF_SECOND, count, count, false);\n        break;\n\n      case 'F':\n        if (count === 1) {\n          this.appendValue(field);\n        } else {\n          throw new IllegalArgumentException('Too many pattern letters: ' + cur);\n        }\n\n        break;\n\n      case 'd':\n      case 'h':\n      case 'H':\n      case 'k':\n      case 'K':\n      case 'm':\n      case 's':\n        if (count === 1) {\n          this.appendValue(field);\n        } else if (count === 2) {\n          this.appendValue(field, count);\n        } else {\n          throw new IllegalArgumentException('Too many pattern letters: ' + cur);\n        }\n\n        break;\n\n      case 'D':\n        if (count === 1) {\n          this.appendValue(field);\n        } else if (count <= 3) {\n          this.appendValue(field, count);\n        } else {\n          throw new IllegalArgumentException('Too many pattern letters: ' + cur);\n        }\n\n        break;\n\n      default:\n        if (count === 1) {\n          this.appendValue(field);\n        } else {\n          this.appendValue(field, count);\n        }\n\n        break;\n    }\n  };\n\n  _proto.padNext = function padNext() {\n    if (arguments.length === 1) {\n      return this._padNext1.apply(this, arguments);\n    } else {\n      return this._padNext2.apply(this, arguments);\n    }\n  };\n\n  _proto._padNext1 = function _padNext1(padWidth) {\n    return this._padNext2(padWidth, ' ');\n  };\n\n  _proto._padNext2 = function _padNext2(padWidth, padChar) {\n    if (padWidth < 1) {\n      throw new IllegalArgumentException('The pad width must be at least one but was ' + padWidth);\n    }\n\n    this._active._padNextWidth = padWidth;\n    this._active._padNextChar = padChar;\n    this._active._valueParserIndex = -1;\n    return this;\n  };\n\n  _proto.optionalStart = function optionalStart() {\n    this._active._valueParserIndex = -1;\n    this._active = DateTimeFormatterBuilder._of(this._active, true);\n    return this;\n  };\n\n  _proto.optionalEnd = function optionalEnd() {\n    if (this._active._parent == null) {\n      throw new IllegalStateException('Cannot call optionalEnd() as there was no previous call to optionalStart()');\n    }\n\n    if (this._active._printerParsers.length > 0) {\n      var cpp = new CompositePrinterParser(this._active._printerParsers, this._active._optional);\n      this._active = this._active._parent;\n\n      this._appendInternal(cpp);\n    } else {\n      this._active = this._active._parent;\n    }\n\n    return this;\n  };\n\n  _proto._appendInternal = function _appendInternal(pp) {\n    assert(pp != null);\n\n    if (this._active._padNextWidth > 0) {\n      if (pp != null) {\n        pp = new PadPrinterParserDecorator(pp, this._active._padNextWidth, this._active._padNextChar);\n      }\n\n      this._active._padNextWidth = 0;\n      this._active._padNextChar = 0;\n    }\n\n    this._active._printerParsers.push(pp);\n\n    this._active._valueParserIndex = -1;\n    return this._active._printerParsers.length - 1;\n  };\n\n  _proto.appendLiteral = function appendLiteral(literal) {\n    assert(literal != null);\n\n    if (literal.length > 0) {\n      if (literal.length === 1) {\n        this._appendInternalPrinterParser(new CharLiteralPrinterParser(literal.charAt(0)));\n      } else {\n        this._appendInternalPrinterParser(new StringLiteralPrinterParser(literal));\n      }\n    }\n\n    return this;\n  };\n\n  _proto._appendInternalPrinterParser = function _appendInternalPrinterParser(pp) {\n    assert(pp != null);\n\n    if (this._active._padNextWidth > 0) {\n      if (pp != null) {\n        pp = new PadPrinterParserDecorator(pp, this._active._padNextWidth, this._active._padNextChar);\n      }\n\n      this._active._padNextWidth = 0;\n      this._active._padNextChar = 0;\n    }\n\n    this._active._printerParsers.push(pp);\n\n    this._active._valueParserIndex = -1;\n    return this._active._printerParsers.length - 1;\n  };\n\n  _proto.append = function append(formatter) {\n    requireNonNull(formatter, 'formatter');\n\n    this._appendInternal(formatter._toPrinterParser(false));\n\n    return this;\n  };\n\n  _proto.toFormatter = function toFormatter(resolverStyle) {\n    if (resolverStyle === void 0) {\n      resolverStyle = ResolverStyle.SMART;\n    }\n\n    while (this._active._parent != null) {\n      this.optionalEnd();\n    }\n\n    var pp = new CompositePrinterParser(this._printerParsers, false);\n    return new DateTimeFormatter(pp, null, DecimalStyle.STANDARD, resolverStyle, null, null, null);\n  };\n\n  return DateTimeFormatterBuilder;\n}();\nvar SECONDS_PER_10000_YEARS = 146097 * 25 * 86400;\nvar SECONDS_0000_TO_1970 = (146097 * 5 - (30 * 365 + 7)) * 86400;\n\nvar InstantPrinterParser = function () {\n  function InstantPrinterParser(fractionalDigits) {\n    this.fractionalDigits = fractionalDigits;\n  }\n\n  var _proto2 = InstantPrinterParser.prototype;\n\n  _proto2.print = function print(context, buf) {\n    var inSecs = context.getValue(ChronoField.INSTANT_SECONDS);\n    var inNanos = 0;\n\n    if (context.temporal().isSupported(ChronoField.NANO_OF_SECOND)) {\n      inNanos = context.temporal().getLong(ChronoField.NANO_OF_SECOND);\n    }\n\n    if (inSecs == null) {\n      return false;\n    }\n\n    var inSec = inSecs;\n    var inNano = ChronoField.NANO_OF_SECOND.checkValidIntValue(inNanos);\n\n    if (inSec >= -SECONDS_0000_TO_1970) {\n      var zeroSecs = inSec - SECONDS_PER_10000_YEARS + SECONDS_0000_TO_1970;\n      var hi = MathUtil.floorDiv(zeroSecs, SECONDS_PER_10000_YEARS) + 1;\n      var lo = MathUtil.floorMod(zeroSecs, SECONDS_PER_10000_YEARS);\n      var ldt = LocalDateTime.ofEpochSecond(lo - SECONDS_0000_TO_1970, 0, ZoneOffset.UTC);\n\n      if (hi > 0) {\n        buf.append('+').append(hi);\n      }\n\n      buf.append(ldt);\n\n      if (ldt.second() === 0) {\n        buf.append(':00');\n      }\n    } else {\n      var _zeroSecs = inSec + SECONDS_0000_TO_1970;\n\n      var _hi = MathUtil.intDiv(_zeroSecs, SECONDS_PER_10000_YEARS);\n\n      var _lo = MathUtil.intMod(_zeroSecs, SECONDS_PER_10000_YEARS);\n\n      var _ldt = LocalDateTime.ofEpochSecond(_lo - SECONDS_0000_TO_1970, 0, ZoneOffset.UTC);\n\n      var pos = buf.length();\n      buf.append(_ldt);\n\n      if (_ldt.second() === 0) {\n        buf.append(':00');\n      }\n\n      if (_hi < 0) {\n        if (_ldt.year() === -10000) {\n          buf.replace(pos, pos + 2, '' + (_hi - 1));\n        } else if (_lo === 0) {\n          buf.insert(pos, _hi);\n        } else {\n          buf.insert(pos + 1, Math.abs(_hi));\n        }\n      }\n    }\n\n    if (this.fractionalDigits === -2) {\n      if (inNano !== 0) {\n        buf.append('.');\n\n        if (MathUtil.intMod(inNano, 1000000) === 0) {\n          buf.append(('' + (MathUtil.intDiv(inNano, 1000000) + 1000)).substring(1));\n        } else if (MathUtil.intMod(inNano, 1000) === 0) {\n          buf.append(('' + (MathUtil.intDiv(inNano, 1000) + 1000000)).substring(1));\n        } else {\n          buf.append(('' + (inNano + 1000000000)).substring(1));\n        }\n      }\n    } else if (this.fractionalDigits > 0 || this.fractionalDigits === -1 && inNano > 0) {\n      buf.append('.');\n      var div = 100000000;\n\n      for (var i = 0; this.fractionalDigits === -1 && inNano > 0 || i < this.fractionalDigits; i++) {\n        var digit = MathUtil.intDiv(inNano, div);\n        buf.append(digit);\n        inNano = inNano - digit * div;\n        div = MathUtil.intDiv(div, 10);\n      }\n    }\n\n    buf.append('Z');\n    return true;\n  };\n\n  _proto2.parse = function parse(context, text, position) {\n    var newContext = context.copy();\n    var minDigits = this.fractionalDigits < 0 ? 0 : this.fractionalDigits;\n    var maxDigits = this.fractionalDigits < 0 ? 9 : this.fractionalDigits;\n\n    var parser = new DateTimeFormatterBuilder().append(DateTimeFormatter.ISO_LOCAL_DATE).appendLiteral('T').appendValue(ChronoField.HOUR_OF_DAY, 2).appendLiteral(':').appendValue(ChronoField.MINUTE_OF_HOUR, 2).appendLiteral(':').appendValue(ChronoField.SECOND_OF_MINUTE, 2).appendFraction(ChronoField.NANO_OF_SECOND, minDigits, maxDigits, true).appendLiteral('Z').toFormatter()._toPrinterParser(false);\n\n    var pos = parser.parse(newContext, text, position);\n\n    if (pos < 0) {\n      return pos;\n    }\n\n    var yearParsed = newContext.getParsed(ChronoField.YEAR);\n    var month = newContext.getParsed(ChronoField.MONTH_OF_YEAR);\n    var day = newContext.getParsed(ChronoField.DAY_OF_MONTH);\n    var hour = newContext.getParsed(ChronoField.HOUR_OF_DAY);\n    var min = newContext.getParsed(ChronoField.MINUTE_OF_HOUR);\n    var secVal = newContext.getParsed(ChronoField.SECOND_OF_MINUTE);\n    var nanoVal = newContext.getParsed(ChronoField.NANO_OF_SECOND);\n    var sec = secVal != null ? secVal : 0;\n    var nano = nanoVal != null ? nanoVal : 0;\n    var year = MathUtil.intMod(yearParsed, 10000);\n    var days = 0;\n\n    if (hour === 24 && min === 0 && sec === 0 && nano === 0) {\n      hour = 0;\n      days = 1;\n    } else if (hour === 23 && min === 59 && sec === 60) {\n      context.setParsedLeapSecond();\n      sec = 59;\n    }\n\n    var instantSecs;\n\n    try {\n      var ldt = LocalDateTime.of(year, month, day, hour, min, sec, 0).plusDays(days);\n      instantSecs = ldt.toEpochSecond(ZoneOffset.UTC);\n      instantSecs += MathUtil.safeMultiply(MathUtil.intDiv(yearParsed, 10000), SECONDS_PER_10000_YEARS);\n    } catch (ex) {\n      return ~position;\n    }\n\n    var successPos = pos;\n    successPos = context.setParsedField(ChronoField.INSTANT_SECONDS, instantSecs, position, successPos);\n    return context.setParsedField(ChronoField.NANO_OF_SECOND, nano, position, successPos);\n  };\n\n  _proto2.toString = function toString() {\n    return 'Instant()';\n  };\n\n  return InstantPrinterParser;\n}();\n\nfunction _init$9() {\n  ReducedPrinterParser.BASE_DATE = LocalDate.of(2000, 1, 1);\n  DateTimeFormatterBuilder.CompositePrinterParser = CompositePrinterParser;\n  DateTimeFormatterBuilder.PadPrinterParserDecorator = PadPrinterParserDecorator;\n  DateTimeFormatterBuilder.SettingsParser = SettingsParser;\n  DateTimeFormatterBuilder.CharLiteralPrinterParser = StringLiteralPrinterParser;\n  DateTimeFormatterBuilder.StringLiteralPrinterParser = StringLiteralPrinterParser;\n  DateTimeFormatterBuilder.CharLiteralPrinterParser = CharLiteralPrinterParser;\n  DateTimeFormatterBuilder.NumberPrinterParser = NumberPrinterParser;\n  DateTimeFormatterBuilder.ReducedPrinterParser = ReducedPrinterParser;\n  DateTimeFormatterBuilder.FractionPrinterParser = FractionPrinterParser;\n  DateTimeFormatterBuilder.OffsetIdPrinterParser = OffsetIdPrinterParser;\n  DateTimeFormatterBuilder.ZoneIdPrinterParser = ZoneIdPrinterParser;\n}\n\n/*\n * @copyright (c) 2016, Philipp Thürwächter & Pattrick Hüper\n * @license BSD-3-Clause (see LICENSE in the root directory of this source tree)\n */\nvar StringBuilder = function () {\n  function StringBuilder() {\n    this._str = '';\n  }\n\n  var _proto = StringBuilder.prototype;\n\n  _proto.append = function append(str) {\n    this._str += str;\n    return this;\n  };\n\n  _proto.appendChar = function appendChar(str) {\n    this._str += str[0];\n    return this;\n  };\n\n  _proto.insert = function insert(offset, str) {\n    this._str = this._str.slice(0, offset) + str + this._str.slice(offset);\n    return this;\n  };\n\n  _proto.replace = function replace(start, end, str) {\n    this._str = this._str.slice(0, start) + str + this._str.slice(end);\n    return this;\n  };\n\n  _proto.length = function length() {\n    return this._str.length;\n  };\n\n  _proto.setLength = function setLength(length) {\n    this._str = this._str.slice(0, length);\n    return this;\n  };\n\n  _proto.toString = function toString() {\n    return this._str;\n  };\n\n  return StringBuilder;\n}();\n\n/**\n * @copyright (c) 2016, Philipp Thürwächter & Pattrick Hüper\n * @copyright (c) 2007-present, Stephen Colebourne & Michael Nascimento Santos\n * @license BSD-3-Clause (see LICENSE in the root directory of this source tree)\n */\nvar DateTimeFormatter = function () {\n  DateTimeFormatter.parsedExcessDays = function parsedExcessDays() {\n    return DateTimeFormatter.PARSED_EXCESS_DAYS;\n  };\n\n  DateTimeFormatter.parsedLeapSecond = function parsedLeapSecond() {\n    return DateTimeFormatter.PARSED_LEAP_SECOND;\n  };\n\n  DateTimeFormatter.ofPattern = function ofPattern(pattern) {\n    return new DateTimeFormatterBuilder().appendPattern(pattern).toFormatter();\n  };\n\n  function DateTimeFormatter(printerParser, locale, decimalStyle, resolverStyle, resolverFields, chrono, zone) {\n    if (chrono === void 0) {\n      chrono = IsoChronology.INSTANCE;\n    }\n\n    assert(printerParser != null);\n    assert(decimalStyle != null);\n    assert(resolverStyle != null);\n    this._printerParser = printerParser;\n    this._locale = locale;\n    this._decimalStyle = decimalStyle;\n    this._resolverStyle = resolverStyle;\n    this._resolverFields = resolverFields;\n    this._chrono = chrono;\n    this._zone = zone;\n  }\n\n  var _proto = DateTimeFormatter.prototype;\n\n  _proto.locale = function locale() {\n    return this._locale;\n  };\n\n  _proto.decimalStyle = function decimalStyle() {\n    return this._decimalStyle;\n  };\n\n  _proto.chronology = function chronology() {\n    return this._chrono;\n  };\n\n  _proto.withChronology = function withChronology(chrono) {\n    if (this._chrono != null && this._chrono.equals(chrono)) {\n      return this;\n    }\n\n    return new DateTimeFormatter(this._printerParser, this._locale, this._decimalStyle, this._resolverStyle, this._resolverFields, chrono, this._zone);\n  };\n\n  _proto.withLocale = function withLocale() {\n    return this;\n  };\n\n  _proto.withResolverStyle = function withResolverStyle(resolverStyle) {\n    requireNonNull(resolverStyle, 'resolverStyle');\n\n    if (resolverStyle.equals(this._resolverStyle)) {\n      return this;\n    }\n\n    return new DateTimeFormatter(this._printerParser, this._locale, this._decimalStyle, resolverStyle, this._resolverFields, this._chrono, this._zone);\n  };\n\n  _proto.format = function format(temporal) {\n    var buf = new StringBuilder(32);\n\n    this._formatTo(temporal, buf);\n\n    return buf.toString();\n  };\n\n  _proto._formatTo = function _formatTo(temporal, appendable) {\n    requireNonNull(temporal, 'temporal');\n    requireNonNull(appendable, 'appendable');\n    var context = new DateTimePrintContext(temporal, this);\n\n    this._printerParser.print(context, appendable);\n  };\n\n  _proto.parse = function parse(text, type) {\n    if (arguments.length === 1) {\n      return this.parse1(text);\n    } else {\n      return this.parse2(text, type);\n    }\n  };\n\n  _proto.parse1 = function parse1(text) {\n    requireNonNull(text, 'text');\n\n    try {\n      return this._parseToBuilder(text, null).resolve(this._resolverStyle, this._resolverFields);\n    } catch (ex) {\n      if (ex instanceof DateTimeParseException) {\n        throw ex;\n      } else {\n        throw this._createError(text, ex);\n      }\n    }\n  };\n\n  _proto.parse2 = function parse2(text, type) {\n    requireNonNull(text, 'text');\n    requireNonNull(type, 'type');\n\n    try {\n      var builder = this._parseToBuilder(text, null).resolve(this._resolverStyle, this._resolverFields);\n\n      return builder.build(type);\n    } catch (ex) {\n      if (ex instanceof DateTimeParseException) {\n        throw ex;\n      } else {\n        throw this._createError(text, ex);\n      }\n    }\n  };\n\n  _proto._createError = function _createError(text, ex) {\n    var abbr = '';\n\n    if (text.length > 64) {\n      abbr = text.substring(0, 64) + '...';\n    } else {\n      abbr = text;\n    }\n\n    return new DateTimeParseException('Text \\'' + abbr + '\\' could not be parsed: ' + ex.message, text, 0, ex);\n  };\n\n  _proto._parseToBuilder = function _parseToBuilder(text, position) {\n    var pos = position != null ? position : new ParsePosition(0);\n\n    var result = this._parseUnresolved0(text, pos);\n\n    if (result == null || pos.getErrorIndex() >= 0 || position == null && pos.getIndex() < text.length) {\n      var abbr = '';\n\n      if (text.length > 64) {\n        abbr = text.substr(0, 64).toString() + '...';\n      } else {\n        abbr = text;\n      }\n\n      if (pos.getErrorIndex() >= 0) {\n        throw new DateTimeParseException('Text \\'' + abbr + '\\' could not be parsed at index ' + pos.getErrorIndex(), text, pos.getErrorIndex());\n      } else {\n        throw new DateTimeParseException('Text \\'' + abbr + '\\' could not be parsed, unparsed text found at index ' + pos.getIndex(), text, pos.getIndex());\n      }\n    }\n\n    return result.toBuilder();\n  };\n\n  _proto.parseUnresolved = function parseUnresolved(text, position) {\n    return this._parseUnresolved0(text, position);\n  };\n\n  _proto._parseUnresolved0 = function _parseUnresolved0(text, position) {\n    assert(text != null, 'text', NullPointerException);\n    assert(position != null, 'position', NullPointerException);\n    var context = new DateTimeParseContext(this);\n    var pos = position.getIndex();\n    pos = this._printerParser.parse(context, text, pos);\n\n    if (pos < 0) {\n      position.setErrorIndex(~pos);\n      return null;\n    }\n\n    position.setIndex(pos);\n    return context.toParsed();\n  };\n\n  _proto._toPrinterParser = function _toPrinterParser(optional) {\n    return this._printerParser.withOptional(optional);\n  };\n\n  _proto.toString = function toString() {\n    var pattern = this._printerParser.toString();\n\n    return pattern.indexOf('[') === 0 ? pattern : pattern.substring(1, pattern.length - 1);\n  };\n\n  return DateTimeFormatter;\n}();\nfunction _init$a() {\n  DateTimeFormatter.ISO_LOCAL_DATE = new DateTimeFormatterBuilder().appendValue(ChronoField.YEAR, 4, 10, SignStyle.EXCEEDS_PAD).appendLiteral('-').appendValue(ChronoField.MONTH_OF_YEAR, 2).appendLiteral('-').appendValue(ChronoField.DAY_OF_MONTH, 2).toFormatter(ResolverStyle.STRICT).withChronology(IsoChronology.INSTANCE);\n  DateTimeFormatter.ISO_LOCAL_TIME = new DateTimeFormatterBuilder().appendValue(ChronoField.HOUR_OF_DAY, 2).appendLiteral(':').appendValue(ChronoField.MINUTE_OF_HOUR, 2).optionalStart().appendLiteral(':').appendValue(ChronoField.SECOND_OF_MINUTE, 2).optionalStart().appendFraction(ChronoField.NANO_OF_SECOND, 0, 9, true).toFormatter(ResolverStyle.STRICT);\n  DateTimeFormatter.ISO_LOCAL_DATE_TIME = new DateTimeFormatterBuilder().parseCaseInsensitive().append(DateTimeFormatter.ISO_LOCAL_DATE).appendLiteral('T').append(DateTimeFormatter.ISO_LOCAL_TIME).toFormatter(ResolverStyle.STRICT).withChronology(IsoChronology.INSTANCE);\n  DateTimeFormatter.ISO_INSTANT = new DateTimeFormatterBuilder().parseCaseInsensitive().appendInstant().toFormatter(ResolverStyle.STRICT);\n  DateTimeFormatter.ISO_OFFSET_DATE_TIME = new DateTimeFormatterBuilder().parseCaseInsensitive().append(DateTimeFormatter.ISO_LOCAL_DATE_TIME).appendOffsetId().toFormatter(ResolverStyle.STRICT).withChronology(IsoChronology.INSTANCE);\n  DateTimeFormatter.ISO_ZONED_DATE_TIME = new DateTimeFormatterBuilder().append(DateTimeFormatter.ISO_OFFSET_DATE_TIME).optionalStart().appendLiteral('[').parseCaseSensitive().appendZoneId().appendLiteral(']').toFormatter(ResolverStyle.STRICT).withChronology(IsoChronology.INSTANCE);\n  DateTimeFormatter.BASIC_ISO_DATE = new DateTimeFormatterBuilder().appendValue(ChronoField.YEAR, 4, 10, SignStyle.EXCEEDS_PAD).appendValue(ChronoField.MONTH_OF_YEAR, 2).appendValue(ChronoField.DAY_OF_MONTH, 2).toFormatter(ResolverStyle.STRICT).withChronology(IsoChronology.INSTANCE);\n  DateTimeFormatter.ISO_OFFSET_DATE = new DateTimeFormatterBuilder().parseCaseInsensitive().append(DateTimeFormatter.ISO_LOCAL_DATE).appendOffsetId().toFormatter(ResolverStyle.STRICT).withChronology(IsoChronology.INSTANCE);\n  DateTimeFormatter.ISO_OFFSET_TIME = new DateTimeFormatterBuilder().parseCaseInsensitive().append(DateTimeFormatter.ISO_LOCAL_TIME).appendOffsetId().toFormatter(ResolverStyle.STRICT).withChronology(IsoChronology.INSTANCE);\n  DateTimeFormatter.ISO_ORDINAL_DATE = new DateTimeFormatterBuilder().appendValue(ChronoField.YEAR, 4, 10, SignStyle.EXCEEDS_PAD).appendLiteral('-').appendValue(ChronoField.DAY_OF_YEAR).toFormatter(ResolverStyle.STRICT);\n  DateTimeFormatter.ISO_WEEK_DATE = new DateTimeFormatterBuilder().appendValue(ChronoField.YEAR, 4, 10, SignStyle.EXCEEDS_PAD).appendLiteral('-W').appendValue(ChronoField.ALIGNED_WEEK_OF_YEAR).appendLiteral('-').appendValue(ChronoField.DAY_OF_WEEK).toFormatter(ResolverStyle.STRICT);\n  DateTimeFormatter.PARSED_EXCESS_DAYS = createTemporalQuery('PARSED_EXCESS_DAYS', function (temporal) {\n    if (temporal instanceof DateTimeBuilder) {\n      return temporal.excessDays;\n    } else {\n      return Period.ZERO;\n    }\n  });\n  DateTimeFormatter.PARSED_LEAP_SECOND = createTemporalQuery('PARSED_LEAP_SECOND', function (temporal) {\n    if (temporal instanceof DateTimeBuilder) {\n      return temporal.leapSecond;\n    } else {\n      return false;\n    }\n  });\n}\n\nvar MonthDay = function (_TemporalAccessor) {\n  _inheritsLoose(MonthDay, _TemporalAccessor);\n\n  MonthDay.now = function now(zoneIdOrClock) {\n    if (arguments.length === 0) {\n      return MonthDay.now0();\n    } else if (arguments.length === 1 && zoneIdOrClock instanceof ZoneId) {\n      return MonthDay.nowZoneId(zoneIdOrClock);\n    } else {\n      return MonthDay.nowClock(zoneIdOrClock);\n    }\n  };\n\n  MonthDay.now0 = function now0() {\n    return this.nowClock(Clock.systemDefaultZone());\n  };\n\n  MonthDay.nowZoneId = function nowZoneId(zone) {\n    requireNonNull(zone, 'zone');\n    return this.nowClock(Clock.system(zone));\n  };\n\n  MonthDay.nowClock = function nowClock(clock) {\n    requireNonNull(clock, 'clock');\n    var now = LocalDate.now(clock);\n    return MonthDay.of(now.month(), now.dayOfMonth());\n  };\n\n  MonthDay.of = function of(monthOrNumber, number) {\n    if (arguments.length === 2 && monthOrNumber instanceof Month) {\n      return MonthDay.ofMonthNumber(monthOrNumber, number);\n    } else {\n      return MonthDay.ofNumberNumber(monthOrNumber, number);\n    }\n  };\n\n  MonthDay.ofMonthNumber = function ofMonthNumber(month, dayOfMonth) {\n    requireNonNull(month, 'month');\n    ChronoField.DAY_OF_MONTH.checkValidValue(dayOfMonth);\n\n    if (dayOfMonth > month.maxLength()) {\n      throw new DateTimeException('Illegal value for DayOfMonth field, value ' + dayOfMonth + ' is not valid for month ' + month.toString());\n    }\n\n    return new MonthDay(month.value(), dayOfMonth);\n  };\n\n  MonthDay.ofNumberNumber = function ofNumberNumber(month, dayOfMonth) {\n    requireNonNull(month, 'month');\n    requireNonNull(dayOfMonth, 'dayOfMonth');\n    return MonthDay.of(Month.of(month), dayOfMonth);\n  };\n\n  MonthDay.from = function from(temporal) {\n    requireNonNull(temporal, 'temporal');\n    requireInstance(temporal, TemporalAccessor, 'temporal');\n\n    if (temporal instanceof MonthDay) {\n      return temporal;\n    }\n\n    try {\n      return MonthDay.of(temporal.get(ChronoField.MONTH_OF_YEAR), temporal.get(ChronoField.DAY_OF_MONTH));\n    } catch (ex) {\n      throw new DateTimeException('Unable to obtain MonthDay from TemporalAccessor: ' + temporal + ', type ' + (temporal && temporal.constructor != null ? temporal.constructor.name : ''));\n    }\n  };\n\n  MonthDay.parse = function parse(text, formatter) {\n    if (arguments.length === 1) {\n      return MonthDay.parseString(text);\n    } else {\n      return MonthDay.parseStringFormatter(text, formatter);\n    }\n  };\n\n  MonthDay.parseString = function parseString(text) {\n    return MonthDay.parseStringFormatter(text, PARSER);\n  };\n\n  MonthDay.parseStringFormatter = function parseStringFormatter(text, formatter) {\n    requireNonNull(text, 'text');\n    requireNonNull(formatter, 'formatter');\n    requireInstance(formatter, DateTimeFormatter, 'formatter');\n    return formatter.parse(text, MonthDay.FROM);\n  };\n\n  function MonthDay(month, dayOfMonth) {\n    var _this;\n\n    _this = _TemporalAccessor.call(this) || this;\n    _this._month = MathUtil.safeToInt(month);\n    _this._day = MathUtil.safeToInt(dayOfMonth);\n    return _this;\n  }\n\n  var _proto = MonthDay.prototype;\n\n  _proto.monthValue = function monthValue() {\n    return this._month;\n  };\n\n  _proto.month = function month() {\n    return Month.of(this._month);\n  };\n\n  _proto.dayOfMonth = function dayOfMonth() {\n    return this._day;\n  };\n\n  _proto.isSupported = function isSupported(field) {\n    if (field instanceof ChronoField) {\n      return field === ChronoField.MONTH_OF_YEAR || field === ChronoField.DAY_OF_MONTH;\n    }\n\n    return field != null && field.isSupportedBy(this);\n  };\n\n  _proto.range = function range(field) {\n    if (field === ChronoField.MONTH_OF_YEAR) {\n      return field.range();\n    } else if (field === ChronoField.DAY_OF_MONTH) {\n      return ValueRange.of(1, this.month().minLength(), this.month().maxLength());\n    }\n\n    return _TemporalAccessor.prototype.range.call(this, field);\n  };\n\n  _proto.get = function get(field) {\n    return this.range(field).checkValidIntValue(this.getLong(field), field);\n  };\n\n  _proto.getLong = function getLong(field) {\n    requireNonNull(field, 'field');\n\n    if (field instanceof ChronoField) {\n      switch (field) {\n        case ChronoField.DAY_OF_MONTH:\n          return this._day;\n\n        case ChronoField.MONTH_OF_YEAR:\n          return this._month;\n      }\n\n      throw new UnsupportedTemporalTypeException('Unsupported field: ' + field);\n    }\n\n    return field.getFrom(this);\n  };\n\n  _proto.isValidYear = function isValidYear(year) {\n    return (this._day === 29 && this._month === 2 && Year.isLeap(year) === false) === false;\n  };\n\n  _proto.withMonth = function withMonth(month) {\n    return this.with(Month.of(month));\n  };\n\n  _proto.with = function _with(month) {\n    requireNonNull(month, 'month');\n\n    if (month.value() === this._month) {\n      return this;\n    }\n\n    var day = Math.min(this._day, month.maxLength());\n    return new MonthDay(month.value(), day);\n  };\n\n  _proto.withDayOfMonth = function withDayOfMonth(dayOfMonth) {\n    if (dayOfMonth === this._day) {\n      return this;\n    }\n\n    return MonthDay.of(this._month, dayOfMonth);\n  };\n\n  _proto.query = function query(_query) {\n    requireNonNull(_query, 'query');\n    requireInstance(_query, TemporalQuery, 'query');\n\n    if (_query === TemporalQueries.chronology()) {\n      return IsoChronology.INSTANCE;\n    }\n\n    return _TemporalAccessor.prototype.query.call(this, _query);\n  };\n\n  _proto.adjustInto = function adjustInto(temporal) {\n    requireNonNull(temporal, 'temporal');\n    temporal = temporal.with(ChronoField.MONTH_OF_YEAR, this._month);\n    return temporal.with(ChronoField.DAY_OF_MONTH, Math.min(temporal.range(ChronoField.DAY_OF_MONTH).maximum(), this._day));\n  };\n\n  _proto.atYear = function atYear(year) {\n    return LocalDate.of(year, this._month, this.isValidYear(year) ? this._day : 28);\n  };\n\n  _proto.compareTo = function compareTo(other) {\n    requireNonNull(other, 'other');\n    requireInstance(other, MonthDay, 'other');\n    var cmp = this._month - other.monthValue();\n\n    if (cmp === 0) {\n      cmp = this._day - other.dayOfMonth();\n    }\n\n    return cmp;\n  };\n\n  _proto.isAfter = function isAfter(other) {\n    requireNonNull(other, 'other');\n    requireInstance(other, MonthDay, 'other');\n    return this.compareTo(other) > 0;\n  };\n\n  _proto.isBefore = function isBefore(other) {\n    requireNonNull(other, 'other');\n    requireInstance(other, MonthDay, 'other');\n    return this.compareTo(other) < 0;\n  };\n\n  _proto.equals = function equals(obj) {\n    if (this === obj) {\n      return true;\n    }\n\n    if (obj instanceof MonthDay) {\n      var other = obj;\n      return this.monthValue() === other.monthValue() && this.dayOfMonth() === other.dayOfMonth();\n    }\n\n    return false;\n  };\n\n  _proto.toString = function toString() {\n    return '--' + (this._month < 10 ? '0' : '') + this._month + (this._day < 10 ? '-0' : '-') + this._day;\n  };\n\n  _proto.toJSON = function toJSON() {\n    return this.toString();\n  };\n\n  _proto.format = function format(formatter) {\n    requireNonNull(formatter, 'formatter');\n    requireInstance(formatter, DateTimeFormatter, 'formatter');\n    return formatter.format(this);\n  };\n\n  return MonthDay;\n}(TemporalAccessor);\nvar PARSER;\nfunction _init$b() {\n  PARSER = new DateTimeFormatterBuilder().appendLiteral('--').appendValue(ChronoField.MONTH_OF_YEAR, 2).appendLiteral('-').appendValue(ChronoField.DAY_OF_MONTH, 2).toFormatter();\n  MonthDay.FROM = createTemporalQuery('MonthDay.FROM', function (temporal) {\n    return MonthDay.from(temporal);\n  });\n}\n\nvar YearMonth = function (_Temporal) {\n  _inheritsLoose(YearMonth, _Temporal);\n\n  YearMonth.now = function now(zoneIdOrClock) {\n    if (arguments.length === 0) {\n      return YearMonth.now0();\n    } else if (arguments.length === 1 && zoneIdOrClock instanceof ZoneId) {\n      return YearMonth.nowZoneId(zoneIdOrClock);\n    } else {\n      return YearMonth.nowClock(zoneIdOrClock);\n    }\n  };\n\n  YearMonth.now0 = function now0() {\n    return YearMonth.nowClock(Clock.systemDefaultZone());\n  };\n\n  YearMonth.nowZoneId = function nowZoneId(zone) {\n    return YearMonth.nowClock(Clock.system(zone));\n  };\n\n  YearMonth.nowClock = function nowClock(clock) {\n    var now = LocalDate.now(clock);\n    return YearMonth.of(now.year(), now.month());\n  };\n\n  YearMonth.of = function of(year, monthOrNumber) {\n    if (arguments.length === 2 && monthOrNumber instanceof Month) {\n      return YearMonth.ofNumberMonth(year, monthOrNumber);\n    } else {\n      return YearMonth.ofNumberNumber(year, monthOrNumber);\n    }\n  };\n\n  YearMonth.ofNumberMonth = function ofNumberMonth(year, month) {\n    requireNonNull(month, 'month');\n    requireInstance(month, Month, 'month');\n    return YearMonth.ofNumberNumber(year, month.value());\n  };\n\n  YearMonth.ofNumberNumber = function ofNumberNumber(year, month) {\n    requireNonNull(year, 'year');\n    requireNonNull(month, 'month');\n    ChronoField.YEAR.checkValidValue(year);\n    ChronoField.MONTH_OF_YEAR.checkValidValue(month);\n    return new YearMonth(year, month);\n  };\n\n  YearMonth.from = function from(temporal) {\n    requireNonNull(temporal, 'temporal');\n\n    if (temporal instanceof YearMonth) {\n      return temporal;\n    }\n\n    try {\n      return YearMonth.of(temporal.get(ChronoField.YEAR), temporal.get(ChronoField.MONTH_OF_YEAR));\n    } catch (ex) {\n      throw new DateTimeException('Unable to obtain YearMonth from TemporalAccessor: ' + temporal + ', type ' + (temporal && temporal.constructor != null ? temporal.constructor.name : ''));\n    }\n  };\n\n  YearMonth.parse = function parse(text, formatter) {\n    if (arguments.length === 1) {\n      return YearMonth.parseString(text);\n    } else {\n      return YearMonth.parseStringFormatter(text, formatter);\n    }\n  };\n\n  YearMonth.parseString = function parseString(text) {\n    return YearMonth.parseStringFormatter(text, PARSER$1);\n  };\n\n  YearMonth.parseStringFormatter = function parseStringFormatter(text, formatter) {\n    requireNonNull(formatter, 'formatter');\n    return formatter.parse(text, YearMonth.FROM);\n  };\n\n  function YearMonth(year, month) {\n    var _this;\n\n    _this = _Temporal.call(this) || this;\n    _this._year = MathUtil.safeToInt(year);\n    _this._month = MathUtil.safeToInt(month);\n    return _this;\n  }\n\n  var _proto = YearMonth.prototype;\n\n  _proto.isSupported = function isSupported(fieldOrUnit) {\n    if (arguments.length === 1 && fieldOrUnit instanceof TemporalField) {\n      return this.isSupportedField(fieldOrUnit);\n    } else {\n      return this.isSupportedUnit(fieldOrUnit);\n    }\n  };\n\n  _proto.isSupportedField = function isSupportedField(field) {\n    if (field instanceof ChronoField) {\n      return field === ChronoField.YEAR || field === ChronoField.MONTH_OF_YEAR || field === ChronoField.PROLEPTIC_MONTH || field === ChronoField.YEAR_OF_ERA || field === ChronoField.ERA;\n    }\n\n    return field != null && field.isSupportedBy(this);\n  };\n\n  _proto.isSupportedUnit = function isSupportedUnit(unit) {\n    if (unit instanceof ChronoUnit) {\n      return unit === ChronoUnit.MONTHS || unit === ChronoUnit.YEARS || unit === ChronoUnit.DECADES || unit === ChronoUnit.CENTURIES || unit === ChronoUnit.MILLENNIA || unit === ChronoUnit.ERAS;\n    }\n\n    return unit != null && unit.isSupportedBy(this);\n  };\n\n  _proto.range = function range(field) {\n    if (field === ChronoField.YEAR_OF_ERA) {\n      return this.year() <= 0 ? ValueRange.of(1, Year.MAX_VALUE + 1) : ValueRange.of(1, Year.MAX_VALUE);\n    }\n\n    return _Temporal.prototype.range.call(this, field);\n  };\n\n  _proto.get = function get(field) {\n    requireNonNull(field, 'field');\n    requireInstance(field, TemporalField, 'field');\n    return this.range(field).checkValidIntValue(this.getLong(field), field);\n  };\n\n  _proto.getLong = function getLong(field) {\n    requireNonNull(field, 'field');\n    requireInstance(field, TemporalField, 'field');\n\n    if (field instanceof ChronoField) {\n      switch (field) {\n        case ChronoField.MONTH_OF_YEAR:\n          return this._month;\n\n        case ChronoField.PROLEPTIC_MONTH:\n          return this._getProlepticMonth();\n\n        case ChronoField.YEAR_OF_ERA:\n          return this._year < 1 ? 1 - this._year : this._year;\n\n        case ChronoField.YEAR:\n          return this._year;\n\n        case ChronoField.ERA:\n          return this._year < 1 ? 0 : 1;\n      }\n\n      throw new UnsupportedTemporalTypeException('Unsupported field: ' + field);\n    }\n\n    return field.getFrom(this);\n  };\n\n  _proto._getProlepticMonth = function _getProlepticMonth() {\n    return MathUtil.safeAdd(MathUtil.safeMultiply(this._year, 12), this._month - 1);\n  };\n\n  _proto.year = function year() {\n    return this._year;\n  };\n\n  _proto.monthValue = function monthValue() {\n    return this._month;\n  };\n\n  _proto.month = function month() {\n    return Month.of(this._month);\n  };\n\n  _proto.isLeapYear = function isLeapYear() {\n    return IsoChronology.isLeapYear(this._year);\n  };\n\n  _proto.isValidDay = function isValidDay(dayOfMonth) {\n    return dayOfMonth >= 1 && dayOfMonth <= this.lengthOfMonth();\n  };\n\n  _proto.lengthOfMonth = function lengthOfMonth() {\n    return this.month().length(this.isLeapYear());\n  };\n\n  _proto.lengthOfYear = function lengthOfYear() {\n    return this.isLeapYear() ? 366 : 365;\n  };\n\n  _proto.with = function _with(adjusterOrField, value) {\n    if (arguments.length === 1) {\n      return this.withAdjuster(adjusterOrField);\n    } else {\n      return this.withFieldValue(adjusterOrField, value);\n    }\n  };\n\n  _proto.withAdjuster = function withAdjuster(adjuster) {\n    requireNonNull(adjuster, 'adjuster');\n    return adjuster.adjustInto(this);\n  };\n\n  _proto.withFieldValue = function withFieldValue(field, newValue) {\n    requireNonNull(field, 'field');\n    requireInstance(field, TemporalField, 'field');\n\n    if (field instanceof ChronoField) {\n      var f = field;\n      f.checkValidValue(newValue);\n\n      switch (f) {\n        case ChronoField.MONTH_OF_YEAR:\n          return this.withMonth(newValue);\n\n        case ChronoField.PROLEPTIC_MONTH:\n          return this.plusMonths(newValue - this.getLong(ChronoField.PROLEPTIC_MONTH));\n\n        case ChronoField.YEAR_OF_ERA:\n          return this.withYear(this._year < 1 ? 1 - newValue : newValue);\n\n        case ChronoField.YEAR:\n          return this.withYear(newValue);\n\n        case ChronoField.ERA:\n          return this.getLong(ChronoField.ERA) === newValue ? this : this.withYear(1 - this._year);\n      }\n\n      throw new UnsupportedTemporalTypeException('Unsupported field: ' + field);\n    }\n\n    return field.adjustInto(this, newValue);\n  };\n\n  _proto.withYear = function withYear(year) {\n    ChronoField.YEAR.checkValidValue(year);\n    return new YearMonth(year, this._month);\n  };\n\n  _proto.withMonth = function withMonth(month) {\n    ChronoField.MONTH_OF_YEAR.checkValidValue(month);\n    return new YearMonth(this._year, month);\n  };\n\n  _proto.plusAmount = function plusAmount(amount) {\n    requireNonNull(amount, 'amount');\n    requireInstance(amount, TemporalAmount, 'amount');\n    return amount.addTo(this);\n  };\n\n  _proto.plusAmountUnit = function plusAmountUnit(amountToAdd, unit) {\n    requireNonNull(unit, 'unit');\n    requireInstance(unit, TemporalUnit, 'unit');\n\n    if (unit instanceof ChronoUnit) {\n      switch (unit) {\n        case ChronoUnit.MONTHS:\n          return this.plusMonths(amountToAdd);\n\n        case ChronoUnit.YEARS:\n          return this.plusYears(amountToAdd);\n\n        case ChronoUnit.DECADES:\n          return this.plusYears(MathUtil.safeMultiply(amountToAdd, 10));\n\n        case ChronoUnit.CENTURIES:\n          return this.plusYears(MathUtil.safeMultiply(amountToAdd, 100));\n\n        case ChronoUnit.MILLENNIA:\n          return this.plusYears(MathUtil.safeMultiply(amountToAdd, 1000));\n\n        case ChronoUnit.ERAS:\n          return this.with(ChronoField.ERA, MathUtil.safeAdd(this.getLong(ChronoField.ERA), amountToAdd));\n      }\n\n      throw new UnsupportedTemporalTypeException('Unsupported unit: ' + unit);\n    }\n\n    return unit.addTo(this, amountToAdd);\n  };\n\n  _proto.plusYears = function plusYears(yearsToAdd) {\n    if (yearsToAdd === 0) {\n      return this;\n    }\n\n    var newYear = ChronoField.YEAR.checkValidIntValue(this._year + yearsToAdd);\n    return this.withYear(newYear);\n  };\n\n  _proto.plusMonths = function plusMonths(monthsToAdd) {\n    if (monthsToAdd === 0) {\n      return this;\n    }\n\n    var monthCount = this._year * 12 + (this._month - 1);\n    var calcMonths = monthCount + monthsToAdd;\n    var newYear = ChronoField.YEAR.checkValidIntValue(MathUtil.floorDiv(calcMonths, 12));\n    var newMonth = MathUtil.floorMod(calcMonths, 12) + 1;\n    return new YearMonth(newYear, newMonth);\n  };\n\n  _proto.minusAmount = function minusAmount(amount) {\n    requireNonNull(amount, 'amount');\n    return amount.subtractFrom(this);\n  };\n\n  _proto.minusAmountUnit = function minusAmountUnit(amountToSubtract, unit) {\n    return amountToSubtract === MathUtil.MIN_SAFE_INTEGER ? this.plusAmountUnit(MathUtil.MAX_SAFE_INTEGER, unit).plusAmountUnit(1, unit) : this.plusAmountUnit(-amountToSubtract, unit);\n  };\n\n  _proto.minusYears = function minusYears(yearsToSubtract) {\n    return yearsToSubtract === MathUtil.MIN_SAFE_INTEGER ? this.plusYears(MathUtil.MIN_SAFE_INTEGER).plusYears(1) : this.plusYears(-yearsToSubtract);\n  };\n\n  _proto.minusMonths = function minusMonths(monthsToSubtract) {\n    return monthsToSubtract === MathUtil.MIN_SAFE_INTEGER ? this.plusMonths(Math.MAX_SAFE_INTEGER).plusMonths(1) : this.plusMonths(-monthsToSubtract);\n  };\n\n  _proto.query = function query(_query) {\n    requireNonNull(_query, 'query');\n    requireInstance(_query, TemporalQuery, 'query');\n\n    if (_query === TemporalQueries.chronology()) {\n      return IsoChronology.INSTANCE;\n    } else if (_query === TemporalQueries.precision()) {\n      return ChronoUnit.MONTHS;\n    } else if (_query === TemporalQueries.localDate() || _query === TemporalQueries.localTime() || _query === TemporalQueries.zone() || _query === TemporalQueries.zoneId() || _query === TemporalQueries.offset()) {\n      return null;\n    }\n\n    return _Temporal.prototype.query.call(this, _query);\n  };\n\n  _proto.adjustInto = function adjustInto(temporal) {\n    requireNonNull(temporal, 'temporal');\n    requireInstance(temporal, Temporal, 'temporal');\n    return temporal.with(ChronoField.PROLEPTIC_MONTH, this._getProlepticMonth());\n  };\n\n  _proto.until = function until(endExclusive, unit) {\n    requireNonNull(endExclusive, 'endExclusive');\n    requireNonNull(unit, 'unit');\n    requireInstance(endExclusive, Temporal, 'endExclusive');\n    requireInstance(unit, TemporalUnit, 'unit');\n    var end = YearMonth.from(endExclusive);\n\n    if (unit instanceof ChronoUnit) {\n      var monthsUntil = end._getProlepticMonth() - this._getProlepticMonth();\n\n      switch (unit) {\n        case ChronoUnit.MONTHS:\n          return monthsUntil;\n\n        case ChronoUnit.YEARS:\n          return monthsUntil / 12;\n\n        case ChronoUnit.DECADES:\n          return monthsUntil / 120;\n\n        case ChronoUnit.CENTURIES:\n          return monthsUntil / 1200;\n\n        case ChronoUnit.MILLENNIA:\n          return monthsUntil / 12000;\n\n        case ChronoUnit.ERAS:\n          return end.getLong(ChronoField.ERA) - this.getLong(ChronoField.ERA);\n      }\n\n      throw new UnsupportedTemporalTypeException('Unsupported unit: ' + unit);\n    }\n\n    return unit.between(this, end);\n  };\n\n  _proto.atDay = function atDay(dayOfMonth) {\n    return LocalDate.of(this._year, this._month, dayOfMonth);\n  };\n\n  _proto.atEndOfMonth = function atEndOfMonth() {\n    return LocalDate.of(this._year, this._month, this.lengthOfMonth());\n  };\n\n  _proto.compareTo = function compareTo(other) {\n    requireNonNull(other, 'other');\n    requireInstance(other, YearMonth, 'other');\n    var cmp = this._year - other.year();\n\n    if (cmp === 0) {\n      cmp = this._month - other.monthValue();\n    }\n\n    return cmp;\n  };\n\n  _proto.isAfter = function isAfter(other) {\n    return this.compareTo(other) > 0;\n  };\n\n  _proto.isBefore = function isBefore(other) {\n    return this.compareTo(other) < 0;\n  };\n\n  _proto.equals = function equals(obj) {\n    if (this === obj) {\n      return true;\n    }\n\n    if (obj instanceof YearMonth) {\n      var other = obj;\n      return this.year() === other.year() && this.monthValue() === other.monthValue();\n    }\n\n    return false;\n  };\n\n  _proto.toString = function toString() {\n    return PARSER$1.format(this);\n  };\n\n  _proto.toJSON = function toJSON() {\n    return this.toString();\n  };\n\n  _proto.format = function format(formatter) {\n    requireNonNull(formatter, 'formatter');\n    return formatter.format(this);\n  };\n\n  return YearMonth;\n}(Temporal);\nvar PARSER$1;\nfunction _init$c() {\n  PARSER$1 = new DateTimeFormatterBuilder().appendValue(ChronoField.YEAR, 4, 10, SignStyle.EXCEEDS_PAD).appendLiteral('-').appendValue(ChronoField.MONTH_OF_YEAR, 2).toFormatter();\n  YearMonth.FROM = createTemporalQuery('YearMonth.FROM', function (temporal) {\n    return YearMonth.from(temporal);\n  });\n}\n\nvar Year = function (_Temporal) {\n  _inheritsLoose(Year, _Temporal);\n\n  function Year(value) {\n    var _this;\n\n    _this = _Temporal.call(this) || this;\n    _this._year = MathUtil.safeToInt(value);\n    return _this;\n  }\n\n  var _proto = Year.prototype;\n\n  _proto.value = function value() {\n    return this._year;\n  };\n\n  Year.now = function now(zoneIdOrClock) {\n    if (zoneIdOrClock === void 0) {\n      zoneIdOrClock = undefined;\n    }\n\n    if (zoneIdOrClock === undefined) {\n      return Year.now0();\n    } else if (zoneIdOrClock instanceof ZoneId) {\n      return Year.nowZoneId(zoneIdOrClock);\n    } else {\n      return Year.nowClock(zoneIdOrClock);\n    }\n  };\n\n  Year.now0 = function now0() {\n    return Year.nowClock(Clock.systemDefaultZone());\n  };\n\n  Year.nowZoneId = function nowZoneId(zone) {\n    requireNonNull(zone, 'zone');\n    requireInstance(zone, ZoneId, 'zone');\n    return Year.nowClock(Clock.system(zone));\n  };\n\n  Year.nowClock = function nowClock(clock) {\n    requireNonNull(clock, 'clock');\n    requireInstance(clock, Clock, 'clock');\n    var now = LocalDate.now(clock);\n    return Year.of(now.year());\n  };\n\n  Year.of = function of(isoYear) {\n    requireNonNull(isoYear, 'isoYear');\n    ChronoField.YEAR.checkValidValue(isoYear);\n    return new Year(isoYear);\n  };\n\n  Year.from = function from(temporal) {\n    requireNonNull(temporal, 'temporal');\n    requireInstance(temporal, TemporalAccessor, 'temporal');\n\n    if (temporal instanceof Year) {\n      return temporal;\n    }\n\n    try {\n      return Year.of(temporal.get(ChronoField.YEAR));\n    } catch (ex) {\n      throw new DateTimeException('Unable to obtain Year from TemporalAccessor: ' + temporal + ', type ' + (temporal && temporal.constructor != null ? temporal.constructor.name : ''));\n    }\n  };\n\n  Year.parse = function parse(text, formatter) {\n    if (arguments.length <= 1) {\n      return Year.parseText(text);\n    } else {\n      return Year.parseTextFormatter(text, formatter);\n    }\n  };\n\n  Year.parseText = function parseText(text) {\n    requireNonNull(text, 'text');\n    return Year.parse(text, PARSER$2);\n  };\n\n  Year.parseTextFormatter = function parseTextFormatter(text, formatter) {\n    if (formatter === void 0) {\n      formatter = PARSER$2;\n    }\n\n    requireNonNull(text, 'text');\n    requireNonNull(formatter, 'formatter');\n    requireInstance(formatter, DateTimeFormatter, 'formatter');\n    return formatter.parse(text, Year.FROM);\n  };\n\n  Year.isLeap = function isLeap(year) {\n    return MathUtil.intMod(year, 4) === 0 && (MathUtil.intMod(year, 100) !== 0 || MathUtil.intMod(year, 400) === 0);\n  };\n\n  _proto.isSupported = function isSupported(fieldOrUnit) {\n    if (arguments.length === 1 && fieldOrUnit instanceof TemporalField) {\n      return this.isSupportedField(fieldOrUnit);\n    } else {\n      return this.isSupportedUnit(fieldOrUnit);\n    }\n  };\n\n  _proto.isSupportedField = function isSupportedField(field) {\n    if (field instanceof ChronoField) {\n      return field === ChronoField.YEAR || field === ChronoField.YEAR_OF_ERA || field === ChronoField.ERA;\n    }\n\n    return field != null && field.isSupportedBy(this);\n  };\n\n  _proto.isSupportedUnit = function isSupportedUnit(unit) {\n    if (unit instanceof ChronoUnit) {\n      return unit === ChronoUnit.YEARS || unit === ChronoUnit.DECADES || unit === ChronoUnit.CENTURIES || unit === ChronoUnit.MILLENNIA || unit === ChronoUnit.ERAS;\n    }\n\n    return unit != null && unit.isSupportedBy(this);\n  };\n\n  _proto.range = function range(field) {\n    if (this.isSupported(field)) {\n      return field.range();\n    } else if (field instanceof ChronoField) {\n      throw new UnsupportedTemporalTypeException('Unsupported field: ' + field);\n    }\n\n    return _Temporal.prototype.range.call(this, field);\n  };\n\n  _proto.get = function get(field) {\n    return this.range(field).checkValidIntValue(this.getLong(field), field);\n  };\n\n  _proto.getLong = function getLong(field) {\n    requireNonNull(field, 'field');\n\n    if (field instanceof ChronoField) {\n      switch (field) {\n        case ChronoField.YEAR_OF_ERA:\n          return this._year < 1 ? 1 - this._year : this._year;\n\n        case ChronoField.YEAR:\n          return this._year;\n\n        case ChronoField.ERA:\n          return this._year < 1 ? 0 : 1;\n      }\n\n      throw new UnsupportedTemporalTypeException('Unsupported field: ' + field);\n    }\n\n    return field.getFrom(this);\n  };\n\n  _proto.isLeap = function isLeap() {\n    return Year.isLeap(this._year);\n  };\n\n  _proto.withAdjuster = function withAdjuster(adjuster) {\n    requireNonNull(adjuster, 'adjuster');\n    return adjuster.adjustInto(this);\n  };\n\n  _proto.withFieldValue = function withFieldValue(field, newValue) {\n    requireNonNull(field, 'field');\n    requireInstance(field, TemporalField, 'field');\n\n    if (field instanceof ChronoField) {\n      field.checkValidValue(newValue);\n\n      switch (field) {\n        case ChronoField.YEAR_OF_ERA:\n          return Year.of(this._year < 1 ? 1 - newValue : newValue);\n\n        case ChronoField.YEAR:\n          return Year.of(newValue);\n\n        case ChronoField.ERA:\n          return this.getLong(ChronoField.ERA) === newValue ? this : Year.of(1 - this._year);\n      }\n\n      throw new UnsupportedTemporalTypeException('Unsupported field: ' + field);\n    }\n\n    return field.adjustInto(this, newValue);\n  };\n\n  _proto.plusAmount = function plusAmount(amount) {\n    requireNonNull(amount, 'amount');\n    requireInstance(amount, TemporalAmount, 'amount');\n    return amount.addTo(this);\n  };\n\n  _proto.plusAmountUnit = function plusAmountUnit(amountToAdd, unit) {\n    requireNonNull(amountToAdd, 'amountToAdd');\n    requireNonNull(unit, 'unit');\n    requireInstance(unit, TemporalUnit, 'unit');\n\n    if (unit instanceof ChronoUnit) {\n      switch (unit) {\n        case ChronoUnit.YEARS:\n          return this.plusYears(amountToAdd);\n\n        case ChronoUnit.DECADES:\n          return this.plusYears(MathUtil.safeMultiply(amountToAdd, 10));\n\n        case ChronoUnit.CENTURIES:\n          return this.plusYears(MathUtil.safeMultiply(amountToAdd, 100));\n\n        case ChronoUnit.MILLENNIA:\n          return this.plusYears(MathUtil.safeMultiply(amountToAdd, 1000));\n\n        case ChronoUnit.ERAS:\n          return this.with(ChronoField.ERA, MathUtil.safeAdd(this.getLong(ChronoField.ERA), amountToAdd));\n      }\n\n      throw new UnsupportedTemporalTypeException('Unsupported unit: ' + unit);\n    }\n\n    return unit.addTo(this, amountToAdd);\n  };\n\n  _proto.plusYears = function plusYears(yearsToAdd) {\n    if (yearsToAdd === 0) {\n      return this;\n    }\n\n    return Year.of(ChronoField.YEAR.checkValidIntValue(MathUtil.safeAdd(this._year, yearsToAdd)));\n  };\n\n  _proto.minusAmount = function minusAmount(amount) {\n    requireNonNull(amount, 'amount');\n    requireInstance(amount, TemporalAmount, 'amount');\n    return amount.subtractFrom(this);\n  };\n\n  _proto.minusAmountUnit = function minusAmountUnit(amountToSubtract, unit) {\n    requireNonNull(amountToSubtract, 'amountToSubtract');\n    requireNonNull(unit, 'unit');\n    requireInstance(unit, TemporalUnit, 'unit');\n    return amountToSubtract === MathUtil.MIN_SAFE_INTEGER ? this.plus(MathUtil.MAX_SAFE_INTEGER, unit).plus(1, unit) : this.plus(-amountToSubtract, unit);\n  };\n\n  _proto.minusYears = function minusYears(yearsToSubtract) {\n    return yearsToSubtract === MathUtil.MIN_SAFE_INTEGER ? this.plusYears(MathUtil.MAX_SAFE_INTEGER).plusYears(1) : this.plusYears(-yearsToSubtract);\n  };\n\n  _proto.adjustInto = function adjustInto(temporal) {\n    requireNonNull(temporal, 'temporal');\n    return temporal.with(ChronoField.YEAR, this._year);\n  };\n\n  _proto.isValidMonthDay = function isValidMonthDay(monthDay) {\n    return monthDay != null && monthDay.isValidYear(this._year);\n  };\n\n  _proto.length = function length() {\n    return this.isLeap() ? 366 : 365;\n  };\n\n  _proto.atDay = function atDay(dayOfYear) {\n    return LocalDate.ofYearDay(this._year, dayOfYear);\n  };\n\n  _proto.atMonth = function atMonth(monthOrNumber) {\n    if (arguments.length === 1 && monthOrNumber instanceof Month) {\n      return this.atMonthMonth(monthOrNumber);\n    } else {\n      return this.atMonthNumber(monthOrNumber);\n    }\n  };\n\n  _proto.atMonthMonth = function atMonthMonth(month) {\n    requireNonNull(month, 'month');\n    requireInstance(month, Month, 'month');\n    return YearMonth.of(this._year, month);\n  };\n\n  _proto.atMonthNumber = function atMonthNumber(month) {\n    requireNonNull(month, 'month');\n    return YearMonth.of(this._year, month);\n  };\n\n  _proto.atMonthDay = function atMonthDay(monthDay) {\n    requireNonNull(monthDay, 'monthDay');\n    requireInstance(monthDay, MonthDay, 'monthDay');\n    return monthDay.atYear(this._year);\n  };\n\n  _proto.query = function query(_query) {\n    requireNonNull(_query, 'query()');\n    requireInstance(_query, TemporalQuery, 'query()');\n\n    if (_query === TemporalQueries.chronology()) {\n      return IsoChronology.INSTANCE;\n    } else if (_query === TemporalQueries.precision()) {\n      return ChronoUnit.YEARS;\n    } else if (_query === TemporalQueries.localDate() || _query === TemporalQueries.localTime() || _query === TemporalQueries.zone() || _query === TemporalQueries.zoneId() || _query === TemporalQueries.offset()) {\n      return null;\n    }\n\n    return _Temporal.prototype.query.call(this, _query);\n  };\n\n  _proto.compareTo = function compareTo(other) {\n    requireNonNull(other, 'other');\n    requireInstance(other, Year, 'other');\n    return this._year - other._year;\n  };\n\n  _proto.isAfter = function isAfter(other) {\n    requireNonNull(other, 'other');\n    requireInstance(other, Year, 'other');\n    return this._year > other._year;\n  };\n\n  _proto.isBefore = function isBefore(other) {\n    requireNonNull(other, 'other');\n    requireInstance(other, Year, 'other');\n    return this._year < other._year;\n  };\n\n  _proto.format = function format(formatter) {\n    requireNonNull(formatter, 'formatter');\n    requireInstance(formatter, DateTimeFormatter, 'formatter');\n    return formatter.format(this);\n  };\n\n  _proto.equals = function equals(other) {\n    if (this === other) {\n      return true;\n    }\n\n    if (other instanceof Year) {\n      return this.value() === other.value();\n    }\n\n    return false;\n  };\n\n  _proto.toString = function toString() {\n    return '' + this._year;\n  };\n\n  _proto.toJSON = function toJSON() {\n    return this.toString();\n  };\n\n  _proto.until = function until(endExclusive, unit) {\n    var end = Year.from(endExclusive);\n\n    if (unit instanceof ChronoUnit) {\n      var yearsUntil = end.value() - this.value();\n\n      switch (unit) {\n        case ChronoUnit.YEARS:\n          return yearsUntil;\n\n        case ChronoUnit.DECADES:\n          return MathUtil.intDiv(yearsUntil, 10);\n\n        case ChronoUnit.CENTURIES:\n          return MathUtil.intDiv(yearsUntil, 100);\n\n        case ChronoUnit.MILLENNIA:\n          return MathUtil.intDiv(yearsUntil, 1000);\n\n        case ChronoUnit.ERAS:\n          return end.getLong(ChronoField.ERA) - this.getLong(ChronoField.ERA);\n      }\n\n      throw new UnsupportedTemporalTypeException('Unsupported unit: ' + unit);\n    }\n\n    return unit.between(this, end);\n  };\n\n  return Year;\n}(Temporal);\nvar PARSER$2;\nfunction _init$d() {\n  Year.MIN_VALUE = YearConstants.MIN_VALUE;\n  Year.MAX_VALUE = YearConstants.MAX_VALUE;\n  PARSER$2 = new DateTimeFormatterBuilder().appendValue(ChronoField.YEAR, 4, 10, SignStyle.EXCEEDS_PAD).toFormatter();\n  Year.FROM = createTemporalQuery('Year.FROM', function (temporal) {\n    return Year.from(temporal);\n  });\n}\n\nvar TemporalAdjusters = function () {\n  function TemporalAdjusters() {}\n\n  TemporalAdjusters.firstDayOfMonth = function firstDayOfMonth() {\n    return Impl.FIRST_DAY_OF_MONTH;\n  };\n\n  TemporalAdjusters.lastDayOfMonth = function lastDayOfMonth() {\n    return Impl.LAST_DAY_OF_MONTH;\n  };\n\n  TemporalAdjusters.firstDayOfNextMonth = function firstDayOfNextMonth() {\n    return Impl.FIRST_DAY_OF_NEXT_MONTH;\n  };\n\n  TemporalAdjusters.firstDayOfYear = function firstDayOfYear() {\n    return Impl.FIRST_DAY_OF_YEAR;\n  };\n\n  TemporalAdjusters.lastDayOfYear = function lastDayOfYear() {\n    return Impl.LAST_DAY_OF_YEAR;\n  };\n\n  TemporalAdjusters.firstDayOfNextYear = function firstDayOfNextYear() {\n    return Impl.FIRST_DAY_OF_NEXT_YEAR;\n  };\n\n  TemporalAdjusters.firstInMonth = function firstInMonth(dayOfWeek) {\n    requireNonNull(dayOfWeek, 'dayOfWeek');\n    return new DayOfWeekInMonth(1, dayOfWeek);\n  };\n\n  TemporalAdjusters.lastInMonth = function lastInMonth(dayOfWeek) {\n    requireNonNull(dayOfWeek, 'dayOfWeek');\n    return new DayOfWeekInMonth(-1, dayOfWeek);\n  };\n\n  TemporalAdjusters.dayOfWeekInMonth = function dayOfWeekInMonth(ordinal, dayOfWeek) {\n    requireNonNull(dayOfWeek, 'dayOfWeek');\n    return new DayOfWeekInMonth(ordinal, dayOfWeek);\n  };\n\n  TemporalAdjusters.next = function next(dayOfWeek) {\n    return new RelativeDayOfWeek(2, dayOfWeek);\n  };\n\n  TemporalAdjusters.nextOrSame = function nextOrSame(dayOfWeek) {\n    return new RelativeDayOfWeek(0, dayOfWeek);\n  };\n\n  TemporalAdjusters.previous = function previous(dayOfWeek) {\n    return new RelativeDayOfWeek(3, dayOfWeek);\n  };\n\n  TemporalAdjusters.previousOrSame = function previousOrSame(dayOfWeek) {\n    return new RelativeDayOfWeek(1, dayOfWeek);\n  };\n\n  return TemporalAdjusters;\n}();\n\nvar Impl = function (_TemporalAdjuster) {\n  _inheritsLoose(Impl, _TemporalAdjuster);\n\n  function Impl(ordinal) {\n    var _this;\n\n    _this = _TemporalAdjuster.call(this) || this;\n    _this._ordinal = ordinal;\n    return _this;\n  }\n\n  var _proto = Impl.prototype;\n\n  _proto.adjustInto = function adjustInto(temporal) {\n    switch (this._ordinal) {\n      case 0:\n        return temporal.with(ChronoField.DAY_OF_MONTH, 1);\n\n      case 1:\n        return temporal.with(ChronoField.DAY_OF_MONTH, temporal.range(ChronoField.DAY_OF_MONTH).maximum());\n\n      case 2:\n        return temporal.with(ChronoField.DAY_OF_MONTH, 1).plus(1, ChronoUnit.MONTHS);\n\n      case 3:\n        return temporal.with(ChronoField.DAY_OF_YEAR, 1);\n\n      case 4:\n        return temporal.with(ChronoField.DAY_OF_YEAR, temporal.range(ChronoField.DAY_OF_YEAR).maximum());\n\n      case 5:\n        return temporal.with(ChronoField.DAY_OF_YEAR, 1).plus(1, ChronoUnit.YEARS);\n    }\n\n    throw new IllegalStateException('Unreachable');\n  };\n\n  return Impl;\n}(TemporalAdjuster);\n\nImpl.FIRST_DAY_OF_MONTH = new Impl(0);\nImpl.LAST_DAY_OF_MONTH = new Impl(1);\nImpl.FIRST_DAY_OF_NEXT_MONTH = new Impl(2);\nImpl.FIRST_DAY_OF_YEAR = new Impl(3);\nImpl.LAST_DAY_OF_YEAR = new Impl(4);\nImpl.FIRST_DAY_OF_NEXT_YEAR = new Impl(5);\n\nvar DayOfWeekInMonth = function (_TemporalAdjuster2) {\n  _inheritsLoose(DayOfWeekInMonth, _TemporalAdjuster2);\n\n  function DayOfWeekInMonth(ordinal, dow) {\n    var _this2;\n\n    _this2 = _TemporalAdjuster2.call(this) || this;\n    _this2._ordinal = ordinal;\n    _this2._dowValue = dow.value();\n    return _this2;\n  }\n\n  var _proto2 = DayOfWeekInMonth.prototype;\n\n  _proto2.adjustInto = function adjustInto(temporal) {\n    if (this._ordinal >= 0) {\n      var temp = temporal.with(ChronoField.DAY_OF_MONTH, 1);\n      var curDow = temp.get(ChronoField.DAY_OF_WEEK);\n      var dowDiff = MathUtil.intMod(this._dowValue - curDow + 7, 7);\n      dowDiff += (this._ordinal - 1) * 7;\n      return temp.plus(dowDiff, ChronoUnit.DAYS);\n    } else {\n      var _temp = temporal.with(ChronoField.DAY_OF_MONTH, temporal.range(ChronoField.DAY_OF_MONTH).maximum());\n\n      var _curDow = _temp.get(ChronoField.DAY_OF_WEEK);\n\n      var daysDiff = this._dowValue - _curDow;\n      daysDiff = daysDiff === 0 ? 0 : daysDiff > 0 ? daysDiff - 7 : daysDiff;\n      daysDiff -= (-this._ordinal - 1) * 7;\n      return _temp.plus(daysDiff, ChronoUnit.DAYS);\n    }\n  };\n\n  return DayOfWeekInMonth;\n}(TemporalAdjuster);\n\nvar RelativeDayOfWeek = function (_TemporalAdjuster3) {\n  _inheritsLoose(RelativeDayOfWeek, _TemporalAdjuster3);\n\n  function RelativeDayOfWeek(relative, dayOfWeek) {\n    var _this3;\n\n    _this3 = _TemporalAdjuster3.call(this) || this;\n    requireNonNull(dayOfWeek, 'dayOfWeek');\n    _this3._relative = relative;\n    _this3._dowValue = dayOfWeek.value();\n    return _this3;\n  }\n\n  var _proto3 = RelativeDayOfWeek.prototype;\n\n  _proto3.adjustInto = function adjustInto(temporal) {\n    var calDow = temporal.get(ChronoField.DAY_OF_WEEK);\n\n    if (this._relative < 2 && calDow === this._dowValue) {\n      return temporal;\n    }\n\n    if ((this._relative & 1) === 0) {\n      var daysDiff = calDow - this._dowValue;\n      return temporal.plus(daysDiff >= 0 ? 7 - daysDiff : -daysDiff, ChronoUnit.DAYS);\n    } else {\n      var _daysDiff = this._dowValue - calDow;\n\n      return temporal.minus(_daysDiff >= 0 ? 7 - _daysDiff : -_daysDiff, ChronoUnit.DAYS);\n    }\n  };\n\n  return RelativeDayOfWeek;\n}(TemporalAdjuster);\n\nvar IsoChronology = function (_Enum) {\n  _inheritsLoose(IsoChronology, _Enum);\n\n  function IsoChronology() {\n    return _Enum.apply(this, arguments) || this;\n  }\n\n  IsoChronology.isLeapYear = function isLeapYear(prolepticYear) {\n    return (prolepticYear & 3) === 0 && (prolepticYear % 100 !== 0 || prolepticYear % 400 === 0);\n  };\n\n  var _proto = IsoChronology.prototype;\n\n  _proto._updateResolveMap = function _updateResolveMap(fieldValues, field, value) {\n    requireNonNull(fieldValues, 'fieldValues');\n    requireNonNull(field, 'field');\n    var current = fieldValues.get(field);\n\n    if (current != null && current !== value) {\n      throw new DateTimeException('Invalid state, field: ' + field + ' ' + current + ' conflicts with ' + field + ' ' + value);\n    }\n\n    fieldValues.put(field, value);\n  };\n\n  _proto.resolveDate = function resolveDate(fieldValues, resolverStyle) {\n    if (fieldValues.containsKey(ChronoField.EPOCH_DAY)) {\n      return LocalDate.ofEpochDay(fieldValues.remove(ChronoField.EPOCH_DAY));\n    }\n\n    var prolepticMonth = fieldValues.remove(ChronoField.PROLEPTIC_MONTH);\n\n    if (prolepticMonth != null) {\n      if (resolverStyle !== ResolverStyle.LENIENT) {\n        ChronoField.PROLEPTIC_MONTH.checkValidValue(prolepticMonth);\n      }\n\n      this._updateResolveMap(fieldValues, ChronoField.MONTH_OF_YEAR, MathUtil.floorMod(prolepticMonth, 12) + 1);\n\n      this._updateResolveMap(fieldValues, ChronoField.YEAR, MathUtil.floorDiv(prolepticMonth, 12));\n    }\n\n    var yoeLong = fieldValues.remove(ChronoField.YEAR_OF_ERA);\n\n    if (yoeLong != null) {\n      if (resolverStyle !== ResolverStyle.LENIENT) {\n        ChronoField.YEAR_OF_ERA.checkValidValue(yoeLong);\n      }\n\n      var era = fieldValues.remove(ChronoField.ERA);\n\n      if (era == null) {\n        var year = fieldValues.get(ChronoField.YEAR);\n\n        if (resolverStyle === ResolverStyle.STRICT) {\n          if (year != null) {\n            this._updateResolveMap(fieldValues, ChronoField.YEAR, year > 0 ? yoeLong : MathUtil.safeSubtract(1, yoeLong));\n          } else {\n            fieldValues.put(ChronoField.YEAR_OF_ERA, yoeLong);\n          }\n        } else {\n          this._updateResolveMap(fieldValues, ChronoField.YEAR, year == null || year > 0 ? yoeLong : MathUtil.safeSubtract(1, yoeLong));\n        }\n      } else if (era === 1) {\n        this._updateResolveMap(fieldValues, ChronoField.YEAR, yoeLong);\n      } else if (era === 0) {\n        this._updateResolveMap(fieldValues, ChronoField.YEAR, MathUtil.safeSubtract(1, yoeLong));\n      } else {\n        throw new DateTimeException('Invalid value for era: ' + era);\n      }\n    } else if (fieldValues.containsKey(ChronoField.ERA)) {\n      ChronoField.ERA.checkValidValue(fieldValues.get(ChronoField.ERA));\n    }\n\n    if (fieldValues.containsKey(ChronoField.YEAR)) {\n      if (fieldValues.containsKey(ChronoField.MONTH_OF_YEAR)) {\n        if (fieldValues.containsKey(ChronoField.DAY_OF_MONTH)) {\n          var y = ChronoField.YEAR.checkValidIntValue(fieldValues.remove(ChronoField.YEAR));\n          var moy = fieldValues.remove(ChronoField.MONTH_OF_YEAR);\n          var dom = fieldValues.remove(ChronoField.DAY_OF_MONTH);\n\n          if (resolverStyle === ResolverStyle.LENIENT) {\n            var months = moy - 1;\n            var days = dom - 1;\n            return LocalDate.of(y, 1, 1).plusMonths(months).plusDays(days);\n          } else if (resolverStyle === ResolverStyle.SMART) {\n            ChronoField.DAY_OF_MONTH.checkValidValue(dom);\n\n            if (moy === 4 || moy === 6 || moy === 9 || moy === 11) {\n              dom = Math.min(dom, 30);\n            } else if (moy === 2) {\n              dom = Math.min(dom, Month.FEBRUARY.length(Year.isLeap(y)));\n            }\n\n            return LocalDate.of(y, moy, dom);\n          } else {\n            return LocalDate.of(y, moy, dom);\n          }\n        }\n      }\n\n      if (fieldValues.containsKey(ChronoField.DAY_OF_YEAR)) {\n        var _y = ChronoField.YEAR.checkValidIntValue(fieldValues.remove(ChronoField.YEAR));\n\n        if (resolverStyle === ResolverStyle.LENIENT) {\n          var _days = MathUtil.safeSubtract(fieldValues.remove(ChronoField.DAY_OF_YEAR), 1);\n\n          return LocalDate.ofYearDay(_y, 1).plusDays(_days);\n        }\n\n        var doy = ChronoField.DAY_OF_YEAR.checkValidIntValue(fieldValues.remove(ChronoField.DAY_OF_YEAR));\n        return LocalDate.ofYearDay(_y, doy);\n      }\n\n      if (fieldValues.containsKey(ChronoField.ALIGNED_WEEK_OF_YEAR)) {\n        if (fieldValues.containsKey(ChronoField.ALIGNED_DAY_OF_WEEK_IN_YEAR)) {\n          var _y2 = ChronoField.YEAR.checkValidIntValue(fieldValues.remove(ChronoField.YEAR));\n\n          if (resolverStyle === ResolverStyle.LENIENT) {\n            var weeks = MathUtil.safeSubtract(fieldValues.remove(ChronoField.ALIGNED_WEEK_OF_YEAR), 1);\n\n            var _days2 = MathUtil.safeSubtract(fieldValues.remove(ChronoField.ALIGNED_DAY_OF_WEEK_IN_YEAR), 1);\n\n            return LocalDate.of(_y2, 1, 1).plusWeeks(weeks).plusDays(_days2);\n          }\n\n          var aw = ChronoField.ALIGNED_WEEK_OF_YEAR.checkValidIntValue(fieldValues.remove(ChronoField.ALIGNED_WEEK_OF_YEAR));\n          var ad = ChronoField.ALIGNED_DAY_OF_WEEK_IN_YEAR.checkValidIntValue(fieldValues.remove(ChronoField.ALIGNED_DAY_OF_WEEK_IN_YEAR));\n          var date = LocalDate.of(_y2, 1, 1).plusDays((aw - 1) * 7 + (ad - 1));\n\n          if (resolverStyle === ResolverStyle.STRICT && date.get(ChronoField.YEAR) !== _y2) {\n            throw new DateTimeException('Strict mode rejected date parsed to a different year');\n          }\n\n          return date;\n        }\n\n        if (fieldValues.containsKey(ChronoField.DAY_OF_WEEK)) {\n          var _y3 = ChronoField.YEAR.checkValidIntValue(fieldValues.remove(ChronoField.YEAR));\n\n          if (resolverStyle === ResolverStyle.LENIENT) {\n            var _weeks = MathUtil.safeSubtract(fieldValues.remove(ChronoField.ALIGNED_WEEK_OF_YEAR), 1);\n\n            var _days3 = MathUtil.safeSubtract(fieldValues.remove(ChronoField.DAY_OF_WEEK), 1);\n\n            return LocalDate.of(_y3, 1, 1).plusWeeks(_weeks).plusDays(_days3);\n          }\n\n          var _aw = ChronoField.ALIGNED_WEEK_OF_YEAR.checkValidIntValue(fieldValues.remove(ChronoField.ALIGNED_WEEK_OF_YEAR));\n\n          var dow = ChronoField.DAY_OF_WEEK.checkValidIntValue(fieldValues.remove(ChronoField.DAY_OF_WEEK));\n\n          var _date = LocalDate.of(_y3, 1, 1).plusWeeks(_aw - 1).with(TemporalAdjusters.nextOrSame(DayOfWeek.of(dow)));\n\n          if (resolverStyle === ResolverStyle.STRICT && _date.get(ChronoField.YEAR) !== _y3) {\n            throw new DateTimeException('Strict mode rejected date parsed to a different month');\n          }\n\n          return _date;\n        }\n      }\n    }\n\n    return null;\n  };\n\n  _proto.date = function date(temporal) {\n    return LocalDate.from(temporal);\n  };\n\n  return IsoChronology;\n}(Enum);\nfunction _init$e() {\n  IsoChronology.INSTANCE = new IsoChronology('IsoChronology');\n}\n\nvar OffsetTime = function (_DefaultInterfaceTemp) {\n  _inheritsLoose(OffsetTime, _DefaultInterfaceTemp);\n\n  OffsetTime.from = function from(temporal) {\n    requireNonNull(temporal, 'temporal');\n\n    if (temporal instanceof OffsetTime) {\n      return temporal;\n    } else if (temporal instanceof OffsetDateTime) {\n      return temporal.toOffsetTime();\n    }\n\n    try {\n      var time = LocalTime.from(temporal);\n      var offset = ZoneOffset.from(temporal);\n      return new OffsetTime(time, offset);\n    } catch (ex) {\n      throw new DateTimeException(\"Unable to obtain OffsetTime TemporalAccessor: \" + temporal + \", type \" + (temporal.constructor != null ? temporal.constructor.name : ''));\n    }\n  };\n\n  OffsetTime.now = function now(clockOrZone) {\n    if (arguments.length === 0) {\n      return OffsetTime._now(Clock.systemDefaultZone());\n    } else if (clockOrZone instanceof Clock) {\n      return OffsetTime._now(clockOrZone);\n    } else {\n      return OffsetTime._now(Clock.system(clockOrZone));\n    }\n  };\n\n  OffsetTime._now = function _now(clock) {\n    requireNonNull(clock, 'clock');\n    var now = clock.instant();\n    return OffsetTime.ofInstant(now, clock.zone().rules().offset(now));\n  };\n\n  OffsetTime.of = function of() {\n    if (arguments.length <= 2) {\n      return OffsetTime.ofTimeAndOffset.apply(this, arguments);\n    } else {\n      return OffsetTime.ofNumbers.apply(this, arguments);\n    }\n  };\n\n  OffsetTime.ofNumbers = function ofNumbers(hour, minute, second, nanoOfSecond, offset) {\n    var time = LocalTime.of(hour, minute, second, nanoOfSecond);\n    return new OffsetTime(time, offset);\n  };\n\n  OffsetTime.ofTimeAndOffset = function ofTimeAndOffset(time, offset) {\n    return new OffsetTime(time, offset);\n  };\n\n  OffsetTime.ofInstant = function ofInstant(instant, zone) {\n    requireNonNull(instant, 'instant');\n    requireInstance(instant, Instant, 'instant');\n    requireNonNull(zone, 'zone');\n    requireInstance(zone, ZoneId, 'zone');\n    var rules = zone.rules();\n    var offset = rules.offset(instant);\n    var secsOfDay = instant.epochSecond() % LocalTime.SECONDS_PER_DAY;\n    secsOfDay = (secsOfDay + offset.totalSeconds()) % LocalTime.SECONDS_PER_DAY;\n\n    if (secsOfDay < 0) {\n      secsOfDay += LocalTime.SECONDS_PER_DAY;\n    }\n\n    var time = LocalTime.ofSecondOfDay(secsOfDay, instant.nano());\n    return new OffsetTime(time, offset);\n  };\n\n  OffsetTime.parse = function parse(text, formatter) {\n    if (formatter === void 0) {\n      formatter = DateTimeFormatter.ISO_OFFSET_TIME;\n    }\n\n    requireNonNull(formatter, 'formatter');\n    return formatter.parse(text, OffsetTime.FROM);\n  };\n\n  function OffsetTime(time, offset) {\n    var _this;\n\n    _this = _DefaultInterfaceTemp.call(this) || this;\n    requireNonNull(time, 'time');\n    requireInstance(time, LocalTime, 'time');\n    requireNonNull(offset, 'offset');\n    requireInstance(offset, ZoneOffset, 'offset');\n    _this._time = time;\n    _this._offset = offset;\n    return _this;\n  }\n\n  var _proto = OffsetTime.prototype;\n\n  _proto.adjustInto = function adjustInto(temporal) {\n    return temporal.with(ChronoField.NANO_OF_DAY, this._time.toNanoOfDay()).with(ChronoField.OFFSET_SECONDS, this.offset().totalSeconds());\n  };\n\n  _proto.atDate = function atDate(date) {\n    return OffsetDateTime.of(date, this._time, this._offset);\n  };\n\n  _proto.format = function format(formatter) {\n    requireNonNull(formatter, 'formatter');\n    return formatter.format(this, OffsetTime.FROM);\n  };\n\n  _proto.get = function get(field) {\n    return _DefaultInterfaceTemp.prototype.get.call(this, field);\n  };\n\n  _proto.getLong = function getLong(field) {\n    if (field instanceof ChronoField) {\n      if (field === ChronoField.OFFSET_SECONDS) {\n        return this._offset.totalSeconds();\n      }\n\n      return this._time.getLong(field);\n    }\n\n    return field.getFrom(this);\n  };\n\n  _proto.hour = function hour() {\n    return this._time.hour();\n  };\n\n  _proto.minute = function minute() {\n    return this._time.minute();\n  };\n\n  _proto.second = function second() {\n    return this._time.second();\n  };\n\n  _proto.nano = function nano() {\n    return this._time.nano();\n  };\n\n  _proto.offset = function offset() {\n    return this._offset;\n  };\n\n  _proto.isAfter = function isAfter(other) {\n    requireNonNull(other, 'other');\n    return this._toEpochNano() > other._toEpochNano();\n  };\n\n  _proto.isBefore = function isBefore(other) {\n    requireNonNull(other, 'other');\n    return this._toEpochNano() < other._toEpochNano();\n  };\n\n  _proto.isEqual = function isEqual(other) {\n    requireNonNull(other, 'other');\n    return this._toEpochNano() === other._toEpochNano();\n  };\n\n  _proto.isSupported = function isSupported(fieldOrUnit) {\n    if (fieldOrUnit instanceof ChronoField) {\n      return fieldOrUnit.isTimeBased() || fieldOrUnit === ChronoField.OFFSET_SECONDS;\n    } else if (fieldOrUnit instanceof ChronoUnit) {\n      return fieldOrUnit.isTimeBased();\n    }\n\n    return fieldOrUnit != null && fieldOrUnit.isSupportedBy(this);\n  };\n\n  _proto.minusHours = function minusHours(hours) {\n    return this._withLocalTimeOffset(this._time.minusHours(hours), this._offset);\n  };\n\n  _proto.minusMinutes = function minusMinutes(minutes) {\n    return this._withLocalTimeOffset(this._time.minusMinutes(minutes), this._offset);\n  };\n\n  _proto.minusSeconds = function minusSeconds(seconds) {\n    return this._withLocalTimeOffset(this._time.minusSeconds(seconds), this._offset);\n  };\n\n  _proto.minusNanos = function minusNanos(nanos) {\n    return this._withLocalTimeOffset(this._time.minusNanos(nanos), this._offset);\n  };\n\n  _proto.minusAmount = function minusAmount(amount) {\n    requireNonNull(amount);\n    return amount.subtractFrom(this);\n  };\n\n  _proto.minusAmountUnit = function minusAmountUnit(amountToSubtract, unit) {\n    return this.plus(-1 * amountToSubtract, unit);\n  };\n\n  _proto.plusAmount = function plusAmount(amount) {\n    requireNonNull(amount);\n    return amount.addTo(this);\n  };\n\n  _proto.plusAmountUnit = function plusAmountUnit(amountToAdd, unit) {\n    if (unit instanceof ChronoUnit) {\n      return this._withLocalTimeOffset(this._time.plus(amountToAdd, unit), this._offset);\n    }\n\n    return unit.addTo(this, amountToAdd);\n  };\n\n  _proto.plusHours = function plusHours(hours) {\n    return this._withLocalTimeOffset(this._time.plusHours(hours), this._offset);\n  };\n\n  _proto.plusMinutes = function plusMinutes(minutes) {\n    return this._withLocalTimeOffset(this._time.plusMinutes(minutes), this._offset);\n  };\n\n  _proto.plusSeconds = function plusSeconds(seconds) {\n    return this._withLocalTimeOffset(this._time.plusSeconds(seconds), this._offset);\n  };\n\n  _proto.plusNanos = function plusNanos(nanos) {\n    return this._withLocalTimeOffset(this._time.plusNanos(nanos), this._offset);\n  };\n\n  _proto.query = function query(_query) {\n    requireNonNull(_query, 'query');\n\n    if (_query === TemporalQueries.precision()) {\n      return ChronoUnit.NANOS;\n    } else if (_query === TemporalQueries.offset() || _query === TemporalQueries.zone()) {\n      return this.offset();\n    } else if (_query === TemporalQueries.localTime()) {\n      return this._time;\n    } else if (_query === TemporalQueries.chronology() || _query === TemporalQueries.localDate() || _query === TemporalQueries.zoneId()) {\n      return null;\n    }\n\n    return _DefaultInterfaceTemp.prototype.query.call(this, _query);\n  };\n\n  _proto.range = function range(field) {\n    if (field instanceof ChronoField) {\n      if (field === ChronoField.OFFSET_SECONDS) {\n        return field.range();\n      }\n\n      return this._time.range(field);\n    }\n\n    return field.rangeRefinedBy(this);\n  };\n\n  _proto.toLocalTime = function toLocalTime() {\n    return this._time;\n  };\n\n  _proto.truncatedTo = function truncatedTo(unit) {\n    return this._withLocalTimeOffset(this._time.truncatedTo(unit), this._offset);\n  };\n\n  _proto.until = function until(endExclusive, unit) {\n    requireNonNull(endExclusive, 'endExclusive');\n    requireNonNull(unit, 'unit');\n    var end = OffsetTime.from(endExclusive);\n\n    if (unit instanceof ChronoUnit) {\n      var nanosUntil = end._toEpochNano() - this._toEpochNano();\n\n      switch (unit) {\n        case ChronoUnit.NANOS:\n          return nanosUntil;\n\n        case ChronoUnit.MICROS:\n          return Math.floor(nanosUntil / 1000);\n\n        case ChronoUnit.MILLIS:\n          return Math.floor(nanosUntil / 1000000);\n\n        case ChronoUnit.SECONDS:\n          return Math.floor(nanosUntil / LocalTime.NANOS_PER_SECOND);\n\n        case ChronoUnit.MINUTES:\n          return Math.floor(nanosUntil / LocalTime.NANOS_PER_MINUTE);\n\n        case ChronoUnit.HOURS:\n          return Math.floor(nanosUntil / LocalTime.NANOS_PER_HOUR);\n\n        case ChronoUnit.HALF_DAYS:\n          return Math.floor(nanosUntil / (12 * LocalTime.NANOS_PER_HOUR));\n      }\n\n      throw new UnsupportedTemporalTypeException('Unsupported unit: ' + unit);\n    }\n\n    return unit.between(this, end);\n  };\n\n  _proto.withHour = function withHour(hour) {\n    return this._withLocalTimeOffset(this._time.withHour(hour), this._offset);\n  };\n\n  _proto.withMinute = function withMinute(minute) {\n    return this._withLocalTimeOffset(this._time.withMinute(minute), this._offset);\n  };\n\n  _proto.withSecond = function withSecond(second) {\n    return this._withLocalTimeOffset(this._time.withSecond(second), this._offset);\n  };\n\n  _proto.withNano = function withNano(nano) {\n    return this._withLocalTimeOffset(this._time.withNano(nano), this._offset);\n  };\n\n  _proto.withOffsetSameInstant = function withOffsetSameInstant(offset) {\n    requireNonNull(offset, 'offset');\n\n    if (offset.equals(this._offset)) {\n      return this;\n    }\n\n    var difference = offset.totalSeconds() - this._offset.totalSeconds();\n\n    var adjusted = this._time.plusSeconds(difference);\n\n    return new OffsetTime(adjusted, offset);\n  };\n\n  _proto.withOffsetSameLocal = function withOffsetSameLocal(offset) {\n    return offset != null && offset.equals(this._offset) ? this : new OffsetTime(this._time, offset);\n  };\n\n  _proto._toEpochNano = function _toEpochNano() {\n    var nod = this._time.toNanoOfDay();\n\n    var offsetNanos = this._offset.totalSeconds() * LocalTime.NANOS_PER_SECOND;\n    return nod - offsetNanos;\n  };\n\n  _proto.withAdjuster = function withAdjuster(adjuster) {\n    requireNonNull(adjuster, 'adjuster');\n\n    if (adjuster instanceof LocalTime) {\n      return this._withLocalTimeOffset(adjuster, this._offset);\n    } else if (adjuster instanceof ZoneOffset) {\n      return this._withLocalTimeOffset(this._time, adjuster);\n    } else if (adjuster instanceof OffsetTime) {\n      return adjuster;\n    }\n\n    return adjuster.adjustInto(this);\n  };\n\n  _proto.withFieldValue = function withFieldValue(field, newValue) {\n    requireNonNull(field, 'field');\n\n    if (field instanceof ChronoField) {\n      if (field === ChronoField.OFFSET_SECONDS) {\n        return this._withLocalTimeOffset(this._time, ZoneOffset.ofTotalSeconds(field.checkValidIntValue(newValue)));\n      }\n\n      return this._withLocalTimeOffset(this._time.with(field, newValue), this._offset);\n    }\n\n    return field.adjustInto(this, newValue);\n  };\n\n  _proto._withLocalTimeOffset = function _withLocalTimeOffset(time, offset) {\n    if (this._time === time && this._offset.equals(offset)) {\n      return this;\n    }\n\n    return new OffsetTime(time, offset);\n  };\n\n  _proto.compareTo = function compareTo(other) {\n    requireNonNull(other, 'other');\n    requireInstance(other, OffsetTime, 'other');\n\n    if (this._offset.equals(other._offset)) {\n      return this._time.compareTo(other._time);\n    }\n\n    var compare = MathUtil.compareNumbers(this._toEpochNano(), other._toEpochNano());\n\n    if (compare === 0) {\n      return this._time.compareTo(other._time);\n    }\n\n    return compare;\n  };\n\n  _proto.equals = function equals(other) {\n    if (this === other) {\n      return true;\n    }\n\n    if (other instanceof OffsetTime) {\n      return this._time.equals(other._time) && this._offset.equals(other._offset);\n    }\n\n    return false;\n  };\n\n  _proto.hashCode = function hashCode() {\n    return this._time.hashCode() ^ this._offset.hashCode();\n  };\n\n  _proto.toString = function toString() {\n    return this._time.toString() + this._offset.toString();\n  };\n\n  _proto.toJSON = function toJSON() {\n    return this.toString();\n  };\n\n  return OffsetTime;\n}(DefaultInterfaceTemporal);\nfunction _init$f() {\n  OffsetTime.MIN = OffsetTime.ofNumbers(0, 0, 0, 0, ZoneOffset.MAX);\n  OffsetTime.MAX = OffsetTime.ofNumbers(23, 59, 59, 999999999, ZoneOffset.MIN);\n  OffsetTime.FROM = createTemporalQuery('OffsetTime.FROM', function (temporal) {\n    return OffsetTime.from(temporal);\n  });\n}\n\nvar ChronoZonedDateTime = function (_DefaultInterfaceTemp) {\n  _inheritsLoose(ChronoZonedDateTime, _DefaultInterfaceTemp);\n\n  function ChronoZonedDateTime() {\n    return _DefaultInterfaceTemp.apply(this, arguments) || this;\n  }\n\n  var _proto = ChronoZonedDateTime.prototype;\n\n  _proto.query = function query(_query) {\n    if (_query === TemporalQueries.zoneId() || _query === TemporalQueries.zone()) {\n      return this.zone();\n    } else if (_query === TemporalQueries.chronology()) {\n      return this.toLocalDate().chronology();\n    } else if (_query === TemporalQueries.precision()) {\n      return ChronoUnit.NANOS;\n    } else if (_query === TemporalQueries.offset()) {\n      return this.offset();\n    } else if (_query === TemporalQueries.localDate()) {\n      return LocalDate.ofEpochDay(this.toLocalDate().toEpochDay());\n    } else if (_query === TemporalQueries.localTime()) {\n      return this.toLocalTime();\n    }\n\n    return _DefaultInterfaceTemp.prototype.query.call(this, _query);\n  };\n\n  _proto.format = function format(formatter) {\n    requireNonNull(formatter, 'formatter');\n    return formatter.format(this);\n  };\n\n  _proto.toInstant = function toInstant() {\n    return Instant.ofEpochSecond(this.toEpochSecond(), this.toLocalTime().nano());\n  };\n\n  _proto.toEpochSecond = function toEpochSecond() {\n    var epochDay = this.toLocalDate().toEpochDay();\n    var secs = epochDay * 86400 + this.toLocalTime().toSecondOfDay();\n    secs -= this.offset().totalSeconds();\n    return secs;\n  };\n\n  _proto.compareTo = function compareTo(other) {\n    requireNonNull(other, 'other');\n    var cmp = MathUtil.compareNumbers(this.toEpochSecond(), other.toEpochSecond());\n\n    if (cmp === 0) {\n      cmp = this.toLocalTime().nano() - other.toLocalTime().nano();\n\n      if (cmp === 0) {\n        cmp = this.toLocalDateTime().compareTo(other.toLocalDateTime());\n\n        if (cmp === 0) {\n          cmp = strcmp(this.zone().id(), other.zone().id());\n        }\n      }\n    }\n\n    return cmp;\n  };\n\n  _proto.isAfter = function isAfter(other) {\n    requireNonNull(other, 'other');\n    var thisEpochSec = this.toEpochSecond();\n    var otherEpochSec = other.toEpochSecond();\n    return thisEpochSec > otherEpochSec || thisEpochSec === otherEpochSec && this.toLocalTime().nano() > other.toLocalTime().nano();\n  };\n\n  _proto.isBefore = function isBefore(other) {\n    requireNonNull(other, 'other');\n    var thisEpochSec = this.toEpochSecond();\n    var otherEpochSec = other.toEpochSecond();\n    return thisEpochSec < otherEpochSec || thisEpochSec === otherEpochSec && this.toLocalTime().nano() < other.toLocalTime().nano();\n  };\n\n  _proto.isEqual = function isEqual(other) {\n    requireNonNull(other, 'other');\n    return this.toEpochSecond() === other.toEpochSecond() && this.toLocalTime().nano() === other.toLocalTime().nano();\n  };\n\n  _proto.equals = function equals(other) {\n    if (this === other) {\n      return true;\n    }\n\n    if (other instanceof ChronoZonedDateTime) {\n      return this.compareTo(other) === 0;\n    }\n\n    return false;\n  };\n\n  return ChronoZonedDateTime;\n}(DefaultInterfaceTemporal);\n\nfunction strcmp(a, b) {\n  if (a < b) {\n    return -1;\n  }\n\n  if (a > b) {\n    return 1;\n  }\n\n  return 0;\n}\n\nvar ZonedDateTime = function (_ChronoZonedDateTime) {\n  _inheritsLoose(ZonedDateTime, _ChronoZonedDateTime);\n\n  ZonedDateTime.now = function now(clockOrZone) {\n    var clock;\n\n    if (clockOrZone instanceof ZoneId) {\n      clock = Clock.system(clockOrZone);\n    } else {\n      clock = clockOrZone == null ? Clock.systemDefaultZone() : clockOrZone;\n    }\n\n    return ZonedDateTime.ofInstant(clock.instant(), clock.zone());\n  };\n\n  ZonedDateTime.of = function of() {\n    if (arguments.length <= 2) {\n      return ZonedDateTime.of2.apply(this, arguments);\n    } else if (arguments.length === 3 && arguments[0] instanceof LocalDate) {\n      return ZonedDateTime.of3.apply(this, arguments);\n    } else {\n      return ZonedDateTime.of8.apply(this, arguments);\n    }\n  };\n\n  ZonedDateTime.of3 = function of3(date, time, zone) {\n    return ZonedDateTime.of2(LocalDateTime.of(date, time), zone);\n  };\n\n  ZonedDateTime.of2 = function of2(localDateTime, zone) {\n    return ZonedDateTime.ofLocal(localDateTime, zone, null);\n  };\n\n  ZonedDateTime.of8 = function of8(year, month, dayOfMonth, hour, minute, second, nanoOfSecond, zone) {\n    var dt = LocalDateTime.of(year, month, dayOfMonth, hour, minute, second, nanoOfSecond);\n    return ZonedDateTime.ofLocal(dt, zone, null);\n  };\n\n  ZonedDateTime.ofLocal = function ofLocal(localDateTime, zone, preferredOffset) {\n    requireNonNull(localDateTime, 'localDateTime');\n    requireNonNull(zone, 'zone');\n\n    if (zone instanceof ZoneOffset) {\n      return new ZonedDateTime(localDateTime, zone, zone);\n    }\n\n    var offset = null;\n    var rules = zone.rules();\n    var validOffsets = rules.validOffsets(localDateTime);\n\n    if (validOffsets.length === 1) {\n      offset = validOffsets[0];\n    } else if (validOffsets.length === 0) {\n      var trans = rules.transition(localDateTime);\n      localDateTime = localDateTime.plusSeconds(trans.duration().seconds());\n      offset = trans.offsetAfter();\n    } else {\n      if (preferredOffset != null && validOffsets.some(function (validOffset) {\n        return validOffset.equals(preferredOffset);\n      })) {\n        offset = preferredOffset;\n      } else {\n        offset = requireNonNull(validOffsets[0], 'offset');\n      }\n    }\n\n    return new ZonedDateTime(localDateTime, offset, zone);\n  };\n\n  ZonedDateTime.ofInstant = function ofInstant() {\n    if (arguments.length === 2) {\n      return ZonedDateTime.ofInstant2.apply(this, arguments);\n    } else {\n      return ZonedDateTime.ofInstant3.apply(this, arguments);\n    }\n  };\n\n  ZonedDateTime.ofInstant2 = function ofInstant2(instant, zone) {\n    requireNonNull(instant, 'instant');\n    requireNonNull(zone, 'zone');\n    return ZonedDateTime._create(instant.epochSecond(), instant.nano(), zone);\n  };\n\n  ZonedDateTime.ofInstant3 = function ofInstant3(localDateTime, offset, zone) {\n    requireNonNull(localDateTime, 'localDateTime');\n    requireNonNull(offset, 'offset');\n    requireNonNull(zone, 'zone');\n    return ZonedDateTime._create(localDateTime.toEpochSecond(offset), localDateTime.nano(), zone);\n  };\n\n  ZonedDateTime._create = function _create(epochSecond, nanoOfSecond, zone) {\n    var rules = zone.rules();\n    var instant = Instant.ofEpochSecond(epochSecond, nanoOfSecond);\n    var offset = rules.offset(instant);\n    var ldt = LocalDateTime.ofEpochSecond(epochSecond, nanoOfSecond, offset);\n    return new ZonedDateTime(ldt, offset, zone);\n  };\n\n  ZonedDateTime.ofStrict = function ofStrict(localDateTime, offset, zone) {\n    requireNonNull(localDateTime, 'localDateTime');\n    requireNonNull(offset, 'offset');\n    requireNonNull(zone, 'zone');\n    var rules = zone.rules();\n\n    if (rules.isValidOffset(localDateTime, offset) === false) {\n      var trans = rules.transition(localDateTime);\n\n      if (trans != null && trans.isGap()) {\n        throw new DateTimeException('LocalDateTime ' + localDateTime + ' does not exist in zone ' + zone + ' due to a gap in the local time-line, typically caused by daylight savings');\n      }\n\n      throw new DateTimeException('ZoneOffset \"' + offset + '\" is not valid for LocalDateTime \"' + localDateTime + '\" in zone \"' + zone + '\"');\n    }\n\n    return new ZonedDateTime(localDateTime, offset, zone);\n  };\n\n  ZonedDateTime.ofLenient = function ofLenient(localDateTime, offset, zone) {\n    requireNonNull(localDateTime, 'localDateTime');\n    requireNonNull(offset, 'offset');\n    requireNonNull(zone, 'zone');\n\n    if (zone instanceof ZoneOffset && offset.equals(zone) === false) {\n      throw new IllegalArgumentException('ZoneId must match ZoneOffset');\n    }\n\n    return new ZonedDateTime(localDateTime, offset, zone);\n  };\n\n  ZonedDateTime.from = function from(temporal) {\n    requireNonNull(temporal, 'temporal');\n\n    if (temporal instanceof ZonedDateTime) {\n      return temporal;\n    }\n\n    var zone = ZoneId.from(temporal);\n\n    if (temporal.isSupported(ChronoField.INSTANT_SECONDS)) {\n      var zdt = ZonedDateTime._from(temporal, zone);\n\n      if (zdt != null) return zdt;\n    }\n\n    var ldt = LocalDateTime.from(temporal);\n    return ZonedDateTime.of2(ldt, zone);\n  };\n\n  ZonedDateTime._from = function _from(temporal, zone) {\n    try {\n      return ZonedDateTime.__from(temporal, zone);\n    } catch (ex) {\n      if (!(ex instanceof DateTimeException)) throw ex;\n    }\n  };\n\n  ZonedDateTime.__from = function __from(temporal, zone) {\n    var epochSecond = temporal.getLong(ChronoField.INSTANT_SECONDS);\n    var nanoOfSecond = temporal.get(ChronoField.NANO_OF_SECOND);\n    return ZonedDateTime._create(epochSecond, nanoOfSecond, zone);\n  };\n\n  ZonedDateTime.parse = function parse(text, formatter) {\n    if (formatter === void 0) {\n      formatter = DateTimeFormatter.ISO_ZONED_DATE_TIME;\n    }\n\n    requireNonNull(formatter, 'formatter');\n    return formatter.parse(text, ZonedDateTime.FROM);\n  };\n\n  function ZonedDateTime(dateTime, offset, zone) {\n    var _this;\n\n    requireNonNull(dateTime, 'dateTime');\n    requireNonNull(offset, 'offset');\n    requireNonNull(zone, 'zone');\n    _this = _ChronoZonedDateTime.call(this) || this;\n    _this._dateTime = dateTime;\n    _this._offset = offset;\n    _this._zone = zone;\n    return _this;\n  }\n\n  var _proto = ZonedDateTime.prototype;\n\n  _proto._resolveLocal = function _resolveLocal(newDateTime) {\n    requireNonNull(newDateTime, 'newDateTime');\n    return ZonedDateTime.ofLocal(newDateTime, this._zone, this._offset);\n  };\n\n  _proto._resolveInstant = function _resolveInstant(newDateTime) {\n    return ZonedDateTime.ofInstant3(newDateTime, this._offset, this._zone);\n  };\n\n  _proto._resolveOffset = function _resolveOffset(offset) {\n    if (offset.equals(this._offset) === false && this._zone.rules().isValidOffset(this._dateTime, offset)) {\n      return new ZonedDateTime(this._dateTime, offset, this._zone);\n    }\n\n    return this;\n  };\n\n  _proto.isSupported = function isSupported(fieldOrUnit) {\n    if (fieldOrUnit instanceof ChronoField) {\n      return true;\n    } else if (fieldOrUnit instanceof ChronoUnit) {\n      return fieldOrUnit.isDateBased() || fieldOrUnit.isTimeBased();\n    }\n\n    return fieldOrUnit != null && fieldOrUnit.isSupportedBy(this);\n  };\n\n  _proto.range = function range(field) {\n    if (field instanceof ChronoField) {\n      if (field === ChronoField.INSTANT_SECONDS || field === ChronoField.OFFSET_SECONDS) {\n        return field.range();\n      }\n\n      return this._dateTime.range(field);\n    }\n\n    return field.rangeRefinedBy(this);\n  };\n\n  _proto.get = function get(field) {\n    return this.getLong(field);\n  };\n\n  _proto.getLong = function getLong(field) {\n    if (field instanceof ChronoField) {\n      switch (field) {\n        case ChronoField.INSTANT_SECONDS:\n          return this.toEpochSecond();\n\n        case ChronoField.OFFSET_SECONDS:\n          return this._offset.totalSeconds();\n      }\n\n      return this._dateTime.getLong(field);\n    }\n\n    requireNonNull(field, 'field');\n    return field.getFrom(this);\n  };\n\n  _proto.offset = function offset() {\n    return this._offset;\n  };\n\n  _proto.withEarlierOffsetAtOverlap = function withEarlierOffsetAtOverlap() {\n    var trans = this._zone.rules().transition(this._dateTime);\n\n    if (trans != null && trans.isOverlap()) {\n      var earlierOffset = trans.offsetBefore();\n\n      if (earlierOffset.equals(this._offset) === false) {\n        return new ZonedDateTime(this._dateTime, earlierOffset, this._zone);\n      }\n    }\n\n    return this;\n  };\n\n  _proto.withLaterOffsetAtOverlap = function withLaterOffsetAtOverlap() {\n    var trans = this._zone.rules().transition(this.toLocalDateTime());\n\n    if (trans != null) {\n      var laterOffset = trans.offsetAfter();\n\n      if (laterOffset.equals(this._offset) === false) {\n        return new ZonedDateTime(this._dateTime, laterOffset, this._zone);\n      }\n    }\n\n    return this;\n  };\n\n  _proto.zone = function zone() {\n    return this._zone;\n  };\n\n  _proto.withZoneSameLocal = function withZoneSameLocal(zone) {\n    requireNonNull(zone, 'zone');\n    return this._zone.equals(zone) ? this : ZonedDateTime.ofLocal(this._dateTime, zone, this._offset);\n  };\n\n  _proto.withZoneSameInstant = function withZoneSameInstant(zone) {\n    requireNonNull(zone, 'zone');\n    return this._zone.equals(zone) ? this : ZonedDateTime._create(this._dateTime.toEpochSecond(this._offset), this._dateTime.nano(), zone);\n  };\n\n  _proto.withFixedOffsetZone = function withFixedOffsetZone() {\n    return this._zone.equals(this._offset) ? this : new ZonedDateTime(this._dateTime, this._offset, this._offset);\n  };\n\n  _proto.year = function year() {\n    return this._dateTime.year();\n  };\n\n  _proto.monthValue = function monthValue() {\n    return this._dateTime.monthValue();\n  };\n\n  _proto.month = function month() {\n    return this._dateTime.month();\n  };\n\n  _proto.dayOfMonth = function dayOfMonth() {\n    return this._dateTime.dayOfMonth();\n  };\n\n  _proto.dayOfYear = function dayOfYear() {\n    return this._dateTime.dayOfYear();\n  };\n\n  _proto.dayOfWeek = function dayOfWeek() {\n    return this._dateTime.dayOfWeek();\n  };\n\n  _proto.hour = function hour() {\n    return this._dateTime.hour();\n  };\n\n  _proto.minute = function minute() {\n    return this._dateTime.minute();\n  };\n\n  _proto.second = function second() {\n    return this._dateTime.second();\n  };\n\n  _proto.nano = function nano() {\n    return this._dateTime.nano();\n  };\n\n  _proto.withAdjuster = function withAdjuster(adjuster) {\n    if (adjuster instanceof LocalDate) {\n      return this._resolveLocal(LocalDateTime.of(adjuster, this._dateTime.toLocalTime()));\n    } else if (adjuster instanceof LocalTime) {\n      return this._resolveLocal(LocalDateTime.of(this._dateTime.toLocalDate(), adjuster));\n    } else if (adjuster instanceof LocalDateTime) {\n      return this._resolveLocal(adjuster);\n    } else if (adjuster instanceof Instant) {\n      var instant = adjuster;\n      return ZonedDateTime._create(instant.epochSecond(), instant.nano(), this._zone);\n    } else if (adjuster instanceof ZoneOffset) {\n      return this._resolveOffset(adjuster);\n    }\n\n    requireNonNull(adjuster, 'adjuster');\n    return adjuster.adjustInto(this);\n  };\n\n  _proto.withFieldValue = function withFieldValue(field, newValue) {\n    if (field instanceof ChronoField) {\n      switch (field) {\n        case ChronoField.INSTANT_SECONDS:\n          return ZonedDateTime._create(newValue, this.nano(), this._zone);\n\n        case ChronoField.OFFSET_SECONDS:\n          {\n            var offset = ZoneOffset.ofTotalSeconds(field.checkValidIntValue(newValue));\n            return this._resolveOffset(offset);\n          }\n      }\n\n      return this._resolveLocal(this._dateTime.with(field, newValue));\n    }\n\n    return field.adjustInto(this, newValue);\n  };\n\n  _proto.withYear = function withYear(year) {\n    return this._resolveLocal(this._dateTime.withYear(year));\n  };\n\n  _proto.withMonth = function withMonth(month) {\n    return this._resolveLocal(this._dateTime.withMonth(month));\n  };\n\n  _proto.withDayOfMonth = function withDayOfMonth(dayOfMonth) {\n    return this._resolveLocal(this._dateTime.withDayOfMonth(dayOfMonth));\n  };\n\n  _proto.withDayOfYear = function withDayOfYear(dayOfYear) {\n    return this._resolveLocal(this._dateTime.withDayOfYear(dayOfYear));\n  };\n\n  _proto.withHour = function withHour(hour) {\n    return this._resolveLocal(this._dateTime.withHour(hour));\n  };\n\n  _proto.withMinute = function withMinute(minute) {\n    return this._resolveLocal(this._dateTime.withMinute(minute));\n  };\n\n  _proto.withSecond = function withSecond(second) {\n    return this._resolveLocal(this._dateTime.withSecond(second));\n  };\n\n  _proto.withNano = function withNano(nanoOfSecond) {\n    return this._resolveLocal(this._dateTime.withNano(nanoOfSecond));\n  };\n\n  _proto.truncatedTo = function truncatedTo(unit) {\n    return this._resolveLocal(this._dateTime.truncatedTo(unit));\n  };\n\n  _proto.plusAmount = function plusAmount(amount) {\n    requireNonNull(amount);\n    return amount.addTo(this);\n  };\n\n  _proto.plusAmountUnit = function plusAmountUnit(amountToAdd, unit) {\n    if (unit instanceof ChronoUnit) {\n      if (unit.isDateBased()) {\n        return this._resolveLocal(this._dateTime.plus(amountToAdd, unit));\n      } else {\n        return this._resolveInstant(this._dateTime.plus(amountToAdd, unit));\n      }\n    }\n\n    requireNonNull(unit, 'unit');\n    return unit.addTo(this, amountToAdd);\n  };\n\n  _proto.plusYears = function plusYears(years) {\n    return this._resolveLocal(this._dateTime.plusYears(years));\n  };\n\n  _proto.plusMonths = function plusMonths(months) {\n    return this._resolveLocal(this._dateTime.plusMonths(months));\n  };\n\n  _proto.plusWeeks = function plusWeeks(weeks) {\n    return this._resolveLocal(this._dateTime.plusWeeks(weeks));\n  };\n\n  _proto.plusDays = function plusDays(days) {\n    return this._resolveLocal(this._dateTime.plusDays(days));\n  };\n\n  _proto.plusHours = function plusHours(hours) {\n    return this._resolveInstant(this._dateTime.plusHours(hours));\n  };\n\n  _proto.plusMinutes = function plusMinutes(minutes) {\n    return this._resolveInstant(this._dateTime.plusMinutes(minutes));\n  };\n\n  _proto.plusSeconds = function plusSeconds(seconds) {\n    return this._resolveInstant(this._dateTime.plusSeconds(seconds));\n  };\n\n  _proto.plusNanos = function plusNanos(nanos) {\n    return this._resolveInstant(this._dateTime.plusNanos(nanos));\n  };\n\n  _proto.minusAmount = function minusAmount(amount) {\n    requireNonNull(amount, 'amount');\n    return amount.subtractFrom(this);\n  };\n\n  _proto.minusAmountUnit = function minusAmountUnit(amountToSubtract, unit) {\n    return this.plusAmountUnit(-1 * amountToSubtract, unit);\n  };\n\n  _proto.minusYears = function minusYears(years) {\n    return this.plusYears(-1 * years);\n  };\n\n  _proto.minusMonths = function minusMonths(months) {\n    return this.plusMonths(-1 * months);\n  };\n\n  _proto.minusWeeks = function minusWeeks(weeks) {\n    return this.plusWeeks(-1 * weeks);\n  };\n\n  _proto.minusDays = function minusDays(days) {\n    return this.plusDays(-1 * days);\n  };\n\n  _proto.minusHours = function minusHours(hours) {\n    return this.plusHours(-1 * hours);\n  };\n\n  _proto.minusMinutes = function minusMinutes(minutes) {\n    return this.plusMinutes(-1 * minutes);\n  };\n\n  _proto.minusSeconds = function minusSeconds(seconds) {\n    return this.plusSeconds(-1 * seconds);\n  };\n\n  _proto.minusNanos = function minusNanos(nanos) {\n    return this.plusNanos(-1 * nanos);\n  };\n\n  _proto.query = function query(_query) {\n    if (_query === TemporalQueries.localDate()) {\n      return this.toLocalDate();\n    }\n\n    requireNonNull(_query, 'query');\n    return _ChronoZonedDateTime.prototype.query.call(this, _query);\n  };\n\n  _proto.until = function until(endExclusive, unit) {\n    var end = ZonedDateTime.from(endExclusive);\n\n    if (unit instanceof ChronoUnit) {\n      end = end.withZoneSameInstant(this._zone);\n\n      if (unit.isDateBased()) {\n        return this._dateTime.until(end._dateTime, unit);\n      } else {\n        var difference = this._offset.totalSeconds() - end._offset.totalSeconds();\n\n        var adjustedEnd = end._dateTime.plusSeconds(difference);\n\n        return this._dateTime.until(adjustedEnd, unit);\n      }\n    }\n\n    return unit.between(this, end);\n  };\n\n  _proto.toLocalDateTime = function toLocalDateTime() {\n    return this._dateTime;\n  };\n\n  _proto.toLocalDate = function toLocalDate() {\n    return this._dateTime.toLocalDate();\n  };\n\n  _proto.toLocalTime = function toLocalTime() {\n    return this._dateTime.toLocalTime();\n  };\n\n  _proto.toOffsetDateTime = function toOffsetDateTime() {\n    return OffsetDateTime.of(this._dateTime, this._offset);\n  };\n\n  _proto.equals = function equals(other) {\n    if (this === other) {\n      return true;\n    }\n\n    if (other instanceof ZonedDateTime) {\n      return this._dateTime.equals(other._dateTime) && this._offset.equals(other._offset) && this._zone.equals(other._zone);\n    }\n\n    return false;\n  };\n\n  _proto.hashCode = function hashCode() {\n    return MathUtil.hashCode(this._dateTime.hashCode(), this._offset.hashCode(), this._zone.hashCode());\n  };\n\n  _proto.toString = function toString() {\n    var str = this._dateTime.toString() + this._offset.toString();\n\n    if (this._offset !== this._zone) {\n      str += '[' + this._zone.toString() + ']';\n    }\n\n    return str;\n  };\n\n  _proto.toJSON = function toJSON() {\n    return this.toString();\n  };\n\n  _proto.format = function format(formatter) {\n    return _ChronoZonedDateTime.prototype.format.call(this, formatter);\n  };\n\n  return ZonedDateTime;\n}(ChronoZonedDateTime);\nfunction _init$g() {\n  ZonedDateTime.FROM = createTemporalQuery('ZonedDateTime.FROM', function (temporal) {\n    return ZonedDateTime.from(temporal);\n  });\n}\n\nvar OffsetDateTime = function (_DefaultInterfaceTemp) {\n  _inheritsLoose(OffsetDateTime, _DefaultInterfaceTemp);\n\n  OffsetDateTime.from = function from(temporal) {\n    requireNonNull(temporal, 'temporal');\n\n    if (temporal instanceof OffsetDateTime) {\n      return temporal;\n    }\n\n    try {\n      var offset = ZoneOffset.from(temporal);\n\n      try {\n        var ldt = LocalDateTime.from(temporal);\n        return OffsetDateTime.of(ldt, offset);\n      } catch (_) {\n        var instant = Instant.from(temporal);\n        return OffsetDateTime.ofInstant(instant, offset);\n      }\n    } catch (ex) {\n      throw new DateTimeException(\"Unable to obtain OffsetDateTime TemporalAccessor: \" + temporal + \", type \" + (temporal.constructor != null ? temporal.constructor.name : ''));\n    }\n  };\n\n  OffsetDateTime.now = function now(clockOrZone) {\n    if (arguments.length === 0) {\n      return OffsetDateTime.now(Clock.systemDefaultZone());\n    } else {\n      requireNonNull(clockOrZone, 'clockOrZone');\n\n      if (clockOrZone instanceof ZoneId) {\n        return OffsetDateTime.now(Clock.system(clockOrZone));\n      } else if (clockOrZone instanceof Clock) {\n        var now = clockOrZone.instant();\n        return OffsetDateTime.ofInstant(now, clockOrZone.zone().rules().offset(now));\n      } else {\n        throw new IllegalArgumentException('clockOrZone must be an instance of ZoneId or Clock');\n      }\n    }\n  };\n\n  OffsetDateTime.of = function of() {\n    if (arguments.length <= 2) {\n      return OffsetDateTime.ofDateTime.apply(this, arguments);\n    } else if (arguments.length === 3) {\n      return OffsetDateTime.ofDateAndTime.apply(this, arguments);\n    } else {\n      return OffsetDateTime.ofNumbers.apply(this, arguments);\n    }\n  };\n\n  OffsetDateTime.ofDateTime = function ofDateTime(dateTime, offset) {\n    return new OffsetDateTime(dateTime, offset);\n  };\n\n  OffsetDateTime.ofDateAndTime = function ofDateAndTime(date, time, offset) {\n    var dt = LocalDateTime.of(date, time);\n    return new OffsetDateTime(dt, offset);\n  };\n\n  OffsetDateTime.ofNumbers = function ofNumbers(year, month, dayOfMonth, hour, minute, second, nanoOfSecond, offset) {\n    if (hour === void 0) {\n      hour = 0;\n    }\n\n    if (minute === void 0) {\n      minute = 0;\n    }\n\n    if (second === void 0) {\n      second = 0;\n    }\n\n    if (nanoOfSecond === void 0) {\n      nanoOfSecond = 0;\n    }\n\n    var dt = LocalDateTime.of(year, month, dayOfMonth, hour, minute, second, nanoOfSecond);\n    return new OffsetDateTime(dt, offset);\n  };\n\n  OffsetDateTime.ofInstant = function ofInstant(instant, zone) {\n    requireNonNull(instant, 'instant');\n    requireNonNull(zone, 'zone');\n    var rules = zone.rules();\n    var offset = rules.offset(instant);\n    var ldt = LocalDateTime.ofEpochSecond(instant.epochSecond(), instant.nano(), offset);\n    return new OffsetDateTime(ldt, offset);\n  };\n\n  OffsetDateTime.parse = function parse(text, formatter) {\n    if (formatter === void 0) {\n      formatter = DateTimeFormatter.ISO_OFFSET_DATE_TIME;\n    }\n\n    requireNonNull(formatter, 'formatter');\n    return formatter.parse(text, OffsetDateTime.FROM);\n  };\n\n  function OffsetDateTime(dateTime, offset) {\n    var _this;\n\n    _this = _DefaultInterfaceTemp.call(this) || this;\n    requireNonNull(dateTime, 'dateTime');\n    requireInstance(dateTime, LocalDateTime, 'dateTime');\n    requireNonNull(offset, 'offset');\n    requireInstance(offset, ZoneOffset, 'offset');\n    _this._dateTime = dateTime;\n    _this._offset = offset;\n    return _this;\n  }\n\n  var _proto = OffsetDateTime.prototype;\n\n  _proto.adjustInto = function adjustInto(temporal) {\n    return temporal.with(ChronoField.EPOCH_DAY, this.toLocalDate().toEpochDay()).with(ChronoField.NANO_OF_DAY, this.toLocalTime().toNanoOfDay()).with(ChronoField.OFFSET_SECONDS, this.offset().totalSeconds());\n  };\n\n  _proto.until = function until(endExclusive, unit) {\n    var end = OffsetDateTime.from(endExclusive);\n\n    if (unit instanceof ChronoUnit) {\n      end = end.withOffsetSameInstant(this._offset);\n      return this._dateTime.until(end._dateTime, unit);\n    }\n\n    return unit.between(this, end);\n  };\n\n  _proto.atZoneSameInstant = function atZoneSameInstant(zone) {\n    return ZonedDateTime.ofInstant(this._dateTime, this._offset, zone);\n  };\n\n  _proto.atZoneSimilarLocal = function atZoneSimilarLocal(zone) {\n    return ZonedDateTime.ofLocal(this._dateTime, zone, this._offset);\n  };\n\n  _proto.query = function query(_query) {\n    requireNonNull(_query, 'query');\n\n    if (_query === TemporalQueries.chronology()) {\n      return IsoChronology.INSTANCE;\n    } else if (_query === TemporalQueries.precision()) {\n      return ChronoUnit.NANOS;\n    } else if (_query === TemporalQueries.offset() || _query === TemporalQueries.zone()) {\n      return this.offset();\n    } else if (_query === TemporalQueries.localDate()) {\n      return this.toLocalDate();\n    } else if (_query === TemporalQueries.localTime()) {\n      return this.toLocalTime();\n    } else if (_query === TemporalQueries.zoneId()) {\n      return null;\n    }\n\n    return _DefaultInterfaceTemp.prototype.query.call(this, _query);\n  };\n\n  _proto.get = function get(field) {\n    if (field instanceof ChronoField) {\n      switch (field) {\n        case ChronoField.INSTANT_SECONDS:\n          throw new DateTimeException('Field too large for an int: ' + field);\n\n        case ChronoField.OFFSET_SECONDS:\n          return this.offset().totalSeconds();\n      }\n\n      return this._dateTime.get(field);\n    }\n\n    return _DefaultInterfaceTemp.prototype.get.call(this, field);\n  };\n\n  _proto.getLong = function getLong(field) {\n    if (field instanceof ChronoField) {\n      switch (field) {\n        case ChronoField.INSTANT_SECONDS:\n          return this.toEpochSecond();\n\n        case ChronoField.OFFSET_SECONDS:\n          return this.offset().totalSeconds();\n      }\n\n      return this._dateTime.getLong(field);\n    }\n\n    return field.getFrom(this);\n  };\n\n  _proto.offset = function offset() {\n    return this._offset;\n  };\n\n  _proto.year = function year() {\n    return this._dateTime.year();\n  };\n\n  _proto.monthValue = function monthValue() {\n    return this._dateTime.monthValue();\n  };\n\n  _proto.month = function month() {\n    return this._dateTime.month();\n  };\n\n  _proto.dayOfMonth = function dayOfMonth() {\n    return this._dateTime.dayOfMonth();\n  };\n\n  _proto.dayOfYear = function dayOfYear() {\n    return this._dateTime.dayOfYear();\n  };\n\n  _proto.dayOfWeek = function dayOfWeek() {\n    return this._dateTime.dayOfWeek();\n  };\n\n  _proto.hour = function hour() {\n    return this._dateTime.hour();\n  };\n\n  _proto.minute = function minute() {\n    return this._dateTime.minute();\n  };\n\n  _proto.second = function second() {\n    return this._dateTime.second();\n  };\n\n  _proto.nano = function nano() {\n    return this._dateTime.nano();\n  };\n\n  _proto.toLocalDateTime = function toLocalDateTime() {\n    return this._dateTime;\n  };\n\n  _proto.toLocalDate = function toLocalDate() {\n    return this._dateTime.toLocalDate();\n  };\n\n  _proto.toLocalTime = function toLocalTime() {\n    return this._dateTime.toLocalTime();\n  };\n\n  _proto.toOffsetTime = function toOffsetTime() {\n    return OffsetTime.of(this._dateTime.toLocalTime(), this._offset);\n  };\n\n  _proto.toZonedDateTime = function toZonedDateTime() {\n    return ZonedDateTime.of(this._dateTime, this._offset);\n  };\n\n  _proto.toInstant = function toInstant() {\n    return this._dateTime.toInstant(this._offset);\n  };\n\n  _proto.toEpochSecond = function toEpochSecond() {\n    return this._dateTime.toEpochSecond(this._offset);\n  };\n\n  _proto.isSupported = function isSupported(fieldOrUnit) {\n    if (fieldOrUnit instanceof ChronoField) {\n      return fieldOrUnit.isDateBased() || fieldOrUnit.isTimeBased();\n    }\n\n    if (fieldOrUnit instanceof ChronoUnit) {\n      return fieldOrUnit.isDateBased() || fieldOrUnit.isTimeBased();\n    }\n\n    return fieldOrUnit != null && fieldOrUnit.isSupportedBy(this);\n  };\n\n  _proto.range = function range(field) {\n    if (field instanceof ChronoField) {\n      if (field === ChronoField.INSTANT_SECONDS || field === ChronoField.OFFSET_SECONDS) {\n        return field.range();\n      }\n\n      return this._dateTime.range(field);\n    }\n\n    return field.rangeRefinedBy(this);\n  };\n\n  _proto.withAdjuster = function withAdjuster(adjuster) {\n    requireNonNull(adjuster);\n\n    if (adjuster instanceof LocalDate || adjuster instanceof LocalTime || adjuster instanceof LocalDateTime) {\n      return this._withDateTimeOffset(this._dateTime.with(adjuster), this._offset);\n    } else if (adjuster instanceof Instant) {\n      return OffsetDateTime.ofInstant(adjuster, this._offset);\n    } else if (adjuster instanceof ZoneOffset) {\n      return this._withDateTimeOffset(this._dateTime, adjuster);\n    } else if (adjuster instanceof OffsetDateTime) {\n      return adjuster;\n    }\n\n    return adjuster.adjustInto(this);\n  };\n\n  _proto.withFieldValue = function withFieldValue(field, newValue) {\n    requireNonNull(field);\n\n    if (field instanceof ChronoField) {\n      var f = field;\n\n      switch (f) {\n        case ChronoField.INSTANT_SECONDS:\n          return OffsetDateTime.ofInstant(Instant.ofEpochSecond(newValue, this.nano()), this._offset);\n\n        case ChronoField.OFFSET_SECONDS:\n          {\n            return this._withDateTimeOffset(this._dateTime, ZoneOffset.ofTotalSeconds(f.checkValidIntValue(newValue)));\n          }\n      }\n\n      return this._withDateTimeOffset(this._dateTime.with(field, newValue), this._offset);\n    }\n\n    return field.adjustInto(this, newValue);\n  };\n\n  _proto._withDateTimeOffset = function _withDateTimeOffset(dateTime, offset) {\n    if (this._dateTime === dateTime && this._offset.equals(offset)) {\n      return this;\n    }\n\n    return new OffsetDateTime(dateTime, offset);\n  };\n\n  _proto.withYear = function withYear(year) {\n    return this._withDateTimeOffset(this._dateTime.withYear(year), this._offset);\n  };\n\n  _proto.withMonth = function withMonth(month) {\n    return this._withDateTimeOffset(this._dateTime.withMonth(month), this._offset);\n  };\n\n  _proto.withDayOfMonth = function withDayOfMonth(dayOfMonth) {\n    return this._withDateTimeOffset(this._dateTime.withDayOfMonth(dayOfMonth), this._offset);\n  };\n\n  _proto.withDayOfYear = function withDayOfYear(dayOfYear) {\n    return this._withDateTimeOffset(this._dateTime.withDayOfYear(dayOfYear), this._offset);\n  };\n\n  _proto.withHour = function withHour(hour) {\n    return this._withDateTimeOffset(this._dateTime.withHour(hour), this._offset);\n  };\n\n  _proto.withMinute = function withMinute(minute) {\n    return this._withDateTimeOffset(this._dateTime.withMinute(minute), this._offset);\n  };\n\n  _proto.withSecond = function withSecond(second) {\n    return this._withDateTimeOffset(this._dateTime.withSecond(second), this._offset);\n  };\n\n  _proto.withNano = function withNano(nanoOfSecond) {\n    return this._withDateTimeOffset(this._dateTime.withNano(nanoOfSecond), this._offset);\n  };\n\n  _proto.withOffsetSameLocal = function withOffsetSameLocal(offset) {\n    requireNonNull(offset, 'offset');\n    return this._withDateTimeOffset(this._dateTime, offset);\n  };\n\n  _proto.withOffsetSameInstant = function withOffsetSameInstant(offset) {\n    requireNonNull(offset, 'offset');\n\n    if (offset.equals(this._offset)) {\n      return this;\n    }\n\n    var difference = offset.totalSeconds() - this._offset.totalSeconds();\n\n    var adjusted = this._dateTime.plusSeconds(difference);\n\n    return new OffsetDateTime(adjusted, offset);\n  };\n\n  _proto.truncatedTo = function truncatedTo(unit) {\n    return this._withDateTimeOffset(this._dateTime.truncatedTo(unit), this._offset);\n  };\n\n  _proto.plusAmount = function plusAmount(amount) {\n    requireNonNull(amount, 'amount');\n    return amount.addTo(this);\n  };\n\n  _proto.plusAmountUnit = function plusAmountUnit(amountToAdd, unit) {\n    if (unit instanceof ChronoUnit) {\n      return this._withDateTimeOffset(this._dateTime.plus(amountToAdd, unit), this._offset);\n    }\n\n    return unit.addTo(this, amountToAdd);\n  };\n\n  _proto.plusYears = function plusYears(years) {\n    return this._withDateTimeOffset(this._dateTime.plusYears(years), this._offset);\n  };\n\n  _proto.plusMonths = function plusMonths(months) {\n    return this._withDateTimeOffset(this._dateTime.plusMonths(months), this._offset);\n  };\n\n  _proto.plusWeeks = function plusWeeks(weeks) {\n    return this._withDateTimeOffset(this._dateTime.plusWeeks(weeks), this._offset);\n  };\n\n  _proto.plusDays = function plusDays(days) {\n    return this._withDateTimeOffset(this._dateTime.plusDays(days), this._offset);\n  };\n\n  _proto.plusHours = function plusHours(hours) {\n    return this._withDateTimeOffset(this._dateTime.plusHours(hours), this._offset);\n  };\n\n  _proto.plusMinutes = function plusMinutes(minutes) {\n    return this._withDateTimeOffset(this._dateTime.plusMinutes(minutes), this._offset);\n  };\n\n  _proto.plusSeconds = function plusSeconds(seconds) {\n    return this._withDateTimeOffset(this._dateTime.plusSeconds(seconds), this._offset);\n  };\n\n  _proto.plusNanos = function plusNanos(nanos) {\n    return this._withDateTimeOffset(this._dateTime.plusNanos(nanos), this._offset);\n  };\n\n  _proto.minusAmount = function minusAmount(amount) {\n    requireNonNull(amount);\n    return amount.subtractFrom(this);\n  };\n\n  _proto.minusAmountUnit = function minusAmountUnit(amountToSubtract, unit) {\n    return this.plus(-1 * amountToSubtract, unit);\n  };\n\n  _proto.minusYears = function minusYears(years) {\n    return this._withDateTimeOffset(this._dateTime.minusYears(years), this._offset);\n  };\n\n  _proto.minusMonths = function minusMonths(months) {\n    return this._withDateTimeOffset(this._dateTime.minusMonths(months), this._offset);\n  };\n\n  _proto.minusWeeks = function minusWeeks(weeks) {\n    return this._withDateTimeOffset(this._dateTime.minusWeeks(weeks), this._offset);\n  };\n\n  _proto.minusDays = function minusDays(days) {\n    return this._withDateTimeOffset(this._dateTime.minusDays(days), this._offset);\n  };\n\n  _proto.minusHours = function minusHours(hours) {\n    return this._withDateTimeOffset(this._dateTime.minusHours(hours), this._offset);\n  };\n\n  _proto.minusMinutes = function minusMinutes(minutes) {\n    return this._withDateTimeOffset(this._dateTime.minusMinutes(minutes), this._offset);\n  };\n\n  _proto.minusSeconds = function minusSeconds(seconds) {\n    return this._withDateTimeOffset(this._dateTime.minusSeconds(seconds), this._offset);\n  };\n\n  _proto.minusNanos = function minusNanos(nanos) {\n    return this._withDateTimeOffset(this._dateTime.minusNanos(nanos), this._offset);\n  };\n\n  _proto.compareTo = function compareTo(other) {\n    requireNonNull(other, 'other');\n    requireInstance(other, OffsetDateTime, 'other');\n\n    if (this.offset().equals(other.offset())) {\n      return this.toLocalDateTime().compareTo(other.toLocalDateTime());\n    }\n\n    var cmp = MathUtil.compareNumbers(this.toEpochSecond(), other.toEpochSecond());\n\n    if (cmp === 0) {\n      cmp = this.toLocalTime().nano() - other.toLocalTime().nano();\n\n      if (cmp === 0) {\n        cmp = this.toLocalDateTime().compareTo(other.toLocalDateTime());\n      }\n    }\n\n    return cmp;\n  };\n\n  _proto.isAfter = function isAfter(other) {\n    requireNonNull(other, 'other');\n    var thisEpochSec = this.toEpochSecond();\n    var otherEpochSec = other.toEpochSecond();\n    return thisEpochSec > otherEpochSec || thisEpochSec === otherEpochSec && this.toLocalTime().nano() > other.toLocalTime().nano();\n  };\n\n  _proto.isBefore = function isBefore(other) {\n    requireNonNull(other, 'other');\n    var thisEpochSec = this.toEpochSecond();\n    var otherEpochSec = other.toEpochSecond();\n    return thisEpochSec < otherEpochSec || thisEpochSec === otherEpochSec && this.toLocalTime().nano() < other.toLocalTime().nano();\n  };\n\n  _proto.isEqual = function isEqual(other) {\n    requireNonNull(other, 'other');\n    return this.toEpochSecond() === other.toEpochSecond() && this.toLocalTime().nano() === other.toLocalTime().nano();\n  };\n\n  _proto.equals = function equals(other) {\n    if (this === other) {\n      return true;\n    }\n\n    if (other instanceof OffsetDateTime) {\n      return this._dateTime.equals(other._dateTime) && this._offset.equals(other._offset);\n    }\n\n    return false;\n  };\n\n  _proto.hashCode = function hashCode() {\n    return this._dateTime.hashCode() ^ this._offset.hashCode();\n  };\n\n  _proto.toString = function toString() {\n    return this._dateTime.toString() + this._offset.toString();\n  };\n\n  _proto.toJSON = function toJSON() {\n    return this.toString();\n  };\n\n  _proto.format = function format(formatter) {\n    requireNonNull(formatter, 'formatter');\n    return formatter.format(this);\n  };\n\n  return OffsetDateTime;\n}(DefaultInterfaceTemporal);\nfunction _init$h() {\n  OffsetDateTime.MIN = LocalDateTime.MIN.atOffset(ZoneOffset.MAX);\n  OffsetDateTime.MAX = LocalDateTime.MAX.atOffset(ZoneOffset.MIN);\n  OffsetDateTime.FROM = createTemporalQuery('OffsetDateTime.FROM', function (temporal) {\n    return OffsetDateTime.from(temporal);\n  });\n}\n\nvar DAYS_PER_CYCLE = 146097;\nvar DAYS_0000_TO_1970 = DAYS_PER_CYCLE * 5 - (30 * 365 + 7);\nvar LocalDate = function (_ChronoLocalDate) {\n  _inheritsLoose(LocalDate, _ChronoLocalDate);\n\n  LocalDate.now = function now(clockOrZone) {\n    var clock;\n\n    if (clockOrZone == null) {\n      clock = Clock.systemDefaultZone();\n    } else if (clockOrZone instanceof ZoneId) {\n      clock = Clock.system(clockOrZone);\n    } else {\n      clock = clockOrZone;\n    }\n\n    return LocalDate.ofInstant(clock.instant(), clock.zone());\n  };\n\n  LocalDate.ofInstant = function ofInstant(instant, zone) {\n    if (zone === void 0) {\n      zone = ZoneId.systemDefault();\n    }\n\n    requireNonNull(instant, 'instant');\n    var offset = zone.rules().offset(instant);\n    var epochSec = instant.epochSecond() + offset.totalSeconds();\n    var epochDay = MathUtil.floorDiv(epochSec, LocalTime.SECONDS_PER_DAY);\n    return LocalDate.ofEpochDay(epochDay);\n  };\n\n  LocalDate.of = function of(year, month, dayOfMonth) {\n    return new LocalDate(year, month, dayOfMonth);\n  };\n\n  LocalDate.ofYearDay = function ofYearDay(year, dayOfYear) {\n    ChronoField.YEAR.checkValidValue(year);\n    var leap = IsoChronology.isLeapYear(year);\n\n    if (dayOfYear === 366 && leap === false) {\n      assert(false, 'Invalid date \\'DayOfYear 366\\' as \\'' + year + '\\' is not a leap year', DateTimeException);\n    }\n\n    var moy = Month.of(Math.floor((dayOfYear - 1) / 31 + 1));\n    var monthEnd = moy.firstDayOfYear(leap) + moy.length(leap) - 1;\n\n    if (dayOfYear > monthEnd) {\n      moy = moy.plus(1);\n    }\n\n    var dom = dayOfYear - moy.firstDayOfYear(leap) + 1;\n    return new LocalDate(year, moy.value(), dom);\n  };\n\n  LocalDate.ofEpochDay = function ofEpochDay(epochDay) {\n    if (epochDay === void 0) {\n      epochDay = 0;\n    }\n\n    var adjust, adjustCycles, doyEst, yearEst, zeroDay;\n    zeroDay = epochDay + DAYS_0000_TO_1970;\n    zeroDay -= 60;\n    adjust = 0;\n\n    if (zeroDay < 0) {\n      adjustCycles = MathUtil.intDiv(zeroDay + 1, DAYS_PER_CYCLE) - 1;\n      adjust = adjustCycles * 400;\n      zeroDay += -adjustCycles * DAYS_PER_CYCLE;\n    }\n\n    yearEst = MathUtil.intDiv(400 * zeroDay + 591, DAYS_PER_CYCLE);\n    doyEst = zeroDay - (365 * yearEst + MathUtil.intDiv(yearEst, 4) - MathUtil.intDiv(yearEst, 100) + MathUtil.intDiv(yearEst, 400));\n\n    if (doyEst < 0) {\n      yearEst--;\n      doyEst = zeroDay - (365 * yearEst + MathUtil.intDiv(yearEst, 4) - MathUtil.intDiv(yearEst, 100) + MathUtil.intDiv(yearEst, 400));\n    }\n\n    yearEst += adjust;\n    var marchDoy0 = doyEst;\n    var marchMonth0 = MathUtil.intDiv(marchDoy0 * 5 + 2, 153);\n    var month = (marchMonth0 + 2) % 12 + 1;\n    var dom = marchDoy0 - MathUtil.intDiv(marchMonth0 * 306 + 5, 10) + 1;\n    yearEst += MathUtil.intDiv(marchMonth0, 10);\n    var year = yearEst;\n    return new LocalDate(year, month, dom);\n  };\n\n  LocalDate.from = function from(temporal) {\n    requireNonNull(temporal, 'temporal');\n    var date = temporal.query(TemporalQueries.localDate());\n\n    if (date == null) {\n      throw new DateTimeException(\"Unable to obtain LocalDate from TemporalAccessor: \" + temporal + \", type \" + (temporal.constructor != null ? temporal.constructor.name : ''));\n    }\n\n    return date;\n  };\n\n  LocalDate.parse = function parse(text, formatter) {\n    if (formatter === void 0) {\n      formatter = DateTimeFormatter.ISO_LOCAL_DATE;\n    }\n\n    assert(formatter != null, 'formatter', NullPointerException);\n    return formatter.parse(text, LocalDate.FROM);\n  };\n\n  LocalDate._resolvePreviousValid = function _resolvePreviousValid(year, month, day) {\n    switch (month) {\n      case 2:\n        day = Math.min(day, IsoChronology.isLeapYear(year) ? 29 : 28);\n        break;\n\n      case 4:\n      case 6:\n      case 9:\n      case 11:\n        day = Math.min(day, 30);\n        break;\n    }\n\n    return LocalDate.of(year, month, day);\n  };\n\n  function LocalDate(year, month, dayOfMonth) {\n    var _this;\n\n    _this = _ChronoLocalDate.call(this) || this;\n    requireNonNull(year, 'year');\n    requireNonNull(month, 'month');\n    requireNonNull(dayOfMonth, 'dayOfMonth');\n\n    if (month instanceof Month) {\n      month = month.value();\n    }\n\n    _this._year = MathUtil.safeToInt(year);\n    _this._month = MathUtil.safeToInt(month);\n    _this._day = MathUtil.safeToInt(dayOfMonth);\n\n    LocalDate._validate(_this._year, _this._month, _this._day);\n\n    return _this;\n  }\n\n  LocalDate._validate = function _validate(year, month, dayOfMonth) {\n    var dom;\n    ChronoField.YEAR.checkValidValue(year);\n    ChronoField.MONTH_OF_YEAR.checkValidValue(month);\n    ChronoField.DAY_OF_MONTH.checkValidValue(dayOfMonth);\n\n    if (dayOfMonth > 28) {\n      dom = 31;\n\n      switch (month) {\n        case 2:\n          dom = IsoChronology.isLeapYear(year) ? 29 : 28;\n          break;\n\n        case 4:\n        case 6:\n        case 9:\n        case 11:\n          dom = 30;\n      }\n\n      if (dayOfMonth > dom) {\n        if (dayOfMonth === 29) {\n          assert(false, 'Invalid date \\'February 29\\' as \\'' + year + '\\' is not a leap year', DateTimeException);\n        } else {\n          assert(false, 'Invalid date \\'' + year + '\\' \\'' + month + '\\' \\'' + dayOfMonth + '\\'', DateTimeException);\n        }\n      }\n    }\n  };\n\n  var _proto = LocalDate.prototype;\n\n  _proto.isSupported = function isSupported(field) {\n    return _ChronoLocalDate.prototype.isSupported.call(this, field);\n  };\n\n  _proto.range = function range(field) {\n    if (field instanceof ChronoField) {\n      if (field.isDateBased()) {\n        switch (field) {\n          case ChronoField.DAY_OF_MONTH:\n            return ValueRange.of(1, this.lengthOfMonth());\n\n          case ChronoField.DAY_OF_YEAR:\n            return ValueRange.of(1, this.lengthOfYear());\n\n          case ChronoField.ALIGNED_WEEK_OF_MONTH:\n            return ValueRange.of(1, this.month() === Month.FEBRUARY && this.isLeapYear() === false ? 4 : 5);\n\n          case ChronoField.YEAR_OF_ERA:\n            return this._year <= 0 ? ValueRange.of(1, Year.MAX_VALUE + 1) : ValueRange.of(1, Year.MAX_VALUE);\n        }\n\n        return field.range();\n      }\n\n      throw new UnsupportedTemporalTypeException('Unsupported field: ' + field);\n    }\n\n    return field.rangeRefinedBy(this);\n  };\n\n  _proto.get = function get(field) {\n    return this.getLong(field);\n  };\n\n  _proto.getLong = function getLong(field) {\n    assert(field != null, '', NullPointerException);\n\n    if (field instanceof ChronoField) {\n      return this._get0(field);\n    }\n\n    return field.getFrom(this);\n  };\n\n  _proto._get0 = function _get0(field) {\n    switch (field) {\n      case ChronoField.DAY_OF_WEEK:\n        return this.dayOfWeek().value();\n\n      case ChronoField.ALIGNED_DAY_OF_WEEK_IN_MONTH:\n        return MathUtil.intMod(this._day - 1, 7) + 1;\n\n      case ChronoField.ALIGNED_DAY_OF_WEEK_IN_YEAR:\n        return MathUtil.intMod(this.dayOfYear() - 1, 7) + 1;\n\n      case ChronoField.DAY_OF_MONTH:\n        return this._day;\n\n      case ChronoField.DAY_OF_YEAR:\n        return this.dayOfYear();\n\n      case ChronoField.EPOCH_DAY:\n        return this.toEpochDay();\n\n      case ChronoField.ALIGNED_WEEK_OF_MONTH:\n        return MathUtil.intDiv(this._day - 1, 7) + 1;\n\n      case ChronoField.ALIGNED_WEEK_OF_YEAR:\n        return MathUtil.intDiv(this.dayOfYear() - 1, 7) + 1;\n\n      case ChronoField.MONTH_OF_YEAR:\n        return this._month;\n\n      case ChronoField.PROLEPTIC_MONTH:\n        return this._prolepticMonth();\n\n      case ChronoField.YEAR_OF_ERA:\n        return this._year >= 1 ? this._year : 1 - this._year;\n\n      case ChronoField.YEAR:\n        return this._year;\n\n      case ChronoField.ERA:\n        return this._year >= 1 ? 1 : 0;\n    }\n\n    throw new UnsupportedTemporalTypeException('Unsupported field: ' + field);\n  };\n\n  _proto._prolepticMonth = function _prolepticMonth() {\n    return this._year * 12 + (this._month - 1);\n  };\n\n  _proto.chronology = function chronology() {\n    return IsoChronology.INSTANCE;\n  };\n\n  _proto.year = function year() {\n    return this._year;\n  };\n\n  _proto.monthValue = function monthValue() {\n    return this._month;\n  };\n\n  _proto.month = function month() {\n    return Month.of(this._month);\n  };\n\n  _proto.dayOfMonth = function dayOfMonth() {\n    return this._day;\n  };\n\n  _proto.dayOfYear = function dayOfYear() {\n    return this.month().firstDayOfYear(this.isLeapYear()) + this._day - 1;\n  };\n\n  _proto.dayOfWeek = function dayOfWeek() {\n    var dow0 = MathUtil.floorMod(this.toEpochDay() + 3, 7);\n    return DayOfWeek.of(dow0 + 1);\n  };\n\n  _proto.isLeapYear = function isLeapYear() {\n    return IsoChronology.isLeapYear(this._year);\n  };\n\n  _proto.lengthOfMonth = function lengthOfMonth() {\n    switch (this._month) {\n      case 2:\n        return this.isLeapYear() ? 29 : 28;\n\n      case 4:\n      case 6:\n      case 9:\n      case 11:\n        return 30;\n\n      default:\n        return 31;\n    }\n  };\n\n  _proto.lengthOfYear = function lengthOfYear() {\n    return this.isLeapYear() ? 366 : 365;\n  };\n\n  _proto.withAdjuster = function withAdjuster(adjuster) {\n    requireNonNull(adjuster, 'adjuster');\n\n    if (adjuster instanceof LocalDate) {\n      return adjuster;\n    }\n\n    assert(typeof adjuster.adjustInto === 'function', 'adjuster', IllegalArgumentException);\n    return adjuster.adjustInto(this);\n  };\n\n  _proto.withFieldValue = function withFieldValue(field, newValue) {\n    assert(field != null, 'field', NullPointerException);\n\n    if (field instanceof ChronoField) {\n      var f = field;\n      f.checkValidValue(newValue);\n\n      switch (f) {\n        case ChronoField.DAY_OF_WEEK:\n          return this.plusDays(newValue - this.dayOfWeek().value());\n\n        case ChronoField.ALIGNED_DAY_OF_WEEK_IN_MONTH:\n          return this.plusDays(newValue - this.getLong(ChronoField.ALIGNED_DAY_OF_WEEK_IN_MONTH));\n\n        case ChronoField.ALIGNED_DAY_OF_WEEK_IN_YEAR:\n          return this.plusDays(newValue - this.getLong(ChronoField.ALIGNED_DAY_OF_WEEK_IN_YEAR));\n\n        case ChronoField.DAY_OF_MONTH:\n          return this.withDayOfMonth(newValue);\n\n        case ChronoField.DAY_OF_YEAR:\n          return this.withDayOfYear(newValue);\n\n        case ChronoField.EPOCH_DAY:\n          return LocalDate.ofEpochDay(newValue);\n\n        case ChronoField.ALIGNED_WEEK_OF_MONTH:\n          return this.plusWeeks(newValue - this.getLong(ChronoField.ALIGNED_WEEK_OF_MONTH));\n\n        case ChronoField.ALIGNED_WEEK_OF_YEAR:\n          return this.plusWeeks(newValue - this.getLong(ChronoField.ALIGNED_WEEK_OF_YEAR));\n\n        case ChronoField.MONTH_OF_YEAR:\n          return this.withMonth(newValue);\n\n        case ChronoField.PROLEPTIC_MONTH:\n          return this.plusMonths(newValue - this.getLong(ChronoField.PROLEPTIC_MONTH));\n\n        case ChronoField.YEAR_OF_ERA:\n          return this.withYear(this._year >= 1 ? newValue : 1 - newValue);\n\n        case ChronoField.YEAR:\n          return this.withYear(newValue);\n\n        case ChronoField.ERA:\n          return this.getLong(ChronoField.ERA) === newValue ? this : this.withYear(1 - this._year);\n      }\n\n      throw new UnsupportedTemporalTypeException('Unsupported field: ' + field);\n    }\n\n    return field.adjustInto(this, newValue);\n  };\n\n  _proto.withYear = function withYear(year) {\n    if (this._year === year) {\n      return this;\n    }\n\n    ChronoField.YEAR.checkValidValue(year);\n    return LocalDate._resolvePreviousValid(year, this._month, this._day);\n  };\n\n  _proto.withMonth = function withMonth(month) {\n    var m = month instanceof Month ? month.value() : month;\n\n    if (this._month === m) {\n      return this;\n    }\n\n    ChronoField.MONTH_OF_YEAR.checkValidValue(m);\n    return LocalDate._resolvePreviousValid(this._year, m, this._day);\n  };\n\n  _proto.withDayOfMonth = function withDayOfMonth(dayOfMonth) {\n    if (this._day === dayOfMonth) {\n      return this;\n    }\n\n    return LocalDate.of(this._year, this._month, dayOfMonth);\n  };\n\n  _proto.withDayOfYear = function withDayOfYear(dayOfYear) {\n    if (this.dayOfYear() === dayOfYear) {\n      return this;\n    }\n\n    return LocalDate.ofYearDay(this._year, dayOfYear);\n  };\n\n  _proto.plusAmount = function plusAmount(amount) {\n    requireNonNull(amount, 'amount');\n    return amount.addTo(this);\n  };\n\n  _proto.plusAmountUnit = function plusAmountUnit(amountToAdd, unit) {\n    requireNonNull(amountToAdd, 'amountToAdd');\n    requireNonNull(unit, 'unit');\n\n    if (unit instanceof ChronoUnit) {\n      switch (unit) {\n        case ChronoUnit.DAYS:\n          return this.plusDays(amountToAdd);\n\n        case ChronoUnit.WEEKS:\n          return this.plusWeeks(amountToAdd);\n\n        case ChronoUnit.MONTHS:\n          return this.plusMonths(amountToAdd);\n\n        case ChronoUnit.YEARS:\n          return this.plusYears(amountToAdd);\n\n        case ChronoUnit.DECADES:\n          return this.plusYears(MathUtil.safeMultiply(amountToAdd, 10));\n\n        case ChronoUnit.CENTURIES:\n          return this.plusYears(MathUtil.safeMultiply(amountToAdd, 100));\n\n        case ChronoUnit.MILLENNIA:\n          return this.plusYears(MathUtil.safeMultiply(amountToAdd, 1000));\n\n        case ChronoUnit.ERAS:\n          return this.with(ChronoField.ERA, MathUtil.safeAdd(this.getLong(ChronoField.ERA), amountToAdd));\n      }\n\n      throw new UnsupportedTemporalTypeException('Unsupported unit: ' + unit);\n    }\n\n    return unit.addTo(this, amountToAdd);\n  };\n\n  _proto.plusYears = function plusYears(yearsToAdd) {\n    if (yearsToAdd === 0) {\n      return this;\n    }\n\n    var newYear = ChronoField.YEAR.checkValidIntValue(this._year + yearsToAdd);\n    return LocalDate._resolvePreviousValid(newYear, this._month, this._day);\n  };\n\n  _proto.plusMonths = function plusMonths(monthsToAdd) {\n    if (monthsToAdd === 0) {\n      return this;\n    }\n\n    var monthCount = this._year * 12 + (this._month - 1);\n    var calcMonths = monthCount + monthsToAdd;\n    var newYear = ChronoField.YEAR.checkValidIntValue(MathUtil.floorDiv(calcMonths, 12));\n    var newMonth = MathUtil.floorMod(calcMonths, 12) + 1;\n    return LocalDate._resolvePreviousValid(newYear, newMonth, this._day);\n  };\n\n  _proto.plusWeeks = function plusWeeks(weeksToAdd) {\n    return this.plusDays(MathUtil.safeMultiply(weeksToAdd, 7));\n  };\n\n  _proto.plusDays = function plusDays(daysToAdd) {\n    if (daysToAdd === 0) {\n      return this;\n    }\n\n    var mjDay = MathUtil.safeAdd(this.toEpochDay(), daysToAdd);\n    return LocalDate.ofEpochDay(mjDay);\n  };\n\n  _proto.minusAmount = function minusAmount(amount) {\n    requireNonNull(amount, 'amount');\n    return amount.subtractFrom(this);\n  };\n\n  _proto.minusAmountUnit = function minusAmountUnit(amountToSubtract, unit) {\n    requireNonNull(amountToSubtract, 'amountToSubtract');\n    requireNonNull(unit, 'unit');\n    return this.plusAmountUnit(-1 * amountToSubtract, unit);\n  };\n\n  _proto.minusYears = function minusYears(yearsToSubtract) {\n    return this.plusYears(yearsToSubtract * -1);\n  };\n\n  _proto.minusMonths = function minusMonths(monthsToSubtract) {\n    return this.plusMonths(monthsToSubtract * -1);\n  };\n\n  _proto.minusWeeks = function minusWeeks(weeksToSubtract) {\n    return this.plusWeeks(weeksToSubtract * -1);\n  };\n\n  _proto.minusDays = function minusDays(daysToSubtract) {\n    return this.plusDays(daysToSubtract * -1);\n  };\n\n  _proto.query = function query(_query) {\n    requireNonNull(_query, 'query');\n\n    if (_query === TemporalQueries.localDate()) {\n      return this;\n    }\n\n    return _ChronoLocalDate.prototype.query.call(this, _query);\n  };\n\n  _proto.adjustInto = function adjustInto(temporal) {\n    return _ChronoLocalDate.prototype.adjustInto.call(this, temporal);\n  };\n\n  _proto.until = function until(p1, p2) {\n    if (arguments.length < 2) {\n      return this.until1(p1);\n    } else {\n      return this.until2(p1, p2);\n    }\n  };\n\n  _proto.until2 = function until2(endExclusive, unit) {\n    var end = LocalDate.from(endExclusive);\n\n    if (unit instanceof ChronoUnit) {\n      switch (unit) {\n        case ChronoUnit.DAYS:\n          return this.daysUntil(end);\n\n        case ChronoUnit.WEEKS:\n          return MathUtil.intDiv(this.daysUntil(end), 7);\n\n        case ChronoUnit.MONTHS:\n          return this._monthsUntil(end);\n\n        case ChronoUnit.YEARS:\n          return MathUtil.intDiv(this._monthsUntil(end), 12);\n\n        case ChronoUnit.DECADES:\n          return MathUtil.intDiv(this._monthsUntil(end), 120);\n\n        case ChronoUnit.CENTURIES:\n          return MathUtil.intDiv(this._monthsUntil(end), 1200);\n\n        case ChronoUnit.MILLENNIA:\n          return MathUtil.intDiv(this._monthsUntil(end), 12000);\n\n        case ChronoUnit.ERAS:\n          return end.getLong(ChronoField.ERA) - this.getLong(ChronoField.ERA);\n      }\n\n      throw new UnsupportedTemporalTypeException('Unsupported unit: ' + unit);\n    }\n\n    return unit.between(this, end);\n  };\n\n  _proto.daysUntil = function daysUntil(end) {\n    return end.toEpochDay() - this.toEpochDay();\n  };\n\n  _proto._monthsUntil = function _monthsUntil(end) {\n    var packed1 = this._prolepticMonth() * 32 + this.dayOfMonth();\n    var packed2 = end._prolepticMonth() * 32 + end.dayOfMonth();\n    return MathUtil.intDiv(packed2 - packed1, 32);\n  };\n\n  _proto.until1 = function until1(endDate) {\n    var end = LocalDate.from(endDate);\n\n    var totalMonths = end._prolepticMonth() - this._prolepticMonth();\n\n    var days = end._day - this._day;\n\n    if (totalMonths > 0 && days < 0) {\n      totalMonths--;\n      var calcDate = this.plusMonths(totalMonths);\n      days = end.toEpochDay() - calcDate.toEpochDay();\n    } else if (totalMonths < 0 && days > 0) {\n      totalMonths++;\n      days -= end.lengthOfMonth();\n    }\n\n    var years = MathUtil.intDiv(totalMonths, 12);\n    var months = MathUtil.intMod(totalMonths, 12);\n    return Period.of(years, months, days);\n  };\n\n  _proto.atTime = function atTime() {\n    if (arguments.length === 1) {\n      return this.atTime1.apply(this, arguments);\n    } else {\n      return this.atTime4.apply(this, arguments);\n    }\n  };\n\n  _proto.atTime1 = function atTime1(time) {\n    requireNonNull(time, 'time');\n\n    if (time instanceof LocalTime) {\n      return LocalDateTime.of(this, time);\n    } else if (time instanceof OffsetTime) {\n      return this._atTimeOffsetTime(time);\n    } else {\n      throw new IllegalArgumentException('time must be an instance of LocalTime or OffsetTime' + (time && time.constructor && time.constructor.name ? ', but is ' + time.constructor.name : ''));\n    }\n  };\n\n  _proto.atTime4 = function atTime4(hour, minute, second, nanoOfSecond) {\n    if (second === void 0) {\n      second = 0;\n    }\n\n    if (nanoOfSecond === void 0) {\n      nanoOfSecond = 0;\n    }\n\n    return this.atTime1(LocalTime.of(hour, minute, second, nanoOfSecond));\n  };\n\n  _proto._atTimeOffsetTime = function _atTimeOffsetTime(time) {\n    return OffsetDateTime.of(LocalDateTime.of(this, time.toLocalTime()), time.offset());\n  };\n\n  _proto.atStartOfDay = function atStartOfDay(zone) {\n    if (zone != null) {\n      return this.atStartOfDayWithZone(zone);\n    } else {\n      return LocalDateTime.of(this, LocalTime.MIDNIGHT);\n    }\n  };\n\n  _proto.atStartOfDayWithZone = function atStartOfDayWithZone(zone) {\n    requireNonNull(zone, 'zone');\n    var ldt = this.atTime(LocalTime.MIDNIGHT);\n\n    if (zone instanceof ZoneOffset === false) {\n      var trans = zone.rules().transition(ldt);\n\n      if (trans != null && trans.isGap()) {\n        ldt = trans.dateTimeAfter();\n      }\n    }\n\n    return ZonedDateTime.of(ldt, zone);\n  };\n\n  _proto.toEpochDay = function toEpochDay() {\n    var y = this._year;\n    var m = this._month;\n    var total = 0;\n    total += 365 * y;\n\n    if (y >= 0) {\n      total += MathUtil.intDiv(y + 3, 4) - MathUtil.intDiv(y + 99, 100) + MathUtil.intDiv(y + 399, 400);\n    } else {\n      total -= MathUtil.intDiv(y, -4) - MathUtil.intDiv(y, -100) + MathUtil.intDiv(y, -400);\n    }\n\n    total += MathUtil.intDiv(367 * m - 362, 12);\n    total += this.dayOfMonth() - 1;\n\n    if (m > 2) {\n      total--;\n\n      if (!IsoChronology.isLeapYear(y)) {\n        total--;\n      }\n    }\n\n    return total - DAYS_0000_TO_1970;\n  };\n\n  _proto.compareTo = function compareTo(other) {\n    requireNonNull(other, 'other');\n    requireInstance(other, LocalDate, 'other');\n    return this._compareTo0(other);\n  };\n\n  _proto._compareTo0 = function _compareTo0(otherDate) {\n    var cmp = this._year - otherDate._year;\n\n    if (cmp === 0) {\n      cmp = this._month - otherDate._month;\n\n      if (cmp === 0) {\n        cmp = this._day - otherDate._day;\n      }\n    }\n\n    return cmp;\n  };\n\n  _proto.isAfter = function isAfter(other) {\n    return this.compareTo(other) > 0;\n  };\n\n  _proto.isBefore = function isBefore(other) {\n    return this.compareTo(other) < 0;\n  };\n\n  _proto.isEqual = function isEqual(other) {\n    return this.compareTo(other) === 0;\n  };\n\n  _proto.equals = function equals(other) {\n    if (this === other) {\n      return true;\n    }\n\n    if (other instanceof LocalDate) {\n      return this._compareTo0(other) === 0;\n    }\n\n    return false;\n  };\n\n  _proto.hashCode = function hashCode() {\n    var yearValue = this._year;\n    var monthValue = this._month;\n    var dayValue = this._day;\n    return MathUtil.hash(yearValue & 0xFFFFF800 ^ (yearValue << 11) + (monthValue << 6) + dayValue);\n  };\n\n  _proto.toString = function toString() {\n    var dayString, monthString, yearString;\n    var yearValue = this._year;\n    var monthValue = this._month;\n    var dayValue = this._day;\n    var absYear = Math.abs(yearValue);\n\n    if (absYear < 1000) {\n      if (yearValue < 0) {\n        yearString = '-' + ('' + (yearValue - 10000)).slice(-4);\n      } else {\n        yearString = ('' + (yearValue + 10000)).slice(-4);\n      }\n    } else {\n      if (yearValue > 9999) {\n        yearString = '+' + yearValue;\n      } else {\n        yearString = '' + yearValue;\n      }\n    }\n\n    if (monthValue < 10) {\n      monthString = '-0' + monthValue;\n    } else {\n      monthString = '-' + monthValue;\n    }\n\n    if (dayValue < 10) {\n      dayString = '-0' + dayValue;\n    } else {\n      dayString = '-' + dayValue;\n    }\n\n    return yearString + monthString + dayString;\n  };\n\n  _proto.toJSON = function toJSON() {\n    return this.toString();\n  };\n\n  _proto.format = function format(formatter) {\n    requireNonNull(formatter, 'formatter');\n    requireInstance(formatter, DateTimeFormatter, 'formatter');\n    return _ChronoLocalDate.prototype.format.call(this, formatter);\n  };\n\n  return LocalDate;\n}(ChronoLocalDate);\nfunction _init$i() {\n  LocalDate.MIN = LocalDate.of(YearConstants.MIN_VALUE, 1, 1);\n  LocalDate.MAX = LocalDate.of(YearConstants.MAX_VALUE, 12, 31);\n  LocalDate.EPOCH_0 = LocalDate.ofEpochDay(0);\n  LocalDate.FROM = createTemporalQuery('LocalDate.FROM', function (temporal) {\n    return LocalDate.from(temporal);\n  });\n}\n\nvar ChronoLocalDateTime = function (_DefaultInterfaceTemp) {\n  _inheritsLoose(ChronoLocalDateTime, _DefaultInterfaceTemp);\n\n  function ChronoLocalDateTime() {\n    return _DefaultInterfaceTemp.apply(this, arguments) || this;\n  }\n\n  var _proto = ChronoLocalDateTime.prototype;\n\n  _proto.chronology = function chronology() {\n    return this.toLocalDate().chronology();\n  };\n\n  _proto.query = function query(_query) {\n    if (_query === TemporalQueries.chronology()) {\n      return this.chronology();\n    } else if (_query === TemporalQueries.precision()) {\n      return ChronoUnit.NANOS;\n    } else if (_query === TemporalQueries.localDate()) {\n      return LocalDate.ofEpochDay(this.toLocalDate().toEpochDay());\n    } else if (_query === TemporalQueries.localTime()) {\n      return this.toLocalTime();\n    } else if (_query === TemporalQueries.zone() || _query === TemporalQueries.zoneId() || _query === TemporalQueries.offset()) {\n      return null;\n    }\n\n    return _DefaultInterfaceTemp.prototype.query.call(this, _query);\n  };\n\n  _proto.adjustInto = function adjustInto(temporal) {\n    return temporal.with(ChronoField.EPOCH_DAY, this.toLocalDate().toEpochDay()).with(ChronoField.NANO_OF_DAY, this.toLocalTime().toNanoOfDay());\n  };\n\n  _proto.toInstant = function toInstant(offset) {\n    requireInstance(offset, ZoneOffset, 'zoneId');\n    return Instant.ofEpochSecond(this.toEpochSecond(offset), this.toLocalTime().nano());\n  };\n\n  _proto.toEpochSecond = function toEpochSecond(offset) {\n    requireNonNull(offset, 'offset');\n    var epochDay = this.toLocalDate().toEpochDay();\n    var secs = epochDay * 86400 + this.toLocalTime().toSecondOfDay();\n    secs -= offset.totalSeconds();\n    return MathUtil.safeToInt(secs);\n  };\n\n  return ChronoLocalDateTime;\n}(DefaultInterfaceTemporal);\n\nvar LocalDateTime = function (_ChronoLocalDateTime) {\n  _inheritsLoose(LocalDateTime, _ChronoLocalDateTime);\n\n  LocalDateTime.now = function now(clockOrZone) {\n    if (clockOrZone == null) {\n      return LocalDateTime._now(Clock.systemDefaultZone());\n    } else if (clockOrZone instanceof Clock) {\n      return LocalDateTime._now(clockOrZone);\n    } else {\n      return LocalDateTime._now(Clock.system(clockOrZone));\n    }\n  };\n\n  LocalDateTime._now = function _now(clock) {\n    requireNonNull(clock, 'clock');\n    return LocalDateTime.ofInstant(clock.instant(), clock.zone());\n  };\n\n  LocalDateTime._ofEpochMillis = function _ofEpochMillis(epochMilli, offset) {\n    var localSecond = MathUtil.floorDiv(epochMilli, 1000) + offset.totalSeconds();\n    var localEpochDay = MathUtil.floorDiv(localSecond, LocalTime.SECONDS_PER_DAY);\n    var secsOfDay = MathUtil.floorMod(localSecond, LocalTime.SECONDS_PER_DAY);\n    var nanoOfSecond = MathUtil.floorMod(epochMilli, 1000) * 1000000;\n    var date = LocalDate.ofEpochDay(localEpochDay);\n    var time = LocalTime.ofSecondOfDay(secsOfDay, nanoOfSecond);\n    return new LocalDateTime(date, time);\n  };\n\n  LocalDateTime.of = function of() {\n    if (arguments.length <= 2) {\n      return LocalDateTime.ofDateAndTime.apply(this, arguments);\n    } else {\n      return LocalDateTime.ofNumbers.apply(this, arguments);\n    }\n  };\n\n  LocalDateTime.ofNumbers = function ofNumbers(year, month, dayOfMonth, hour, minute, second, nanoOfSecond) {\n    if (hour === void 0) {\n      hour = 0;\n    }\n\n    if (minute === void 0) {\n      minute = 0;\n    }\n\n    if (second === void 0) {\n      second = 0;\n    }\n\n    if (nanoOfSecond === void 0) {\n      nanoOfSecond = 0;\n    }\n\n    var date = LocalDate.of(year, month, dayOfMonth);\n    var time = LocalTime.of(hour, minute, second, nanoOfSecond);\n    return new LocalDateTime(date, time);\n  };\n\n  LocalDateTime.ofDateAndTime = function ofDateAndTime(date, time) {\n    requireNonNull(date, 'date');\n    requireNonNull(time, 'time');\n    return new LocalDateTime(date, time);\n  };\n\n  LocalDateTime.ofInstant = function ofInstant(instant, zone) {\n    if (zone === void 0) {\n      zone = ZoneId.systemDefault();\n    }\n\n    requireNonNull(instant, 'instant');\n    requireInstance(instant, Instant, 'instant');\n    requireNonNull(zone, 'zone');\n    var offset = zone.rules().offset(instant);\n    return LocalDateTime.ofEpochSecond(instant.epochSecond(), instant.nano(), offset);\n  };\n\n  LocalDateTime.ofEpochSecond = function ofEpochSecond(epochSecond, nanoOfSecond, offset) {\n    if (epochSecond === void 0) {\n      epochSecond = 0;\n    }\n\n    if (nanoOfSecond === void 0) {\n      nanoOfSecond = 0;\n    }\n\n    if (arguments.length === 2 && nanoOfSecond instanceof ZoneOffset) {\n      offset = nanoOfSecond;\n      nanoOfSecond = 0;\n    }\n\n    requireNonNull(offset, 'offset');\n    var localSecond = epochSecond + offset.totalSeconds();\n    var localEpochDay = MathUtil.floorDiv(localSecond, LocalTime.SECONDS_PER_DAY);\n    var secsOfDay = MathUtil.floorMod(localSecond, LocalTime.SECONDS_PER_DAY);\n    var date = LocalDate.ofEpochDay(localEpochDay);\n    var time = LocalTime.ofSecondOfDay(secsOfDay, nanoOfSecond);\n    return new LocalDateTime(date, time);\n  };\n\n  LocalDateTime.from = function from(temporal) {\n    requireNonNull(temporal, 'temporal');\n\n    if (temporal instanceof LocalDateTime) {\n      return temporal;\n    } else if (temporal instanceof ZonedDateTime) {\n      return temporal.toLocalDateTime();\n    }\n\n    try {\n      var date = LocalDate.from(temporal);\n      var time = LocalTime.from(temporal);\n      return new LocalDateTime(date, time);\n    } catch (ex) {\n      throw new DateTimeException(\"Unable to obtain LocalDateTime TemporalAccessor: \" + temporal + \", type \" + (temporal.constructor != null ? temporal.constructor.name : ''));\n    }\n  };\n\n  LocalDateTime.parse = function parse(text, formatter) {\n    if (formatter === void 0) {\n      formatter = DateTimeFormatter.ISO_LOCAL_DATE_TIME;\n    }\n\n    requireNonNull(formatter, 'formatter');\n    return formatter.parse(text, LocalDateTime.FROM);\n  };\n\n  function LocalDateTime(date, time) {\n    var _this;\n\n    _this = _ChronoLocalDateTime.call(this) || this;\n    requireInstance(date, LocalDate, 'date');\n    requireInstance(time, LocalTime, 'time');\n    _this._date = date;\n    _this._time = time;\n    return _this;\n  }\n\n  var _proto = LocalDateTime.prototype;\n\n  _proto._withDateTime = function _withDateTime(newDate, newTime) {\n    if (this._date.equals(newDate) && this._time.equals(newTime)) {\n      return this;\n    }\n\n    return new LocalDateTime(newDate, newTime);\n  };\n\n  _proto.isSupported = function isSupported(fieldOrUnit) {\n    if (fieldOrUnit instanceof ChronoField) {\n      return fieldOrUnit.isDateBased() || fieldOrUnit.isTimeBased();\n    } else if (fieldOrUnit instanceof ChronoUnit) {\n      return fieldOrUnit.isDateBased() || fieldOrUnit.isTimeBased();\n    }\n\n    return fieldOrUnit != null && fieldOrUnit.isSupportedBy(this);\n  };\n\n  _proto.range = function range(field) {\n    if (field instanceof ChronoField) {\n      return field.isTimeBased() ? this._time.range(field) : this._date.range(field);\n    }\n\n    return field.rangeRefinedBy(this);\n  };\n\n  _proto.get = function get(field) {\n    if (field instanceof ChronoField) {\n      return field.isTimeBased() ? this._time.get(field) : this._date.get(field);\n    }\n\n    return _ChronoLocalDateTime.prototype.get.call(this, field);\n  };\n\n  _proto.getLong = function getLong(field) {\n    requireNonNull(field, 'field');\n\n    if (field instanceof ChronoField) {\n      return field.isTimeBased() ? this._time.getLong(field) : this._date.getLong(field);\n    }\n\n    return field.getFrom(this);\n  };\n\n  _proto.year = function year() {\n    return this._date.year();\n  };\n\n  _proto.monthValue = function monthValue() {\n    return this._date.monthValue();\n  };\n\n  _proto.month = function month() {\n    return this._date.month();\n  };\n\n  _proto.dayOfMonth = function dayOfMonth() {\n    return this._date.dayOfMonth();\n  };\n\n  _proto.dayOfYear = function dayOfYear() {\n    return this._date.dayOfYear();\n  };\n\n  _proto.dayOfWeek = function dayOfWeek() {\n    return this._date.dayOfWeek();\n  };\n\n  _proto.hour = function hour() {\n    return this._time.hour();\n  };\n\n  _proto.minute = function minute() {\n    return this._time.minute();\n  };\n\n  _proto.second = function second() {\n    return this._time.second();\n  };\n\n  _proto.nano = function nano() {\n    return this._time.nano();\n  };\n\n  _proto.withAdjuster = function withAdjuster(adjuster) {\n    requireNonNull(adjuster, 'adjuster');\n\n    if (adjuster instanceof LocalDate) {\n      return this._withDateTime(adjuster, this._time);\n    } else if (adjuster instanceof LocalTime) {\n      return this._withDateTime(this._date, adjuster);\n    } else if (adjuster instanceof LocalDateTime) {\n      return adjuster;\n    }\n\n    assert(typeof adjuster.adjustInto === 'function', 'adjuster', IllegalArgumentException);\n    return adjuster.adjustInto(this);\n  };\n\n  _proto.withFieldValue = function withFieldValue(field, newValue) {\n    requireNonNull(field, 'field');\n\n    if (field instanceof ChronoField) {\n      if (field.isTimeBased()) {\n        return this._withDateTime(this._date, this._time.with(field, newValue));\n      } else {\n        return this._withDateTime(this._date.with(field, newValue), this._time);\n      }\n    }\n\n    return field.adjustInto(this, newValue);\n  };\n\n  _proto.withYear = function withYear(year) {\n    return this._withDateTime(this._date.withYear(year), this._time);\n  };\n\n  _proto.withMonth = function withMonth(month) {\n    return this._withDateTime(this._date.withMonth(month), this._time);\n  };\n\n  _proto.withDayOfMonth = function withDayOfMonth(dayOfMonth) {\n    return this._withDateTime(this._date.withDayOfMonth(dayOfMonth), this._time);\n  };\n\n  _proto.withDayOfYear = function withDayOfYear(dayOfYear) {\n    return this._withDateTime(this._date.withDayOfYear(dayOfYear), this._time);\n  };\n\n  _proto.withHour = function withHour(hour) {\n    var newTime = this._time.withHour(hour);\n\n    return this._withDateTime(this._date, newTime);\n  };\n\n  _proto.withMinute = function withMinute(minute) {\n    var newTime = this._time.withMinute(minute);\n\n    return this._withDateTime(this._date, newTime);\n  };\n\n  _proto.withSecond = function withSecond(second) {\n    var newTime = this._time.withSecond(second);\n\n    return this._withDateTime(this._date, newTime);\n  };\n\n  _proto.withNano = function withNano(nanoOfSecond) {\n    var newTime = this._time.withNano(nanoOfSecond);\n\n    return this._withDateTime(this._date, newTime);\n  };\n\n  _proto.truncatedTo = function truncatedTo(unit) {\n    return this._withDateTime(this._date, this._time.truncatedTo(unit));\n  };\n\n  _proto.plusAmount = function plusAmount(amount) {\n    requireNonNull(amount, 'amount');\n    return amount.addTo(this);\n  };\n\n  _proto.plusAmountUnit = function plusAmountUnit(amountToAdd, unit) {\n    requireNonNull(unit, 'unit');\n\n    if (unit instanceof ChronoUnit) {\n      switch (unit) {\n        case ChronoUnit.NANOS:\n          return this.plusNanos(amountToAdd);\n\n        case ChronoUnit.MICROS:\n          return this.plusDays(MathUtil.intDiv(amountToAdd, LocalTime.MICROS_PER_DAY)).plusNanos(MathUtil.intMod(amountToAdd, LocalTime.MICROS_PER_DAY) * 1000);\n\n        case ChronoUnit.MILLIS:\n          return this.plusDays(MathUtil.intDiv(amountToAdd, LocalTime.MILLIS_PER_DAY)).plusNanos(MathUtil.intMod(amountToAdd, LocalTime.MILLIS_PER_DAY) * 1000000);\n\n        case ChronoUnit.SECONDS:\n          return this.plusSeconds(amountToAdd);\n\n        case ChronoUnit.MINUTES:\n          return this.plusMinutes(amountToAdd);\n\n        case ChronoUnit.HOURS:\n          return this.plusHours(amountToAdd);\n\n        case ChronoUnit.HALF_DAYS:\n          return this.plusDays(MathUtil.intDiv(amountToAdd, 256)).plusHours(MathUtil.intMod(amountToAdd, 256) * 12);\n      }\n\n      return this._withDateTime(this._date.plus(amountToAdd, unit), this._time);\n    }\n\n    return unit.addTo(this, amountToAdd);\n  };\n\n  _proto.plusYears = function plusYears(years) {\n    var newDate = this._date.plusYears(years);\n\n    return this._withDateTime(newDate, this._time);\n  };\n\n  _proto.plusMonths = function plusMonths(months) {\n    var newDate = this._date.plusMonths(months);\n\n    return this._withDateTime(newDate, this._time);\n  };\n\n  _proto.plusWeeks = function plusWeeks(weeks) {\n    var newDate = this._date.plusWeeks(weeks);\n\n    return this._withDateTime(newDate, this._time);\n  };\n\n  _proto.plusDays = function plusDays(days) {\n    var newDate = this._date.plusDays(days);\n\n    return this._withDateTime(newDate, this._time);\n  };\n\n  _proto.plusHours = function plusHours(hours) {\n    return this._plusWithOverflow(this._date, hours, 0, 0, 0, 1);\n  };\n\n  _proto.plusMinutes = function plusMinutes(minutes) {\n    return this._plusWithOverflow(this._date, 0, minutes, 0, 0, 1);\n  };\n\n  _proto.plusSeconds = function plusSeconds(seconds) {\n    return this._plusWithOverflow(this._date, 0, 0, seconds, 0, 1);\n  };\n\n  _proto.plusNanos = function plusNanos(nanos) {\n    return this._plusWithOverflow(this._date, 0, 0, 0, nanos, 1);\n  };\n\n  _proto.minusAmount = function minusAmount(amount) {\n    requireNonNull(amount, 'amount');\n    return amount.subtractFrom(this);\n  };\n\n  _proto.minusAmountUnit = function minusAmountUnit(amountToSubtract, unit) {\n    requireNonNull(unit, 'unit');\n    return this.plusAmountUnit(-1 * amountToSubtract, unit);\n  };\n\n  _proto.minusYears = function minusYears(years) {\n    return this.plusYears(-1 * years);\n  };\n\n  _proto.minusMonths = function minusMonths(months) {\n    return this.plusMonths(-1 * months);\n  };\n\n  _proto.minusWeeks = function minusWeeks(weeks) {\n    return this.plusWeeks(-1 * weeks);\n  };\n\n  _proto.minusDays = function minusDays(days) {\n    return this.plusDays(-1 * days);\n  };\n\n  _proto.minusHours = function minusHours(hours) {\n    return this._plusWithOverflow(this._date, hours, 0, 0, 0, -1);\n  };\n\n  _proto.minusMinutes = function minusMinutes(minutes) {\n    return this._plusWithOverflow(this._date, 0, minutes, 0, 0, -1);\n  };\n\n  _proto.minusSeconds = function minusSeconds(seconds) {\n    return this._plusWithOverflow(this._date, 0, 0, seconds, 0, -1);\n  };\n\n  _proto.minusNanos = function minusNanos(nanos) {\n    return this._plusWithOverflow(this._date, 0, 0, 0, nanos, -1);\n  };\n\n  _proto._plusWithOverflow = function _plusWithOverflow(newDate, hours, minutes, seconds, nanos, sign) {\n    if (hours === 0 && minutes === 0 && seconds === 0 && nanos === 0) {\n      return this._withDateTime(newDate, this._time);\n    }\n\n    var totDays = MathUtil.intDiv(nanos, LocalTime.NANOS_PER_DAY) + MathUtil.intDiv(seconds, LocalTime.SECONDS_PER_DAY) + MathUtil.intDiv(minutes, LocalTime.MINUTES_PER_DAY) + MathUtil.intDiv(hours, LocalTime.HOURS_PER_DAY);\n    totDays *= sign;\n    var totNanos = MathUtil.intMod(nanos, LocalTime.NANOS_PER_DAY) + MathUtil.intMod(seconds, LocalTime.SECONDS_PER_DAY) * LocalTime.NANOS_PER_SECOND + MathUtil.intMod(minutes, LocalTime.MINUTES_PER_DAY) * LocalTime.NANOS_PER_MINUTE + MathUtil.intMod(hours, LocalTime.HOURS_PER_DAY) * LocalTime.NANOS_PER_HOUR;\n\n    var curNoD = this._time.toNanoOfDay();\n\n    totNanos = totNanos * sign + curNoD;\n    totDays += MathUtil.floorDiv(totNanos, LocalTime.NANOS_PER_DAY);\n    var newNoD = MathUtil.floorMod(totNanos, LocalTime.NANOS_PER_DAY);\n    var newTime = newNoD === curNoD ? this._time : LocalTime.ofNanoOfDay(newNoD);\n    return this._withDateTime(newDate.plusDays(totDays), newTime);\n  };\n\n  _proto.query = function query(_query) {\n    requireNonNull(_query, 'query');\n\n    if (_query === TemporalQueries.localDate()) {\n      return this.toLocalDate();\n    }\n\n    return _ChronoLocalDateTime.prototype.query.call(this, _query);\n  };\n\n  _proto.adjustInto = function adjustInto(temporal) {\n    return _ChronoLocalDateTime.prototype.adjustInto.call(this, temporal);\n  };\n\n  _proto.until = function until(endExclusive, unit) {\n    requireNonNull(endExclusive, 'endExclusive');\n    requireNonNull(unit, 'unit');\n    var end = LocalDateTime.from(endExclusive);\n\n    if (unit instanceof ChronoUnit) {\n      if (unit.isTimeBased()) {\n        var daysUntil = this._date.daysUntil(end._date);\n\n        var timeUntil = end._time.toNanoOfDay() - this._time.toNanoOfDay();\n\n        if (daysUntil > 0 && timeUntil < 0) {\n          daysUntil--;\n          timeUntil += LocalTime.NANOS_PER_DAY;\n        } else if (daysUntil < 0 && timeUntil > 0) {\n          daysUntil++;\n          timeUntil -= LocalTime.NANOS_PER_DAY;\n        }\n\n        var amount = daysUntil;\n\n        switch (unit) {\n          case ChronoUnit.NANOS:\n            amount = MathUtil.safeMultiply(amount, LocalTime.NANOS_PER_DAY);\n            return MathUtil.safeAdd(amount, timeUntil);\n\n          case ChronoUnit.MICROS:\n            amount = MathUtil.safeMultiply(amount, LocalTime.MICROS_PER_DAY);\n            return MathUtil.safeAdd(amount, MathUtil.intDiv(timeUntil, 1000));\n\n          case ChronoUnit.MILLIS:\n            amount = MathUtil.safeMultiply(amount, LocalTime.MILLIS_PER_DAY);\n            return MathUtil.safeAdd(amount, MathUtil.intDiv(timeUntil, 1000000));\n\n          case ChronoUnit.SECONDS:\n            amount = MathUtil.safeMultiply(amount, LocalTime.SECONDS_PER_DAY);\n            return MathUtil.safeAdd(amount, MathUtil.intDiv(timeUntil, LocalTime.NANOS_PER_SECOND));\n\n          case ChronoUnit.MINUTES:\n            amount = MathUtil.safeMultiply(amount, LocalTime.MINUTES_PER_DAY);\n            return MathUtil.safeAdd(amount, MathUtil.intDiv(timeUntil, LocalTime.NANOS_PER_MINUTE));\n\n          case ChronoUnit.HOURS:\n            amount = MathUtil.safeMultiply(amount, LocalTime.HOURS_PER_DAY);\n            return MathUtil.safeAdd(amount, MathUtil.intDiv(timeUntil, LocalTime.NANOS_PER_HOUR));\n\n          case ChronoUnit.HALF_DAYS:\n            amount = MathUtil.safeMultiply(amount, 2);\n            return MathUtil.safeAdd(amount, MathUtil.intDiv(timeUntil, LocalTime.NANOS_PER_HOUR * 12));\n        }\n\n        throw new UnsupportedTemporalTypeException('Unsupported unit: ' + unit);\n      }\n\n      var endDate = end._date;\n      var endTime = end._time;\n\n      if (endDate.isAfter(this._date) && endTime.isBefore(this._time)) {\n        endDate = endDate.minusDays(1);\n      } else if (endDate.isBefore(this._date) && endTime.isAfter(this._time)) {\n        endDate = endDate.plusDays(1);\n      }\n\n      return this._date.until(endDate, unit);\n    }\n\n    return unit.between(this, end);\n  };\n\n  _proto.atOffset = function atOffset(offset) {\n    return OffsetDateTime.of(this, offset);\n  };\n\n  _proto.atZone = function atZone(zone) {\n    return ZonedDateTime.of(this, zone);\n  };\n\n  _proto.toLocalDate = function toLocalDate() {\n    return this._date;\n  };\n\n  _proto.toLocalTime = function toLocalTime() {\n    return this._time;\n  };\n\n  _proto.compareTo = function compareTo(other) {\n    requireNonNull(other, 'other');\n    requireInstance(other, LocalDateTime, 'other');\n    return this._compareTo0(other);\n  };\n\n  _proto._compareTo0 = function _compareTo0(other) {\n    var cmp = this._date.compareTo(other.toLocalDate());\n\n    if (cmp === 0) {\n      cmp = this._time.compareTo(other.toLocalTime());\n    }\n\n    return cmp;\n  };\n\n  _proto.isAfter = function isAfter(other) {\n    return this.compareTo(other) > 0;\n  };\n\n  _proto.isBefore = function isBefore(other) {\n    return this.compareTo(other) < 0;\n  };\n\n  _proto.isEqual = function isEqual(other) {\n    return this.compareTo(other) === 0;\n  };\n\n  _proto.equals = function equals(other) {\n    if (this === other) {\n      return true;\n    }\n\n    if (other instanceof LocalDateTime) {\n      return this._date.equals(other._date) && this._time.equals(other._time);\n    }\n\n    return false;\n  };\n\n  _proto.hashCode = function hashCode() {\n    return this._date.hashCode() ^ this._time.hashCode();\n  };\n\n  _proto.toString = function toString() {\n    return this._date.toString() + 'T' + this._time.toString();\n  };\n\n  _proto.toJSON = function toJSON() {\n    return this.toString();\n  };\n\n  _proto.format = function format(formatter) {\n    requireNonNull(formatter, 'formatter');\n    return formatter.format(this);\n  };\n\n  return LocalDateTime;\n}(ChronoLocalDateTime);\nfunction _init$j() {\n  LocalDateTime.MIN = LocalDateTime.of(LocalDate.MIN, LocalTime.MIN);\n  LocalDateTime.MAX = LocalDateTime.of(LocalDate.MAX, LocalTime.MAX);\n  LocalDateTime.FROM = createTemporalQuery('LocalDateTime.FROM', function (temporal) {\n    return LocalDateTime.from(temporal);\n  });\n}\n\nvar LocalTime = function (_Temporal) {\n  _inheritsLoose(LocalTime, _Temporal);\n\n  LocalTime.now = function now(clockOrZone) {\n    if (clockOrZone == null) {\n      return LocalTime._now(Clock.systemDefaultZone());\n    } else if (clockOrZone instanceof Clock) {\n      return LocalTime._now(clockOrZone);\n    } else {\n      return LocalTime._now(Clock.system(clockOrZone));\n    }\n  };\n\n  LocalTime._now = function _now(clock) {\n    if (clock === void 0) {\n      clock = Clock.systemDefaultZone();\n    }\n\n    requireNonNull(clock, 'clock');\n    return LocalTime.ofInstant(clock.instant(), clock.zone());\n  };\n\n  LocalTime.ofInstant = function ofInstant(instant, zone) {\n    if (zone === void 0) {\n      zone = ZoneId.systemDefault();\n    }\n\n    var offset = zone.rules().offset(instant);\n    var secsOfDay = MathUtil.intMod(instant.epochSecond(), LocalTime.SECONDS_PER_DAY);\n    secsOfDay = MathUtil.intMod(secsOfDay + offset.totalSeconds(), LocalTime.SECONDS_PER_DAY);\n\n    if (secsOfDay < 0) {\n      secsOfDay += LocalTime.SECONDS_PER_DAY;\n    }\n\n    return LocalTime.ofSecondOfDay(secsOfDay, instant.nano());\n  };\n\n  LocalTime.of = function of(hour, minute, second, nanoOfSecond) {\n    return new LocalTime(hour, minute, second, nanoOfSecond);\n  };\n\n  LocalTime.ofSecondOfDay = function ofSecondOfDay(secondOfDay, nanoOfSecond) {\n    if (secondOfDay === void 0) {\n      secondOfDay = 0;\n    }\n\n    if (nanoOfSecond === void 0) {\n      nanoOfSecond = 0;\n    }\n\n    ChronoField.SECOND_OF_DAY.checkValidValue(secondOfDay);\n    ChronoField.NANO_OF_SECOND.checkValidValue(nanoOfSecond);\n    var hours = MathUtil.intDiv(secondOfDay, LocalTime.SECONDS_PER_HOUR);\n    secondOfDay -= hours * LocalTime.SECONDS_PER_HOUR;\n    var minutes = MathUtil.intDiv(secondOfDay, LocalTime.SECONDS_PER_MINUTE);\n    secondOfDay -= minutes * LocalTime.SECONDS_PER_MINUTE;\n    return new LocalTime(hours, minutes, secondOfDay, nanoOfSecond);\n  };\n\n  LocalTime.ofNanoOfDay = function ofNanoOfDay(nanoOfDay) {\n    if (nanoOfDay === void 0) {\n      nanoOfDay = 0;\n    }\n\n    ChronoField.NANO_OF_DAY.checkValidValue(nanoOfDay);\n    var hours = MathUtil.intDiv(nanoOfDay, LocalTime.NANOS_PER_HOUR);\n    nanoOfDay -= hours * LocalTime.NANOS_PER_HOUR;\n    var minutes = MathUtil.intDiv(nanoOfDay, LocalTime.NANOS_PER_MINUTE);\n    nanoOfDay -= minutes * LocalTime.NANOS_PER_MINUTE;\n    var seconds = MathUtil.intDiv(nanoOfDay, LocalTime.NANOS_PER_SECOND);\n    nanoOfDay -= seconds * LocalTime.NANOS_PER_SECOND;\n    return new LocalTime(hours, minutes, seconds, nanoOfDay);\n  };\n\n  LocalTime.from = function from(temporal) {\n    requireNonNull(temporal, 'temporal');\n    var time = temporal.query(TemporalQueries.localTime());\n\n    if (time == null) {\n      throw new DateTimeException(\"Unable to obtain LocalTime TemporalAccessor: \" + temporal + \", type \" + (temporal.constructor != null ? temporal.constructor.name : ''));\n    }\n\n    return time;\n  };\n\n  LocalTime.parse = function parse(text, formatter) {\n    if (formatter === void 0) {\n      formatter = DateTimeFormatter.ISO_LOCAL_TIME;\n    }\n\n    requireNonNull(formatter, 'formatter');\n    return formatter.parse(text, LocalTime.FROM);\n  };\n\n  function LocalTime(hour, minute, second, nanoOfSecond) {\n    var _this;\n\n    if (hour === void 0) {\n      hour = 0;\n    }\n\n    if (minute === void 0) {\n      minute = 0;\n    }\n\n    if (second === void 0) {\n      second = 0;\n    }\n\n    if (nanoOfSecond === void 0) {\n      nanoOfSecond = 0;\n    }\n\n    _this = _Temporal.call(this) || this;\n\n    var _hour = MathUtil.safeToInt(hour);\n\n    var _minute = MathUtil.safeToInt(minute);\n\n    var _second = MathUtil.safeToInt(second);\n\n    var _nanoOfSecond = MathUtil.safeToInt(nanoOfSecond);\n\n    LocalTime._validate(_hour, _minute, _second, _nanoOfSecond);\n\n    if (_minute === 0 && _second === 0 && _nanoOfSecond === 0) {\n      if (!LocalTime.HOURS[_hour]) {\n        _this._hour = _hour;\n        _this._minute = _minute;\n        _this._second = _second;\n        _this._nano = _nanoOfSecond;\n        LocalTime.HOURS[_hour] = _assertThisInitialized(_this);\n      }\n\n      return LocalTime.HOURS[_hour] || _assertThisInitialized(_this);\n    }\n\n    _this._hour = _hour;\n    _this._minute = _minute;\n    _this._second = _second;\n    _this._nano = _nanoOfSecond;\n    return _this;\n  }\n\n  LocalTime._validate = function _validate(hour, minute, second, nanoOfSecond) {\n    ChronoField.HOUR_OF_DAY.checkValidValue(hour);\n    ChronoField.MINUTE_OF_HOUR.checkValidValue(minute);\n    ChronoField.SECOND_OF_MINUTE.checkValidValue(second);\n    ChronoField.NANO_OF_SECOND.checkValidValue(nanoOfSecond);\n  };\n\n  var _proto = LocalTime.prototype;\n\n  _proto.isSupported = function isSupported(fieldOrUnit) {\n    if (fieldOrUnit instanceof ChronoField) {\n      return fieldOrUnit.isTimeBased();\n    } else if (fieldOrUnit instanceof ChronoUnit) {\n      return fieldOrUnit.isTimeBased();\n    }\n\n    return fieldOrUnit != null && fieldOrUnit.isSupportedBy(this);\n  };\n\n  _proto.range = function range(field) {\n    requireNonNull(field);\n    return _Temporal.prototype.range.call(this, field);\n  };\n\n  _proto.get = function get(field) {\n    return this.getLong(field);\n  };\n\n  _proto.getLong = function getLong(field) {\n    requireNonNull(field, 'field');\n\n    if (field instanceof ChronoField) {\n      return this._get0(field);\n    }\n\n    return field.getFrom(this);\n  };\n\n  _proto._get0 = function _get0(field) {\n    switch (field) {\n      case ChronoField.NANO_OF_SECOND:\n        return this._nano;\n\n      case ChronoField.NANO_OF_DAY:\n        return this.toNanoOfDay();\n\n      case ChronoField.MICRO_OF_SECOND:\n        return MathUtil.intDiv(this._nano, 1000);\n\n      case ChronoField.MICRO_OF_DAY:\n        return MathUtil.intDiv(this.toNanoOfDay(), 1000);\n\n      case ChronoField.MILLI_OF_SECOND:\n        return MathUtil.intDiv(this._nano, 1000000);\n\n      case ChronoField.MILLI_OF_DAY:\n        return MathUtil.intDiv(this.toNanoOfDay(), 1000000);\n\n      case ChronoField.SECOND_OF_MINUTE:\n        return this._second;\n\n      case ChronoField.SECOND_OF_DAY:\n        return this.toSecondOfDay();\n\n      case ChronoField.MINUTE_OF_HOUR:\n        return this._minute;\n\n      case ChronoField.MINUTE_OF_DAY:\n        return this._hour * 60 + this._minute;\n\n      case ChronoField.HOUR_OF_AMPM:\n        return MathUtil.intMod(this._hour, 12);\n\n      case ChronoField.CLOCK_HOUR_OF_AMPM:\n        {\n          var ham = MathUtil.intMod(this._hour, 12);\n          return ham % 12 === 0 ? 12 : ham;\n        }\n\n      case ChronoField.HOUR_OF_DAY:\n        return this._hour;\n\n      case ChronoField.CLOCK_HOUR_OF_DAY:\n        return this._hour === 0 ? 24 : this._hour;\n\n      case ChronoField.AMPM_OF_DAY:\n        return MathUtil.intDiv(this._hour, 12);\n    }\n\n    throw new UnsupportedTemporalTypeException('Unsupported field: ' + field);\n  };\n\n  _proto.hour = function hour() {\n    return this._hour;\n  };\n\n  _proto.minute = function minute() {\n    return this._minute;\n  };\n\n  _proto.second = function second() {\n    return this._second;\n  };\n\n  _proto.nano = function nano() {\n    return this._nano;\n  };\n\n  _proto.withAdjuster = function withAdjuster(adjuster) {\n    requireNonNull(adjuster, 'adjuster');\n\n    if (adjuster instanceof LocalTime) {\n      return adjuster;\n    }\n\n    assert(typeof adjuster.adjustInto === 'function', 'adjuster', IllegalArgumentException);\n    return adjuster.adjustInto(this);\n  };\n\n  _proto.withFieldValue = function withFieldValue(field, newValue) {\n    requireNonNull(field, 'field');\n    requireInstance(field, TemporalField, 'field');\n\n    if (field instanceof ChronoField) {\n      field.checkValidValue(newValue);\n\n      switch (field) {\n        case ChronoField.NANO_OF_SECOND:\n          return this.withNano(newValue);\n\n        case ChronoField.NANO_OF_DAY:\n          return LocalTime.ofNanoOfDay(newValue);\n\n        case ChronoField.MICRO_OF_SECOND:\n          return this.withNano(newValue * 1000);\n\n        case ChronoField.MICRO_OF_DAY:\n          return LocalTime.ofNanoOfDay(newValue * 1000);\n\n        case ChronoField.MILLI_OF_SECOND:\n          return this.withNano(newValue * 1000000);\n\n        case ChronoField.MILLI_OF_DAY:\n          return LocalTime.ofNanoOfDay(newValue * 1000000);\n\n        case ChronoField.SECOND_OF_MINUTE:\n          return this.withSecond(newValue);\n\n        case ChronoField.SECOND_OF_DAY:\n          return this.plusSeconds(newValue - this.toSecondOfDay());\n\n        case ChronoField.MINUTE_OF_HOUR:\n          return this.withMinute(newValue);\n\n        case ChronoField.MINUTE_OF_DAY:\n          return this.plusMinutes(newValue - (this._hour * 60 + this._minute));\n\n        case ChronoField.HOUR_OF_AMPM:\n          return this.plusHours(newValue - MathUtil.intMod(this._hour, 12));\n\n        case ChronoField.CLOCK_HOUR_OF_AMPM:\n          return this.plusHours((newValue === 12 ? 0 : newValue) - MathUtil.intMod(this._hour, 12));\n\n        case ChronoField.HOUR_OF_DAY:\n          return this.withHour(newValue);\n\n        case ChronoField.CLOCK_HOUR_OF_DAY:\n          return this.withHour(newValue === 24 ? 0 : newValue);\n\n        case ChronoField.AMPM_OF_DAY:\n          return this.plusHours((newValue - MathUtil.intDiv(this._hour, 12)) * 12);\n      }\n\n      throw new UnsupportedTemporalTypeException('Unsupported field: ' + field);\n    }\n\n    return field.adjustInto(this, newValue);\n  };\n\n  _proto.withHour = function withHour(hour) {\n    if (hour === void 0) {\n      hour = 0;\n    }\n\n    if (this._hour === hour) {\n      return this;\n    }\n\n    return new LocalTime(hour, this._minute, this._second, this._nano);\n  };\n\n  _proto.withMinute = function withMinute(minute) {\n    if (minute === void 0) {\n      minute = 0;\n    }\n\n    if (this._minute === minute) {\n      return this;\n    }\n\n    return new LocalTime(this._hour, minute, this._second, this._nano);\n  };\n\n  _proto.withSecond = function withSecond(second) {\n    if (second === void 0) {\n      second = 0;\n    }\n\n    if (this._second === second) {\n      return this;\n    }\n\n    return new LocalTime(this._hour, this._minute, second, this._nano);\n  };\n\n  _proto.withNano = function withNano(nanoOfSecond) {\n    if (nanoOfSecond === void 0) {\n      nanoOfSecond = 0;\n    }\n\n    if (this._nano === nanoOfSecond) {\n      return this;\n    }\n\n    return new LocalTime(this._hour, this._minute, this._second, nanoOfSecond);\n  };\n\n  _proto.truncatedTo = function truncatedTo(unit) {\n    requireNonNull(unit, 'unit');\n\n    if (unit === ChronoUnit.NANOS) {\n      return this;\n    }\n\n    var unitDur = unit.duration();\n\n    if (unitDur.seconds() > LocalTime.SECONDS_PER_DAY) {\n      throw new DateTimeException('Unit is too large to be used for truncation');\n    }\n\n    var dur = unitDur.toNanos();\n\n    if (MathUtil.intMod(LocalTime.NANOS_PER_DAY, dur) !== 0) {\n      throw new DateTimeException('Unit must divide into a standard day without remainder');\n    }\n\n    var nod = this.toNanoOfDay();\n    return LocalTime.ofNanoOfDay(MathUtil.intDiv(nod, dur) * dur);\n  };\n\n  _proto.plusAmount = function plusAmount(amount) {\n    requireNonNull(amount, 'amount');\n    return amount.addTo(this);\n  };\n\n  _proto.plusAmountUnit = function plusAmountUnit(amountToAdd, unit) {\n    requireNonNull(unit, 'unit');\n\n    if (unit instanceof ChronoUnit) {\n      switch (unit) {\n        case ChronoUnit.NANOS:\n          return this.plusNanos(amountToAdd);\n\n        case ChronoUnit.MICROS:\n          return this.plusNanos(MathUtil.intMod(amountToAdd, LocalTime.MICROS_PER_DAY) * 1000);\n\n        case ChronoUnit.MILLIS:\n          return this.plusNanos(MathUtil.intMod(amountToAdd, LocalTime.MILLIS_PER_DAY) * 1000000);\n\n        case ChronoUnit.SECONDS:\n          return this.plusSeconds(amountToAdd);\n\n        case ChronoUnit.MINUTES:\n          return this.plusMinutes(amountToAdd);\n\n        case ChronoUnit.HOURS:\n          return this.plusHours(amountToAdd);\n\n        case ChronoUnit.HALF_DAYS:\n          return this.plusHours(MathUtil.intMod(amountToAdd, 2) * 12);\n      }\n\n      throw new UnsupportedTemporalTypeException('Unsupported unit: ' + unit);\n    }\n\n    return unit.addTo(this, amountToAdd);\n  };\n\n  _proto.plusHours = function plusHours(hoursToAdd) {\n    if (hoursToAdd === 0) {\n      return this;\n    }\n\n    var newHour = MathUtil.intMod(MathUtil.intMod(hoursToAdd, LocalTime.HOURS_PER_DAY) + this._hour + LocalTime.HOURS_PER_DAY, LocalTime.HOURS_PER_DAY);\n    return new LocalTime(newHour, this._minute, this._second, this._nano);\n  };\n\n  _proto.plusMinutes = function plusMinutes(minutesToAdd) {\n    if (minutesToAdd === 0) {\n      return this;\n    }\n\n    var mofd = this._hour * LocalTime.MINUTES_PER_HOUR + this._minute;\n    var newMofd = MathUtil.intMod(MathUtil.intMod(minutesToAdd, LocalTime.MINUTES_PER_DAY) + mofd + LocalTime.MINUTES_PER_DAY, LocalTime.MINUTES_PER_DAY);\n\n    if (mofd === newMofd) {\n      return this;\n    }\n\n    var newHour = MathUtil.intDiv(newMofd, LocalTime.MINUTES_PER_HOUR);\n    var newMinute = MathUtil.intMod(newMofd, LocalTime.MINUTES_PER_HOUR);\n    return new LocalTime(newHour, newMinute, this._second, this._nano);\n  };\n\n  _proto.plusSeconds = function plusSeconds(secondsToAdd) {\n    if (secondsToAdd === 0) {\n      return this;\n    }\n\n    var sofd = this._hour * LocalTime.SECONDS_PER_HOUR + this._minute * LocalTime.SECONDS_PER_MINUTE + this._second;\n    var newSofd = MathUtil.intMod(MathUtil.intMod(secondsToAdd, LocalTime.SECONDS_PER_DAY) + sofd + LocalTime.SECONDS_PER_DAY, LocalTime.SECONDS_PER_DAY);\n\n    if (sofd === newSofd) {\n      return this;\n    }\n\n    var newHour = MathUtil.intDiv(newSofd, LocalTime.SECONDS_PER_HOUR);\n    var newMinute = MathUtil.intMod(MathUtil.intDiv(newSofd, LocalTime.SECONDS_PER_MINUTE), LocalTime.MINUTES_PER_HOUR);\n    var newSecond = MathUtil.intMod(newSofd, LocalTime.SECONDS_PER_MINUTE);\n    return new LocalTime(newHour, newMinute, newSecond, this._nano);\n  };\n\n  _proto.plusNanos = function plusNanos(nanosToAdd) {\n    if (nanosToAdd === 0) {\n      return this;\n    }\n\n    var nofd = this.toNanoOfDay();\n    var newNofd = MathUtil.intMod(MathUtil.intMod(nanosToAdd, LocalTime.NANOS_PER_DAY) + nofd + LocalTime.NANOS_PER_DAY, LocalTime.NANOS_PER_DAY);\n\n    if (nofd === newNofd) {\n      return this;\n    }\n\n    var newHour = MathUtil.intDiv(newNofd, LocalTime.NANOS_PER_HOUR);\n    var newMinute = MathUtil.intMod(MathUtil.intDiv(newNofd, LocalTime.NANOS_PER_MINUTE), LocalTime.MINUTES_PER_HOUR);\n    var newSecond = MathUtil.intMod(MathUtil.intDiv(newNofd, LocalTime.NANOS_PER_SECOND), LocalTime.SECONDS_PER_MINUTE);\n    var newNano = MathUtil.intMod(newNofd, LocalTime.NANOS_PER_SECOND);\n    return new LocalTime(newHour, newMinute, newSecond, newNano);\n  };\n\n  _proto.minusAmount = function minusAmount(amount) {\n    requireNonNull(amount, 'amount');\n    return amount.subtractFrom(this);\n  };\n\n  _proto.minusAmountUnit = function minusAmountUnit(amountToSubtract, unit) {\n    requireNonNull(unit, 'unit');\n    return this.plusAmountUnit(-1 * amountToSubtract, unit);\n  };\n\n  _proto.minusHours = function minusHours(hoursToSubtract) {\n    return this.plusHours(-1 * MathUtil.intMod(hoursToSubtract, LocalTime.HOURS_PER_DAY));\n  };\n\n  _proto.minusMinutes = function minusMinutes(minutesToSubtract) {\n    return this.plusMinutes(-1 * MathUtil.intMod(minutesToSubtract, LocalTime.MINUTES_PER_DAY));\n  };\n\n  _proto.minusSeconds = function minusSeconds(secondsToSubtract) {\n    return this.plusSeconds(-1 * MathUtil.intMod(secondsToSubtract, LocalTime.SECONDS_PER_DAY));\n  };\n\n  _proto.minusNanos = function minusNanos(nanosToSubtract) {\n    return this.plusNanos(-1 * MathUtil.intMod(nanosToSubtract, LocalTime.NANOS_PER_DAY));\n  };\n\n  _proto.query = function query(_query) {\n    requireNonNull(_query, 'query');\n\n    if (_query === TemporalQueries.precision()) {\n      return ChronoUnit.NANOS;\n    } else if (_query === TemporalQueries.localTime()) {\n      return this;\n    }\n\n    if (_query === TemporalQueries.chronology() || _query === TemporalQueries.zoneId() || _query === TemporalQueries.zone() || _query === TemporalQueries.offset() || _query === TemporalQueries.localDate()) {\n      return null;\n    }\n\n    return _query.queryFrom(this);\n  };\n\n  _proto.adjustInto = function adjustInto(temporal) {\n    return temporal.with(LocalTime.NANO_OF_DAY, this.toNanoOfDay());\n  };\n\n  _proto.until = function until(endExclusive, unit) {\n    requireNonNull(endExclusive, 'endExclusive');\n    requireNonNull(unit, 'unit');\n    var end = LocalTime.from(endExclusive);\n\n    if (unit instanceof ChronoUnit) {\n      var nanosUntil = end.toNanoOfDay() - this.toNanoOfDay();\n\n      switch (unit) {\n        case ChronoUnit.NANOS:\n          return nanosUntil;\n\n        case ChronoUnit.MICROS:\n          return MathUtil.intDiv(nanosUntil, 1000);\n\n        case ChronoUnit.MILLIS:\n          return MathUtil.intDiv(nanosUntil, 1000000);\n\n        case ChronoUnit.SECONDS:\n          return MathUtil.intDiv(nanosUntil, LocalTime.NANOS_PER_SECOND);\n\n        case ChronoUnit.MINUTES:\n          return MathUtil.intDiv(nanosUntil, LocalTime.NANOS_PER_MINUTE);\n\n        case ChronoUnit.HOURS:\n          return MathUtil.intDiv(nanosUntil, LocalTime.NANOS_PER_HOUR);\n\n        case ChronoUnit.HALF_DAYS:\n          return MathUtil.intDiv(nanosUntil, 12 * LocalTime.NANOS_PER_HOUR);\n      }\n\n      throw new UnsupportedTemporalTypeException('Unsupported unit: ' + unit);\n    }\n\n    return unit.between(this, end);\n  };\n\n  _proto.atDate = function atDate(date) {\n    return LocalDateTime.of(date, this);\n  };\n\n  _proto.toSecondOfDay = function toSecondOfDay() {\n    var total = this._hour * LocalTime.SECONDS_PER_HOUR;\n    total += this._minute * LocalTime.SECONDS_PER_MINUTE;\n    total += this._second;\n    return total;\n  };\n\n  _proto.toNanoOfDay = function toNanoOfDay() {\n    var total = this._hour * LocalTime.NANOS_PER_HOUR;\n    total += this._minute * LocalTime.NANOS_PER_MINUTE;\n    total += this._second * LocalTime.NANOS_PER_SECOND;\n    total += this._nano;\n    return total;\n  };\n\n  _proto.compareTo = function compareTo(other) {\n    requireNonNull(other, 'other');\n    requireInstance(other, LocalTime, 'other');\n    var cmp = MathUtil.compareNumbers(this._hour, other._hour);\n\n    if (cmp === 0) {\n      cmp = MathUtil.compareNumbers(this._minute, other._minute);\n\n      if (cmp === 0) {\n        cmp = MathUtil.compareNumbers(this._second, other._second);\n\n        if (cmp === 0) {\n          cmp = MathUtil.compareNumbers(this._nano, other._nano);\n        }\n      }\n    }\n\n    return cmp;\n  };\n\n  _proto.isAfter = function isAfter(other) {\n    return this.compareTo(other) > 0;\n  };\n\n  _proto.isBefore = function isBefore(other) {\n    return this.compareTo(other) < 0;\n  };\n\n  _proto.equals = function equals(other) {\n    if (this === other) {\n      return true;\n    }\n\n    if (other instanceof LocalTime) {\n      return this._hour === other._hour && this._minute === other._minute && this._second === other._second && this._nano === other._nano;\n    }\n\n    return false;\n  };\n\n  _proto.hashCode = function hashCode() {\n    var nod = this.toNanoOfDay();\n    return MathUtil.hash(nod);\n  };\n\n  _proto.toString = function toString() {\n    var buf = '';\n    var hourValue = this._hour;\n    var minuteValue = this._minute;\n    var secondValue = this._second;\n    var nanoValue = this._nano;\n    buf += hourValue < 10 ? '0' : '';\n    buf += hourValue;\n    buf += minuteValue < 10 ? ':0' : ':';\n    buf += minuteValue;\n\n    if (secondValue > 0 || nanoValue > 0) {\n      buf += secondValue < 10 ? ':0' : ':';\n      buf += secondValue;\n\n      if (nanoValue > 0) {\n        buf += '.';\n\n        if (MathUtil.intMod(nanoValue, 1000000) === 0) {\n          buf += ('' + (MathUtil.intDiv(nanoValue, 1000000) + 1000)).substring(1);\n        } else if (MathUtil.intMod(nanoValue, 1000) === 0) {\n          buf += ('' + (MathUtil.intDiv(nanoValue, 1000) + 1000000)).substring(1);\n        } else {\n          buf += ('' + (nanoValue + 1000000000)).substring(1);\n        }\n      }\n    }\n\n    return buf;\n  };\n\n  _proto.toJSON = function toJSON() {\n    return this.toString();\n  };\n\n  _proto.format = function format(formatter) {\n    requireNonNull(formatter, 'formatter');\n    return formatter.format(this);\n  };\n\n  return LocalTime;\n}(Temporal);\nfunction _init$k() {\n  LocalTime.HOURS = [];\n\n  for (var hour = 0; hour < 24; hour++) {\n    LocalTime.of(hour, 0, 0, 0);\n  }\n\n  LocalTime.MIN = LocalTime.HOURS[0];\n  LocalTime.MAX = new LocalTime(23, 59, 59, 999999999);\n  LocalTime.MIDNIGHT = LocalTime.HOURS[0];\n  LocalTime.NOON = LocalTime.HOURS[12];\n  LocalTime.FROM = createTemporalQuery('LocalTime.FROM', function (temporal) {\n    return LocalTime.from(temporal);\n  });\n}\nLocalTime.HOURS_PER_DAY = 24;\nLocalTime.MINUTES_PER_HOUR = 60;\nLocalTime.MINUTES_PER_DAY = LocalTime.MINUTES_PER_HOUR * LocalTime.HOURS_PER_DAY;\nLocalTime.SECONDS_PER_MINUTE = 60;\nLocalTime.SECONDS_PER_HOUR = LocalTime.SECONDS_PER_MINUTE * LocalTime.MINUTES_PER_HOUR;\nLocalTime.SECONDS_PER_DAY = LocalTime.SECONDS_PER_HOUR * LocalTime.HOURS_PER_DAY;\nLocalTime.MILLIS_PER_DAY = LocalTime.SECONDS_PER_DAY * 1000;\nLocalTime.MICROS_PER_DAY = LocalTime.SECONDS_PER_DAY * 1000000;\nLocalTime.NANOS_PER_SECOND = 1000000000;\nLocalTime.NANOS_PER_MINUTE = LocalTime.NANOS_PER_SECOND * LocalTime.SECONDS_PER_MINUTE;\nLocalTime.NANOS_PER_HOUR = LocalTime.NANOS_PER_MINUTE * LocalTime.MINUTES_PER_HOUR;\nLocalTime.NANOS_PER_DAY = LocalTime.NANOS_PER_HOUR * LocalTime.HOURS_PER_DAY;\n\nvar NANOS_PER_MILLI = 1000000;\nvar Instant = function (_Temporal) {\n  _inheritsLoose(Instant, _Temporal);\n\n  Instant.now = function now(clock) {\n    if (clock === void 0) {\n      clock = Clock.systemUTC();\n    }\n\n    return clock.instant();\n  };\n\n  Instant.ofEpochSecond = function ofEpochSecond(epochSecond, nanoAdjustment) {\n    if (nanoAdjustment === void 0) {\n      nanoAdjustment = 0;\n    }\n\n    var secs = epochSecond + MathUtil.floorDiv(nanoAdjustment, LocalTime.NANOS_PER_SECOND);\n    var nos = MathUtil.floorMod(nanoAdjustment, LocalTime.NANOS_PER_SECOND);\n    return Instant._create(secs, nos);\n  };\n\n  Instant.ofEpochMilli = function ofEpochMilli(epochMilli) {\n    var secs = MathUtil.floorDiv(epochMilli, 1000);\n    var mos = MathUtil.floorMod(epochMilli, 1000);\n    return Instant._create(secs, mos * 1000000);\n  };\n\n  Instant.from = function from(temporal) {\n    try {\n      var instantSecs = temporal.getLong(ChronoField.INSTANT_SECONDS);\n      var nanoOfSecond = temporal.get(ChronoField.NANO_OF_SECOND);\n      return Instant.ofEpochSecond(instantSecs, nanoOfSecond);\n    } catch (ex) {\n      throw new DateTimeException('Unable to obtain Instant from TemporalAccessor: ' + temporal + ', type ' + typeof temporal, ex);\n    }\n  };\n\n  Instant.parse = function parse(text) {\n    return DateTimeFormatter.ISO_INSTANT.parse(text, Instant.FROM);\n  };\n\n  Instant._create = function _create(seconds, nanoOfSecond) {\n    if (seconds === 0 && nanoOfSecond === 0) {\n      return Instant.EPOCH;\n    }\n\n    return new Instant(seconds, nanoOfSecond);\n  };\n\n  Instant._validate = function _validate(seconds, nanoOfSecond) {\n    if (seconds < Instant.MIN_SECONDS || seconds > Instant.MAX_SECONDS) {\n      throw new DateTimeException('Instant exceeds minimum or maximum instant');\n    }\n\n    if (nanoOfSecond < 0 || nanoOfSecond > LocalTime.NANOS_PER_SECOND) {\n      throw new DateTimeException('Instant exceeds minimum or maximum instant');\n    }\n  };\n\n  function Instant(seconds, nanoOfSecond) {\n    var _this;\n\n    _this = _Temporal.call(this) || this;\n\n    Instant._validate(seconds, nanoOfSecond);\n\n    _this._seconds = MathUtil.safeToInt(seconds);\n    _this._nanos = MathUtil.safeToInt(nanoOfSecond);\n    return _this;\n  }\n\n  var _proto = Instant.prototype;\n\n  _proto.isSupported = function isSupported(fieldOrUnit) {\n    if (fieldOrUnit instanceof ChronoField) {\n      return fieldOrUnit === ChronoField.INSTANT_SECONDS || fieldOrUnit === ChronoField.NANO_OF_SECOND || fieldOrUnit === ChronoField.MICRO_OF_SECOND || fieldOrUnit === ChronoField.MILLI_OF_SECOND;\n    }\n\n    if (fieldOrUnit instanceof ChronoUnit) {\n      return fieldOrUnit.isTimeBased() || fieldOrUnit === ChronoUnit.DAYS;\n    }\n\n    return fieldOrUnit != null && fieldOrUnit.isSupportedBy(this);\n  };\n\n  _proto.range = function range(field) {\n    return _Temporal.prototype.range.call(this, field);\n  };\n\n  _proto.get = function get(field) {\n    return this.getLong(field);\n  };\n\n  _proto.getLong = function getLong(field) {\n    if (field instanceof ChronoField) {\n      switch (field) {\n        case ChronoField.NANO_OF_SECOND:\n          return this._nanos;\n\n        case ChronoField.MICRO_OF_SECOND:\n          return MathUtil.intDiv(this._nanos, 1000);\n\n        case ChronoField.MILLI_OF_SECOND:\n          return MathUtil.intDiv(this._nanos, NANOS_PER_MILLI);\n\n        case ChronoField.INSTANT_SECONDS:\n          return this._seconds;\n      }\n\n      throw new UnsupportedTemporalTypeException('Unsupported field: ' + field);\n    }\n\n    return field.getFrom(this);\n  };\n\n  _proto.epochSecond = function epochSecond() {\n    return this._seconds;\n  };\n\n  _proto.nano = function nano() {\n    return this._nanos;\n  };\n\n  _proto.withAdjuster = function withAdjuster(adjuster) {\n    requireNonNull(adjuster, 'adjuster');\n    return adjuster.adjustInto(this);\n  };\n\n  _proto.withFieldValue = function withFieldValue(field, newValue) {\n    requireNonNull(field, 'field');\n\n    if (field instanceof ChronoField) {\n      field.checkValidValue(newValue);\n\n      switch (field) {\n        case ChronoField.MILLI_OF_SECOND:\n          {\n            var nval = newValue * NANOS_PER_MILLI;\n            return nval !== this._nanos ? Instant._create(this._seconds, nval) : this;\n          }\n\n        case ChronoField.MICRO_OF_SECOND:\n          {\n            var _nval = newValue * 1000;\n\n            return _nval !== this._nanos ? Instant._create(this._seconds, _nval) : this;\n          }\n\n        case ChronoField.NANO_OF_SECOND:\n          return newValue !== this._nanos ? Instant._create(this._seconds, newValue) : this;\n\n        case ChronoField.INSTANT_SECONDS:\n          return newValue !== this._seconds ? Instant._create(newValue, this._nanos) : this;\n      }\n\n      throw new UnsupportedTemporalTypeException('Unsupported field: ' + field);\n    }\n\n    return field.adjustInto(this, newValue);\n  };\n\n  _proto.truncatedTo = function truncatedTo(unit) {\n    requireNonNull(unit, 'unit');\n\n    if (unit === ChronoUnit.NANOS) {\n      return this;\n    }\n\n    var unitDur = unit.duration();\n\n    if (unitDur.seconds() > LocalTime.SECONDS_PER_DAY) {\n      throw new DateTimeException('Unit is too large to be used for truncation');\n    }\n\n    var dur = unitDur.toNanos();\n\n    if (MathUtil.intMod(LocalTime.NANOS_PER_DAY, dur) !== 0) {\n      throw new DateTimeException('Unit must divide into a standard day without remainder');\n    }\n\n    var nod = MathUtil.intMod(this._seconds, LocalTime.SECONDS_PER_DAY) * LocalTime.NANOS_PER_SECOND + this._nanos;\n\n    var result = MathUtil.intDiv(nod, dur) * dur;\n    return this.plusNanos(result - nod);\n  };\n\n  _proto.plusAmount = function plusAmount(amount) {\n    requireNonNull(amount, 'amount');\n    return amount.addTo(this);\n  };\n\n  _proto.plusAmountUnit = function plusAmountUnit(amountToAdd, unit) {\n    requireNonNull(amountToAdd, 'amountToAdd');\n    requireNonNull(unit, 'unit');\n    requireInstance(unit, TemporalUnit);\n\n    if (unit instanceof ChronoUnit) {\n      switch (unit) {\n        case ChronoUnit.NANOS:\n          return this.plusNanos(amountToAdd);\n\n        case ChronoUnit.MICROS:\n          return this._plus(MathUtil.intDiv(amountToAdd, 1000000), MathUtil.intMod(amountToAdd, 1000000) * 1000);\n\n        case ChronoUnit.MILLIS:\n          return this.plusMillis(amountToAdd);\n\n        case ChronoUnit.SECONDS:\n          return this.plusSeconds(amountToAdd);\n\n        case ChronoUnit.MINUTES:\n          return this.plusSeconds(MathUtil.safeMultiply(amountToAdd, LocalTime.SECONDS_PER_MINUTE));\n\n        case ChronoUnit.HOURS:\n          return this.plusSeconds(MathUtil.safeMultiply(amountToAdd, LocalTime.SECONDS_PER_HOUR));\n\n        case ChronoUnit.HALF_DAYS:\n          return this.plusSeconds(MathUtil.safeMultiply(amountToAdd, LocalTime.SECONDS_PER_DAY / 2));\n\n        case ChronoUnit.DAYS:\n          return this.plusSeconds(MathUtil.safeMultiply(amountToAdd, LocalTime.SECONDS_PER_DAY));\n      }\n\n      throw new UnsupportedTemporalTypeException('Unsupported unit: ' + unit);\n    }\n\n    return unit.addTo(this, amountToAdd);\n  };\n\n  _proto.plusSeconds = function plusSeconds(secondsToAdd) {\n    return this._plus(secondsToAdd, 0);\n  };\n\n  _proto.plusMillis = function plusMillis(millisToAdd) {\n    return this._plus(MathUtil.intDiv(millisToAdd, 1000), MathUtil.intMod(millisToAdd, 1000) * NANOS_PER_MILLI);\n  };\n\n  _proto.plusNanos = function plusNanos(nanosToAdd) {\n    return this._plus(0, nanosToAdd);\n  };\n\n  _proto._plus = function _plus(secondsToAdd, nanosToAdd) {\n    if (secondsToAdd === 0 && nanosToAdd === 0) {\n      return this;\n    }\n\n    var epochSec = this._seconds + secondsToAdd;\n    epochSec = epochSec + MathUtil.intDiv(nanosToAdd, LocalTime.NANOS_PER_SECOND);\n    var nanoAdjustment = this._nanos + nanosToAdd % LocalTime.NANOS_PER_SECOND;\n    return Instant.ofEpochSecond(epochSec, nanoAdjustment);\n  };\n\n  _proto.minusAmount = function minusAmount(amount) {\n    requireNonNull(amount, 'amount');\n    return amount.subtractFrom(this);\n  };\n\n  _proto.minusAmountUnit = function minusAmountUnit(amountToSubtract, unit) {\n    return this.plusAmountUnit(-1 * amountToSubtract, unit);\n  };\n\n  _proto.minusSeconds = function minusSeconds(secondsToSubtract) {\n    return this.plusSeconds(secondsToSubtract * -1);\n  };\n\n  _proto.minusMillis = function minusMillis(millisToSubtract) {\n    return this.plusMillis(-1 * millisToSubtract);\n  };\n\n  _proto.minusNanos = function minusNanos(nanosToSubtract) {\n    return this.plusNanos(-1 * nanosToSubtract);\n  };\n\n  _proto.query = function query(_query) {\n    requireNonNull(_query, 'query');\n\n    if (_query === TemporalQueries.precision()) {\n      return ChronoUnit.NANOS;\n    }\n\n    if (_query === TemporalQueries.localDate() || _query === TemporalQueries.localTime() || _query === TemporalQueries.chronology() || _query === TemporalQueries.zoneId() || _query === TemporalQueries.zone() || _query === TemporalQueries.offset()) {\n      return null;\n    }\n\n    return _query.queryFrom(this);\n  };\n\n  _proto.adjustInto = function adjustInto(temporal) {\n    requireNonNull(temporal, 'temporal');\n    return temporal.with(ChronoField.INSTANT_SECONDS, this._seconds).with(ChronoField.NANO_OF_SECOND, this._nanos);\n  };\n\n  _proto.until = function until(endExclusive, unit) {\n    requireNonNull(endExclusive, 'endExclusive');\n    requireNonNull(unit, 'unit');\n    var end = Instant.from(endExclusive);\n\n    if (unit instanceof ChronoUnit) {\n      switch (unit) {\n        case ChronoUnit.NANOS:\n          return this._nanosUntil(end);\n\n        case ChronoUnit.MICROS:\n          return MathUtil.intDiv(this._nanosUntil(end), 1000);\n\n        case ChronoUnit.MILLIS:\n          return MathUtil.safeSubtract(end.toEpochMilli(), this.toEpochMilli());\n\n        case ChronoUnit.SECONDS:\n          return this._secondsUntil(end);\n\n        case ChronoUnit.MINUTES:\n          return MathUtil.intDiv(this._secondsUntil(end), LocalTime.SECONDS_PER_MINUTE);\n\n        case ChronoUnit.HOURS:\n          return MathUtil.intDiv(this._secondsUntil(end), LocalTime.SECONDS_PER_HOUR);\n\n        case ChronoUnit.HALF_DAYS:\n          return MathUtil.intDiv(this._secondsUntil(end), 12 * LocalTime.SECONDS_PER_HOUR);\n\n        case ChronoUnit.DAYS:\n          return MathUtil.intDiv(this._secondsUntil(end), LocalTime.SECONDS_PER_DAY);\n      }\n\n      throw new UnsupportedTemporalTypeException('Unsupported unit: ' + unit);\n    }\n\n    return unit.between(this, end);\n  };\n\n  _proto._nanosUntil = function _nanosUntil(end) {\n    var secsDiff = MathUtil.safeSubtract(end.epochSecond(), this.epochSecond());\n    var totalNanos = MathUtil.safeMultiply(secsDiff, LocalTime.NANOS_PER_SECOND);\n    return MathUtil.safeAdd(totalNanos, end.nano() - this.nano());\n  };\n\n  _proto._secondsUntil = function _secondsUntil(end) {\n    var secsDiff = MathUtil.safeSubtract(end.epochSecond(), this.epochSecond());\n    var nanosDiff = end.nano() - this.nano();\n\n    if (secsDiff > 0 && nanosDiff < 0) {\n      secsDiff--;\n    } else if (secsDiff < 0 && nanosDiff > 0) {\n      secsDiff++;\n    }\n\n    return secsDiff;\n  };\n\n  _proto.atOffset = function atOffset(offset) {\n    return OffsetDateTime.ofInstant(this, offset);\n  };\n\n  _proto.atZone = function atZone(zone) {\n    return ZonedDateTime.ofInstant(this, zone);\n  };\n\n  _proto.toEpochMilli = function toEpochMilli() {\n    var millis = MathUtil.safeMultiply(this._seconds, 1000);\n    return millis + MathUtil.intDiv(this._nanos, NANOS_PER_MILLI);\n  };\n\n  _proto.compareTo = function compareTo(otherInstant) {\n    requireNonNull(otherInstant, 'otherInstant');\n    requireInstance(otherInstant, Instant, 'otherInstant');\n    var cmp = MathUtil.compareNumbers(this._seconds, otherInstant._seconds);\n\n    if (cmp !== 0) {\n      return cmp;\n    }\n\n    return this._nanos - otherInstant._nanos;\n  };\n\n  _proto.isAfter = function isAfter(otherInstant) {\n    return this.compareTo(otherInstant) > 0;\n  };\n\n  _proto.isBefore = function isBefore(otherInstant) {\n    return this.compareTo(otherInstant) < 0;\n  };\n\n  _proto.equals = function equals(other) {\n    if (this === other) {\n      return true;\n    }\n\n    if (other instanceof Instant) {\n      return this.epochSecond() === other.epochSecond() && this.nano() === other.nano();\n    }\n\n    return false;\n  };\n\n  _proto.hashCode = function hashCode() {\n    return MathUtil.hashCode(this._seconds, this._nanos);\n  };\n\n  _proto.toString = function toString() {\n    return DateTimeFormatter.ISO_INSTANT.format(this);\n  };\n\n  _proto.toJSON = function toJSON() {\n    return this.toString();\n  };\n\n  return Instant;\n}(Temporal);\nfunction _init$l() {\n  Instant.MIN_SECONDS = -31619119219200;\n  Instant.MAX_SECONDS = 31494816403199;\n  Instant.EPOCH = new Instant(0, 0);\n  Instant.MIN = Instant.ofEpochSecond(Instant.MIN_SECONDS, 0);\n  Instant.MAX = Instant.ofEpochSecond(Instant.MAX_SECONDS, 999999999);\n  Instant.FROM = createTemporalQuery('Instant.FROM', function (temporal) {\n    return Instant.from(temporal);\n  });\n}\n\nvar Clock = function () {\n  function Clock() {}\n\n  Clock.systemUTC = function systemUTC() {\n    return new SystemClock(ZoneOffset.UTC);\n  };\n\n  Clock.systemDefaultZone = function systemDefaultZone() {\n    return new SystemClock(ZoneId.systemDefault());\n  };\n\n  Clock.system = function system(zone) {\n    return new SystemClock(zone);\n  };\n\n  Clock.fixed = function fixed(fixedInstant, zoneId) {\n    return new FixedClock(fixedInstant, zoneId);\n  };\n\n  Clock.offset = function offset(baseClock, duration) {\n    return new OffsetClock(baseClock, duration);\n  };\n\n  var _proto = Clock.prototype;\n\n  _proto.millis = function millis() {\n    abstractMethodFail('Clock.millis');\n  };\n\n  _proto.instant = function instant() {\n    abstractMethodFail('Clock.instant');\n  };\n\n  _proto.zone = function zone() {\n    abstractMethodFail('Clock.zone');\n  };\n\n  _proto.withZone = function withZone() {\n    abstractMethodFail('Clock.withZone');\n  };\n\n  return Clock;\n}();\n\nvar SystemClock = function (_Clock) {\n  _inheritsLoose(SystemClock, _Clock);\n\n  function SystemClock(zone) {\n    var _this;\n\n    requireNonNull(zone, 'zone');\n    _this = _Clock.call(this) || this;\n    _this._zone = zone;\n    return _this;\n  }\n\n  var _proto2 = SystemClock.prototype;\n\n  _proto2.zone = function zone() {\n    return this._zone;\n  };\n\n  _proto2.millis = function millis() {\n    return new Date().getTime();\n  };\n\n  _proto2.instant = function instant() {\n    return Instant.ofEpochMilli(this.millis());\n  };\n\n  _proto2.equals = function equals(obj) {\n    if (obj instanceof SystemClock) {\n      return this._zone.equals(obj._zone);\n    }\n\n    return false;\n  };\n\n  _proto2.withZone = function withZone(zone) {\n    if (zone.equals(this._zone)) {\n      return this;\n    }\n\n    return new SystemClock(zone);\n  };\n\n  _proto2.toString = function toString() {\n    return 'SystemClock[' + this._zone.toString() + ']';\n  };\n\n  return SystemClock;\n}(Clock);\n\nvar FixedClock = function (_Clock2) {\n  _inheritsLoose(FixedClock, _Clock2);\n\n  function FixedClock(fixedInstant, zoneId) {\n    var _this2;\n\n    _this2 = _Clock2.call(this) || this;\n    _this2._instant = fixedInstant;\n    _this2._zoneId = zoneId;\n    return _this2;\n  }\n\n  var _proto3 = FixedClock.prototype;\n\n  _proto3.instant = function instant() {\n    return this._instant;\n  };\n\n  _proto3.millis = function millis() {\n    return this._instant.toEpochMilli();\n  };\n\n  _proto3.zone = function zone() {\n    return this._zoneId;\n  };\n\n  _proto3.toString = function toString() {\n    return 'FixedClock[]';\n  };\n\n  _proto3.equals = function equals(obj) {\n    if (obj instanceof FixedClock) {\n      return this._instant.equals(obj._instant) && this._zoneId.equals(obj._zoneId);\n    }\n\n    return false;\n  };\n\n  _proto3.withZone = function withZone(zone) {\n    if (zone.equals(this._zoneId)) {\n      return this;\n    }\n\n    return new FixedClock(this._instant, zone);\n  };\n\n  return FixedClock;\n}(Clock);\n\nvar OffsetClock = function (_Clock3) {\n  _inheritsLoose(OffsetClock, _Clock3);\n\n  function OffsetClock(baseClock, offset) {\n    var _this3;\n\n    _this3 = _Clock3.call(this) || this;\n    _this3._baseClock = baseClock;\n    _this3._offset = offset;\n    return _this3;\n  }\n\n  var _proto4 = OffsetClock.prototype;\n\n  _proto4.zone = function zone() {\n    return this._baseClock.zone();\n  };\n\n  _proto4.withZone = function withZone(zone) {\n    if (zone.equals(this._baseClock.zone())) {\n      return this;\n    }\n\n    return new OffsetClock(this._baseClock.withZone(zone), this._offset);\n  };\n\n  _proto4.millis = function millis() {\n    return this._baseClock.millis() + this._offset.toMillis();\n  };\n\n  _proto4.instant = function instant() {\n    return this._baseClock.instant().plus(this._offset);\n  };\n\n  _proto4.equals = function equals(obj) {\n    if (obj instanceof OffsetClock) {\n      return this._baseClock.equals(obj._baseClock) && this._offset.equals(obj._offset);\n    }\n\n    return false;\n  };\n\n  _proto4.toString = function toString() {\n    return 'OffsetClock[' + this._baseClock + ',' + this._offset + ']';\n  };\n\n  return OffsetClock;\n}(Clock);\n\n/*\n * @copyright (c) 2016, Philipp Thürwächter & Pattrick Hüper\n * @copyright (c) 2007-present, Stephen Colebourne & Michael Nascimento Santos\n * @license BSD-3-Clause (see LICENSE in the root directory of this source tree)\n */\nvar ZoneOffsetTransition = function () {\n  ZoneOffsetTransition.of = function of(transition, offsetBefore, offsetAfter) {\n    return new ZoneOffsetTransition(transition, offsetBefore, offsetAfter);\n  };\n\n  function ZoneOffsetTransition(transition, offsetBefore, offsetAfter) {\n    requireNonNull(transition, 'transition');\n    requireNonNull(offsetBefore, 'offsetBefore');\n    requireNonNull(offsetAfter, 'offsetAfter');\n\n    if (offsetBefore.equals(offsetAfter)) {\n      throw new IllegalArgumentException('Offsets must not be equal');\n    }\n\n    if (transition.nano() !== 0) {\n      throw new IllegalArgumentException('Nano-of-second must be zero');\n    }\n\n    if (transition instanceof LocalDateTime) {\n      this._transition = transition;\n    } else {\n      this._transition = LocalDateTime.ofEpochSecond(transition, 0, offsetBefore);\n    }\n\n    this._offsetBefore = offsetBefore;\n    this._offsetAfter = offsetAfter;\n  }\n\n  var _proto = ZoneOffsetTransition.prototype;\n\n  _proto.instant = function instant() {\n    return this._transition.toInstant(this._offsetBefore);\n  };\n\n  _proto.toEpochSecond = function toEpochSecond() {\n    return this._transition.toEpochSecond(this._offsetBefore);\n  };\n\n  _proto.dateTimeBefore = function dateTimeBefore() {\n    return this._transition;\n  };\n\n  _proto.dateTimeAfter = function dateTimeAfter() {\n    return this._transition.plusSeconds(this.durationSeconds());\n  };\n\n  _proto.offsetBefore = function offsetBefore() {\n    return this._offsetBefore;\n  };\n\n  _proto.offsetAfter = function offsetAfter() {\n    return this._offsetAfter;\n  };\n\n  _proto.duration = function duration() {\n    return Duration.ofSeconds(this.durationSeconds());\n  };\n\n  _proto.durationSeconds = function durationSeconds() {\n    return this._offsetAfter.totalSeconds() - this._offsetBefore.totalSeconds();\n  };\n\n  _proto.isGap = function isGap() {\n    return this._offsetAfter.totalSeconds() > this._offsetBefore.totalSeconds();\n  };\n\n  _proto.isOverlap = function isOverlap() {\n    return this._offsetAfter.totalSeconds() < this._offsetBefore.totalSeconds();\n  };\n\n  _proto.isValidOffset = function isValidOffset(offset) {\n    return this.isGap() ? false : this._offsetBefore.equals(offset) || this._offsetAfter.equals(offset);\n  };\n\n  _proto.validOffsets = function validOffsets() {\n    if (this.isGap()) {\n      return [];\n    } else {\n      return [this._offsetBefore, this._offsetAfter];\n    }\n  };\n\n  _proto.compareTo = function compareTo(transition) {\n    return this.instant().compareTo(transition.instant());\n  };\n\n  _proto.equals = function equals(other) {\n    if (other === this) {\n      return true;\n    }\n\n    if (other instanceof ZoneOffsetTransition) {\n      var d = other;\n      return this._transition.equals(d._transition) && this._offsetBefore.equals(d.offsetBefore()) && this._offsetAfter.equals(d.offsetAfter());\n    }\n\n    return false;\n  };\n\n  _proto.hashCode = function hashCode() {\n    return this._transition.hashCode() ^ this._offsetBefore.hashCode() ^ this._offsetAfter.hashCode() >>> 16;\n  };\n\n  _proto.toString = function toString() {\n    return 'Transition[' + (this.isGap() ? 'Gap' : 'Overlap') + ' at ' + this._transition.toString() + this._offsetBefore.toString() + ' to ' + this._offsetAfter + ']';\n  };\n\n  return ZoneOffsetTransition;\n}();\n\n/*\n * @copyright (c) 2016, Philipp Thürwächter & Pattrick Hüper\n * @copyright (c) 2007-present, Stephen Colebourne & Michael Nascimento Santos\n * @license BSD-3-Clause (see LICENSE in the root directory of this source tree)\n */\nfunction _init$m() {\n  TemporalQueries.ZONE_ID = createTemporalQuery('ZONE_ID', function (temporal) {\n    return temporal.query(TemporalQueries.ZONE_ID);\n  });\n  TemporalQueries.CHRONO = createTemporalQuery('CHRONO', function (temporal) {\n    return temporal.query(TemporalQueries.CHRONO);\n  });\n  TemporalQueries.PRECISION = createTemporalQuery('PRECISION', function (temporal) {\n    return temporal.query(TemporalQueries.PRECISION);\n  });\n  TemporalQueries.OFFSET = createTemporalQuery('OFFSET', function (temporal) {\n    if (temporal.isSupported(ChronoField.OFFSET_SECONDS)) {\n      return ZoneOffset.ofTotalSeconds(temporal.get(ChronoField.OFFSET_SECONDS));\n    }\n\n    return null;\n  });\n  TemporalQueries.ZONE = createTemporalQuery('ZONE', function (temporal) {\n    var zone = temporal.query(TemporalQueries.ZONE_ID);\n    return zone != null ? zone : temporal.query(TemporalQueries.OFFSET);\n  });\n  TemporalQueries.LOCAL_DATE = createTemporalQuery('LOCAL_DATE', function (temporal) {\n    if (temporal.isSupported(ChronoField.EPOCH_DAY)) {\n      return LocalDate.ofEpochDay(temporal.getLong(ChronoField.EPOCH_DAY));\n    }\n\n    return null;\n  });\n  TemporalQueries.LOCAL_TIME = createTemporalQuery('LOCAL_TIME', function (temporal) {\n    if (temporal.isSupported(ChronoField.NANO_OF_DAY)) {\n      return LocalTime.ofNanoOfDay(temporal.getLong(ChronoField.NANO_OF_DAY));\n    }\n\n    return null;\n  });\n}\n\nvar SystemDefaultZoneRules = function (_ZoneRules) {\n  _inheritsLoose(SystemDefaultZoneRules, _ZoneRules);\n\n  function SystemDefaultZoneRules() {\n    return _ZoneRules.apply(this, arguments) || this;\n  }\n\n  var _proto = SystemDefaultZoneRules.prototype;\n\n  _proto.isFixedOffset = function isFixedOffset() {\n    return false;\n  };\n\n  _proto.offsetOfInstant = function offsetOfInstant(instant) {\n    var offsetInMinutes = new Date(instant.toEpochMilli()).getTimezoneOffset();\n    return ZoneOffset.ofTotalMinutes(offsetInMinutes * -1);\n  };\n\n  _proto.offsetOfEpochMilli = function offsetOfEpochMilli(epochMilli) {\n    var offsetInMinutes = new Date(epochMilli).getTimezoneOffset();\n    return ZoneOffset.ofTotalMinutes(offsetInMinutes * -1);\n  };\n\n  _proto.offsetOfLocalDateTime = function offsetOfLocalDateTime(localDateTime) {\n    var epochMilli = localDateTime.toEpochSecond(ZoneOffset.UTC) * 1000;\n    var offsetInMinutesBeforePossibleTransition = new Date(epochMilli).getTimezoneOffset();\n    var epochMilliSystemZone = epochMilli + offsetInMinutesBeforePossibleTransition * 60000;\n    var offsetInMinutesAfterPossibleTransition = new Date(epochMilliSystemZone).getTimezoneOffset();\n    return ZoneOffset.ofTotalMinutes(offsetInMinutesAfterPossibleTransition * -1);\n  };\n\n  _proto.validOffsets = function validOffsets(localDateTime) {\n    return [this.offsetOfLocalDateTime(localDateTime)];\n  };\n\n  _proto.transition = function transition() {\n    return null;\n  };\n\n  _proto.standardOffset = function standardOffset(instant) {\n    return this.offsetOfInstant(instant);\n  };\n\n  _proto.daylightSavings = function daylightSavings() {\n    this._throwNotSupported();\n  };\n\n  _proto.isDaylightSavings = function isDaylightSavings() {\n    this._throwNotSupported();\n  };\n\n  _proto.isValidOffset = function isValidOffset(dateTime, offset) {\n    return this.offsetOfLocalDateTime(dateTime).equals(offset);\n  };\n\n  _proto.nextTransition = function nextTransition() {\n    this._throwNotSupported();\n  };\n\n  _proto.previousTransition = function previousTransition() {\n    this._throwNotSupported();\n  };\n\n  _proto.transitions = function transitions() {\n    this._throwNotSupported();\n  };\n\n  _proto.transitionRules = function transitionRules() {\n    this._throwNotSupported();\n  };\n\n  _proto._throwNotSupported = function _throwNotSupported() {\n    throw new DateTimeException('not supported operation');\n  };\n\n  _proto.equals = function equals(other) {\n    if (this === other || other instanceof SystemDefaultZoneRules) {\n      return true;\n    } else {\n      return false;\n    }\n  };\n\n  _proto.toString = function toString() {\n    return 'SYSTEM';\n  };\n\n  return SystemDefaultZoneRules;\n}(ZoneRules);\n\nvar SystemDefaultZoneId = function (_ZoneId) {\n  _inheritsLoose(SystemDefaultZoneId, _ZoneId);\n\n  function SystemDefaultZoneId() {\n    var _this;\n\n    _this = _ZoneId.call(this) || this;\n    _this._rules = new SystemDefaultZoneRules();\n    return _this;\n  }\n\n  var _proto = SystemDefaultZoneId.prototype;\n\n  _proto.rules = function rules() {\n    return this._rules;\n  };\n\n  _proto.equals = function equals(other) {\n    if (this === other) {\n      return true;\n    }\n\n    return false;\n  };\n\n  _proto.id = function id() {\n    return 'SYSTEM';\n  };\n\n  return SystemDefaultZoneId;\n}(ZoneId);\n\n/*\n * @copyright (c) 2016, Philipp Thürwächter & Pattrick Hüper\n * @copyright (c) 2007-present, Stephen Colebourne & Michael Nascimento Santos\n * @license BSD-3-Clause (see LICENSE in the root directory of this source tree)\n */\nvar ZoneIdFactory = function () {\n  function ZoneIdFactory() {}\n\n  ZoneIdFactory.systemDefault = function systemDefault() {\n    return SYSTEM_DEFAULT_ZONE_ID_INSTANCE;\n  };\n\n  ZoneIdFactory.getAvailableZoneIds = function getAvailableZoneIds() {\n    return ZoneRulesProvider.getAvailableZoneIds();\n  };\n\n  ZoneIdFactory.of = function of(zoneId) {\n    requireNonNull(zoneId, 'zoneId');\n\n    if (zoneId === 'Z') {\n      return ZoneOffset.UTC;\n    }\n\n    if (zoneId.length === 1) {\n      throw new DateTimeException('Invalid zone: ' + zoneId);\n    }\n\n    if (StringUtil.startsWith(zoneId, '+') || StringUtil.startsWith(zoneId, '-')) {\n      return ZoneOffset.of(zoneId);\n    }\n\n    if (zoneId === 'UTC' || zoneId === 'GMT' || zoneId === 'GMT0' || zoneId === 'UT') {\n      return new ZoneRegion(zoneId, ZoneOffset.UTC.rules());\n    }\n\n    if (StringUtil.startsWith(zoneId, 'UTC+') || StringUtil.startsWith(zoneId, 'GMT+') || StringUtil.startsWith(zoneId, 'UTC-') || StringUtil.startsWith(zoneId, 'GMT-')) {\n      var offset = ZoneOffset.of(zoneId.substring(3));\n\n      if (offset.totalSeconds() === 0) {\n        return new ZoneRegion(zoneId.substring(0, 3), offset.rules());\n      }\n\n      return new ZoneRegion(zoneId.substring(0, 3) + offset.id(), offset.rules());\n    }\n\n    if (StringUtil.startsWith(zoneId, 'UT+') || StringUtil.startsWith(zoneId, 'UT-')) {\n      var _offset = ZoneOffset.of(zoneId.substring(2));\n\n      if (_offset.totalSeconds() === 0) {\n        return new ZoneRegion('UT', _offset.rules());\n      }\n\n      return new ZoneRegion('UT' + _offset.id(), _offset.rules());\n    }\n\n    if (zoneId === 'SYSTEM') {\n      return ZoneId.systemDefault();\n    }\n\n    return ZoneRegion.ofId(zoneId);\n  };\n\n  ZoneIdFactory.ofOffset = function ofOffset(prefix, offset) {\n    requireNonNull(prefix, 'prefix');\n    requireNonNull(offset, 'offset');\n\n    if (prefix.length === 0) {\n      return offset;\n    }\n\n    if (prefix === 'GMT' || prefix === 'UTC' || prefix === 'UT') {\n      if (offset.totalSeconds() === 0) {\n        return new ZoneRegion(prefix, offset.rules());\n      }\n\n      return new ZoneRegion(prefix + offset.id(), offset.rules());\n    }\n\n    throw new IllegalArgumentException('Invalid prefix, must be GMT, UTC or UT: ' + prefix);\n  };\n\n  ZoneIdFactory.from = function from(temporal) {\n    requireNonNull(temporal, 'temporal');\n    var obj = temporal.query(TemporalQueries.zone());\n\n    if (obj == null) {\n      throw new DateTimeException('Unable to obtain ZoneId from TemporalAccessor: ' + temporal + ', type ' + (temporal.constructor != null ? temporal.constructor.name : ''));\n    }\n\n    return obj;\n  };\n\n  return ZoneIdFactory;\n}();\nvar SYSTEM_DEFAULT_ZONE_ID_INSTANCE = null;\nfunction _init$n() {\n  SYSTEM_DEFAULT_ZONE_ID_INSTANCE = new SystemDefaultZoneId();\n  ZoneId.systemDefault = ZoneIdFactory.systemDefault;\n  ZoneId.getAvailableZoneIds = ZoneIdFactory.getAvailableZoneIds;\n  ZoneId.of = ZoneIdFactory.of;\n  ZoneId.ofOffset = ZoneIdFactory.ofOffset;\n  ZoneId.from = ZoneIdFactory.from;\n  ZoneOffset.from = ZoneIdFactory.from;\n  ZoneId.SYSTEM = SYSTEM_DEFAULT_ZONE_ID_INSTANCE;\n  ZoneId.UTC = ZoneOffset.ofTotalSeconds(0);\n}\n\n/*\n * @copyright (c) 2016, Philipp Thürwächter & Pattrick Hüper\n * @license BSD-3-Clause (see LICENSE in the root directory of this source tree)\n */\nvar isInit = false;\n\nfunction init() {\n  if (isInit) {\n    return;\n  }\n\n  isInit = true;\n  _init$1();\n  _init();\n  _init$2();\n  _init$3();\n  _init$k();\n  _init$8();\n  _init$m();\n  _init$4();\n  _init$l();\n  _init$i();\n  _init$j();\n  _init$d();\n  _init$5();\n  _init$c();\n  _init$b();\n  _init$6();\n  _init$7();\n  _init$g();\n  _init$n();\n  _init$e();\n  _init$a();\n  _init$9();\n  _init$h();\n  _init$f();\n}\n\ninit();\n\n/*\n * @copyright (c) 2016, Philipp Thürwächter & Pattrick Hüper\n * @license BSD-3-Clause (see LICENSE in the root directory of this source tree)\n */\n\nvar ToNativeJsConverter = function () {\n  function ToNativeJsConverter(temporal, zone) {\n    var zonedDateTime;\n\n    if (temporal instanceof LocalDate) {\n      zone = zone == null ? ZoneId.systemDefault() : zone;\n      zonedDateTime = temporal.atStartOfDay(zone);\n    } else if (temporal instanceof LocalDateTime) {\n      zone = zone == null ? ZoneId.systemDefault() : zone;\n      zonedDateTime = temporal.atZone(zone);\n    } else if (temporal instanceof ZonedDateTime) {\n      if (zone == null) {\n        zonedDateTime = temporal;\n      } else {\n        zonedDateTime = temporal.withZoneSameInstant(zone);\n      }\n    } else {\n      throw new IllegalArgumentException('unsupported instance for convert operation:' + temporal);\n    }\n\n    this.instant = zonedDateTime.toInstant();\n  }\n\n  var _proto = ToNativeJsConverter.prototype;\n\n  _proto.toDate = function toDate() {\n    return new Date(this.instant.toEpochMilli());\n  };\n\n  _proto.toEpochMilli = function toEpochMilli() {\n    return this.instant.toEpochMilli();\n  };\n\n  return ToNativeJsConverter;\n}();\n\nfunction convert(temporal, zone) {\n  return new ToNativeJsConverter(temporal, zone);\n}\n\nvar NativeJsTemporal = function (_TemporalAccessor) {\n  _inheritsLoose(NativeJsTemporal, _TemporalAccessor);\n\n  function NativeJsTemporal(date, zone) {\n    var _this;\n\n    if (zone === void 0) {\n      zone = ZoneId.systemDefault();\n    }\n\n    _this = _TemporalAccessor.call(this) || this;\n    _this._zone = zone;\n\n    if (date instanceof Date) {\n      _this._epochMilli = date.getTime();\n      return _assertThisInitialized(_this);\n    } else if (typeof date.toDate === 'function' && date.toDate() instanceof Date) {\n      _this._epochMilli = date.toDate().getTime();\n      return _assertThisInitialized(_this);\n    }\n\n    assert(false, 'date must be either a javascript date or a moment');\n    return _this;\n  }\n\n  var _proto = NativeJsTemporal.prototype;\n\n  _proto.query = function query(_query) {\n    requireNonNull(_query, 'query');\n\n    if (_query === TemporalQueries.localDate()) {\n      return LocalDate.ofInstant(Instant.ofEpochMilli(this._epochMilli), this._zone);\n    } else if (_query === TemporalQueries.localTime()) {\n      return LocalTime.ofInstant(Instant.ofEpochMilli(this._epochMilli), this._zone);\n    } else if (_query === TemporalQueries.zone()) {\n      return this._zone;\n    }\n\n    return _TemporalAccessor.prototype.query.call(this, _query);\n  };\n\n  _proto.get = function get(field) {\n    return this.getLong(field);\n  };\n\n  _proto.getLong = function getLong(field) {\n    requireNonNull(field, 'field');\n\n    if (field instanceof ChronoField) {\n      switch (field) {\n        case ChronoField.NANO_OF_SECOND:\n          return MathUtil.floorMod(this._epochMilli, 1000) * 1000000;\n\n        case ChronoField.INSTANT_SECONDS:\n          return MathUtil.floorDiv(this._epochMilli, 1000);\n      }\n\n      throw new UnsupportedTemporalTypeException('Unsupported field: ' + field);\n    }\n\n    return field.getFrom(this);\n  };\n\n  _proto.isSupported = function isSupported(field) {\n    return field === ChronoField.INSTANT_SECONDS || field === ChronoField.NANO_OF_SECOND;\n  };\n\n  return NativeJsTemporal;\n}(TemporalAccessor);\n\nfunction nativeJs(date, zone) {\n  return new NativeJsTemporal(date, zone);\n}\n\nfunction bindUse(jsJoda) {\n  var used = [];\n  return function use(fn) {\n    if (!~used.indexOf(fn)) {\n      fn(jsJoda);\n      used.push(fn);\n    }\n\n    return jsJoda;\n  };\n}\n\n/**\n * @copyright (c) 2016, Philipp Thürwächter & Pattrick Hüper\n * @license BSD-3-Clause (see LICENSE in the root directory of this source tree)\n */\nvar _ = {\n  assert: assert$1,\n  DateTimeBuilder: DateTimeBuilder,\n  DateTimeParseContext: DateTimeParseContext,\n  DateTimePrintContext: DateTimePrintContext,\n  MathUtil: MathUtil,\n  StringUtil: StringUtil,\n  StringBuilder: StringBuilder\n};\nvar jsJodaExports = {\n  _: _,\n  convert: convert,\n  nativeJs: nativeJs,\n  ArithmeticException: ArithmeticException,\n  DateTimeException: DateTimeException,\n  DateTimeParseException: DateTimeParseException,\n  IllegalArgumentException: IllegalArgumentException,\n  IllegalStateException: IllegalStateException,\n  UnsupportedTemporalTypeException: UnsupportedTemporalTypeException,\n  NullPointerException: NullPointerException,\n  Clock: Clock,\n  DayOfWeek: DayOfWeek,\n  Duration: Duration,\n  Instant: Instant,\n  LocalDate: LocalDate,\n  LocalTime: LocalTime,\n  LocalDateTime: LocalDateTime,\n  OffsetTime: OffsetTime,\n  OffsetDateTime: OffsetDateTime,\n  Month: Month,\n  MonthDay: MonthDay,\n  Period: Period,\n  Year: Year,\n  YearConstants: YearConstants,\n  YearMonth: YearMonth,\n  ZonedDateTime: ZonedDateTime,\n  ZoneOffset: ZoneOffset,\n  ZoneId: ZoneId,\n  ZoneRegion: ZoneRegion,\n  ZoneOffsetTransition: ZoneOffsetTransition,\n  ZoneRules: ZoneRules,\n  ZoneRulesProvider: ZoneRulesProvider,\n  ChronoLocalDate: ChronoLocalDate,\n  ChronoLocalDateTime: ChronoLocalDateTime,\n  ChronoZonedDateTime: ChronoZonedDateTime,\n  IsoChronology: IsoChronology,\n  ChronoField: ChronoField,\n  ChronoUnit: ChronoUnit,\n  IsoFields: IsoFields,\n  Temporal: Temporal,\n  TemporalAccessor: TemporalAccessor,\n  TemporalAdjuster: TemporalAdjuster,\n  TemporalAdjusters: TemporalAdjusters,\n  TemporalAmount: TemporalAmount,\n  TemporalField: TemporalField,\n  TemporalQueries: TemporalQueries,\n  TemporalQuery: TemporalQuery,\n  TemporalUnit: TemporalUnit,\n  ValueRange: ValueRange,\n  DateTimeFormatter: DateTimeFormatter,\n  DateTimeFormatterBuilder: DateTimeFormatterBuilder,\n  DecimalStyle: DecimalStyle,\n  ResolverStyle: ResolverStyle,\n  SignStyle: SignStyle,\n  TextStyle: TextStyle\n};\nvar use = bindUse(jsJodaExports);\njsJodaExports.use = use;\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vLi4vbm9kZV9tb2R1bGVzL0Bqcy1qb2RhL2NvcmUvZGlzdC9qcy1qb2RhLmVzbS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSwyRUFBMkUsYUFBYTtBQUN4RjtBQUNBOztBQUVBLHlDQUF5QyxzQkFBc0I7QUFDL0Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxDQUFDO0FBQ0Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsK0hBQStILElBQUk7QUFDbkk7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxDQUFDOztBQUVEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxrQkFBa0Isd0JBQXdCO0FBQzFDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLGtCQUFrQix5QkFBeUI7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG9CQUFvQixrQkFBa0I7QUFDdEM7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsb0JBQW9CLG9CQUFvQjtBQUN4QztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxDQUFDOztBQUVEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxvQkFBb0IsU0FBUztBQUM3QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxpRUFBaUU7QUFDakU7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLGtFQUFrRTtBQUNsRTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsTUFBTTtBQUNOOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLFlBQVk7QUFDWjtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsb0JBQW9CLFlBQVk7QUFDaEM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxDQUFDOztBQUVEO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7O0FBRUE7QUFDQSxRQUFRO0FBQ1I7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxDQUFDOztBQUVEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLE1BQU07QUFDTjs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxDQUFDOztBQUVEO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLG9CQUFvQix3QkFBd0I7QUFDNUM7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLENBQUM7QUFDRDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0Esc0JBQXNCLGlDQUFpQztBQUN2RDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsc0JBQXNCLGlDQUFpQztBQUN2RDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTix1QkFBdUIsa0NBQWtDO0FBQ3pEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxzQkFBc0IsaUNBQWlDO0FBQ3ZEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx3QkFBd0IsbUJBQW1CO0FBQzNDO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG9CQUFvQixpQ0FBaUM7QUFDckQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsdUJBQXVCLFVBQVU7QUFDakM7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLG9CQUFvQixxQkFBcUI7QUFDekM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLENBQUM7QUFDRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBLG9CQUFvQiwwQkFBMEI7QUFDOUM7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBLG9CQUFvQiwwQkFBMEI7QUFDOUM7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsQ0FBQzs7QUFFRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHNCQUFzQixzQkFBc0I7QUFDNUM7O0FBRUE7QUFDQTs7QUFFQSxlQUFlLHFEQUFxRDtBQUNwRTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLHFCQUFxQixxREFBcUQ7QUFDMUU7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0EsWUFBWTtBQUNaO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBOztBQUVBO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7O0FBRUE7QUFDQSxRQUFRO0FBQ1I7O0FBRUEsZUFBZSxzQkFBc0I7QUFDckM7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBOztBQUVBO0FBQ0EsUUFBUSxtQkFBbUIsZUFBZTtBQUMxQztBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxVQUFVO0FBQ1Y7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxDQUFDO0FBQ0Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUEsc0JBQXNCLHlFQUF5RTtBQUMvRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxDQUFDOztBQUVEO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7O0FBRUE7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBOztBQUVBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsUUFBUTtBQUNSOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOOztBQUVBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7O0FBRUEscUJBQXFCLFdBQVc7QUFDaEM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxDQUFDOztBQUVEO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRXd6QiIsInNvdXJjZXMiOlsid2VicGFjazovL3dlYi1hcHAvLi4vLi4vbm9kZV9tb2R1bGVzL0Bqcy1qb2RhL2NvcmUvZGlzdC9qcy1qb2RhLmVzbS5qcz9kMDEyIl0sInNvdXJjZXNDb250ZW50IjpbIi8vISBAdmVyc2lvbiBAanMtam9kYS9jb3JlIC0gMy4yLjBcbi8vISBAY29weXJpZ2h0IChjKSAyMDE1LXByZXNlbnQsIFBoaWxpcHAgVGjDvHJ3w6RjaHRlciwgUGF0dHJpY2sgSMO8cGVyICYganMtam9kYSBjb250cmlidXRvcnNcbi8vISBAY29weXJpZ2h0IChjKSAyMDA3LXByZXNlbnQsIFN0ZXBoZW4gQ29sZWJvdXJuZSAmIE1pY2hhZWwgTmFzY2ltZW50byBTYW50b3Ncbi8vISBAbGljZW5zZSBCU0QtMy1DbGF1c2UgKHNlZSBMSUNFTlNFIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlKVxuXG4vKipcbiAqIEBjb3B5cmlnaHQgKGMpIDIwMTYsIFBoaWxpcHAgVGjDvHJ3w6RjaHRlciAmIFBhdHRyaWNrIEjDvHBlclxuICogQGxpY2Vuc2UgQlNELTMtQ2xhdXNlIChzZWUgTElDRU5TRSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZSlcbiAqL1xuZnVuY3Rpb24gY3JlYXRlRXJyb3JUeXBlKG5hbWUsIGluaXQsIHN1cGVyRXJyb3JDbGFzcykge1xuICBpZiAoc3VwZXJFcnJvckNsYXNzID09PSB2b2lkIDApIHtcbiAgICBzdXBlckVycm9yQ2xhc3MgPSBFcnJvcjtcbiAgfVxuXG4gIGZ1bmN0aW9uIEpzSm9kYUV4Y2VwdGlvbihtZXNzYWdlKSB7XG4gICAgaWYgKCFFcnJvci5jYXB0dXJlU3RhY2tUcmFjZSkge1xuICAgICAgdGhpcy5zdGFjayA9IG5ldyBFcnJvcigpLnN0YWNrO1xuICAgIH0gZWxzZSB7XG4gICAgICBFcnJvci5jYXB0dXJlU3RhY2tUcmFjZSh0aGlzLCB0aGlzLmNvbnN0cnVjdG9yKTtcbiAgICB9XG5cbiAgICB0aGlzLm1lc3NhZ2UgPSBtZXNzYWdlO1xuICAgIGluaXQgJiYgaW5pdC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXG4gICAgdGhpcy50b1N0cmluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLm5hbWUgKyBcIjogXCIgKyB0aGlzLm1lc3NhZ2U7XG4gICAgfTtcbiAgfVxuXG4gIEpzSm9kYUV4Y2VwdGlvbi5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyRXJyb3JDbGFzcy5wcm90b3R5cGUpO1xuICBKc0pvZGFFeGNlcHRpb24ucHJvdG90eXBlLm5hbWUgPSBuYW1lO1xuICBKc0pvZGFFeGNlcHRpb24ucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gSnNKb2RhRXhjZXB0aW9uO1xuICByZXR1cm4gSnNKb2RhRXhjZXB0aW9uO1xufVxuXG52YXIgRGF0ZVRpbWVFeGNlcHRpb24gPSBjcmVhdGVFcnJvclR5cGUoJ0RhdGVUaW1lRXhjZXB0aW9uJywgbWVzc2FnZVdpdGhDYXVzZSk7XG52YXIgRGF0ZVRpbWVQYXJzZUV4Y2VwdGlvbiA9IGNyZWF0ZUVycm9yVHlwZSgnRGF0ZVRpbWVQYXJzZUV4Y2VwdGlvbicsIG1lc3NhZ2VGb3JEYXRlVGltZVBhcnNlRXhjZXB0aW9uKTtcbnZhciBVbnN1cHBvcnRlZFRlbXBvcmFsVHlwZUV4Y2VwdGlvbiA9IGNyZWF0ZUVycm9yVHlwZSgnVW5zdXBwb3J0ZWRUZW1wb3JhbFR5cGVFeGNlcHRpb24nLCBudWxsLCBEYXRlVGltZUV4Y2VwdGlvbik7XG52YXIgQXJpdGhtZXRpY0V4Y2VwdGlvbiA9IGNyZWF0ZUVycm9yVHlwZSgnQXJpdGhtZXRpY0V4Y2VwdGlvbicpO1xudmFyIElsbGVnYWxBcmd1bWVudEV4Y2VwdGlvbiA9IGNyZWF0ZUVycm9yVHlwZSgnSWxsZWdhbEFyZ3VtZW50RXhjZXB0aW9uJyk7XG52YXIgSWxsZWdhbFN0YXRlRXhjZXB0aW9uID0gY3JlYXRlRXJyb3JUeXBlKCdJbGxlZ2FsU3RhdGVFeGNlcHRpb24nKTtcbnZhciBOdWxsUG9pbnRlckV4Y2VwdGlvbiA9IGNyZWF0ZUVycm9yVHlwZSgnTnVsbFBvaW50ZXJFeGNlcHRpb24nKTtcblxuZnVuY3Rpb24gbWVzc2FnZVdpdGhDYXVzZShtZXNzYWdlLCBjYXVzZSkge1xuICBpZiAoY2F1c2UgPT09IHZvaWQgMCkge1xuICAgIGNhdXNlID0gbnVsbDtcbiAgfVxuXG4gIHZhciBtc2cgPSBtZXNzYWdlIHx8IHRoaXMubmFtZTtcblxuICBpZiAoY2F1c2UgIT09IG51bGwgJiYgY2F1c2UgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgIG1zZyArPSAnXFxuLS0tLS0tLVxcbkNhdXNlZCBieTogJyArIGNhdXNlLnN0YWNrICsgJ1xcbi0tLS0tLS1cXG4nO1xuICB9XG5cbiAgdGhpcy5tZXNzYWdlID0gbXNnO1xufVxuXG5mdW5jdGlvbiBtZXNzYWdlRm9yRGF0ZVRpbWVQYXJzZUV4Y2VwdGlvbihtZXNzYWdlLCB0ZXh0LCBpbmRleCwgY2F1c2UpIHtcbiAgaWYgKHRleHQgPT09IHZvaWQgMCkge1xuICAgIHRleHQgPSAnJztcbiAgfVxuXG4gIGlmIChpbmRleCA9PT0gdm9pZCAwKSB7XG4gICAgaW5kZXggPSAwO1xuICB9XG5cbiAgaWYgKGNhdXNlID09PSB2b2lkIDApIHtcbiAgICBjYXVzZSA9IG51bGw7XG4gIH1cblxuICB2YXIgbXNnID0gbWVzc2FnZSB8fCB0aGlzLm5hbWU7XG4gIG1zZyArPSAnOiAnICsgdGV4dCArICcsIGF0IGluZGV4OiAnICsgaW5kZXg7XG5cbiAgaWYgKGNhdXNlICE9PSBudWxsICYmIGNhdXNlIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICBtc2cgKz0gJ1xcbi0tLS0tLS1cXG5DYXVzZWQgYnk6ICcgKyBjYXVzZS5zdGFjayArICdcXG4tLS0tLS0tXFxuJztcbiAgfVxuXG4gIHRoaXMubWVzc2FnZSA9IG1zZztcblxuICB0aGlzLnBhcnNlZFN0cmluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGV4dDtcbiAgfTtcblxuICB0aGlzLmVycm9ySW5kZXggPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIGluZGV4O1xuICB9O1xufVxuXG5mdW5jdGlvbiBfaW5oZXJpdHNMb29zZShzdWJDbGFzcywgc3VwZXJDbGFzcykge1xuICBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MucHJvdG90eXBlKTtcbiAgc3ViQ2xhc3MucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gc3ViQ2xhc3M7XG4gIHN1YkNsYXNzLl9fcHJvdG9fXyA9IHN1cGVyQ2xhc3M7XG59XG5cbmZ1bmN0aW9uIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoc2VsZikge1xuICBpZiAoc2VsZiA9PT0gdm9pZCAwKSB7XG4gICAgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpO1xuICB9XG5cbiAgcmV0dXJuIHNlbGY7XG59XG5cbi8qKlxuICogQGNvcHlyaWdodCAoYykgMjAxNiwgUGhpbGlwcCBUaMO8cnfDpGNodGVyICYgUGF0dHJpY2sgSMO8cGVyXG4gKiBAbGljZW5zZSBCU0QtMy1DbGF1c2UgKHNlZSBMSUNFTlNFIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlKVxuICovXG5mdW5jdGlvbiBhc3NlcnQoYXNzZXJ0aW9uLCBtc2csIGVycm9yKSB7XG4gIGlmICghYXNzZXJ0aW9uKSB7XG4gICAgaWYgKGVycm9yKSB7XG4gICAgICB0aHJvdyBuZXcgZXJyb3IobXNnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKG1zZyk7XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiByZXF1aXJlTm9uTnVsbCh2YWx1ZSwgcGFyYW1ldGVyTmFtZSkge1xuICBpZiAodmFsdWUgPT0gbnVsbCkge1xuICAgIHRocm93IG5ldyBOdWxsUG9pbnRlckV4Y2VwdGlvbihwYXJhbWV0ZXJOYW1lICsgJyBtdXN0IG5vdCBiZSBudWxsJyk7XG4gIH1cblxuICByZXR1cm4gdmFsdWU7XG59XG5mdW5jdGlvbiByZXF1aXJlSW5zdGFuY2UodmFsdWUsIF9jbGFzcywgcGFyYW1ldGVyTmFtZSkge1xuICBpZiAoISh2YWx1ZSBpbnN0YW5jZW9mIF9jbGFzcykpIHtcbiAgICB0aHJvdyBuZXcgSWxsZWdhbEFyZ3VtZW50RXhjZXB0aW9uKHBhcmFtZXRlck5hbWUgKyAnIG11c3QgYmUgYW4gaW5zdGFuY2Ugb2YgJyArIChfY2xhc3MubmFtZSA/IF9jbGFzcy5uYW1lIDogX2NsYXNzKSArICh2YWx1ZSAmJiB2YWx1ZS5jb25zdHJ1Y3RvciAmJiB2YWx1ZS5jb25zdHJ1Y3Rvci5uYW1lID8gJywgYnV0IGlzICcgKyB2YWx1ZS5jb25zdHJ1Y3Rvci5uYW1lIDogJycpKTtcbiAgfVxuXG4gIHJldHVybiB2YWx1ZTtcbn1cbmZ1bmN0aW9uIGFic3RyYWN0TWV0aG9kRmFpbChtZXRob2ROYW1lKSB7XG4gIHRocm93IG5ldyBUeXBlRXJyb3IoJ2Fic3RyYWN0IG1ldGhvZCBcIicgKyBtZXRob2ROYW1lICsgJ1wiIGlzIG5vdCBpbXBsZW1lbnRlZCcpO1xufVxuXG52YXIgYXNzZXJ0JDEgPSAvKiNfX1BVUkVfXyovT2JqZWN0LmZyZWV6ZSh7XG4gICAgX19wcm90b19fOiBudWxsLFxuICAgIGFzc2VydDogYXNzZXJ0LFxuICAgIHJlcXVpcmVOb25OdWxsOiByZXF1aXJlTm9uTnVsbCxcbiAgICByZXF1aXJlSW5zdGFuY2U6IHJlcXVpcmVJbnN0YW5jZSxcbiAgICBhYnN0cmFjdE1ldGhvZEZhaWw6IGFic3RyYWN0TWV0aG9kRmFpbFxufSk7XG5cbi8qKlxuICogQGNvcHlyaWdodCAoYykgMjAxNiwgUGhpbGlwcCBUaMO8cnfDpGNodGVyICYgUGF0dHJpY2sgSMO8cGVyXG4gKiBAY29weXJpZ2h0IChjKSAyMDA3LXByZXNlbnQsIFN0ZXBoZW4gQ29sZWJvdXJuZSAmIE1pY2hhZWwgTmFzY2ltZW50byBTYW50b3NcbiAqIEBsaWNlbnNlIEJTRC0zLUNsYXVzZSAoc2VlIExJQ0VOU0UgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUpXG4gKi9cbnZhciBNQVhfU0FGRV9JTlRFR0VSID0gOTAwNzE5OTI1NDc0MDk5MTtcbnZhciBNSU5fU0FGRV9JTlRFR0VSID0gLTkwMDcxOTkyNTQ3NDA5OTE7XG52YXIgTWF0aFV0aWwgPSBmdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIE1hdGhVdGlsKCkge31cblxuICBNYXRoVXRpbC5pbnREaXYgPSBmdW5jdGlvbiBpbnREaXYoeCwgeSkge1xuICAgIHZhciByID0geCAvIHk7XG4gICAgciA9IE1hdGhVdGlsLnJvdW5kRG93bihyKTtcbiAgICByZXR1cm4gTWF0aFV0aWwuc2FmZVplcm8ocik7XG4gIH07XG5cbiAgTWF0aFV0aWwuaW50TW9kID0gZnVuY3Rpb24gaW50TW9kKHgsIHkpIHtcbiAgICB2YXIgciA9IHggLSBNYXRoVXRpbC5pbnREaXYoeCwgeSkgKiB5O1xuICAgIHIgPSBNYXRoVXRpbC5yb3VuZERvd24ocik7XG4gICAgcmV0dXJuIE1hdGhVdGlsLnNhZmVaZXJvKHIpO1xuICB9O1xuXG4gIE1hdGhVdGlsLnJvdW5kRG93biA9IGZ1bmN0aW9uIHJvdW5kRG93bihyKSB7XG4gICAgaWYgKHIgPCAwKSB7XG4gICAgICByZXR1cm4gTWF0aC5jZWlsKHIpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gTWF0aC5mbG9vcihyKTtcbiAgICB9XG4gIH07XG5cbiAgTWF0aFV0aWwuZmxvb3JEaXYgPSBmdW5jdGlvbiBmbG9vckRpdih4LCB5KSB7XG4gICAgdmFyIHIgPSBNYXRoLmZsb29yKHggLyB5KTtcbiAgICByZXR1cm4gTWF0aFV0aWwuc2FmZVplcm8ocik7XG4gIH07XG5cbiAgTWF0aFV0aWwuZmxvb3JNb2QgPSBmdW5jdGlvbiBmbG9vck1vZCh4LCB5KSB7XG4gICAgdmFyIHIgPSB4IC0gTWF0aFV0aWwuZmxvb3JEaXYoeCwgeSkgKiB5O1xuICAgIHJldHVybiBNYXRoVXRpbC5zYWZlWmVybyhyKTtcbiAgfTtcblxuICBNYXRoVXRpbC5zYWZlQWRkID0gZnVuY3Rpb24gc2FmZUFkZCh4LCB5KSB7XG4gICAgTWF0aFV0aWwudmVyaWZ5SW50KHgpO1xuICAgIE1hdGhVdGlsLnZlcmlmeUludCh5KTtcblxuICAgIGlmICh4ID09PSAwKSB7XG4gICAgICByZXR1cm4gTWF0aFV0aWwuc2FmZVplcm8oeSk7XG4gICAgfVxuXG4gICAgaWYgKHkgPT09IDApIHtcbiAgICAgIHJldHVybiBNYXRoVXRpbC5zYWZlWmVybyh4KTtcbiAgICB9XG5cbiAgICB2YXIgciA9IE1hdGhVdGlsLnNhZmVUb0ludCh4ICsgeSk7XG5cbiAgICBpZiAociA9PT0geCB8fCByID09PSB5KSB7XG4gICAgICB0aHJvdyBuZXcgQXJpdGhtZXRpY0V4Y2VwdGlvbignSW52YWxpZCBhZGRpdGlvbiBiZXlvbmQgTUFYX1NBRkVfSU5URUdFUiEnKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcjtcbiAgfTtcblxuICBNYXRoVXRpbC5zYWZlU3VidHJhY3QgPSBmdW5jdGlvbiBzYWZlU3VidHJhY3QoeCwgeSkge1xuICAgIE1hdGhVdGlsLnZlcmlmeUludCh4KTtcbiAgICBNYXRoVXRpbC52ZXJpZnlJbnQoeSk7XG5cbiAgICBpZiAoeCA9PT0gMCAmJiB5ID09PSAwKSB7XG4gICAgICByZXR1cm4gMDtcbiAgICB9IGVsc2UgaWYgKHggPT09IDApIHtcbiAgICAgIHJldHVybiBNYXRoVXRpbC5zYWZlWmVybygtMSAqIHkpO1xuICAgIH0gZWxzZSBpZiAoeSA9PT0gMCkge1xuICAgICAgcmV0dXJuIE1hdGhVdGlsLnNhZmVaZXJvKHgpO1xuICAgIH1cblxuICAgIHJldHVybiBNYXRoVXRpbC5zYWZlVG9JbnQoeCAtIHkpO1xuICB9O1xuXG4gIE1hdGhVdGlsLnNhZmVNdWx0aXBseSA9IGZ1bmN0aW9uIHNhZmVNdWx0aXBseSh4LCB5KSB7XG4gICAgTWF0aFV0aWwudmVyaWZ5SW50KHgpO1xuICAgIE1hdGhVdGlsLnZlcmlmeUludCh5KTtcblxuICAgIGlmICh4ID09PSAxKSB7XG4gICAgICByZXR1cm4gTWF0aFV0aWwuc2FmZVplcm8oeSk7XG4gICAgfVxuXG4gICAgaWYgKHkgPT09IDEpIHtcbiAgICAgIHJldHVybiBNYXRoVXRpbC5zYWZlWmVybyh4KTtcbiAgICB9XG5cbiAgICBpZiAoeCA9PT0gMCB8fCB5ID09PSAwKSB7XG4gICAgICByZXR1cm4gMDtcbiAgICB9XG5cbiAgICB2YXIgciA9IE1hdGhVdGlsLnNhZmVUb0ludCh4ICogeSk7XG5cbiAgICBpZiAociAvIHkgIT09IHggfHwgeCA9PT0gTUlOX1NBRkVfSU5URUdFUiAmJiB5ID09PSAtMSB8fCB5ID09PSBNSU5fU0FGRV9JTlRFR0VSICYmIHggPT09IC0xKSB7XG4gICAgICB0aHJvdyBuZXcgQXJpdGhtZXRpY0V4Y2VwdGlvbignTXVsdGlwbGljYXRpb24gb3ZlcmZsb3dzOiAnICsgeCArICcgKiAnICsgeSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHI7XG4gIH07XG5cbiAgTWF0aFV0aWwucGFyc2VJbnQgPSBmdW5jdGlvbiAoX3BhcnNlSW50KSB7XG4gICAgZnVuY3Rpb24gcGFyc2VJbnQoX3gpIHtcbiAgICAgIHJldHVybiBfcGFyc2VJbnQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG5cbiAgICBwYXJzZUludC50b1N0cmluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBfcGFyc2VJbnQudG9TdHJpbmcoKTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIHBhcnNlSW50O1xuICB9KGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgIHZhciByID0gcGFyc2VJbnQodmFsdWUpO1xuICAgIHJldHVybiBNYXRoVXRpbC5zYWZlVG9JbnQocik7XG4gIH0pO1xuXG4gIE1hdGhVdGlsLnNhZmVUb0ludCA9IGZ1bmN0aW9uIHNhZmVUb0ludCh2YWx1ZSkge1xuICAgIE1hdGhVdGlsLnZlcmlmeUludCh2YWx1ZSk7XG4gICAgcmV0dXJuIE1hdGhVdGlsLnNhZmVaZXJvKHZhbHVlKTtcbiAgfTtcblxuICBNYXRoVXRpbC52ZXJpZnlJbnQgPSBmdW5jdGlvbiB2ZXJpZnlJbnQodmFsdWUpIHtcbiAgICBpZiAodmFsdWUgPT0gbnVsbCkge1xuICAgICAgdGhyb3cgbmV3IEFyaXRobWV0aWNFeGNlcHRpb24oXCJJbnZhbGlkIHZhbHVlOiAnXCIgKyB2YWx1ZSArIFwiJywgdXNpbmcgbnVsbCBvciB1bmRlZmluZWQgYXMgYXJndW1lbnRcIik7XG4gICAgfVxuXG4gICAgaWYgKGlzTmFOKHZhbHVlKSkge1xuICAgICAgdGhyb3cgbmV3IEFyaXRobWV0aWNFeGNlcHRpb24oJ0ludmFsaWQgaW50IHZhbHVlLCB1c2luZyBOYU4gYXMgYXJndW1lbnQnKTtcbiAgICB9XG5cbiAgICBpZiAodmFsdWUgJSAxICE9PSAwKSB7XG4gICAgICB0aHJvdyBuZXcgQXJpdGhtZXRpY0V4Y2VwdGlvbihcIkludmFsaWQgdmFsdWU6ICdcIiArIHZhbHVlICsgXCInIGlzIGEgZmxvYXRcIik7XG4gICAgfVxuXG4gICAgaWYgKHZhbHVlID4gTUFYX1NBRkVfSU5URUdFUiB8fCB2YWx1ZSA8IE1JTl9TQUZFX0lOVEVHRVIpIHtcbiAgICAgIHRocm93IG5ldyBBcml0aG1ldGljRXhjZXB0aW9uKCdDYWxjdWxhdGlvbiBvdmVyZmxvd3MgYW4gaW50OiAnICsgdmFsdWUpO1xuICAgIH1cbiAgfTtcblxuICBNYXRoVXRpbC5zYWZlWmVybyA9IGZ1bmN0aW9uIHNhZmVaZXJvKHZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlID09PSAwID8gMCA6ICt2YWx1ZTtcbiAgfTtcblxuICBNYXRoVXRpbC5jb21wYXJlTnVtYmVycyA9IGZ1bmN0aW9uIGNvbXBhcmVOdW1iZXJzKGEsIGIpIHtcbiAgICBpZiAoYSA8IGIpIHtcbiAgICAgIHJldHVybiAtMTtcbiAgICB9XG5cbiAgICBpZiAoYSA+IGIpIHtcbiAgICAgIHJldHVybiAxO1xuICAgIH1cblxuICAgIHJldHVybiAwO1xuICB9O1xuXG4gIE1hdGhVdGlsLnNtaSA9IGZ1bmN0aW9uIHNtaShpbnQpIHtcbiAgICByZXR1cm4gaW50ID4+PiAxICYgMHg0MDAwMDAwMCB8IGludCAmIDB4QkZGRkZGRkY7XG4gIH07XG5cbiAgTWF0aFV0aWwuaGFzaCA9IGZ1bmN0aW9uIGhhc2gobnVtYmVyKSB7XG4gICAgaWYgKG51bWJlciAhPT0gbnVtYmVyIHx8IG51bWJlciA9PT0gSW5maW5pdHkpIHtcbiAgICAgIHJldHVybiAwO1xuICAgIH1cblxuICAgIHZhciByZXN1bHQgPSBudW1iZXI7XG5cbiAgICB3aGlsZSAobnVtYmVyID4gMHhGRkZGRkZGRikge1xuICAgICAgbnVtYmVyIC89IDB4RkZGRkZGRkY7XG4gICAgICByZXN1bHQgXj0gbnVtYmVyO1xuICAgIH1cblxuICAgIHJldHVybiBNYXRoVXRpbC5zbWkocmVzdWx0KTtcbiAgfTtcblxuICBNYXRoVXRpbC5oYXNoQ29kZSA9IGZ1bmN0aW9uIGhhc2hDb2RlKCkge1xuICAgIHZhciByZXN1bHQgPSAxNztcblxuICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBudW1iZXJzID0gbmV3IEFycmF5KF9sZW4pLCBfa2V5ID0gMDsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgICAgbnVtYmVyc1tfa2V5XSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICB9XG5cbiAgICBmb3IgKHZhciBfaSA9IDAsIF9udW1iZXJzID0gbnVtYmVyczsgX2kgPCBfbnVtYmVycy5sZW5ndGg7IF9pKyspIHtcbiAgICAgIHZhciBuID0gX251bWJlcnNbX2ldO1xuICAgICAgcmVzdWx0ID0gKHJlc3VsdCA8PCA1KSAtIHJlc3VsdCArIE1hdGhVdGlsLmhhc2gobik7XG4gICAgfVxuXG4gICAgcmV0dXJuIE1hdGhVdGlsLmhhc2gocmVzdWx0KTtcbiAgfTtcblxuICByZXR1cm4gTWF0aFV0aWw7XG59KCk7XG5NYXRoVXRpbC5NQVhfU0FGRV9JTlRFR0VSID0gTUFYX1NBRkVfSU5URUdFUjtcbk1hdGhVdGlsLk1JTl9TQUZFX0lOVEVHRVIgPSBNSU5fU0FGRV9JTlRFR0VSO1xuXG4vKipcbiAqIEBjb3B5cmlnaHQgKGMpIDIwMTYsIFBoaWxpcHAgVGjDvHJ3w6RjaHRlciAmIFBhdHRyaWNrIEjDvHBlclxuICogQGxpY2Vuc2UgQlNELTMtQ2xhdXNlIChzZWUgTElDRU5TRSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZSlcbiAqL1xudmFyIEVudW0gPSBmdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIEVudW0obmFtZSkge1xuICAgIHRoaXMuX25hbWUgPSBuYW1lO1xuICB9XG5cbiAgdmFyIF9wcm90byA9IEVudW0ucHJvdG90eXBlO1xuXG4gIF9wcm90by5lcXVhbHMgPSBmdW5jdGlvbiBlcXVhbHMob3RoZXIpIHtcbiAgICByZXR1cm4gdGhpcyA9PT0gb3RoZXI7XG4gIH07XG5cbiAgX3Byb3RvLnRvU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG4gICAgcmV0dXJuIHRoaXMuX25hbWU7XG4gIH07XG5cbiAgX3Byb3RvLnRvSlNPTiA9IGZ1bmN0aW9uIHRvSlNPTigpIHtcbiAgICByZXR1cm4gdGhpcy50b1N0cmluZygpO1xuICB9O1xuXG4gIHJldHVybiBFbnVtO1xufSgpO1xuXG4vKlxuICogQGNvcHlyaWdodCAoYykgMjAxNiwgUGhpbGlwcCBUaMO8cnfDpGNodGVyICYgUGF0dHJpY2sgSMO8cGVyXG4gKiBAY29weXJpZ2h0IChjKSAyMDA3LXByZXNlbnQsIFN0ZXBoZW4gQ29sZWJvdXJuZSAmIE1pY2hhZWwgTmFzY2ltZW50byBTYW50b3NcbiAqIEBsaWNlbnNlIEJTRC0zLUNsYXVzZSAoc2VlIExJQ0VOU0UgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUpXG4gKi9cbnZhciBUZW1wb3JhbEFtb3VudCA9IGZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gVGVtcG9yYWxBbW91bnQoKSB7fVxuXG4gIHZhciBfcHJvdG8gPSBUZW1wb3JhbEFtb3VudC5wcm90b3R5cGU7XG5cbiAgX3Byb3RvLmdldCA9IGZ1bmN0aW9uIGdldCh1bml0KSB7XG4gICAgYWJzdHJhY3RNZXRob2RGYWlsKCdnZXQnKTtcbiAgfTtcblxuICBfcHJvdG8udW5pdHMgPSBmdW5jdGlvbiB1bml0cygpIHtcbiAgICBhYnN0cmFjdE1ldGhvZEZhaWwoJ3VuaXRzJyk7XG4gIH07XG5cbiAgX3Byb3RvLmFkZFRvID0gZnVuY3Rpb24gYWRkVG8odGVtcG9yYWwpIHtcbiAgICBhYnN0cmFjdE1ldGhvZEZhaWwoJ2FkZFRvJyk7XG4gIH07XG5cbiAgX3Byb3RvLnN1YnRyYWN0RnJvbSA9IGZ1bmN0aW9uIHN1YnRyYWN0RnJvbSh0ZW1wb3JhbCkge1xuICAgIGFic3RyYWN0TWV0aG9kRmFpbCgnc3VidHJhY3RGcm9tJyk7XG4gIH07XG5cbiAgcmV0dXJuIFRlbXBvcmFsQW1vdW50O1xufSgpO1xuXG4vKlxuICogQGNvcHlyaWdodCAoYykgMjAxNiwgUGhpbGlwcCBUaMO8cnfDpGNodGVyICYgUGF0dHJpY2sgSMO8cGVyXG4gKiBAY29weXJpZ2h0IChjKSAyMDA3LXByZXNlbnQsIFN0ZXBoZW4gQ29sZWJvdXJuZSAmIE1pY2hhZWwgTmFzY2ltZW50byBTYW50b3NcbiAqIEBsaWNlbnNlIEJTRC0zLUNsYXVzZSAoc2VlIExJQ0VOU0UgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUpXG4gKi9cbnZhciBUZW1wb3JhbFVuaXQgPSBmdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIFRlbXBvcmFsVW5pdCgpIHt9XG5cbiAgdmFyIF9wcm90byA9IFRlbXBvcmFsVW5pdC5wcm90b3R5cGU7XG5cbiAgX3Byb3RvLmR1cmF0aW9uID0gZnVuY3Rpb24gZHVyYXRpb24oKSB7XG4gICAgYWJzdHJhY3RNZXRob2RGYWlsKCdkdXJhdGlvbicpO1xuICB9O1xuXG4gIF9wcm90by5pc0R1cmF0aW9uRXN0aW1hdGVkID0gZnVuY3Rpb24gaXNEdXJhdGlvbkVzdGltYXRlZCgpIHtcbiAgICBhYnN0cmFjdE1ldGhvZEZhaWwoJ2lzRHVyYXRpb25Fc3RpbWF0ZWQnKTtcbiAgfTtcblxuICBfcHJvdG8uaXNEYXRlQmFzZWQgPSBmdW5jdGlvbiBpc0RhdGVCYXNlZCgpIHtcbiAgICBhYnN0cmFjdE1ldGhvZEZhaWwoJ2lzRGF0ZUJhc2VkJyk7XG4gIH07XG5cbiAgX3Byb3RvLmlzVGltZUJhc2VkID0gZnVuY3Rpb24gaXNUaW1lQmFzZWQoKSB7XG4gICAgYWJzdHJhY3RNZXRob2RGYWlsKCdpc1RpbWVCYXNlZCcpO1xuICB9O1xuXG4gIF9wcm90by5pc1N1cHBvcnRlZEJ5ID0gZnVuY3Rpb24gaXNTdXBwb3J0ZWRCeSh0ZW1wb3JhbCkge1xuICAgIGFic3RyYWN0TWV0aG9kRmFpbCgnaXNTdXBwb3J0ZWRCeScpO1xuICB9O1xuXG4gIF9wcm90by5hZGRUbyA9IGZ1bmN0aW9uIGFkZFRvKGRhdGVUaW1lLCBwZXJpb2RUb0FkZCkge1xuICAgIGFic3RyYWN0TWV0aG9kRmFpbCgnYWRkVG8nKTtcbiAgfTtcblxuICBfcHJvdG8uYmV0d2VlbiA9IGZ1bmN0aW9uIGJldHdlZW4odGVtcG9yYWwxLCB0ZW1wb3JhbDIpIHtcbiAgICBhYnN0cmFjdE1ldGhvZEZhaWwoJ2JldHdlZW4nKTtcbiAgfTtcblxuICByZXR1cm4gVGVtcG9yYWxVbml0O1xufSgpO1xuXG52YXIgRHVyYXRpb24gPSBmdW5jdGlvbiAoX1RlbXBvcmFsQW1vdW50KSB7XG4gIF9pbmhlcml0c0xvb3NlKER1cmF0aW9uLCBfVGVtcG9yYWxBbW91bnQpO1xuXG4gIGZ1bmN0aW9uIER1cmF0aW9uKHNlY29uZHMsIG5hbm9zKSB7XG4gICAgdmFyIF90aGlzO1xuXG4gICAgX3RoaXMgPSBfVGVtcG9yYWxBbW91bnQuY2FsbCh0aGlzKSB8fCB0aGlzO1xuICAgIF90aGlzLl9zZWNvbmRzID0gTWF0aFV0aWwuc2FmZVRvSW50KHNlY29uZHMpO1xuICAgIF90aGlzLl9uYW5vcyA9IE1hdGhVdGlsLnNhZmVUb0ludChuYW5vcyk7XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG5cbiAgRHVyYXRpb24ub2ZEYXlzID0gZnVuY3Rpb24gb2ZEYXlzKGRheXMpIHtcbiAgICByZXR1cm4gRHVyYXRpb24uX2NyZWF0ZShNYXRoVXRpbC5zYWZlTXVsdGlwbHkoZGF5cywgTG9jYWxUaW1lLlNFQ09ORFNfUEVSX0RBWSksIDApO1xuICB9O1xuXG4gIER1cmF0aW9uLm9mSG91cnMgPSBmdW5jdGlvbiBvZkhvdXJzKGhvdXJzKSB7XG4gICAgcmV0dXJuIER1cmF0aW9uLl9jcmVhdGUoTWF0aFV0aWwuc2FmZU11bHRpcGx5KGhvdXJzLCBMb2NhbFRpbWUuU0VDT05EU19QRVJfSE9VUiksIDApO1xuICB9O1xuXG4gIER1cmF0aW9uLm9mTWludXRlcyA9IGZ1bmN0aW9uIG9mTWludXRlcyhtaW51dGVzKSB7XG4gICAgcmV0dXJuIER1cmF0aW9uLl9jcmVhdGUoTWF0aFV0aWwuc2FmZU11bHRpcGx5KG1pbnV0ZXMsIExvY2FsVGltZS5TRUNPTkRTX1BFUl9NSU5VVEUpLCAwKTtcbiAgfTtcblxuICBEdXJhdGlvbi5vZlNlY29uZHMgPSBmdW5jdGlvbiBvZlNlY29uZHMoc2Vjb25kcywgbmFub0FkanVzdG1lbnQpIHtcbiAgICBpZiAobmFub0FkanVzdG1lbnQgPT09IHZvaWQgMCkge1xuICAgICAgbmFub0FkanVzdG1lbnQgPSAwO1xuICAgIH1cblxuICAgIHZhciBzZWNzID0gTWF0aFV0aWwuc2FmZUFkZChzZWNvbmRzLCBNYXRoVXRpbC5mbG9vckRpdihuYW5vQWRqdXN0bWVudCwgTG9jYWxUaW1lLk5BTk9TX1BFUl9TRUNPTkQpKTtcbiAgICB2YXIgbm9zID0gTWF0aFV0aWwuZmxvb3JNb2QobmFub0FkanVzdG1lbnQsIExvY2FsVGltZS5OQU5PU19QRVJfU0VDT05EKTtcbiAgICByZXR1cm4gRHVyYXRpb24uX2NyZWF0ZShzZWNzLCBub3MpO1xuICB9O1xuXG4gIER1cmF0aW9uLm9mTWlsbGlzID0gZnVuY3Rpb24gb2ZNaWxsaXMobWlsbGlzKSB7XG4gICAgdmFyIHNlY3MgPSBNYXRoVXRpbC5pbnREaXYobWlsbGlzLCAxMDAwKTtcbiAgICB2YXIgbW9zID0gTWF0aFV0aWwuaW50TW9kKG1pbGxpcywgMTAwMCk7XG5cbiAgICBpZiAobW9zIDwgMCkge1xuICAgICAgbW9zICs9IDEwMDA7XG4gICAgICBzZWNzLS07XG4gICAgfVxuXG4gICAgcmV0dXJuIER1cmF0aW9uLl9jcmVhdGUoc2VjcywgbW9zICogMTAwMDAwMCk7XG4gIH07XG5cbiAgRHVyYXRpb24ub2ZOYW5vcyA9IGZ1bmN0aW9uIG9mTmFub3MobmFub3MpIHtcbiAgICB2YXIgc2VjcyA9IE1hdGhVdGlsLmludERpdihuYW5vcywgTG9jYWxUaW1lLk5BTk9TX1BFUl9TRUNPTkQpO1xuICAgIHZhciBub3MgPSBNYXRoVXRpbC5pbnRNb2QobmFub3MsIExvY2FsVGltZS5OQU5PU19QRVJfU0VDT05EKTtcblxuICAgIGlmIChub3MgPCAwKSB7XG4gICAgICBub3MgKz0gTG9jYWxUaW1lLk5BTk9TX1BFUl9TRUNPTkQ7XG4gICAgICBzZWNzLS07XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuX2NyZWF0ZShzZWNzLCBub3MpO1xuICB9O1xuXG4gIER1cmF0aW9uLm9mID0gZnVuY3Rpb24gb2YoYW1vdW50LCB1bml0KSB7XG4gICAgcmV0dXJuIER1cmF0aW9uLlpFUk8ucGx1cyhhbW91bnQsIHVuaXQpO1xuICB9O1xuXG4gIER1cmF0aW9uLmZyb20gPSBmdW5jdGlvbiBmcm9tKGFtb3VudCkge1xuICAgIHJlcXVpcmVOb25OdWxsKGFtb3VudCwgJ2Ftb3VudCcpO1xuICAgIHJlcXVpcmVJbnN0YW5jZShhbW91bnQsIFRlbXBvcmFsQW1vdW50KTtcbiAgICB2YXIgZHVyYXRpb24gPSBEdXJhdGlvbi5aRVJPO1xuICAgIGFtb3VudC51bml0cygpLmZvckVhY2goZnVuY3Rpb24gKHVuaXQpIHtcbiAgICAgIGR1cmF0aW9uID0gZHVyYXRpb24ucGx1cyhhbW91bnQuZ2V0KHVuaXQpLCB1bml0KTtcbiAgICB9KTtcbiAgICByZXR1cm4gZHVyYXRpb247XG4gIH07XG5cbiAgRHVyYXRpb24uYmV0d2VlbiA9IGZ1bmN0aW9uIGJldHdlZW4oc3RhcnRJbmNsdXNpdmUsIGVuZEV4Y2x1c2l2ZSkge1xuICAgIHJlcXVpcmVOb25OdWxsKHN0YXJ0SW5jbHVzaXZlLCAnc3RhcnRJbmNsdXNpdmUnKTtcbiAgICByZXF1aXJlTm9uTnVsbChlbmRFeGNsdXNpdmUsICdlbmRFeGNsdXNpdmUnKTtcbiAgICB2YXIgc2VjcyA9IHN0YXJ0SW5jbHVzaXZlLnVudGlsKGVuZEV4Y2x1c2l2ZSwgQ2hyb25vVW5pdC5TRUNPTkRTKTtcbiAgICB2YXIgbmFub3MgPSAwO1xuXG4gICAgaWYgKHN0YXJ0SW5jbHVzaXZlLmlzU3VwcG9ydGVkKENocm9ub0ZpZWxkLk5BTk9fT0ZfU0VDT05EKSAmJiBlbmRFeGNsdXNpdmUuaXNTdXBwb3J0ZWQoQ2hyb25vRmllbGQuTkFOT19PRl9TRUNPTkQpKSB7XG4gICAgICB0cnkge1xuICAgICAgICB2YXIgc3RhcnROb3MgPSBzdGFydEluY2x1c2l2ZS5nZXRMb25nKENocm9ub0ZpZWxkLk5BTk9fT0ZfU0VDT05EKTtcbiAgICAgICAgbmFub3MgPSBlbmRFeGNsdXNpdmUuZ2V0TG9uZyhDaHJvbm9GaWVsZC5OQU5PX09GX1NFQ09ORCkgLSBzdGFydE5vcztcblxuICAgICAgICBpZiAoc2VjcyA+IDAgJiYgbmFub3MgPCAwKSB7XG4gICAgICAgICAgbmFub3MgKz0gTG9jYWxUaW1lLk5BTk9TX1BFUl9TRUNPTkQ7XG4gICAgICAgIH0gZWxzZSBpZiAoc2VjcyA8IDAgJiYgbmFub3MgPiAwKSB7XG4gICAgICAgICAgbmFub3MgLT0gTG9jYWxUaW1lLk5BTk9TX1BFUl9TRUNPTkQ7XG4gICAgICAgIH0gZWxzZSBpZiAoc2VjcyA9PT0gMCAmJiBuYW5vcyAhPT0gMCkge1xuICAgICAgICAgIHZhciBhZGp1c3RlZEVuZCA9IGVuZEV4Y2x1c2l2ZS53aXRoKENocm9ub0ZpZWxkLk5BTk9fT0ZfU0VDT05ELCBzdGFydE5vcyk7XG4gICAgICAgICAgc2VjcyA9IHN0YXJ0SW5jbHVzaXZlLnVudGlsKGFkanVzdGVkRW5kLCBDaHJvbm9Vbml0LlNFQ09ORFMpO1xuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlKSB7fVxuICAgIH1cblxuICAgIHJldHVybiB0aGlzLm9mU2Vjb25kcyhzZWNzLCBuYW5vcyk7XG4gIH07XG5cbiAgRHVyYXRpb24ucGFyc2UgPSBmdW5jdGlvbiBwYXJzZSh0ZXh0KSB7XG4gICAgcmVxdWlyZU5vbk51bGwodGV4dCwgJ3RleHQnKTtcbiAgICB2YXIgUEFUVEVSTiA9IG5ldyBSZWdFeHAoJyhbLStdPylQKD86KFstK10/WzAtOV0rKUQpPyhUKD86KFstK10/WzAtOV0rKUgpPyg/OihbLStdP1swLTldKylNKT8oPzooWy0rXT9bMC05XSspKD86Wy4sXShbMC05XXswLDl9KSk/Uyk/KT8nLCAnaScpO1xuICAgIHZhciBtYXRjaGVzID0gUEFUVEVSTi5leGVjKHRleHQpO1xuXG4gICAgaWYgKG1hdGNoZXMgIT09IG51bGwpIHtcbiAgICAgIGlmICgnVCcgPT09IG1hdGNoZXNbM10gPT09IGZhbHNlKSB7XG4gICAgICAgIHZhciBuZWdhdGUgPSAnLScgPT09IG1hdGNoZXNbMV07XG4gICAgICAgIHZhciBkYXlNYXRjaCA9IG1hdGNoZXNbMl07XG4gICAgICAgIHZhciBob3VyTWF0Y2ggPSBtYXRjaGVzWzRdO1xuICAgICAgICB2YXIgbWludXRlTWF0Y2ggPSBtYXRjaGVzWzVdO1xuICAgICAgICB2YXIgc2Vjb25kTWF0Y2ggPSBtYXRjaGVzWzZdO1xuICAgICAgICB2YXIgZnJhY3Rpb25NYXRjaCA9IG1hdGNoZXNbN107XG5cbiAgICAgICAgaWYgKGRheU1hdGNoICE9IG51bGwgfHwgaG91ck1hdGNoICE9IG51bGwgfHwgbWludXRlTWF0Y2ggIT0gbnVsbCB8fCBzZWNvbmRNYXRjaCAhPSBudWxsKSB7XG4gICAgICAgICAgdmFyIGRheXNBc1NlY3MgPSBEdXJhdGlvbi5fcGFyc2VOdW1iZXIodGV4dCwgZGF5TWF0Y2gsIExvY2FsVGltZS5TRUNPTkRTX1BFUl9EQVksICdkYXlzJyk7XG5cbiAgICAgICAgICB2YXIgaG91cnNBc1NlY3MgPSBEdXJhdGlvbi5fcGFyc2VOdW1iZXIodGV4dCwgaG91ck1hdGNoLCBMb2NhbFRpbWUuU0VDT05EU19QRVJfSE9VUiwgJ2hvdXJzJyk7XG5cbiAgICAgICAgICB2YXIgbWluc0FzU2VjcyA9IER1cmF0aW9uLl9wYXJzZU51bWJlcih0ZXh0LCBtaW51dGVNYXRjaCwgTG9jYWxUaW1lLlNFQ09ORFNfUEVSX01JTlVURSwgJ21pbnV0ZXMnKTtcblxuICAgICAgICAgIHZhciBzZWNvbmRzID0gRHVyYXRpb24uX3BhcnNlTnVtYmVyKHRleHQsIHNlY29uZE1hdGNoLCAxLCAnc2Vjb25kcycpO1xuXG4gICAgICAgICAgdmFyIG5lZ2F0aXZlU2VjcyA9IHNlY29uZE1hdGNoICE9IG51bGwgJiYgc2Vjb25kTWF0Y2guY2hhckF0KDApID09PSAnLSc7XG5cbiAgICAgICAgICB2YXIgbmFub3MgPSBEdXJhdGlvbi5fcGFyc2VGcmFjdGlvbih0ZXh0LCBmcmFjdGlvbk1hdGNoLCBuZWdhdGl2ZVNlY3MgPyAtMSA6IDEpO1xuXG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJldHVybiBEdXJhdGlvbi5fY3JlYXRlKG5lZ2F0ZSwgZGF5c0FzU2VjcywgaG91cnNBc1NlY3MsIG1pbnNBc1NlY3MsIHNlY29uZHMsIG5hbm9zKTtcbiAgICAgICAgICB9IGNhdGNoIChleCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IERhdGVUaW1lUGFyc2VFeGNlcHRpb24oJ1RleHQgY2Fubm90IGJlIHBhcnNlZCB0byBhIER1cmF0aW9uOiBvdmVyZmxvdycsIHRleHQsIDAsIGV4KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aHJvdyBuZXcgRGF0ZVRpbWVQYXJzZUV4Y2VwdGlvbignVGV4dCBjYW5ub3QgYmUgcGFyc2VkIHRvIGEgRHVyYXRpb24nLCB0ZXh0LCAwKTtcbiAgfTtcblxuICBEdXJhdGlvbi5fcGFyc2VOdW1iZXIgPSBmdW5jdGlvbiBfcGFyc2VOdW1iZXIodGV4dCwgcGFyc2VkLCBtdWx0aXBsaWVyLCBlcnJvclRleHQpIHtcbiAgICBpZiAocGFyc2VkID09IG51bGwpIHtcbiAgICAgIHJldHVybiAwO1xuICAgIH1cblxuICAgIHRyeSB7XG4gICAgICBpZiAocGFyc2VkWzBdID09PSAnKycpIHtcbiAgICAgICAgcGFyc2VkID0gcGFyc2VkLnN1YnN0cmluZygxKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIE1hdGhVdGlsLnNhZmVNdWx0aXBseShwYXJzZUZsb2F0KHBhcnNlZCksIG11bHRpcGxpZXIpO1xuICAgIH0gY2F0Y2ggKGV4KSB7XG4gICAgICB0aHJvdyBuZXcgRGF0ZVRpbWVQYXJzZUV4Y2VwdGlvbignVGV4dCBjYW5ub3QgYmUgcGFyc2VkIHRvIGEgRHVyYXRpb246ICcgKyBlcnJvclRleHQsIHRleHQsIDAsIGV4KTtcbiAgICB9XG4gIH07XG5cbiAgRHVyYXRpb24uX3BhcnNlRnJhY3Rpb24gPSBmdW5jdGlvbiBfcGFyc2VGcmFjdGlvbih0ZXh0LCBwYXJzZWQsIG5lZ2F0ZSkge1xuICAgIGlmIChwYXJzZWQgPT0gbnVsbCB8fCBwYXJzZWQubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm4gMDtcbiAgICB9XG5cbiAgICBwYXJzZWQgPSAocGFyc2VkICsgJzAwMDAwMDAwMCcpLnN1YnN0cmluZygwLCA5KTtcbiAgICByZXR1cm4gcGFyc2VGbG9hdChwYXJzZWQpICogbmVnYXRlO1xuICB9O1xuXG4gIER1cmF0aW9uLl9jcmVhdGUgPSBmdW5jdGlvbiBfY3JlYXRlKCkge1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoIDw9IDIpIHtcbiAgICAgIHJldHVybiBEdXJhdGlvbi5fY3JlYXRlU2Vjb25kc05hbm9zKGFyZ3VtZW50c1swXSwgYXJndW1lbnRzWzFdKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIER1cmF0aW9uLl9jcmVhdGVOZWdhdGVEYXlzSG91cnNNaW51dGVzU2Vjb25kc05hbm9zKGFyZ3VtZW50c1swXSwgYXJndW1lbnRzWzFdLCBhcmd1bWVudHNbMl0sIGFyZ3VtZW50c1szXSwgYXJndW1lbnRzWzRdLCBhcmd1bWVudHNbNV0pO1xuICAgIH1cbiAgfTtcblxuICBEdXJhdGlvbi5fY3JlYXRlTmVnYXRlRGF5c0hvdXJzTWludXRlc1NlY29uZHNOYW5vcyA9IGZ1bmN0aW9uIF9jcmVhdGVOZWdhdGVEYXlzSG91cnNNaW51dGVzU2Vjb25kc05hbm9zKG5lZ2F0ZSwgZGF5c0FzU2VjcywgaG91cnNBc1NlY3MsIG1pbnNBc1NlY3MsIHNlY3MsIG5hbm9zKSB7XG4gICAgdmFyIHNlY29uZHMgPSBNYXRoVXRpbC5zYWZlQWRkKGRheXNBc1NlY3MsIE1hdGhVdGlsLnNhZmVBZGQoaG91cnNBc1NlY3MsIE1hdGhVdGlsLnNhZmVBZGQobWluc0FzU2Vjcywgc2VjcykpKTtcblxuICAgIGlmIChuZWdhdGUpIHtcbiAgICAgIHJldHVybiBEdXJhdGlvbi5vZlNlY29uZHMoc2Vjb25kcywgbmFub3MpLm5lZ2F0ZWQoKTtcbiAgICB9XG5cbiAgICByZXR1cm4gRHVyYXRpb24ub2ZTZWNvbmRzKHNlY29uZHMsIG5hbm9zKTtcbiAgfTtcblxuICBEdXJhdGlvbi5fY3JlYXRlU2Vjb25kc05hbm9zID0gZnVuY3Rpb24gX2NyZWF0ZVNlY29uZHNOYW5vcyhzZWNvbmRzLCBuYW5vQWRqdXN0bWVudCkge1xuICAgIGlmIChzZWNvbmRzID09PSB2b2lkIDApIHtcbiAgICAgIHNlY29uZHMgPSAwO1xuICAgIH1cblxuICAgIGlmIChuYW5vQWRqdXN0bWVudCA9PT0gdm9pZCAwKSB7XG4gICAgICBuYW5vQWRqdXN0bWVudCA9IDA7XG4gICAgfVxuXG4gICAgaWYgKHNlY29uZHMgPT09IDAgJiYgbmFub0FkanVzdG1lbnQgPT09IDApIHtcbiAgICAgIHJldHVybiBEdXJhdGlvbi5aRVJPO1xuICAgIH1cblxuICAgIHJldHVybiBuZXcgRHVyYXRpb24oc2Vjb25kcywgbmFub0FkanVzdG1lbnQpO1xuICB9O1xuXG4gIHZhciBfcHJvdG8gPSBEdXJhdGlvbi5wcm90b3R5cGU7XG5cbiAgX3Byb3RvLmdldCA9IGZ1bmN0aW9uIGdldCh1bml0KSB7XG4gICAgaWYgKHVuaXQgPT09IENocm9ub1VuaXQuU0VDT05EUykge1xuICAgICAgcmV0dXJuIHRoaXMuX3NlY29uZHM7XG4gICAgfSBlbHNlIGlmICh1bml0ID09PSBDaHJvbm9Vbml0Lk5BTk9TKSB7XG4gICAgICByZXR1cm4gdGhpcy5fbmFub3M7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBVbnN1cHBvcnRlZFRlbXBvcmFsVHlwZUV4Y2VwdGlvbignVW5zdXBwb3J0ZWQgdW5pdDogJyArIHVuaXQpO1xuICAgIH1cbiAgfTtcblxuICBfcHJvdG8udW5pdHMgPSBmdW5jdGlvbiB1bml0cygpIHtcbiAgICByZXR1cm4gW0Nocm9ub1VuaXQuU0VDT05EUywgQ2hyb25vVW5pdC5OQU5PU107XG4gIH07XG5cbiAgX3Byb3RvLmlzWmVybyA9IGZ1bmN0aW9uIGlzWmVybygpIHtcbiAgICByZXR1cm4gdGhpcy5fc2Vjb25kcyA9PT0gMCAmJiB0aGlzLl9uYW5vcyA9PT0gMDtcbiAgfTtcblxuICBfcHJvdG8uaXNOZWdhdGl2ZSA9IGZ1bmN0aW9uIGlzTmVnYXRpdmUoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3NlY29uZHMgPCAwO1xuICB9O1xuXG4gIF9wcm90by5zZWNvbmRzID0gZnVuY3Rpb24gc2Vjb25kcygpIHtcbiAgICByZXR1cm4gdGhpcy5fc2Vjb25kcztcbiAgfTtcblxuICBfcHJvdG8ubmFubyA9IGZ1bmN0aW9uIG5hbm8oKSB7XG4gICAgcmV0dXJuIHRoaXMuX25hbm9zO1xuICB9O1xuXG4gIF9wcm90by53aXRoU2Vjb25kcyA9IGZ1bmN0aW9uIHdpdGhTZWNvbmRzKHNlY29uZHMpIHtcbiAgICByZXR1cm4gRHVyYXRpb24uX2NyZWF0ZShzZWNvbmRzLCB0aGlzLl9uYW5vcyk7XG4gIH07XG5cbiAgX3Byb3RvLndpdGhOYW5vcyA9IGZ1bmN0aW9uIHdpdGhOYW5vcyhuYW5vT2ZTZWNvbmQpIHtcbiAgICBDaHJvbm9GaWVsZC5OQU5PX09GX1NFQ09ORC5jaGVja1ZhbGlkSW50VmFsdWUobmFub09mU2Vjb25kKTtcbiAgICByZXR1cm4gRHVyYXRpb24uX2NyZWF0ZSh0aGlzLl9zZWNvbmRzLCBuYW5vT2ZTZWNvbmQpO1xuICB9O1xuXG4gIF9wcm90by5wbHVzRHVyYXRpb24gPSBmdW5jdGlvbiBwbHVzRHVyYXRpb24oZHVyYXRpb24pIHtcbiAgICByZXF1aXJlTm9uTnVsbChkdXJhdGlvbiwgJ2R1cmF0aW9uJyk7XG4gICAgcmV0dXJuIHRoaXMucGx1cyhkdXJhdGlvbi5zZWNvbmRzKCksIGR1cmF0aW9uLm5hbm8oKSk7XG4gIH07XG5cbiAgX3Byb3RvLnBsdXMgPSBmdW5jdGlvbiBwbHVzKGR1cmF0aW9uT3JOdW1iZXIsIHVuaXRPck51bWJlcikge1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAxKSB7XG4gICAgICByZXR1cm4gdGhpcy5wbHVzRHVyYXRpb24oZHVyYXRpb25Pck51bWJlcik7XG4gICAgfSBlbHNlIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAyICYmIHVuaXRPck51bWJlciBpbnN0YW5jZW9mIFRlbXBvcmFsVW5pdCkge1xuICAgICAgcmV0dXJuIHRoaXMucGx1c0Ftb3VudFVuaXQoZHVyYXRpb25Pck51bWJlciwgdW5pdE9yTnVtYmVyKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHRoaXMucGx1c1NlY29uZHNOYW5vcyhkdXJhdGlvbk9yTnVtYmVyLCB1bml0T3JOdW1iZXIpO1xuICAgIH1cbiAgfTtcblxuICBfcHJvdG8ucGx1c0Ftb3VudFVuaXQgPSBmdW5jdGlvbiBwbHVzQW1vdW50VW5pdChhbW91bnRUb0FkZCwgdW5pdCkge1xuICAgIHJlcXVpcmVOb25OdWxsKGFtb3VudFRvQWRkLCAnYW1vdW50VG9BZGQnKTtcbiAgICByZXF1aXJlTm9uTnVsbCh1bml0LCAndW5pdCcpO1xuXG4gICAgaWYgKHVuaXQgPT09IENocm9ub1VuaXQuREFZUykge1xuICAgICAgcmV0dXJuIHRoaXMucGx1c1NlY29uZHNOYW5vcyhNYXRoVXRpbC5zYWZlTXVsdGlwbHkoYW1vdW50VG9BZGQsIExvY2FsVGltZS5TRUNPTkRTX1BFUl9EQVkpLCAwKTtcbiAgICB9XG5cbiAgICBpZiAodW5pdC5pc0R1cmF0aW9uRXN0aW1hdGVkKCkpIHtcbiAgICAgIHRocm93IG5ldyBVbnN1cHBvcnRlZFRlbXBvcmFsVHlwZUV4Y2VwdGlvbignVW5pdCBtdXN0IG5vdCBoYXZlIGFuIGVzdGltYXRlZCBkdXJhdGlvbicpO1xuICAgIH1cblxuICAgIGlmIChhbW91bnRUb0FkZCA9PT0gMCkge1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgaWYgKHVuaXQgaW5zdGFuY2VvZiBDaHJvbm9Vbml0KSB7XG4gICAgICBzd2l0Y2ggKHVuaXQpIHtcbiAgICAgICAgY2FzZSBDaHJvbm9Vbml0Lk5BTk9TOlxuICAgICAgICAgIHJldHVybiB0aGlzLnBsdXNOYW5vcyhhbW91bnRUb0FkZCk7XG5cbiAgICAgICAgY2FzZSBDaHJvbm9Vbml0Lk1JQ1JPUzpcbiAgICAgICAgICByZXR1cm4gdGhpcy5wbHVzU2Vjb25kc05hbm9zKE1hdGhVdGlsLmludERpdihhbW91bnRUb0FkZCwgMTAwMDAwMCAqIDEwMDApICogMTAwMCwgTWF0aFV0aWwuaW50TW9kKGFtb3VudFRvQWRkLCAxMDAwMDAwICogMTAwMCkgKiAxMDAwKTtcblxuICAgICAgICBjYXNlIENocm9ub1VuaXQuTUlMTElTOlxuICAgICAgICAgIHJldHVybiB0aGlzLnBsdXNNaWxsaXMoYW1vdW50VG9BZGQpO1xuXG4gICAgICAgIGNhc2UgQ2hyb25vVW5pdC5TRUNPTkRTOlxuICAgICAgICAgIHJldHVybiB0aGlzLnBsdXNTZWNvbmRzKGFtb3VudFRvQWRkKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXMucGx1c1NlY29uZHNOYW5vcyhNYXRoVXRpbC5zYWZlTXVsdGlwbHkodW5pdC5kdXJhdGlvbigpLnNlY29uZHMoKSwgYW1vdW50VG9BZGQpLCAwKTtcbiAgICB9XG5cbiAgICB2YXIgZHVyYXRpb24gPSB1bml0LmR1cmF0aW9uKCkubXVsdGlwbGllZEJ5KGFtb3VudFRvQWRkKTtcbiAgICByZXR1cm4gdGhpcy5wbHVzU2Vjb25kc05hbm9zKGR1cmF0aW9uLnNlY29uZHMoKSwgZHVyYXRpb24ubmFubygpKTtcbiAgfTtcblxuICBfcHJvdG8ucGx1c0RheXMgPSBmdW5jdGlvbiBwbHVzRGF5cyhkYXlzVG9BZGQpIHtcbiAgICByZXR1cm4gdGhpcy5wbHVzU2Vjb25kc05hbm9zKE1hdGhVdGlsLnNhZmVNdWx0aXBseShkYXlzVG9BZGQsIExvY2FsVGltZS5TRUNPTkRTX1BFUl9EQVkpLCAwKTtcbiAgfTtcblxuICBfcHJvdG8ucGx1c0hvdXJzID0gZnVuY3Rpb24gcGx1c0hvdXJzKGhvdXJzVG9BZGQpIHtcbiAgICByZXR1cm4gdGhpcy5wbHVzU2Vjb25kc05hbm9zKE1hdGhVdGlsLnNhZmVNdWx0aXBseShob3Vyc1RvQWRkLCBMb2NhbFRpbWUuU0VDT05EU19QRVJfSE9VUiksIDApO1xuICB9O1xuXG4gIF9wcm90by5wbHVzTWludXRlcyA9IGZ1bmN0aW9uIHBsdXNNaW51dGVzKG1pbnV0ZXNUb0FkZCkge1xuICAgIHJldHVybiB0aGlzLnBsdXNTZWNvbmRzTmFub3MoTWF0aFV0aWwuc2FmZU11bHRpcGx5KG1pbnV0ZXNUb0FkZCwgTG9jYWxUaW1lLlNFQ09ORFNfUEVSX01JTlVURSksIDApO1xuICB9O1xuXG4gIF9wcm90by5wbHVzU2Vjb25kcyA9IGZ1bmN0aW9uIHBsdXNTZWNvbmRzKHNlY29uZHNUb0FkZCkge1xuICAgIHJldHVybiB0aGlzLnBsdXNTZWNvbmRzTmFub3Moc2Vjb25kc1RvQWRkLCAwKTtcbiAgfTtcblxuICBfcHJvdG8ucGx1c01pbGxpcyA9IGZ1bmN0aW9uIHBsdXNNaWxsaXMobWlsbGlzVG9BZGQpIHtcbiAgICByZXR1cm4gdGhpcy5wbHVzU2Vjb25kc05hbm9zKE1hdGhVdGlsLmludERpdihtaWxsaXNUb0FkZCwgMTAwMCksIE1hdGhVdGlsLmludE1vZChtaWxsaXNUb0FkZCwgMTAwMCkgKiAxMDAwMDAwKTtcbiAgfTtcblxuICBfcHJvdG8ucGx1c05hbm9zID0gZnVuY3Rpb24gcGx1c05hbm9zKG5hbm9zVG9BZGQpIHtcbiAgICByZXR1cm4gdGhpcy5wbHVzU2Vjb25kc05hbm9zKDAsIG5hbm9zVG9BZGQpO1xuICB9O1xuXG4gIF9wcm90by5wbHVzU2Vjb25kc05hbm9zID0gZnVuY3Rpb24gcGx1c1NlY29uZHNOYW5vcyhzZWNvbmRzVG9BZGQsIG5hbm9zVG9BZGQpIHtcbiAgICByZXF1aXJlTm9uTnVsbChzZWNvbmRzVG9BZGQsICdzZWNvbmRzVG9BZGQnKTtcbiAgICByZXF1aXJlTm9uTnVsbChuYW5vc1RvQWRkLCAnbmFub3NUb0FkZCcpO1xuXG4gICAgaWYgKHNlY29uZHNUb0FkZCA9PT0gMCAmJiBuYW5vc1RvQWRkID09PSAwKSB7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICB2YXIgZXBvY2hTZWMgPSBNYXRoVXRpbC5zYWZlQWRkKHRoaXMuX3NlY29uZHMsIHNlY29uZHNUb0FkZCk7XG4gICAgZXBvY2hTZWMgPSBNYXRoVXRpbC5zYWZlQWRkKGVwb2NoU2VjLCBNYXRoVXRpbC5pbnREaXYobmFub3NUb0FkZCwgTG9jYWxUaW1lLk5BTk9TX1BFUl9TRUNPTkQpKTtcbiAgICBuYW5vc1RvQWRkID0gTWF0aFV0aWwuaW50TW9kKG5hbm9zVG9BZGQsIExvY2FsVGltZS5OQU5PU19QRVJfU0VDT05EKTtcbiAgICB2YXIgbmFub0FkanVzdG1lbnQgPSBNYXRoVXRpbC5zYWZlQWRkKHRoaXMuX25hbm9zLCBuYW5vc1RvQWRkKTtcbiAgICByZXR1cm4gRHVyYXRpb24ub2ZTZWNvbmRzKGVwb2NoU2VjLCBuYW5vQWRqdXN0bWVudCk7XG4gIH07XG5cbiAgX3Byb3RvLm1pbnVzID0gZnVuY3Rpb24gbWludXMoZHVyYXRpb25Pck51bWJlciwgdW5pdCkge1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAxKSB7XG4gICAgICByZXR1cm4gdGhpcy5taW51c0R1cmF0aW9uKGR1cmF0aW9uT3JOdW1iZXIpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gdGhpcy5taW51c0Ftb3VudFVuaXQoZHVyYXRpb25Pck51bWJlciwgdW5pdCk7XG4gICAgfVxuICB9O1xuXG4gIF9wcm90by5taW51c0R1cmF0aW9uID0gZnVuY3Rpb24gbWludXNEdXJhdGlvbihkdXJhdGlvbikge1xuICAgIHJlcXVpcmVOb25OdWxsKGR1cmF0aW9uLCAnZHVyYXRpb24nKTtcbiAgICB2YXIgc2Vjc1RvU3VidHJhY3QgPSBkdXJhdGlvbi5zZWNvbmRzKCk7XG4gICAgdmFyIG5hbm9zVG9TdWJ0cmFjdCA9IGR1cmF0aW9uLm5hbm8oKTtcblxuICAgIGlmIChzZWNzVG9TdWJ0cmFjdCA9PT0gTUlOX1NBRkVfSU5URUdFUikge1xuICAgICAgcmV0dXJuIHRoaXMucGx1cyhNQVhfU0FGRV9JTlRFR0VSLCAtbmFub3NUb1N1YnRyYWN0KTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5wbHVzKC1zZWNzVG9TdWJ0cmFjdCwgLW5hbm9zVG9TdWJ0cmFjdCk7XG4gIH07XG5cbiAgX3Byb3RvLm1pbnVzQW1vdW50VW5pdCA9IGZ1bmN0aW9uIG1pbnVzQW1vdW50VW5pdChhbW91bnRUb1N1YnRyYWN0LCB1bml0KSB7XG4gICAgcmVxdWlyZU5vbk51bGwoYW1vdW50VG9TdWJ0cmFjdCwgJ2Ftb3VudFRvU3VidHJhY3QnKTtcbiAgICByZXF1aXJlTm9uTnVsbCh1bml0LCAndW5pdCcpO1xuICAgIHJldHVybiBhbW91bnRUb1N1YnRyYWN0ID09PSBNSU5fU0FGRV9JTlRFR0VSID8gdGhpcy5wbHVzQW1vdW50VW5pdChNQVhfU0FGRV9JTlRFR0VSLCB1bml0KSA6IHRoaXMucGx1c0Ftb3VudFVuaXQoLWFtb3VudFRvU3VidHJhY3QsIHVuaXQpO1xuICB9O1xuXG4gIF9wcm90by5taW51c0RheXMgPSBmdW5jdGlvbiBtaW51c0RheXMoZGF5c1RvU3VidHJhY3QpIHtcbiAgICByZXR1cm4gZGF5c1RvU3VidHJhY3QgPT09IE1JTl9TQUZFX0lOVEVHRVIgPyB0aGlzLnBsdXNEYXlzKE1BWF9TQUZFX0lOVEVHRVIpIDogdGhpcy5wbHVzRGF5cygtZGF5c1RvU3VidHJhY3QpO1xuICB9O1xuXG4gIF9wcm90by5taW51c0hvdXJzID0gZnVuY3Rpb24gbWludXNIb3Vycyhob3Vyc1RvU3VidHJhY3QpIHtcbiAgICByZXR1cm4gaG91cnNUb1N1YnRyYWN0ID09PSBNSU5fU0FGRV9JTlRFR0VSID8gdGhpcy5wbHVzSG91cnMoTUFYX1NBRkVfSU5URUdFUikgOiB0aGlzLnBsdXNIb3VycygtaG91cnNUb1N1YnRyYWN0KTtcbiAgfTtcblxuICBfcHJvdG8ubWludXNNaW51dGVzID0gZnVuY3Rpb24gbWludXNNaW51dGVzKG1pbnV0ZXNUb1N1YnRyYWN0KSB7XG4gICAgcmV0dXJuIG1pbnV0ZXNUb1N1YnRyYWN0ID09PSBNSU5fU0FGRV9JTlRFR0VSID8gdGhpcy5wbHVzTWludXRlcyhNQVhfU0FGRV9JTlRFR0VSKSA6IHRoaXMucGx1c01pbnV0ZXMoLW1pbnV0ZXNUb1N1YnRyYWN0KTtcbiAgfTtcblxuICBfcHJvdG8ubWludXNTZWNvbmRzID0gZnVuY3Rpb24gbWludXNTZWNvbmRzKHNlY29uZHNUb1N1YnRyYWN0KSB7XG4gICAgcmV0dXJuIHNlY29uZHNUb1N1YnRyYWN0ID09PSBNSU5fU0FGRV9JTlRFR0VSID8gdGhpcy5wbHVzU2Vjb25kcyhNQVhfU0FGRV9JTlRFR0VSKSA6IHRoaXMucGx1c1NlY29uZHMoLXNlY29uZHNUb1N1YnRyYWN0KTtcbiAgfTtcblxuICBfcHJvdG8ubWludXNNaWxsaXMgPSBmdW5jdGlvbiBtaW51c01pbGxpcyhtaWxsaXNUb1N1YnRyYWN0KSB7XG4gICAgcmV0dXJuIG1pbGxpc1RvU3VidHJhY3QgPT09IE1JTl9TQUZFX0lOVEVHRVIgPyB0aGlzLnBsdXNNaWxsaXMoTUFYX1NBRkVfSU5URUdFUikgOiB0aGlzLnBsdXNNaWxsaXMoLW1pbGxpc1RvU3VidHJhY3QpO1xuICB9O1xuXG4gIF9wcm90by5taW51c05hbm9zID0gZnVuY3Rpb24gbWludXNOYW5vcyhuYW5vc1RvU3VidHJhY3QpIHtcbiAgICByZXR1cm4gbmFub3NUb1N1YnRyYWN0ID09PSBNSU5fU0FGRV9JTlRFR0VSID8gdGhpcy5wbHVzTmFub3MoTUFYX1NBRkVfSU5URUdFUikgOiB0aGlzLnBsdXNOYW5vcygtbmFub3NUb1N1YnRyYWN0KTtcbiAgfTtcblxuICBfcHJvdG8ubXVsdGlwbGllZEJ5ID0gZnVuY3Rpb24gbXVsdGlwbGllZEJ5KG11bHRpcGxpY2FuZCkge1xuICAgIGlmIChtdWx0aXBsaWNhbmQgPT09IDApIHtcbiAgICAgIHJldHVybiBEdXJhdGlvbi5aRVJPO1xuICAgIH1cblxuICAgIGlmIChtdWx0aXBsaWNhbmQgPT09IDEpIHtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIHZhciBzZWNzID0gTWF0aFV0aWwuc2FmZU11bHRpcGx5KHRoaXMuX3NlY29uZHMsIG11bHRpcGxpY2FuZCk7XG4gICAgdmFyIG5vcyA9IE1hdGhVdGlsLnNhZmVNdWx0aXBseSh0aGlzLl9uYW5vcywgbXVsdGlwbGljYW5kKTtcbiAgICBzZWNzID0gc2VjcyArIE1hdGhVdGlsLmludERpdihub3MsIExvY2FsVGltZS5OQU5PU19QRVJfU0VDT05EKTtcbiAgICBub3MgPSBNYXRoVXRpbC5pbnRNb2Qobm9zLCBMb2NhbFRpbWUuTkFOT1NfUEVSX1NFQ09ORCk7XG4gICAgcmV0dXJuIER1cmF0aW9uLm9mU2Vjb25kcyhzZWNzLCBub3MpO1xuICB9O1xuXG4gIF9wcm90by5kaXZpZGVkQnkgPSBmdW5jdGlvbiBkaXZpZGVkQnkoZGl2aXNvcikge1xuICAgIGlmIChkaXZpc29yID09PSAwKSB7XG4gICAgICB0aHJvdyBuZXcgQXJpdGhtZXRpY0V4Y2VwdGlvbignQ2Fubm90IGRpdmlkZSBieSB6ZXJvJyk7XG4gICAgfVxuXG4gICAgaWYgKGRpdmlzb3IgPT09IDEpIHtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIHZhciBzZWNzID0gTWF0aFV0aWwuaW50RGl2KHRoaXMuX3NlY29uZHMsIGRpdmlzb3IpO1xuICAgIHZhciBzZWNzTW9kID0gTWF0aFV0aWwucm91bmREb3duKCh0aGlzLl9zZWNvbmRzIC8gZGl2aXNvciAtIHNlY3MpICogTG9jYWxUaW1lLk5BTk9TX1BFUl9TRUNPTkQpO1xuICAgIHZhciBub3MgPSBNYXRoVXRpbC5pbnREaXYodGhpcy5fbmFub3MsIGRpdmlzb3IpO1xuICAgIG5vcyA9IHNlY3NNb2QgKyBub3M7XG4gICAgcmV0dXJuIER1cmF0aW9uLm9mU2Vjb25kcyhzZWNzLCBub3MpO1xuICB9O1xuXG4gIF9wcm90by5uZWdhdGVkID0gZnVuY3Rpb24gbmVnYXRlZCgpIHtcbiAgICByZXR1cm4gdGhpcy5tdWx0aXBsaWVkQnkoLTEpO1xuICB9O1xuXG4gIF9wcm90by5hYnMgPSBmdW5jdGlvbiBhYnMoKSB7XG4gICAgcmV0dXJuIHRoaXMuaXNOZWdhdGl2ZSgpID8gdGhpcy5uZWdhdGVkKCkgOiB0aGlzO1xuICB9O1xuXG4gIF9wcm90by5hZGRUbyA9IGZ1bmN0aW9uIGFkZFRvKHRlbXBvcmFsKSB7XG4gICAgcmVxdWlyZU5vbk51bGwodGVtcG9yYWwsICd0ZW1wb3JhbCcpO1xuXG4gICAgaWYgKHRoaXMuX3NlY29uZHMgIT09IDApIHtcbiAgICAgIHRlbXBvcmFsID0gdGVtcG9yYWwucGx1cyh0aGlzLl9zZWNvbmRzLCBDaHJvbm9Vbml0LlNFQ09ORFMpO1xuICAgIH1cblxuICAgIGlmICh0aGlzLl9uYW5vcyAhPT0gMCkge1xuICAgICAgdGVtcG9yYWwgPSB0ZW1wb3JhbC5wbHVzKHRoaXMuX25hbm9zLCBDaHJvbm9Vbml0Lk5BTk9TKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGVtcG9yYWw7XG4gIH07XG5cbiAgX3Byb3RvLnN1YnRyYWN0RnJvbSA9IGZ1bmN0aW9uIHN1YnRyYWN0RnJvbSh0ZW1wb3JhbCkge1xuICAgIHJlcXVpcmVOb25OdWxsKHRlbXBvcmFsLCAndGVtcG9yYWwnKTtcblxuICAgIGlmICh0aGlzLl9zZWNvbmRzICE9PSAwKSB7XG4gICAgICB0ZW1wb3JhbCA9IHRlbXBvcmFsLm1pbnVzKHRoaXMuX3NlY29uZHMsIENocm9ub1VuaXQuU0VDT05EUyk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuX25hbm9zICE9PSAwKSB7XG4gICAgICB0ZW1wb3JhbCA9IHRlbXBvcmFsLm1pbnVzKHRoaXMuX25hbm9zLCBDaHJvbm9Vbml0Lk5BTk9TKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGVtcG9yYWw7XG4gIH07XG5cbiAgX3Byb3RvLnRvRGF5cyA9IGZ1bmN0aW9uIHRvRGF5cygpIHtcbiAgICByZXR1cm4gTWF0aFV0aWwuaW50RGl2KHRoaXMuX3NlY29uZHMsIExvY2FsVGltZS5TRUNPTkRTX1BFUl9EQVkpO1xuICB9O1xuXG4gIF9wcm90by50b0hvdXJzID0gZnVuY3Rpb24gdG9Ib3VycygpIHtcbiAgICByZXR1cm4gTWF0aFV0aWwuaW50RGl2KHRoaXMuX3NlY29uZHMsIExvY2FsVGltZS5TRUNPTkRTX1BFUl9IT1VSKTtcbiAgfTtcblxuICBfcHJvdG8udG9NaW51dGVzID0gZnVuY3Rpb24gdG9NaW51dGVzKCkge1xuICAgIHJldHVybiBNYXRoVXRpbC5pbnREaXYodGhpcy5fc2Vjb25kcywgTG9jYWxUaW1lLlNFQ09ORFNfUEVSX01JTlVURSk7XG4gIH07XG5cbiAgX3Byb3RvLnRvTWlsbGlzID0gZnVuY3Rpb24gdG9NaWxsaXMoKSB7XG4gICAgdmFyIG1pbGxpcyA9IE1hdGgucm91bmQoTWF0aFV0aWwuc2FmZU11bHRpcGx5KHRoaXMuX3NlY29uZHMsIDEwMDApKTtcbiAgICBtaWxsaXMgPSBNYXRoVXRpbC5zYWZlQWRkKG1pbGxpcywgTWF0aFV0aWwuaW50RGl2KHRoaXMuX25hbm9zLCAxMDAwMDAwKSk7XG4gICAgcmV0dXJuIG1pbGxpcztcbiAgfTtcblxuICBfcHJvdG8udG9OYW5vcyA9IGZ1bmN0aW9uIHRvTmFub3MoKSB7XG4gICAgdmFyIHRvdGFsTmFub3MgPSBNYXRoVXRpbC5zYWZlTXVsdGlwbHkodGhpcy5fc2Vjb25kcywgTG9jYWxUaW1lLk5BTk9TX1BFUl9TRUNPTkQpO1xuICAgIHRvdGFsTmFub3MgPSBNYXRoVXRpbC5zYWZlQWRkKHRvdGFsTmFub3MsIHRoaXMuX25hbm9zKTtcbiAgICByZXR1cm4gdG90YWxOYW5vcztcbiAgfTtcblxuICBfcHJvdG8uY29tcGFyZVRvID0gZnVuY3Rpb24gY29tcGFyZVRvKG90aGVyRHVyYXRpb24pIHtcbiAgICByZXF1aXJlTm9uTnVsbChvdGhlckR1cmF0aW9uLCAnb3RoZXJEdXJhdGlvbicpO1xuICAgIHJlcXVpcmVJbnN0YW5jZShvdGhlckR1cmF0aW9uLCBEdXJhdGlvbiwgJ290aGVyRHVyYXRpb24nKTtcbiAgICB2YXIgY21wID0gTWF0aFV0aWwuY29tcGFyZU51bWJlcnModGhpcy5fc2Vjb25kcywgb3RoZXJEdXJhdGlvbi5zZWNvbmRzKCkpO1xuXG4gICAgaWYgKGNtcCAhPT0gMCkge1xuICAgICAgcmV0dXJuIGNtcDtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5fbmFub3MgLSBvdGhlckR1cmF0aW9uLm5hbm8oKTtcbiAgfTtcblxuICBfcHJvdG8uZXF1YWxzID0gZnVuY3Rpb24gZXF1YWxzKG90aGVyRHVyYXRpb24pIHtcbiAgICBpZiAodGhpcyA9PT0gb3RoZXJEdXJhdGlvbikge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgaWYgKG90aGVyRHVyYXRpb24gaW5zdGFuY2VvZiBEdXJhdGlvbikge1xuICAgICAgcmV0dXJuIHRoaXMuc2Vjb25kcygpID09PSBvdGhlckR1cmF0aW9uLnNlY29uZHMoKSAmJiB0aGlzLm5hbm8oKSA9PT0gb3RoZXJEdXJhdGlvbi5uYW5vKCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9O1xuXG4gIF9wcm90by50b1N0cmluZyA9IGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuICAgIGlmICh0aGlzID09PSBEdXJhdGlvbi5aRVJPKSB7XG4gICAgICByZXR1cm4gJ1BUMFMnO1xuICAgIH1cblxuICAgIHZhciBob3VycyA9IE1hdGhVdGlsLmludERpdih0aGlzLl9zZWNvbmRzLCBMb2NhbFRpbWUuU0VDT05EU19QRVJfSE9VUik7XG4gICAgdmFyIG1pbnV0ZXMgPSBNYXRoVXRpbC5pbnREaXYoTWF0aFV0aWwuaW50TW9kKHRoaXMuX3NlY29uZHMsIExvY2FsVGltZS5TRUNPTkRTX1BFUl9IT1VSKSwgTG9jYWxUaW1lLlNFQ09ORFNfUEVSX01JTlVURSk7XG4gICAgdmFyIHNlY3MgPSBNYXRoVXRpbC5pbnRNb2QodGhpcy5fc2Vjb25kcywgTG9jYWxUaW1lLlNFQ09ORFNfUEVSX01JTlVURSk7XG4gICAgdmFyIHJ2YWwgPSAnUFQnO1xuXG4gICAgaWYgKGhvdXJzICE9PSAwKSB7XG4gICAgICBydmFsICs9IGhvdXJzICsgJ0gnO1xuICAgIH1cblxuICAgIGlmIChtaW51dGVzICE9PSAwKSB7XG4gICAgICBydmFsICs9IG1pbnV0ZXMgKyAnTSc7XG4gICAgfVxuXG4gICAgaWYgKHNlY3MgPT09IDAgJiYgdGhpcy5fbmFub3MgPT09IDAgJiYgcnZhbC5sZW5ndGggPiAyKSB7XG4gICAgICByZXR1cm4gcnZhbDtcbiAgICB9XG5cbiAgICBpZiAoc2VjcyA8IDAgJiYgdGhpcy5fbmFub3MgPiAwKSB7XG4gICAgICBpZiAoc2VjcyA9PT0gLTEpIHtcbiAgICAgICAgcnZhbCArPSAnLTAnO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcnZhbCArPSBzZWNzICsgMTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgcnZhbCArPSBzZWNzO1xuICAgIH1cblxuICAgIGlmICh0aGlzLl9uYW5vcyA+IDApIHtcbiAgICAgIHJ2YWwgKz0gJy4nO1xuICAgICAgdmFyIG5hbm9TdHJpbmc7XG5cbiAgICAgIGlmIChzZWNzIDwgMCkge1xuICAgICAgICBuYW5vU3RyaW5nID0gJycgKyAoMiAqIExvY2FsVGltZS5OQU5PU19QRVJfU0VDT05EIC0gdGhpcy5fbmFub3MpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbmFub1N0cmluZyA9ICcnICsgKExvY2FsVGltZS5OQU5PU19QRVJfU0VDT05EICsgdGhpcy5fbmFub3MpO1xuICAgICAgfVxuXG4gICAgICBuYW5vU3RyaW5nID0gbmFub1N0cmluZy5zbGljZSgxLCBuYW5vU3RyaW5nLmxlbmd0aCk7XG4gICAgICBydmFsICs9IG5hbm9TdHJpbmc7XG5cbiAgICAgIHdoaWxlIChydmFsLmNoYXJBdChydmFsLmxlbmd0aCAtIDEpID09PSAnMCcpIHtcbiAgICAgICAgcnZhbCA9IHJ2YWwuc2xpY2UoMCwgcnZhbC5sZW5ndGggLSAxKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBydmFsICs9ICdTJztcbiAgICByZXR1cm4gcnZhbDtcbiAgfTtcblxuICBfcHJvdG8udG9KU09OID0gZnVuY3Rpb24gdG9KU09OKCkge1xuICAgIHJldHVybiB0aGlzLnRvU3RyaW5nKCk7XG4gIH07XG5cbiAgcmV0dXJuIER1cmF0aW9uO1xufShUZW1wb3JhbEFtb3VudCk7XG5mdW5jdGlvbiBfaW5pdCgpIHtcbiAgRHVyYXRpb24uWkVSTyA9IG5ldyBEdXJhdGlvbigwLCAwKTtcbn1cblxuLypcbiAqIEBjb3B5cmlnaHQgKGMpIDIwMTYsIFBoaWxpcHAgVGjDvHJ3w6RjaHRlciAmIFBhdHRyaWNrIEjDvHBlclxuICogQGxpY2Vuc2UgQlNELTMtQ2xhdXNlIChzZWUgTElDRU5TRS5tZCBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZSlcbiAqL1xudmFyIFllYXJDb25zdGFudHMgPSBmdW5jdGlvbiBZZWFyQ29uc3RhbnRzKCkge307XG5mdW5jdGlvbiBfaW5pdCQxKCkge1xuICBZZWFyQ29uc3RhbnRzLk1JTl9WQUxVRSA9IC05OTk5OTk7XG4gIFllYXJDb25zdGFudHMuTUFYX1ZBTFVFID0gOTk5OTk5O1xufVxuXG52YXIgQ2hyb25vVW5pdCA9IGZ1bmN0aW9uIChfVGVtcG9yYWxVbml0KSB7XG4gIF9pbmhlcml0c0xvb3NlKENocm9ub1VuaXQsIF9UZW1wb3JhbFVuaXQpO1xuXG4gIGZ1bmN0aW9uIENocm9ub1VuaXQobmFtZSwgZXN0aW1hdGVkRHVyYXRpb24pIHtcbiAgICB2YXIgX3RoaXM7XG5cbiAgICBfdGhpcyA9IF9UZW1wb3JhbFVuaXQuY2FsbCh0aGlzKSB8fCB0aGlzO1xuICAgIF90aGlzLl9uYW1lID0gbmFtZTtcbiAgICBfdGhpcy5fZHVyYXRpb24gPSBlc3RpbWF0ZWREdXJhdGlvbjtcbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cblxuICB2YXIgX3Byb3RvID0gQ2hyb25vVW5pdC5wcm90b3R5cGU7XG5cbiAgX3Byb3RvLmR1cmF0aW9uID0gZnVuY3Rpb24gZHVyYXRpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuX2R1cmF0aW9uO1xuICB9O1xuXG4gIF9wcm90by5pc0R1cmF0aW9uRXN0aW1hdGVkID0gZnVuY3Rpb24gaXNEdXJhdGlvbkVzdGltYXRlZCgpIHtcbiAgICByZXR1cm4gdGhpcy5pc0RhdGVCYXNlZCgpIHx8IHRoaXMgPT09IENocm9ub1VuaXQuRk9SRVZFUjtcbiAgfTtcblxuICBfcHJvdG8uaXNEYXRlQmFzZWQgPSBmdW5jdGlvbiBpc0RhdGVCYXNlZCgpIHtcbiAgICByZXR1cm4gdGhpcy5jb21wYXJlVG8oQ2hyb25vVW5pdC5EQVlTKSA+PSAwICYmIHRoaXMgIT09IENocm9ub1VuaXQuRk9SRVZFUjtcbiAgfTtcblxuICBfcHJvdG8uaXNUaW1lQmFzZWQgPSBmdW5jdGlvbiBpc1RpbWVCYXNlZCgpIHtcbiAgICByZXR1cm4gdGhpcy5jb21wYXJlVG8oQ2hyb25vVW5pdC5EQVlTKSA8IDA7XG4gIH07XG5cbiAgX3Byb3RvLmlzU3VwcG9ydGVkQnkgPSBmdW5jdGlvbiBpc1N1cHBvcnRlZEJ5KHRlbXBvcmFsKSB7XG4gICAgaWYgKHRoaXMgPT09IENocm9ub1VuaXQuRk9SRVZFUikge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHRyeSB7XG4gICAgICB0ZW1wb3JhbC5wbHVzKDEsIHRoaXMpO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgdGVtcG9yYWwucGx1cygtMSwgdGhpcyk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfSBjYXRjaCAoZTIpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICBfcHJvdG8uYWRkVG8gPSBmdW5jdGlvbiBhZGRUbyh0ZW1wb3JhbCwgYW1vdW50KSB7XG4gICAgcmV0dXJuIHRlbXBvcmFsLnBsdXMoYW1vdW50LCB0aGlzKTtcbiAgfTtcblxuICBfcHJvdG8uYmV0d2VlbiA9IGZ1bmN0aW9uIGJldHdlZW4odGVtcG9yYWwxLCB0ZW1wb3JhbDIpIHtcbiAgICByZXR1cm4gdGVtcG9yYWwxLnVudGlsKHRlbXBvcmFsMiwgdGhpcyk7XG4gIH07XG5cbiAgX3Byb3RvLnRvU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG4gICAgcmV0dXJuIHRoaXMuX25hbWU7XG4gIH07XG5cbiAgX3Byb3RvLmNvbXBhcmVUbyA9IGZ1bmN0aW9uIGNvbXBhcmVUbyhvdGhlcikge1xuICAgIHJldHVybiB0aGlzLmR1cmF0aW9uKCkuY29tcGFyZVRvKG90aGVyLmR1cmF0aW9uKCkpO1xuICB9O1xuXG4gIHJldHVybiBDaHJvbm9Vbml0O1xufShUZW1wb3JhbFVuaXQpO1xuZnVuY3Rpb24gX2luaXQkMigpIHtcbiAgQ2hyb25vVW5pdC5OQU5PUyA9IG5ldyBDaHJvbm9Vbml0KCdOYW5vcycsIER1cmF0aW9uLm9mTmFub3MoMSkpO1xuICBDaHJvbm9Vbml0Lk1JQ1JPUyA9IG5ldyBDaHJvbm9Vbml0KCdNaWNyb3MnLCBEdXJhdGlvbi5vZk5hbm9zKDEwMDApKTtcbiAgQ2hyb25vVW5pdC5NSUxMSVMgPSBuZXcgQ2hyb25vVW5pdCgnTWlsbGlzJywgRHVyYXRpb24ub2ZOYW5vcygxMDAwMDAwKSk7XG4gIENocm9ub1VuaXQuU0VDT05EUyA9IG5ldyBDaHJvbm9Vbml0KCdTZWNvbmRzJywgRHVyYXRpb24ub2ZTZWNvbmRzKDEpKTtcbiAgQ2hyb25vVW5pdC5NSU5VVEVTID0gbmV3IENocm9ub1VuaXQoJ01pbnV0ZXMnLCBEdXJhdGlvbi5vZlNlY29uZHMoNjApKTtcbiAgQ2hyb25vVW5pdC5IT1VSUyA9IG5ldyBDaHJvbm9Vbml0KCdIb3VycycsIER1cmF0aW9uLm9mU2Vjb25kcygzNjAwKSk7XG4gIENocm9ub1VuaXQuSEFMRl9EQVlTID0gbmV3IENocm9ub1VuaXQoJ0hhbGZEYXlzJywgRHVyYXRpb24ub2ZTZWNvbmRzKDQzMjAwKSk7XG4gIENocm9ub1VuaXQuREFZUyA9IG5ldyBDaHJvbm9Vbml0KCdEYXlzJywgRHVyYXRpb24ub2ZTZWNvbmRzKDg2NDAwKSk7XG4gIENocm9ub1VuaXQuV0VFS1MgPSBuZXcgQ2hyb25vVW5pdCgnV2Vla3MnLCBEdXJhdGlvbi5vZlNlY29uZHMoNyAqIDg2NDAwKSk7XG4gIENocm9ub1VuaXQuTU9OVEhTID0gbmV3IENocm9ub1VuaXQoJ01vbnRocycsIER1cmF0aW9uLm9mU2Vjb25kcygzMTU1Njk1MiAvIDEyKSk7XG4gIENocm9ub1VuaXQuWUVBUlMgPSBuZXcgQ2hyb25vVW5pdCgnWWVhcnMnLCBEdXJhdGlvbi5vZlNlY29uZHMoMzE1NTY5NTIpKTtcbiAgQ2hyb25vVW5pdC5ERUNBREVTID0gbmV3IENocm9ub1VuaXQoJ0RlY2FkZXMnLCBEdXJhdGlvbi5vZlNlY29uZHMoMzE1NTY5NTIgKiAxMCkpO1xuICBDaHJvbm9Vbml0LkNFTlRVUklFUyA9IG5ldyBDaHJvbm9Vbml0KCdDZW50dXJpZXMnLCBEdXJhdGlvbi5vZlNlY29uZHMoMzE1NTY5NTIgKiAxMDApKTtcbiAgQ2hyb25vVW5pdC5NSUxMRU5OSUEgPSBuZXcgQ2hyb25vVW5pdCgnTWlsbGVubmlhJywgRHVyYXRpb24ub2ZTZWNvbmRzKDMxNTU2OTUyICogMTAwMCkpO1xuICBDaHJvbm9Vbml0LkVSQVMgPSBuZXcgQ2hyb25vVW5pdCgnRXJhcycsIER1cmF0aW9uLm9mU2Vjb25kcygzMTU1Njk1MiAqIChZZWFyQ29uc3RhbnRzLk1BWF9WQUxVRSArIDEpKSk7XG4gIENocm9ub1VuaXQuRk9SRVZFUiA9IG5ldyBDaHJvbm9Vbml0KCdGb3JldmVyJywgRHVyYXRpb24ub2ZTZWNvbmRzKE1hdGhVdGlsLk1BWF9TQUZFX0lOVEVHRVIsIDk5OTk5OTk5OSkpO1xufVxuXG4vKipcbiAqIEBjb3B5cmlnaHQgKGMpIDIwMTYsIFBoaWxpcHAgVGjDvHJ3w6RjaHRlciAmIFBhdHRyaWNrIEjDvHBlclxuICogQGNvcHlyaWdodCAoYykgMjAwNy1wcmVzZW50LCBTdGVwaGVuIENvbGVib3VybmUgJiBNaWNoYWVsIE5hc2NpbWVudG8gU2FudG9zXG4gKiBAbGljZW5zZSBCU0QtMy1DbGF1c2UgKHNlZSBMSUNFTlNFIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlKVxuICovXG5cbnZhciBUZW1wb3JhbEZpZWxkID0gZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBUZW1wb3JhbEZpZWxkKCkge31cblxuICB2YXIgX3Byb3RvID0gVGVtcG9yYWxGaWVsZC5wcm90b3R5cGU7XG5cbiAgX3Byb3RvLmlzRGF0ZUJhc2VkID0gZnVuY3Rpb24gaXNEYXRlQmFzZWQoKSB7XG4gICAgYWJzdHJhY3RNZXRob2RGYWlsKCdpc0RhdGVCYXNlZCcpO1xuICB9O1xuXG4gIF9wcm90by5pc1RpbWVCYXNlZCA9IGZ1bmN0aW9uIGlzVGltZUJhc2VkKCkge1xuICAgIGFic3RyYWN0TWV0aG9kRmFpbCgnaXNUaW1lQmFzZWQnKTtcbiAgfTtcblxuICBfcHJvdG8uYmFzZVVuaXQgPSBmdW5jdGlvbiBiYXNlVW5pdCgpIHtcbiAgICBhYnN0cmFjdE1ldGhvZEZhaWwoJ2Jhc2VVbml0Jyk7XG4gIH07XG5cbiAgX3Byb3RvLnJhbmdlVW5pdCA9IGZ1bmN0aW9uIHJhbmdlVW5pdCgpIHtcbiAgICBhYnN0cmFjdE1ldGhvZEZhaWwoJ3JhbmdlVW5pdCcpO1xuICB9O1xuXG4gIF9wcm90by5yYW5nZSA9IGZ1bmN0aW9uIHJhbmdlKCkge1xuICAgIGFic3RyYWN0TWV0aG9kRmFpbCgncmFuZ2UnKTtcbiAgfTtcblxuICBfcHJvdG8ucmFuZ2VSZWZpbmVkQnkgPSBmdW5jdGlvbiByYW5nZVJlZmluZWRCeSh0ZW1wb3JhbCkge1xuICAgIGFic3RyYWN0TWV0aG9kRmFpbCgncmFuZ2VSZWZpbmVkQnknKTtcbiAgfTtcblxuICBfcHJvdG8uZ2V0RnJvbSA9IGZ1bmN0aW9uIGdldEZyb20odGVtcG9yYWwpIHtcbiAgICBhYnN0cmFjdE1ldGhvZEZhaWwoJ2dldEZyb20nKTtcbiAgfTtcblxuICBfcHJvdG8uYWRqdXN0SW50byA9IGZ1bmN0aW9uIGFkanVzdEludG8odGVtcG9yYWwsIG5ld1ZhbHVlKSB7XG4gICAgYWJzdHJhY3RNZXRob2RGYWlsKCdhZGp1c3RJbnRvJyk7XG4gIH07XG5cbiAgX3Byb3RvLmlzU3VwcG9ydGVkQnkgPSBmdW5jdGlvbiBpc1N1cHBvcnRlZEJ5KHRlbXBvcmFsKSB7XG4gICAgYWJzdHJhY3RNZXRob2RGYWlsKCdpc1N1cHBvcnRlZEJ5Jyk7XG4gIH07XG5cbiAgX3Byb3RvLmRpc3BsYXlOYW1lID0gZnVuY3Rpb24gZGlzcGxheU5hbWUoKSB7XG4gICAgYWJzdHJhY3RNZXRob2RGYWlsKCdkaXNwbGF5TmFtZScpO1xuICB9O1xuXG4gIF9wcm90by5lcXVhbHMgPSBmdW5jdGlvbiBlcXVhbHMob3RoZXIpIHtcbiAgICBhYnN0cmFjdE1ldGhvZEZhaWwoJ2VxdWFscycpO1xuICB9O1xuXG4gIF9wcm90by5uYW1lID0gZnVuY3Rpb24gbmFtZSgpIHtcbiAgICBhYnN0cmFjdE1ldGhvZEZhaWwoJ25hbWUnKTtcbiAgfTtcblxuICByZXR1cm4gVGVtcG9yYWxGaWVsZDtcbn0oKTtcblxuLyoqXG4gKiBAY29weXJpZ2h0IChjKSAyMDE2LCBQaGlsaXBwIFRow7xyd8OkY2h0ZXIgJiBQYXR0cmljayBIw7xwZXJcbiAqIEBjb3B5cmlnaHQgKGMpIDIwMDctcHJlc2VudCwgU3RlcGhlbiBDb2xlYm91cm5lICYgTWljaGFlbCBOYXNjaW1lbnRvIFNhbnRvc1xuICogQGxpY2Vuc2UgQlNELTMtQ2xhdXNlIChzZWUgTElDRU5TRSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZSlcbiAqL1xudmFyIFZhbHVlUmFuZ2UgPSBmdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIFZhbHVlUmFuZ2UobWluU21hbGxlc3QsIG1pbkxhcmdlc3QsIG1heFNtYWxsZXN0LCBtYXhMYXJnZXN0KSB7XG4gICAgYXNzZXJ0KCEobWluU21hbGxlc3QgPiBtaW5MYXJnZXN0KSwgJ1NtYWxsZXN0IG1pbmltdW0gdmFsdWUgXFwnJyArIG1pblNtYWxsZXN0ICsgJ1xcJyBtdXN0IGJlIGxlc3MgdGhhbiBsYXJnZXN0IG1pbmltdW0gdmFsdWUgXFwnJyArIG1pbkxhcmdlc3QgKyAnXFwnJywgSWxsZWdhbEFyZ3VtZW50RXhjZXB0aW9uKTtcbiAgICBhc3NlcnQoIShtYXhTbWFsbGVzdCA+IG1heExhcmdlc3QpLCAnU21hbGxlc3QgbWF4aW11bSB2YWx1ZSBcXCcnICsgbWF4U21hbGxlc3QgKyAnXFwnIG11c3QgYmUgbGVzcyB0aGFuIGxhcmdlc3QgbWF4aW11bSB2YWx1ZSBcXCcnICsgbWF4TGFyZ2VzdCArICdcXCcnLCBJbGxlZ2FsQXJndW1lbnRFeGNlcHRpb24pO1xuICAgIGFzc2VydCghKG1pbkxhcmdlc3QgPiBtYXhMYXJnZXN0KSwgJ01pbmltdW0gdmFsdWUgXFwnJyArIG1pbkxhcmdlc3QgKyAnXFwnIG11c3QgYmUgbGVzcyB0aGFuIG1heGltdW0gdmFsdWUgXFwnJyArIG1heExhcmdlc3QgKyAnXFwnJywgSWxsZWdhbEFyZ3VtZW50RXhjZXB0aW9uKTtcbiAgICB0aGlzLl9taW5TbWFsbGVzdCA9IG1pblNtYWxsZXN0O1xuICAgIHRoaXMuX21pbkxhcmdlc3QgPSBtaW5MYXJnZXN0O1xuICAgIHRoaXMuX21heExhcmdlc3QgPSBtYXhMYXJnZXN0O1xuICAgIHRoaXMuX21heFNtYWxsZXN0ID0gbWF4U21hbGxlc3Q7XG4gIH1cblxuICB2YXIgX3Byb3RvID0gVmFsdWVSYW5nZS5wcm90b3R5cGU7XG5cbiAgX3Byb3RvLmlzRml4ZWQgPSBmdW5jdGlvbiBpc0ZpeGVkKCkge1xuICAgIHJldHVybiB0aGlzLl9taW5TbWFsbGVzdCA9PT0gdGhpcy5fbWluTGFyZ2VzdCAmJiB0aGlzLl9tYXhTbWFsbGVzdCA9PT0gdGhpcy5fbWF4TGFyZ2VzdDtcbiAgfTtcblxuICBfcHJvdG8ubWluaW11bSA9IGZ1bmN0aW9uIG1pbmltdW0oKSB7XG4gICAgcmV0dXJuIHRoaXMuX21pblNtYWxsZXN0O1xuICB9O1xuXG4gIF9wcm90by5sYXJnZXN0TWluaW11bSA9IGZ1bmN0aW9uIGxhcmdlc3RNaW5pbXVtKCkge1xuICAgIHJldHVybiB0aGlzLl9taW5MYXJnZXN0O1xuICB9O1xuXG4gIF9wcm90by5tYXhpbXVtID0gZnVuY3Rpb24gbWF4aW11bSgpIHtcbiAgICByZXR1cm4gdGhpcy5fbWF4TGFyZ2VzdDtcbiAgfTtcblxuICBfcHJvdG8uc21hbGxlc3RNYXhpbXVtID0gZnVuY3Rpb24gc21hbGxlc3RNYXhpbXVtKCkge1xuICAgIHJldHVybiB0aGlzLl9tYXhTbWFsbGVzdDtcbiAgfTtcblxuICBfcHJvdG8uaXNWYWxpZFZhbHVlID0gZnVuY3Rpb24gaXNWYWxpZFZhbHVlKHZhbHVlKSB7XG4gICAgcmV0dXJuIHRoaXMubWluaW11bSgpIDw9IHZhbHVlICYmIHZhbHVlIDw9IHRoaXMubWF4aW11bSgpO1xuICB9O1xuXG4gIF9wcm90by5jaGVja1ZhbGlkVmFsdWUgPSBmdW5jdGlvbiBjaGVja1ZhbGlkVmFsdWUodmFsdWUsIGZpZWxkKSB7XG4gICAgdmFyIG1zZztcblxuICAgIGlmICghdGhpcy5pc1ZhbGlkVmFsdWUodmFsdWUpKSB7XG4gICAgICBpZiAoZmllbGQgIT0gbnVsbCkge1xuICAgICAgICBtc2cgPSAnSW52YWxpZCB2YWx1ZSBmb3IgJyArIGZpZWxkICsgJyAodmFsaWQgdmFsdWVzICcgKyB0aGlzLnRvU3RyaW5nKCkgKyAnKTogJyArIHZhbHVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbXNnID0gJ0ludmFsaWQgdmFsdWUgKHZhbGlkIHZhbHVlcyAnICsgdGhpcy50b1N0cmluZygpICsgJyk6ICcgKyB2YWx1ZTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGFzc2VydChmYWxzZSwgbXNnLCBEYXRlVGltZUV4Y2VwdGlvbik7XG4gICAgfVxuXG4gICAgcmV0dXJuIHZhbHVlO1xuICB9O1xuXG4gIF9wcm90by5jaGVja1ZhbGlkSW50VmFsdWUgPSBmdW5jdGlvbiBjaGVja1ZhbGlkSW50VmFsdWUodmFsdWUsIGZpZWxkKSB7XG4gICAgaWYgKHRoaXMuaXNWYWxpZEludFZhbHVlKHZhbHVlKSA9PT0gZmFsc2UpIHtcbiAgICAgIHRocm93IG5ldyBEYXRlVGltZUV4Y2VwdGlvbignSW52YWxpZCBpbnQgdmFsdWUgZm9yICcgKyBmaWVsZCArICc6ICcgKyB2YWx1ZSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHZhbHVlO1xuICB9O1xuXG4gIF9wcm90by5pc1ZhbGlkSW50VmFsdWUgPSBmdW5jdGlvbiBpc1ZhbGlkSW50VmFsdWUodmFsdWUpIHtcbiAgICByZXR1cm4gdGhpcy5pc0ludFZhbHVlKCkgJiYgdGhpcy5pc1ZhbGlkVmFsdWUodmFsdWUpO1xuICB9O1xuXG4gIF9wcm90by5pc0ludFZhbHVlID0gZnVuY3Rpb24gaXNJbnRWYWx1ZSgpIHtcbiAgICByZXR1cm4gdGhpcy5taW5pbXVtKCkgPj0gTWF0aFV0aWwuTUlOX1NBRkVfSU5URUdFUiAmJiB0aGlzLm1heGltdW0oKSA8PSBNYXRoVXRpbC5NQVhfU0FGRV9JTlRFR0VSO1xuICB9O1xuXG4gIF9wcm90by5lcXVhbHMgPSBmdW5jdGlvbiBlcXVhbHMob3RoZXIpIHtcbiAgICBpZiAob3RoZXIgPT09IHRoaXMpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIGlmIChvdGhlciBpbnN0YW5jZW9mIFZhbHVlUmFuZ2UpIHtcbiAgICAgIHJldHVybiB0aGlzLl9taW5TbWFsbGVzdCA9PT0gb3RoZXIuX21pblNtYWxsZXN0ICYmIHRoaXMuX21pbkxhcmdlc3QgPT09IG90aGVyLl9taW5MYXJnZXN0ICYmIHRoaXMuX21heFNtYWxsZXN0ID09PSBvdGhlci5fbWF4U21hbGxlc3QgJiYgdGhpcy5fbWF4TGFyZ2VzdCA9PT0gb3RoZXIuX21heExhcmdlc3Q7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9O1xuXG4gIF9wcm90by5oYXNoQ29kZSA9IGZ1bmN0aW9uIGhhc2hDb2RlKCkge1xuICAgIHJldHVybiBNYXRoVXRpbC5oYXNoQ29kZSh0aGlzLl9taW5TbWFsbGVzdCwgdGhpcy5fbWluTGFyZ2VzdCwgdGhpcy5fbWF4U21hbGxlc3QsIHRoaXMuX21heExhcmdlc3QpO1xuICB9O1xuXG4gIF9wcm90by50b1N0cmluZyA9IGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuICAgIHZhciBzdHIgPSB0aGlzLm1pbmltdW0oKSArICh0aGlzLm1pbmltdW0oKSAhPT0gdGhpcy5sYXJnZXN0TWluaW11bSgpID8gJy8nICsgdGhpcy5sYXJnZXN0TWluaW11bSgpIDogJycpO1xuICAgIHN0ciArPSAnIC0gJztcbiAgICBzdHIgKz0gdGhpcy5zbWFsbGVzdE1heGltdW0oKSArICh0aGlzLnNtYWxsZXN0TWF4aW11bSgpICE9PSB0aGlzLm1heGltdW0oKSA/ICcvJyArIHRoaXMubWF4aW11bSgpIDogJycpO1xuICAgIHJldHVybiBzdHI7XG4gIH07XG5cbiAgVmFsdWVSYW5nZS5vZiA9IGZ1bmN0aW9uIG9mKCkge1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAyKSB7XG4gICAgICByZXR1cm4gbmV3IFZhbHVlUmFuZ2UoYXJndW1lbnRzWzBdLCBhcmd1bWVudHNbMF0sIGFyZ3VtZW50c1sxXSwgYXJndW1lbnRzWzFdKTtcbiAgICB9IGVsc2UgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDMpIHtcbiAgICAgIHJldHVybiBuZXcgVmFsdWVSYW5nZShhcmd1bWVudHNbMF0sIGFyZ3VtZW50c1swXSwgYXJndW1lbnRzWzFdLCBhcmd1bWVudHNbMl0pO1xuICAgIH0gZWxzZSBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gNCkge1xuICAgICAgcmV0dXJuIG5ldyBWYWx1ZVJhbmdlKGFyZ3VtZW50c1swXSwgYXJndW1lbnRzWzFdLCBhcmd1bWVudHNbMl0sIGFyZ3VtZW50c1szXSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBhc3NlcnQoZmFsc2UsICdJbnZhbGlkIG51bWJlciBvZiBhcmd1bWVudHMgJyArIGFyZ3VtZW50cy5sZW5ndGgsIElsbGVnYWxBcmd1bWVudEV4Y2VwdGlvbik7XG4gICAgfVxuICB9O1xuXG4gIHJldHVybiBWYWx1ZVJhbmdlO1xufSgpO1xuXG52YXIgQ2hyb25vRmllbGQgPSBmdW5jdGlvbiAoX1RlbXBvcmFsRmllbGQpIHtcbiAgX2luaGVyaXRzTG9vc2UoQ2hyb25vRmllbGQsIF9UZW1wb3JhbEZpZWxkKTtcblxuICBDaHJvbm9GaWVsZC5ieU5hbWUgPSBmdW5jdGlvbiBieU5hbWUoZmllbGROYW1lKSB7XG4gICAgZm9yICh2YXIgcHJvcCBpbiBDaHJvbm9GaWVsZCkge1xuICAgICAgaWYgKENocm9ub0ZpZWxkW3Byb3BdKSB7XG4gICAgICAgIGlmIChDaHJvbm9GaWVsZFtwcm9wXSBpbnN0YW5jZW9mIENocm9ub0ZpZWxkICYmIENocm9ub0ZpZWxkW3Byb3BdLm5hbWUoKSA9PT0gZmllbGROYW1lKSB7XG4gICAgICAgICAgcmV0dXJuIENocm9ub0ZpZWxkW3Byb3BdO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIGZ1bmN0aW9uIENocm9ub0ZpZWxkKG5hbWUsIGJhc2VVbml0LCByYW5nZVVuaXQsIHJhbmdlKSB7XG4gICAgdmFyIF90aGlzO1xuXG4gICAgX3RoaXMgPSBfVGVtcG9yYWxGaWVsZC5jYWxsKHRoaXMpIHx8IHRoaXM7XG4gICAgX3RoaXMuX25hbWUgPSBuYW1lO1xuICAgIF90aGlzLl9iYXNlVW5pdCA9IGJhc2VVbml0O1xuICAgIF90aGlzLl9yYW5nZVVuaXQgPSByYW5nZVVuaXQ7XG4gICAgX3RoaXMuX3JhbmdlID0gcmFuZ2U7XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG5cbiAgdmFyIF9wcm90byA9IENocm9ub0ZpZWxkLnByb3RvdHlwZTtcblxuICBfcHJvdG8ubmFtZSA9IGZ1bmN0aW9uIG5hbWUoKSB7XG4gICAgcmV0dXJuIHRoaXMuX25hbWU7XG4gIH07XG5cbiAgX3Byb3RvLmJhc2VVbml0ID0gZnVuY3Rpb24gYmFzZVVuaXQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2Jhc2VVbml0O1xuICB9O1xuXG4gIF9wcm90by5yYW5nZVVuaXQgPSBmdW5jdGlvbiByYW5nZVVuaXQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3JhbmdlVW5pdDtcbiAgfTtcblxuICBfcHJvdG8ucmFuZ2UgPSBmdW5jdGlvbiByYW5nZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fcmFuZ2U7XG4gIH07XG5cbiAgX3Byb3RvLmRpc3BsYXlOYW1lID0gZnVuY3Rpb24gZGlzcGxheU5hbWUoKSB7XG4gICAgcmV0dXJuIHRoaXMudG9TdHJpbmcoKTtcbiAgfTtcblxuICBfcHJvdG8uY2hlY2tWYWxpZFZhbHVlID0gZnVuY3Rpb24gY2hlY2tWYWxpZFZhbHVlKHZhbHVlKSB7XG4gICAgcmV0dXJuIHRoaXMucmFuZ2UoKS5jaGVja1ZhbGlkVmFsdWUodmFsdWUsIHRoaXMpO1xuICB9O1xuXG4gIF9wcm90by5jaGVja1ZhbGlkSW50VmFsdWUgPSBmdW5jdGlvbiBjaGVja1ZhbGlkSW50VmFsdWUodmFsdWUpIHtcbiAgICByZXR1cm4gdGhpcy5yYW5nZSgpLmNoZWNrVmFsaWRJbnRWYWx1ZSh2YWx1ZSwgdGhpcyk7XG4gIH07XG5cbiAgX3Byb3RvLmlzRGF0ZUJhc2VkID0gZnVuY3Rpb24gaXNEYXRlQmFzZWQoKSB7XG4gICAgdmFyIGRhdGVCYXNlZCA9IHRoaXMgPT09IENocm9ub0ZpZWxkLkRBWV9PRl9XRUVLIHx8IHRoaXMgPT09IENocm9ub0ZpZWxkLkFMSUdORURfREFZX09GX1dFRUtfSU5fTU9OVEggfHwgdGhpcyA9PT0gQ2hyb25vRmllbGQuQUxJR05FRF9EQVlfT0ZfV0VFS19JTl9ZRUFSIHx8IHRoaXMgPT09IENocm9ub0ZpZWxkLkRBWV9PRl9NT05USCB8fCB0aGlzID09PSBDaHJvbm9GaWVsZC5EQVlfT0ZfWUVBUiB8fCB0aGlzID09PSBDaHJvbm9GaWVsZC5FUE9DSF9EQVkgfHwgdGhpcyA9PT0gQ2hyb25vRmllbGQuQUxJR05FRF9XRUVLX09GX01PTlRIIHx8IHRoaXMgPT09IENocm9ub0ZpZWxkLkFMSUdORURfV0VFS19PRl9ZRUFSIHx8IHRoaXMgPT09IENocm9ub0ZpZWxkLk1PTlRIX09GX1lFQVIgfHwgdGhpcyA9PT0gQ2hyb25vRmllbGQuWUVBUl9PRl9FUkEgfHwgdGhpcyA9PT0gQ2hyb25vRmllbGQuWUVBUiB8fCB0aGlzID09PSBDaHJvbm9GaWVsZC5FUkE7XG4gICAgcmV0dXJuIGRhdGVCYXNlZDtcbiAgfTtcblxuICBfcHJvdG8uaXNUaW1lQmFzZWQgPSBmdW5jdGlvbiBpc1RpbWVCYXNlZCgpIHtcbiAgICB2YXIgdGltZUJhc2VkID0gdGhpcyA9PT0gQ2hyb25vRmllbGQuTkFOT19PRl9TRUNPTkQgfHwgdGhpcyA9PT0gQ2hyb25vRmllbGQuTkFOT19PRl9EQVkgfHwgdGhpcyA9PT0gQ2hyb25vRmllbGQuTUlDUk9fT0ZfU0VDT05EIHx8IHRoaXMgPT09IENocm9ub0ZpZWxkLk1JQ1JPX09GX0RBWSB8fCB0aGlzID09PSBDaHJvbm9GaWVsZC5NSUxMSV9PRl9TRUNPTkQgfHwgdGhpcyA9PT0gQ2hyb25vRmllbGQuTUlMTElfT0ZfREFZIHx8IHRoaXMgPT09IENocm9ub0ZpZWxkLlNFQ09ORF9PRl9NSU5VVEUgfHwgdGhpcyA9PT0gQ2hyb25vRmllbGQuU0VDT05EX09GX0RBWSB8fCB0aGlzID09PSBDaHJvbm9GaWVsZC5NSU5VVEVfT0ZfSE9VUiB8fCB0aGlzID09PSBDaHJvbm9GaWVsZC5NSU5VVEVfT0ZfREFZIHx8IHRoaXMgPT09IENocm9ub0ZpZWxkLkhPVVJfT0ZfQU1QTSB8fCB0aGlzID09PSBDaHJvbm9GaWVsZC5DTE9DS19IT1VSX09GX0FNUE0gfHwgdGhpcyA9PT0gQ2hyb25vRmllbGQuSE9VUl9PRl9EQVkgfHwgdGhpcyA9PT0gQ2hyb25vRmllbGQuQ0xPQ0tfSE9VUl9PRl9EQVkgfHwgdGhpcyA9PT0gQ2hyb25vRmllbGQuQU1QTV9PRl9EQVk7XG4gICAgcmV0dXJuIHRpbWVCYXNlZDtcbiAgfTtcblxuICBfcHJvdG8ucmFuZ2VSZWZpbmVkQnkgPSBmdW5jdGlvbiByYW5nZVJlZmluZWRCeSh0ZW1wb3JhbCkge1xuICAgIHJldHVybiB0ZW1wb3JhbC5yYW5nZSh0aGlzKTtcbiAgfTtcblxuICBfcHJvdG8uZ2V0RnJvbSA9IGZ1bmN0aW9uIGdldEZyb20odGVtcG9yYWwpIHtcbiAgICByZXR1cm4gdGVtcG9yYWwuZ2V0TG9uZyh0aGlzKTtcbiAgfTtcblxuICBfcHJvdG8udG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZygpIHtcbiAgICByZXR1cm4gdGhpcy5uYW1lKCk7XG4gIH07XG5cbiAgX3Byb3RvLmVxdWFscyA9IGZ1bmN0aW9uIGVxdWFscyhvdGhlcikge1xuICAgIHJldHVybiB0aGlzID09PSBvdGhlcjtcbiAgfTtcblxuICBfcHJvdG8uYWRqdXN0SW50byA9IGZ1bmN0aW9uIGFkanVzdEludG8odGVtcG9yYWwsIG5ld1ZhbHVlKSB7XG4gICAgcmV0dXJuIHRlbXBvcmFsLndpdGgodGhpcywgbmV3VmFsdWUpO1xuICB9O1xuXG4gIF9wcm90by5pc1N1cHBvcnRlZEJ5ID0gZnVuY3Rpb24gaXNTdXBwb3J0ZWRCeSh0ZW1wb3JhbCkge1xuICAgIHJldHVybiB0ZW1wb3JhbC5pc1N1cHBvcnRlZCh0aGlzKTtcbiAgfTtcblxuICByZXR1cm4gQ2hyb25vRmllbGQ7XG59KFRlbXBvcmFsRmllbGQpO1xuZnVuY3Rpb24gX2luaXQkMygpIHtcbiAgQ2hyb25vRmllbGQuTkFOT19PRl9TRUNPTkQgPSBuZXcgQ2hyb25vRmllbGQoJ05hbm9PZlNlY29uZCcsIENocm9ub1VuaXQuTkFOT1MsIENocm9ub1VuaXQuU0VDT05EUywgVmFsdWVSYW5nZS5vZigwLCA5OTk5OTk5OTkpKTtcbiAgQ2hyb25vRmllbGQuTkFOT19PRl9EQVkgPSBuZXcgQ2hyb25vRmllbGQoJ05hbm9PZkRheScsIENocm9ub1VuaXQuTkFOT1MsIENocm9ub1VuaXQuREFZUywgVmFsdWVSYW5nZS5vZigwLCA4NjQwMCAqIDEwMDAwMDAwMDAgLSAxKSk7XG4gIENocm9ub0ZpZWxkLk1JQ1JPX09GX1NFQ09ORCA9IG5ldyBDaHJvbm9GaWVsZCgnTWljcm9PZlNlY29uZCcsIENocm9ub1VuaXQuTUlDUk9TLCBDaHJvbm9Vbml0LlNFQ09ORFMsIFZhbHVlUmFuZ2Uub2YoMCwgOTk5OTk5KSk7XG4gIENocm9ub0ZpZWxkLk1JQ1JPX09GX0RBWSA9IG5ldyBDaHJvbm9GaWVsZCgnTWljcm9PZkRheScsIENocm9ub1VuaXQuTUlDUk9TLCBDaHJvbm9Vbml0LkRBWVMsIFZhbHVlUmFuZ2Uub2YoMCwgODY0MDAgKiAxMDAwMDAwIC0gMSkpO1xuICBDaHJvbm9GaWVsZC5NSUxMSV9PRl9TRUNPTkQgPSBuZXcgQ2hyb25vRmllbGQoJ01pbGxpT2ZTZWNvbmQnLCBDaHJvbm9Vbml0Lk1JTExJUywgQ2hyb25vVW5pdC5TRUNPTkRTLCBWYWx1ZVJhbmdlLm9mKDAsIDk5OSkpO1xuICBDaHJvbm9GaWVsZC5NSUxMSV9PRl9EQVkgPSBuZXcgQ2hyb25vRmllbGQoJ01pbGxpT2ZEYXknLCBDaHJvbm9Vbml0Lk1JTExJUywgQ2hyb25vVW5pdC5EQVlTLCBWYWx1ZVJhbmdlLm9mKDAsIDg2NDAwICogMTAwMCAtIDEpKTtcbiAgQ2hyb25vRmllbGQuU0VDT05EX09GX01JTlVURSA9IG5ldyBDaHJvbm9GaWVsZCgnU2Vjb25kT2ZNaW51dGUnLCBDaHJvbm9Vbml0LlNFQ09ORFMsIENocm9ub1VuaXQuTUlOVVRFUywgVmFsdWVSYW5nZS5vZigwLCA1OSkpO1xuICBDaHJvbm9GaWVsZC5TRUNPTkRfT0ZfREFZID0gbmV3IENocm9ub0ZpZWxkKCdTZWNvbmRPZkRheScsIENocm9ub1VuaXQuU0VDT05EUywgQ2hyb25vVW5pdC5EQVlTLCBWYWx1ZVJhbmdlLm9mKDAsIDg2NDAwIC0gMSkpO1xuICBDaHJvbm9GaWVsZC5NSU5VVEVfT0ZfSE9VUiA9IG5ldyBDaHJvbm9GaWVsZCgnTWludXRlT2ZIb3VyJywgQ2hyb25vVW5pdC5NSU5VVEVTLCBDaHJvbm9Vbml0LkhPVVJTLCBWYWx1ZVJhbmdlLm9mKDAsIDU5KSk7XG4gIENocm9ub0ZpZWxkLk1JTlVURV9PRl9EQVkgPSBuZXcgQ2hyb25vRmllbGQoJ01pbnV0ZU9mRGF5JywgQ2hyb25vVW5pdC5NSU5VVEVTLCBDaHJvbm9Vbml0LkRBWVMsIFZhbHVlUmFuZ2Uub2YoMCwgMjQgKiA2MCAtIDEpKTtcbiAgQ2hyb25vRmllbGQuSE9VUl9PRl9BTVBNID0gbmV3IENocm9ub0ZpZWxkKCdIb3VyT2ZBbVBtJywgQ2hyb25vVW5pdC5IT1VSUywgQ2hyb25vVW5pdC5IQUxGX0RBWVMsIFZhbHVlUmFuZ2Uub2YoMCwgMTEpKTtcbiAgQ2hyb25vRmllbGQuQ0xPQ0tfSE9VUl9PRl9BTVBNID0gbmV3IENocm9ub0ZpZWxkKCdDbG9ja0hvdXJPZkFtUG0nLCBDaHJvbm9Vbml0LkhPVVJTLCBDaHJvbm9Vbml0LkhBTEZfREFZUywgVmFsdWVSYW5nZS5vZigxLCAxMikpO1xuICBDaHJvbm9GaWVsZC5IT1VSX09GX0RBWSA9IG5ldyBDaHJvbm9GaWVsZCgnSG91ck9mRGF5JywgQ2hyb25vVW5pdC5IT1VSUywgQ2hyb25vVW5pdC5EQVlTLCBWYWx1ZVJhbmdlLm9mKDAsIDIzKSk7XG4gIENocm9ub0ZpZWxkLkNMT0NLX0hPVVJfT0ZfREFZID0gbmV3IENocm9ub0ZpZWxkKCdDbG9ja0hvdXJPZkRheScsIENocm9ub1VuaXQuSE9VUlMsIENocm9ub1VuaXQuREFZUywgVmFsdWVSYW5nZS5vZigxLCAyNCkpO1xuICBDaHJvbm9GaWVsZC5BTVBNX09GX0RBWSA9IG5ldyBDaHJvbm9GaWVsZCgnQW1QbU9mRGF5JywgQ2hyb25vVW5pdC5IQUxGX0RBWVMsIENocm9ub1VuaXQuREFZUywgVmFsdWVSYW5nZS5vZigwLCAxKSk7XG4gIENocm9ub0ZpZWxkLkRBWV9PRl9XRUVLID0gbmV3IENocm9ub0ZpZWxkKCdEYXlPZldlZWsnLCBDaHJvbm9Vbml0LkRBWVMsIENocm9ub1VuaXQuV0VFS1MsIFZhbHVlUmFuZ2Uub2YoMSwgNykpO1xuICBDaHJvbm9GaWVsZC5BTElHTkVEX0RBWV9PRl9XRUVLX0lOX01PTlRIID0gbmV3IENocm9ub0ZpZWxkKCdBbGlnbmVkRGF5T2ZXZWVrSW5Nb250aCcsIENocm9ub1VuaXQuREFZUywgQ2hyb25vVW5pdC5XRUVLUywgVmFsdWVSYW5nZS5vZigxLCA3KSk7XG4gIENocm9ub0ZpZWxkLkFMSUdORURfREFZX09GX1dFRUtfSU5fWUVBUiA9IG5ldyBDaHJvbm9GaWVsZCgnQWxpZ25lZERheU9mV2Vla0luWWVhcicsIENocm9ub1VuaXQuREFZUywgQ2hyb25vVW5pdC5XRUVLUywgVmFsdWVSYW5nZS5vZigxLCA3KSk7XG4gIENocm9ub0ZpZWxkLkRBWV9PRl9NT05USCA9IG5ldyBDaHJvbm9GaWVsZCgnRGF5T2ZNb250aCcsIENocm9ub1VuaXQuREFZUywgQ2hyb25vVW5pdC5NT05USFMsIFZhbHVlUmFuZ2Uub2YoMSwgMjgsIDMxKSwgJ2RheScpO1xuICBDaHJvbm9GaWVsZC5EQVlfT0ZfWUVBUiA9IG5ldyBDaHJvbm9GaWVsZCgnRGF5T2ZZZWFyJywgQ2hyb25vVW5pdC5EQVlTLCBDaHJvbm9Vbml0LllFQVJTLCBWYWx1ZVJhbmdlLm9mKDEsIDM2NSwgMzY2KSk7XG4gIENocm9ub0ZpZWxkLkVQT0NIX0RBWSA9IG5ldyBDaHJvbm9GaWVsZCgnRXBvY2hEYXknLCBDaHJvbm9Vbml0LkRBWVMsIENocm9ub1VuaXQuRk9SRVZFUiwgVmFsdWVSYW5nZS5vZihNYXRoLmZsb29yKFllYXJDb25zdGFudHMuTUlOX1ZBTFVFICogMzY1LjI1KSwgTWF0aC5mbG9vcihZZWFyQ29uc3RhbnRzLk1BWF9WQUxVRSAqIDM2NS4yNSkpKTtcbiAgQ2hyb25vRmllbGQuQUxJR05FRF9XRUVLX09GX01PTlRIID0gbmV3IENocm9ub0ZpZWxkKCdBbGlnbmVkV2Vla09mTW9udGgnLCBDaHJvbm9Vbml0LldFRUtTLCBDaHJvbm9Vbml0Lk1PTlRIUywgVmFsdWVSYW5nZS5vZigxLCA0LCA1KSk7XG4gIENocm9ub0ZpZWxkLkFMSUdORURfV0VFS19PRl9ZRUFSID0gbmV3IENocm9ub0ZpZWxkKCdBbGlnbmVkV2Vla09mWWVhcicsIENocm9ub1VuaXQuV0VFS1MsIENocm9ub1VuaXQuWUVBUlMsIFZhbHVlUmFuZ2Uub2YoMSwgNTMpKTtcbiAgQ2hyb25vRmllbGQuTU9OVEhfT0ZfWUVBUiA9IG5ldyBDaHJvbm9GaWVsZCgnTW9udGhPZlllYXInLCBDaHJvbm9Vbml0Lk1PTlRIUywgQ2hyb25vVW5pdC5ZRUFSUywgVmFsdWVSYW5nZS5vZigxLCAxMiksICdtb250aCcpO1xuICBDaHJvbm9GaWVsZC5QUk9MRVBUSUNfTU9OVEggPSBuZXcgQ2hyb25vRmllbGQoJ1Byb2xlcHRpY01vbnRoJywgQ2hyb25vVW5pdC5NT05USFMsIENocm9ub1VuaXQuRk9SRVZFUiwgVmFsdWVSYW5nZS5vZihZZWFyQ29uc3RhbnRzLk1JTl9WQUxVRSAqIDEyLCBZZWFyQ29uc3RhbnRzLk1BWF9WQUxVRSAqIDEyICsgMTEpKTtcbiAgQ2hyb25vRmllbGQuWUVBUl9PRl9FUkEgPSBuZXcgQ2hyb25vRmllbGQoJ1llYXJPZkVyYScsIENocm9ub1VuaXQuWUVBUlMsIENocm9ub1VuaXQuRk9SRVZFUiwgVmFsdWVSYW5nZS5vZigxLCBZZWFyQ29uc3RhbnRzLk1BWF9WQUxVRSwgWWVhckNvbnN0YW50cy5NQVhfVkFMVUUgKyAxKSk7XG4gIENocm9ub0ZpZWxkLllFQVIgPSBuZXcgQ2hyb25vRmllbGQoJ1llYXInLCBDaHJvbm9Vbml0LllFQVJTLCBDaHJvbm9Vbml0LkZPUkVWRVIsIFZhbHVlUmFuZ2Uub2YoWWVhckNvbnN0YW50cy5NSU5fVkFMVUUsIFllYXJDb25zdGFudHMuTUFYX1ZBTFVFKSwgJ3llYXInKTtcbiAgQ2hyb25vRmllbGQuRVJBID0gbmV3IENocm9ub0ZpZWxkKCdFcmEnLCBDaHJvbm9Vbml0LkVSQVMsIENocm9ub1VuaXQuRk9SRVZFUiwgVmFsdWVSYW5nZS5vZigwLCAxKSk7XG4gIENocm9ub0ZpZWxkLklOU1RBTlRfU0VDT05EUyA9IG5ldyBDaHJvbm9GaWVsZCgnSW5zdGFudFNlY29uZHMnLCBDaHJvbm9Vbml0LlNFQ09ORFMsIENocm9ub1VuaXQuRk9SRVZFUiwgVmFsdWVSYW5nZS5vZihNSU5fU0FGRV9JTlRFR0VSLCBNQVhfU0FGRV9JTlRFR0VSKSk7XG4gIENocm9ub0ZpZWxkLk9GRlNFVF9TRUNPTkRTID0gbmV3IENocm9ub0ZpZWxkKCdPZmZzZXRTZWNvbmRzJywgQ2hyb25vVW5pdC5TRUNPTkRTLCBDaHJvbm9Vbml0LkZPUkVWRVIsIFZhbHVlUmFuZ2Uub2YoLTE4ICogMzYwMCwgMTggKiAzNjAwKSk7XG59XG5cbi8qKlxuICogQGNvcHlyaWdodCAoYykgMjAxNiwgUGhpbGlwcCBUaMO8cnfDpGNodGVyICYgUGF0dHJpY2sgSMO8cGVyXG4gKiBAY29weXJpZ2h0IChjKSAyMDA3LXByZXNlbnQsIFN0ZXBoZW4gQ29sZWJvdXJuZSAmIE1pY2hhZWwgTmFzY2ltZW50byBTYW50b3NcbiAqIEBsaWNlbnNlIEJTRC0zLUNsYXVzZSAoc2VlIExJQ0VOU0UgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUpXG4gKi9cbnZhciBUZW1wb3JhbFF1ZXJpZXMgPSBmdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIFRlbXBvcmFsUXVlcmllcygpIHt9XG5cbiAgVGVtcG9yYWxRdWVyaWVzLnpvbmVJZCA9IGZ1bmN0aW9uIHpvbmVJZCgpIHtcbiAgICByZXR1cm4gVGVtcG9yYWxRdWVyaWVzLlpPTkVfSUQ7XG4gIH07XG5cbiAgVGVtcG9yYWxRdWVyaWVzLmNocm9ub2xvZ3kgPSBmdW5jdGlvbiBjaHJvbm9sb2d5KCkge1xuICAgIHJldHVybiBUZW1wb3JhbFF1ZXJpZXMuQ0hST05PO1xuICB9O1xuXG4gIFRlbXBvcmFsUXVlcmllcy5wcmVjaXNpb24gPSBmdW5jdGlvbiBwcmVjaXNpb24oKSB7XG4gICAgcmV0dXJuIFRlbXBvcmFsUXVlcmllcy5QUkVDSVNJT047XG4gIH07XG5cbiAgVGVtcG9yYWxRdWVyaWVzLnpvbmUgPSBmdW5jdGlvbiB6b25lKCkge1xuICAgIHJldHVybiBUZW1wb3JhbFF1ZXJpZXMuWk9ORTtcbiAgfTtcblxuICBUZW1wb3JhbFF1ZXJpZXMub2Zmc2V0ID0gZnVuY3Rpb24gb2Zmc2V0KCkge1xuICAgIHJldHVybiBUZW1wb3JhbFF1ZXJpZXMuT0ZGU0VUO1xuICB9O1xuXG4gIFRlbXBvcmFsUXVlcmllcy5sb2NhbERhdGUgPSBmdW5jdGlvbiBsb2NhbERhdGUoKSB7XG4gICAgcmV0dXJuIFRlbXBvcmFsUXVlcmllcy5MT0NBTF9EQVRFO1xuICB9O1xuXG4gIFRlbXBvcmFsUXVlcmllcy5sb2NhbFRpbWUgPSBmdW5jdGlvbiBsb2NhbFRpbWUoKSB7XG4gICAgcmV0dXJuIFRlbXBvcmFsUXVlcmllcy5MT0NBTF9USU1FO1xuICB9O1xuXG4gIHJldHVybiBUZW1wb3JhbFF1ZXJpZXM7XG59KCk7XG5cbi8qKlxuICogQGNvcHlyaWdodCAoYykgMjAxNiwgUGhpbGlwcCBUaMO8cnfDpGNodGVyICYgUGF0dHJpY2sgSMO8cGVyXG4gKiBAY29weXJpZ2h0IChjKSAyMDA3LXByZXNlbnQsIFN0ZXBoZW4gQ29sZWJvdXJuZSAmIE1pY2hhZWwgTmFzY2ltZW50byBTYW50b3NcbiAqIEBsaWNlbnNlIEJTRC0zLUNsYXVzZSAoc2VlIExJQ0VOU0UgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUpXG4gKi9cbnZhciBUZW1wb3JhbEFjY2Vzc29yID0gZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBUZW1wb3JhbEFjY2Vzc29yKCkge31cblxuICB2YXIgX3Byb3RvID0gVGVtcG9yYWxBY2Nlc3Nvci5wcm90b3R5cGU7XG5cbiAgX3Byb3RvLnF1ZXJ5ID0gZnVuY3Rpb24gcXVlcnkoX3F1ZXJ5KSB7XG4gICAgaWYgKF9xdWVyeSA9PT0gVGVtcG9yYWxRdWVyaWVzLnpvbmVJZCgpIHx8IF9xdWVyeSA9PT0gVGVtcG9yYWxRdWVyaWVzLmNocm9ub2xvZ3koKSB8fCBfcXVlcnkgPT09IFRlbXBvcmFsUXVlcmllcy5wcmVjaXNpb24oKSkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgcmV0dXJuIF9xdWVyeS5xdWVyeUZyb20odGhpcyk7XG4gIH07XG5cbiAgX3Byb3RvLmdldCA9IGZ1bmN0aW9uIGdldChmaWVsZCkge1xuICAgIHJldHVybiB0aGlzLnJhbmdlKGZpZWxkKS5jaGVja1ZhbGlkSW50VmFsdWUodGhpcy5nZXRMb25nKGZpZWxkKSwgZmllbGQpO1xuICB9O1xuXG4gIF9wcm90by5yYW5nZSA9IGZ1bmN0aW9uIHJhbmdlKGZpZWxkKSB7XG4gICAgaWYgKGZpZWxkIGluc3RhbmNlb2YgQ2hyb25vRmllbGQpIHtcbiAgICAgIGlmICh0aGlzLmlzU3VwcG9ydGVkKGZpZWxkKSkge1xuICAgICAgICByZXR1cm4gZmllbGQucmFuZ2UoKTtcbiAgICAgIH1cblxuICAgICAgdGhyb3cgbmV3IFVuc3VwcG9ydGVkVGVtcG9yYWxUeXBlRXhjZXB0aW9uKCdVbnN1cHBvcnRlZCBmaWVsZDogJyArIGZpZWxkKTtcbiAgICB9XG5cbiAgICByZXR1cm4gZmllbGQucmFuZ2VSZWZpbmVkQnkodGhpcyk7XG4gIH07XG5cbiAgcmV0dXJuIFRlbXBvcmFsQWNjZXNzb3I7XG59KCk7XG5cbnZhciBUZW1wb3JhbFF1ZXJ5ID0gZnVuY3Rpb24gKF9FbnVtKSB7XG4gIF9pbmhlcml0c0xvb3NlKFRlbXBvcmFsUXVlcnksIF9FbnVtKTtcblxuICBmdW5jdGlvbiBUZW1wb3JhbFF1ZXJ5KCkge1xuICAgIHJldHVybiBfRW51bS5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gIH1cblxuICB2YXIgX3Byb3RvID0gVGVtcG9yYWxRdWVyeS5wcm90b3R5cGU7XG5cbiAgX3Byb3RvLnF1ZXJ5RnJvbSA9IGZ1bmN0aW9uIHF1ZXJ5RnJvbSh0ZW1wb3JhbCkge1xuICAgIGFic3RyYWN0TWV0aG9kRmFpbCgncXVlcnlGcm9tJyk7XG4gIH07XG5cbiAgcmV0dXJuIFRlbXBvcmFsUXVlcnk7XG59KEVudW0pO1xuZnVuY3Rpb24gY3JlYXRlVGVtcG9yYWxRdWVyeShuYW1lLCBxdWVyeUZyb21GdW5jdGlvbikge1xuICB2YXIgRXh0ZW5kZWRUZW1wb3JhbFF1ZXJ5ID0gZnVuY3Rpb24gKF9UZW1wb3JhbFF1ZXJ5KSB7XG4gICAgX2luaGVyaXRzTG9vc2UoRXh0ZW5kZWRUZW1wb3JhbFF1ZXJ5LCBfVGVtcG9yYWxRdWVyeSk7XG5cbiAgICBmdW5jdGlvbiBFeHRlbmRlZFRlbXBvcmFsUXVlcnkoKSB7XG4gICAgICByZXR1cm4gX1RlbXBvcmFsUXVlcnkuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgIH1cblxuICAgIHJldHVybiBFeHRlbmRlZFRlbXBvcmFsUXVlcnk7XG4gIH0oVGVtcG9yYWxRdWVyeSk7XG5cbiAgRXh0ZW5kZWRUZW1wb3JhbFF1ZXJ5LnByb3RvdHlwZS5xdWVyeUZyb20gPSBxdWVyeUZyb21GdW5jdGlvbjtcbiAgcmV0dXJuIG5ldyBFeHRlbmRlZFRlbXBvcmFsUXVlcnkobmFtZSk7XG59XG5cbnZhciBEYXlPZldlZWsgPSBmdW5jdGlvbiAoX1RlbXBvcmFsQWNjZXNzb3IpIHtcbiAgX2luaGVyaXRzTG9vc2UoRGF5T2ZXZWVrLCBfVGVtcG9yYWxBY2Nlc3Nvcik7XG5cbiAgZnVuY3Rpb24gRGF5T2ZXZWVrKG9yZGluYWwsIG5hbWUpIHtcbiAgICB2YXIgX3RoaXM7XG5cbiAgICBfdGhpcyA9IF9UZW1wb3JhbEFjY2Vzc29yLmNhbGwodGhpcykgfHwgdGhpcztcbiAgICBfdGhpcy5fb3JkaW5hbCA9IG9yZGluYWw7XG4gICAgX3RoaXMuX25hbWUgPSBuYW1lO1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuXG4gIHZhciBfcHJvdG8gPSBEYXlPZldlZWsucHJvdG90eXBlO1xuXG4gIF9wcm90by5vcmRpbmFsID0gZnVuY3Rpb24gb3JkaW5hbCgpIHtcbiAgICByZXR1cm4gdGhpcy5fb3JkaW5hbDtcbiAgfTtcblxuICBfcHJvdG8ubmFtZSA9IGZ1bmN0aW9uIG5hbWUoKSB7XG4gICAgcmV0dXJuIHRoaXMuX25hbWU7XG4gIH07XG5cbiAgRGF5T2ZXZWVrLnZhbHVlcyA9IGZ1bmN0aW9uIHZhbHVlcygpIHtcbiAgICByZXR1cm4gRU5VTVMuc2xpY2UoKTtcbiAgfTtcblxuICBEYXlPZldlZWsudmFsdWVPZiA9IGZ1bmN0aW9uIHZhbHVlT2YobmFtZSkge1xuICAgIHZhciBvcmRpbmFsID0gMDtcblxuICAgIGZvciAob3JkaW5hbDsgb3JkaW5hbCA8IEVOVU1TLmxlbmd0aDsgb3JkaW5hbCsrKSB7XG4gICAgICBpZiAoRU5VTVNbb3JkaW5hbF0ubmFtZSgpID09PSBuYW1lKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBEYXlPZldlZWsub2Yob3JkaW5hbCArIDEpO1xuICB9O1xuXG4gIERheU9mV2Vlay5vZiA9IGZ1bmN0aW9uIG9mKGRheU9mV2Vlaykge1xuICAgIGlmIChkYXlPZldlZWsgPCAxIHx8IGRheU9mV2VlayA+IDcpIHtcbiAgICAgIHRocm93IG5ldyBEYXRlVGltZUV4Y2VwdGlvbignSW52YWxpZCB2YWx1ZSBmb3IgRGF5T2ZXZWVrOiAnICsgZGF5T2ZXZWVrKTtcbiAgICB9XG5cbiAgICByZXR1cm4gRU5VTVNbZGF5T2ZXZWVrIC0gMV07XG4gIH07XG5cbiAgRGF5T2ZXZWVrLmZyb20gPSBmdW5jdGlvbiBmcm9tKHRlbXBvcmFsKSB7XG4gICAgYXNzZXJ0KHRlbXBvcmFsICE9IG51bGwsICd0ZW1wb3JhbCcsIE51bGxQb2ludGVyRXhjZXB0aW9uKTtcblxuICAgIGlmICh0ZW1wb3JhbCBpbnN0YW5jZW9mIERheU9mV2Vlaykge1xuICAgICAgcmV0dXJuIHRlbXBvcmFsO1xuICAgIH1cblxuICAgIHRyeSB7XG4gICAgICByZXR1cm4gRGF5T2ZXZWVrLm9mKHRlbXBvcmFsLmdldChDaHJvbm9GaWVsZC5EQVlfT0ZfV0VFSykpO1xuICAgIH0gY2F0Y2ggKGV4KSB7XG4gICAgICBpZiAoZXggaW5zdGFuY2VvZiBEYXRlVGltZUV4Y2VwdGlvbikge1xuICAgICAgICB0aHJvdyBuZXcgRGF0ZVRpbWVFeGNlcHRpb24oJ1VuYWJsZSB0byBvYnRhaW4gRGF5T2ZXZWVrIGZyb20gVGVtcG9yYWxBY2Nlc3NvcjogJyArIHRlbXBvcmFsICsgJywgdHlwZSAnICsgKHRlbXBvcmFsLmNvbnN0cnVjdG9yICE9IG51bGwgPyB0ZW1wb3JhbC5jb25zdHJ1Y3Rvci5uYW1lIDogJycpLCBleCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBleDtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgX3Byb3RvLnZhbHVlID0gZnVuY3Rpb24gdmFsdWUoKSB7XG4gICAgcmV0dXJuIHRoaXMuX29yZGluYWwgKyAxO1xuICB9O1xuXG4gIF9wcm90by5kaXNwbGF5TmFtZSA9IGZ1bmN0aW9uIGRpc3BsYXlOYW1lKHN0eWxlLCBsb2NhbGUpIHtcbiAgICB0aHJvdyBuZXcgSWxsZWdhbEFyZ3VtZW50RXhjZXB0aW9uKCdQYXR0ZXJuIHVzaW5nIChsb2NhbGl6ZWQpIHRleHQgbm90IGltcGxlbWVudGVkIHlldCEnKTtcbiAgfTtcblxuICBfcHJvdG8uaXNTdXBwb3J0ZWQgPSBmdW5jdGlvbiBpc1N1cHBvcnRlZChmaWVsZCkge1xuICAgIGlmIChmaWVsZCBpbnN0YW5jZW9mIENocm9ub0ZpZWxkKSB7XG4gICAgICByZXR1cm4gZmllbGQgPT09IENocm9ub0ZpZWxkLkRBWV9PRl9XRUVLO1xuICAgIH1cblxuICAgIHJldHVybiBmaWVsZCAhPSBudWxsICYmIGZpZWxkLmlzU3VwcG9ydGVkQnkodGhpcyk7XG4gIH07XG5cbiAgX3Byb3RvLnJhbmdlID0gZnVuY3Rpb24gcmFuZ2UoZmllbGQpIHtcbiAgICBpZiAoZmllbGQgPT09IENocm9ub0ZpZWxkLkRBWV9PRl9XRUVLKSB7XG4gICAgICByZXR1cm4gZmllbGQucmFuZ2UoKTtcbiAgICB9IGVsc2UgaWYgKGZpZWxkIGluc3RhbmNlb2YgQ2hyb25vRmllbGQpIHtcbiAgICAgIHRocm93IG5ldyBVbnN1cHBvcnRlZFRlbXBvcmFsVHlwZUV4Y2VwdGlvbignVW5zdXBwb3J0ZWQgZmllbGQ6ICcgKyBmaWVsZCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZpZWxkLnJhbmdlUmVmaW5lZEJ5KHRoaXMpO1xuICB9O1xuXG4gIF9wcm90by5nZXQgPSBmdW5jdGlvbiBnZXQoZmllbGQpIHtcbiAgICBpZiAoZmllbGQgPT09IENocm9ub0ZpZWxkLkRBWV9PRl9XRUVLKSB7XG4gICAgICByZXR1cm4gdGhpcy52YWx1ZSgpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLnJhbmdlKGZpZWxkKS5jaGVja1ZhbGlkSW50VmFsdWUodGhpcy5nZXRMb25nKGZpZWxkKSwgZmllbGQpO1xuICB9O1xuXG4gIF9wcm90by5nZXRMb25nID0gZnVuY3Rpb24gZ2V0TG9uZyhmaWVsZCkge1xuICAgIGlmIChmaWVsZCA9PT0gQ2hyb25vRmllbGQuREFZX09GX1dFRUspIHtcbiAgICAgIHJldHVybiB0aGlzLnZhbHVlKCk7XG4gICAgfSBlbHNlIGlmIChmaWVsZCBpbnN0YW5jZW9mIENocm9ub0ZpZWxkKSB7XG4gICAgICB0aHJvdyBuZXcgVW5zdXBwb3J0ZWRUZW1wb3JhbFR5cGVFeGNlcHRpb24oJ1Vuc3VwcG9ydGVkIGZpZWxkOiAnICsgZmllbGQpO1xuICAgIH1cblxuICAgIHJldHVybiBmaWVsZC5nZXRGcm9tKHRoaXMpO1xuICB9O1xuXG4gIF9wcm90by5wbHVzID0gZnVuY3Rpb24gcGx1cyhkYXlzKSB7XG4gICAgdmFyIGFtb3VudCA9IE1hdGhVdGlsLmZsb29yTW9kKGRheXMsIDcpO1xuICAgIHJldHVybiBFTlVNU1tNYXRoVXRpbC5mbG9vck1vZCh0aGlzLl9vcmRpbmFsICsgKGFtb3VudCArIDcpLCA3KV07XG4gIH07XG5cbiAgX3Byb3RvLm1pbnVzID0gZnVuY3Rpb24gbWludXMoZGF5cykge1xuICAgIHJldHVybiB0aGlzLnBsdXMoLTEgKiBNYXRoVXRpbC5mbG9vck1vZChkYXlzLCA3KSk7XG4gIH07XG5cbiAgX3Byb3RvLnF1ZXJ5ID0gZnVuY3Rpb24gcXVlcnkoX3F1ZXJ5KSB7XG4gICAgaWYgKF9xdWVyeSA9PT0gVGVtcG9yYWxRdWVyaWVzLnByZWNpc2lvbigpKSB7XG4gICAgICByZXR1cm4gQ2hyb25vVW5pdC5EQVlTO1xuICAgIH0gZWxzZSBpZiAoX3F1ZXJ5ID09PSBUZW1wb3JhbFF1ZXJpZXMubG9jYWxEYXRlKCkgfHwgX3F1ZXJ5ID09PSBUZW1wb3JhbFF1ZXJpZXMubG9jYWxUaW1lKCkgfHwgX3F1ZXJ5ID09PSBUZW1wb3JhbFF1ZXJpZXMuY2hyb25vbG9neSgpIHx8IF9xdWVyeSA9PT0gVGVtcG9yYWxRdWVyaWVzLnpvbmUoKSB8fCBfcXVlcnkgPT09IFRlbXBvcmFsUXVlcmllcy56b25lSWQoKSB8fCBfcXVlcnkgPT09IFRlbXBvcmFsUXVlcmllcy5vZmZzZXQoKSkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgYXNzZXJ0KF9xdWVyeSAhPSBudWxsLCAncXVlcnknLCBOdWxsUG9pbnRlckV4Y2VwdGlvbik7XG4gICAgcmV0dXJuIF9xdWVyeS5xdWVyeUZyb20odGhpcyk7XG4gIH07XG5cbiAgX3Byb3RvLmFkanVzdEludG8gPSBmdW5jdGlvbiBhZGp1c3RJbnRvKHRlbXBvcmFsKSB7XG4gICAgcmVxdWlyZU5vbk51bGwodGVtcG9yYWwsICd0ZW1wb3JhbCcpO1xuICAgIHJldHVybiB0ZW1wb3JhbC53aXRoKENocm9ub0ZpZWxkLkRBWV9PRl9XRUVLLCB0aGlzLnZhbHVlKCkpO1xuICB9O1xuXG4gIF9wcm90by5lcXVhbHMgPSBmdW5jdGlvbiBlcXVhbHMob3RoZXIpIHtcbiAgICByZXR1cm4gdGhpcyA9PT0gb3RoZXI7XG4gIH07XG5cbiAgX3Byb3RvLnRvU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG4gICAgcmV0dXJuIHRoaXMuX25hbWU7XG4gIH07XG5cbiAgX3Byb3RvLmNvbXBhcmVUbyA9IGZ1bmN0aW9uIGNvbXBhcmVUbyhvdGhlcikge1xuICAgIHJlcXVpcmVOb25OdWxsKG90aGVyLCAnb3RoZXInKTtcbiAgICByZXF1aXJlSW5zdGFuY2Uob3RoZXIsIERheU9mV2VlaywgJ290aGVyJyk7XG4gICAgcmV0dXJuIHRoaXMuX29yZGluYWwgLSBvdGhlci5fb3JkaW5hbDtcbiAgfTtcblxuICBfcHJvdG8udG9KU09OID0gZnVuY3Rpb24gdG9KU09OKCkge1xuICAgIHJldHVybiB0aGlzLnRvU3RyaW5nKCk7XG4gIH07XG5cbiAgcmV0dXJuIERheU9mV2Vlaztcbn0oVGVtcG9yYWxBY2Nlc3Nvcik7XG52YXIgRU5VTVM7XG5mdW5jdGlvbiBfaW5pdCQ0KCkge1xuICBEYXlPZldlZWsuTU9OREFZID0gbmV3IERheU9mV2VlaygwLCAnTU9OREFZJyk7XG4gIERheU9mV2Vlay5UVUVTREFZID0gbmV3IERheU9mV2VlaygxLCAnVFVFU0RBWScpO1xuICBEYXlPZldlZWsuV0VETkVTREFZID0gbmV3IERheU9mV2VlaygyLCAnV0VETkVTREFZJyk7XG4gIERheU9mV2Vlay5USFVSU0RBWSA9IG5ldyBEYXlPZldlZWsoMywgJ1RIVVJTREFZJyk7XG4gIERheU9mV2Vlay5GUklEQVkgPSBuZXcgRGF5T2ZXZWVrKDQsICdGUklEQVknKTtcbiAgRGF5T2ZXZWVrLlNBVFVSREFZID0gbmV3IERheU9mV2Vlayg1LCAnU0FUVVJEQVknKTtcbiAgRGF5T2ZXZWVrLlNVTkRBWSA9IG5ldyBEYXlPZldlZWsoNiwgJ1NVTkRBWScpO1xuICBEYXlPZldlZWsuRlJPTSA9IGNyZWF0ZVRlbXBvcmFsUXVlcnkoJ0RheU9mV2Vlay5GUk9NJywgZnVuY3Rpb24gKHRlbXBvcmFsKSB7XG4gICAgcmV0dXJuIERheU9mV2Vlay5mcm9tKHRlbXBvcmFsKTtcbiAgfSk7XG4gIEVOVU1TID0gW0RheU9mV2Vlay5NT05EQVksIERheU9mV2Vlay5UVUVTREFZLCBEYXlPZldlZWsuV0VETkVTREFZLCBEYXlPZldlZWsuVEhVUlNEQVksIERheU9mV2Vlay5GUklEQVksIERheU9mV2Vlay5TQVRVUkRBWSwgRGF5T2ZXZWVrLlNVTkRBWV07XG59XG5cbnZhciBNb250aCA9IGZ1bmN0aW9uIChfVGVtcG9yYWxBY2Nlc3Nvcikge1xuICBfaW5oZXJpdHNMb29zZShNb250aCwgX1RlbXBvcmFsQWNjZXNzb3IpO1xuXG4gIGZ1bmN0aW9uIE1vbnRoKHZhbHVlLCBuYW1lKSB7XG4gICAgdmFyIF90aGlzO1xuXG4gICAgX3RoaXMgPSBfVGVtcG9yYWxBY2Nlc3Nvci5jYWxsKHRoaXMpIHx8IHRoaXM7XG4gICAgX3RoaXMuX3ZhbHVlID0gTWF0aFV0aWwuc2FmZVRvSW50KHZhbHVlKTtcbiAgICBfdGhpcy5fbmFtZSA9IG5hbWU7XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG5cbiAgdmFyIF9wcm90byA9IE1vbnRoLnByb3RvdHlwZTtcblxuICBfcHJvdG8udmFsdWUgPSBmdW5jdGlvbiB2YWx1ZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fdmFsdWU7XG4gIH07XG5cbiAgX3Byb3RvLm9yZGluYWwgPSBmdW5jdGlvbiBvcmRpbmFsKCkge1xuICAgIHJldHVybiB0aGlzLl92YWx1ZSAtIDE7XG4gIH07XG5cbiAgX3Byb3RvLm5hbWUgPSBmdW5jdGlvbiBuYW1lKCkge1xuICAgIHJldHVybiB0aGlzLl9uYW1lO1xuICB9O1xuXG4gIF9wcm90by5kaXNwbGF5TmFtZSA9IGZ1bmN0aW9uIGRpc3BsYXlOYW1lKHN0eWxlLCBsb2NhbGUpIHtcbiAgICB0aHJvdyBuZXcgSWxsZWdhbEFyZ3VtZW50RXhjZXB0aW9uKCdQYXR0ZXJuIHVzaW5nIChsb2NhbGl6ZWQpIHRleHQgbm90IGltcGxlbWVudGVkIHlldCEnKTtcbiAgfTtcblxuICBfcHJvdG8uaXNTdXBwb3J0ZWQgPSBmdW5jdGlvbiBpc1N1cHBvcnRlZChmaWVsZCkge1xuICAgIGlmIChudWxsID09PSBmaWVsZCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGlmIChmaWVsZCBpbnN0YW5jZW9mIENocm9ub0ZpZWxkKSB7XG4gICAgICByZXR1cm4gZmllbGQgPT09IENocm9ub0ZpZWxkLk1PTlRIX09GX1lFQVI7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZpZWxkICE9IG51bGwgJiYgZmllbGQuaXNTdXBwb3J0ZWRCeSh0aGlzKTtcbiAgfTtcblxuICBfcHJvdG8uZ2V0ID0gZnVuY3Rpb24gZ2V0KGZpZWxkKSB7XG4gICAgaWYgKGZpZWxkID09PSBDaHJvbm9GaWVsZC5NT05USF9PRl9ZRUFSKSB7XG4gICAgICByZXR1cm4gdGhpcy52YWx1ZSgpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLnJhbmdlKGZpZWxkKS5jaGVja1ZhbGlkSW50VmFsdWUodGhpcy5nZXRMb25nKGZpZWxkKSwgZmllbGQpO1xuICB9O1xuXG4gIF9wcm90by5nZXRMb25nID0gZnVuY3Rpb24gZ2V0TG9uZyhmaWVsZCkge1xuICAgIGlmIChmaWVsZCA9PT0gQ2hyb25vRmllbGQuTU9OVEhfT0ZfWUVBUikge1xuICAgICAgcmV0dXJuIHRoaXMudmFsdWUoKTtcbiAgICB9IGVsc2UgaWYgKGZpZWxkIGluc3RhbmNlb2YgQ2hyb25vRmllbGQpIHtcbiAgICAgIHRocm93IG5ldyBVbnN1cHBvcnRlZFRlbXBvcmFsVHlwZUV4Y2VwdGlvbignVW5zdXBwb3J0ZWQgZmllbGQ6ICcgKyBmaWVsZCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZpZWxkLmdldEZyb20odGhpcyk7XG4gIH07XG5cbiAgX3Byb3RvLnBsdXMgPSBmdW5jdGlvbiBwbHVzKG1vbnRocykge1xuICAgIHZhciBhbW91bnQgPSBNYXRoVXRpbC5pbnRNb2QobW9udGhzLCAxMikgKyAxMjtcbiAgICB2YXIgbmV3TW9udGhWYWwgPSBNYXRoVXRpbC5pbnRNb2QodGhpcy52YWx1ZSgpICsgYW1vdW50LCAxMik7XG4gICAgbmV3TW9udGhWYWwgPSBuZXdNb250aFZhbCA9PT0gMCA/IDEyIDogbmV3TW9udGhWYWw7XG4gICAgcmV0dXJuIE1vbnRoLm9mKG5ld01vbnRoVmFsKTtcbiAgfTtcblxuICBfcHJvdG8ubWludXMgPSBmdW5jdGlvbiBtaW51cyhtb250aHMpIHtcbiAgICByZXR1cm4gdGhpcy5wbHVzKC0xICogTWF0aFV0aWwuaW50TW9kKG1vbnRocywgMTIpKTtcbiAgfTtcblxuICBfcHJvdG8ubGVuZ3RoID0gZnVuY3Rpb24gbGVuZ3RoKGxlYXBZZWFyKSB7XG4gICAgc3dpdGNoICh0aGlzKSB7XG4gICAgICBjYXNlIE1vbnRoLkZFQlJVQVJZOlxuICAgICAgICByZXR1cm4gbGVhcFllYXIgPyAyOSA6IDI4O1xuXG4gICAgICBjYXNlIE1vbnRoLkFQUklMOlxuICAgICAgY2FzZSBNb250aC5KVU5FOlxuICAgICAgY2FzZSBNb250aC5TRVBURU1CRVI6XG4gICAgICBjYXNlIE1vbnRoLk5PVkVNQkVSOlxuICAgICAgICByZXR1cm4gMzA7XG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiAzMTtcbiAgICB9XG4gIH07XG5cbiAgX3Byb3RvLm1pbkxlbmd0aCA9IGZ1bmN0aW9uIG1pbkxlbmd0aCgpIHtcbiAgICBzd2l0Y2ggKHRoaXMpIHtcbiAgICAgIGNhc2UgTW9udGguRkVCUlVBUlk6XG4gICAgICAgIHJldHVybiAyODtcblxuICAgICAgY2FzZSBNb250aC5BUFJJTDpcbiAgICAgIGNhc2UgTW9udGguSlVORTpcbiAgICAgIGNhc2UgTW9udGguU0VQVEVNQkVSOlxuICAgICAgY2FzZSBNb250aC5OT1ZFTUJFUjpcbiAgICAgICAgcmV0dXJuIDMwO1xuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gMzE7XG4gICAgfVxuICB9O1xuXG4gIF9wcm90by5tYXhMZW5ndGggPSBmdW5jdGlvbiBtYXhMZW5ndGgoKSB7XG4gICAgc3dpdGNoICh0aGlzKSB7XG4gICAgICBjYXNlIE1vbnRoLkZFQlJVQVJZOlxuICAgICAgICByZXR1cm4gMjk7XG5cbiAgICAgIGNhc2UgTW9udGguQVBSSUw6XG4gICAgICBjYXNlIE1vbnRoLkpVTkU6XG4gICAgICBjYXNlIE1vbnRoLlNFUFRFTUJFUjpcbiAgICAgIGNhc2UgTW9udGguTk9WRU1CRVI6XG4gICAgICAgIHJldHVybiAzMDtcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIDMxO1xuICAgIH1cbiAgfTtcblxuICBfcHJvdG8uZmlyc3REYXlPZlllYXIgPSBmdW5jdGlvbiBmaXJzdERheU9mWWVhcihsZWFwWWVhcikge1xuICAgIHZhciBsZWFwID0gbGVhcFllYXIgPyAxIDogMDtcblxuICAgIHN3aXRjaCAodGhpcykge1xuICAgICAgY2FzZSBNb250aC5KQU5VQVJZOlxuICAgICAgICByZXR1cm4gMTtcblxuICAgICAgY2FzZSBNb250aC5GRUJSVUFSWTpcbiAgICAgICAgcmV0dXJuIDMyO1xuXG4gICAgICBjYXNlIE1vbnRoLk1BUkNIOlxuICAgICAgICByZXR1cm4gNjAgKyBsZWFwO1xuXG4gICAgICBjYXNlIE1vbnRoLkFQUklMOlxuICAgICAgICByZXR1cm4gOTEgKyBsZWFwO1xuXG4gICAgICBjYXNlIE1vbnRoLk1BWTpcbiAgICAgICAgcmV0dXJuIDEyMSArIGxlYXA7XG5cbiAgICAgIGNhc2UgTW9udGguSlVORTpcbiAgICAgICAgcmV0dXJuIDE1MiArIGxlYXA7XG5cbiAgICAgIGNhc2UgTW9udGguSlVMWTpcbiAgICAgICAgcmV0dXJuIDE4MiArIGxlYXA7XG5cbiAgICAgIGNhc2UgTW9udGguQVVHVVNUOlxuICAgICAgICByZXR1cm4gMjEzICsgbGVhcDtcblxuICAgICAgY2FzZSBNb250aC5TRVBURU1CRVI6XG4gICAgICAgIHJldHVybiAyNDQgKyBsZWFwO1xuXG4gICAgICBjYXNlIE1vbnRoLk9DVE9CRVI6XG4gICAgICAgIHJldHVybiAyNzQgKyBsZWFwO1xuXG4gICAgICBjYXNlIE1vbnRoLk5PVkVNQkVSOlxuICAgICAgICByZXR1cm4gMzA1ICsgbGVhcDtcblxuICAgICAgY2FzZSBNb250aC5ERUNFTUJFUjpcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiAzMzUgKyBsZWFwO1xuICAgIH1cbiAgfTtcblxuICBfcHJvdG8uZmlyc3RNb250aE9mUXVhcnRlciA9IGZ1bmN0aW9uIGZpcnN0TW9udGhPZlF1YXJ0ZXIoKSB7XG4gICAgc3dpdGNoICh0aGlzKSB7XG4gICAgICBjYXNlIE1vbnRoLkpBTlVBUlk6XG4gICAgICBjYXNlIE1vbnRoLkZFQlJVQVJZOlxuICAgICAgY2FzZSBNb250aC5NQVJDSDpcbiAgICAgICAgcmV0dXJuIE1vbnRoLkpBTlVBUlk7XG5cbiAgICAgIGNhc2UgTW9udGguQVBSSUw6XG4gICAgICBjYXNlIE1vbnRoLk1BWTpcbiAgICAgIGNhc2UgTW9udGguSlVORTpcbiAgICAgICAgcmV0dXJuIE1vbnRoLkFQUklMO1xuXG4gICAgICBjYXNlIE1vbnRoLkpVTFk6XG4gICAgICBjYXNlIE1vbnRoLkFVR1VTVDpcbiAgICAgIGNhc2UgTW9udGguU0VQVEVNQkVSOlxuICAgICAgICByZXR1cm4gTW9udGguSlVMWTtcblxuICAgICAgY2FzZSBNb250aC5PQ1RPQkVSOlxuICAgICAgY2FzZSBNb250aC5OT1ZFTUJFUjpcbiAgICAgIGNhc2UgTW9udGguREVDRU1CRVI6XG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gTW9udGguT0NUT0JFUjtcbiAgICB9XG4gIH07XG5cbiAgX3Byb3RvLnF1ZXJ5ID0gZnVuY3Rpb24gcXVlcnkoX3F1ZXJ5KSB7XG4gICAgYXNzZXJ0KF9xdWVyeSAhPSBudWxsLCAncXVlcnkoKSBwYXJhbWV0ZXIgbXVzdCBub3QgYmUgbnVsbCcsIERhdGVUaW1lRXhjZXB0aW9uKTtcblxuICAgIGlmIChfcXVlcnkgPT09IFRlbXBvcmFsUXVlcmllcy5jaHJvbm9sb2d5KCkpIHtcbiAgICAgIHJldHVybiBJc29DaHJvbm9sb2d5LklOU1RBTkNFO1xuICAgIH0gZWxzZSBpZiAoX3F1ZXJ5ID09PSBUZW1wb3JhbFF1ZXJpZXMucHJlY2lzaW9uKCkpIHtcbiAgICAgIHJldHVybiBDaHJvbm9Vbml0Lk1PTlRIUztcbiAgICB9XG5cbiAgICByZXR1cm4gX1RlbXBvcmFsQWNjZXNzb3IucHJvdG90eXBlLnF1ZXJ5LmNhbGwodGhpcywgX3F1ZXJ5KTtcbiAgfTtcblxuICBfcHJvdG8udG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZygpIHtcbiAgICBzd2l0Y2ggKHRoaXMpIHtcbiAgICAgIGNhc2UgTW9udGguSkFOVUFSWTpcbiAgICAgICAgcmV0dXJuICdKQU5VQVJZJztcblxuICAgICAgY2FzZSBNb250aC5GRUJSVUFSWTpcbiAgICAgICAgcmV0dXJuICdGRUJSVUFSWSc7XG5cbiAgICAgIGNhc2UgTW9udGguTUFSQ0g6XG4gICAgICAgIHJldHVybiAnTUFSQ0gnO1xuXG4gICAgICBjYXNlIE1vbnRoLkFQUklMOlxuICAgICAgICByZXR1cm4gJ0FQUklMJztcblxuICAgICAgY2FzZSBNb250aC5NQVk6XG4gICAgICAgIHJldHVybiAnTUFZJztcblxuICAgICAgY2FzZSBNb250aC5KVU5FOlxuICAgICAgICByZXR1cm4gJ0pVTkUnO1xuXG4gICAgICBjYXNlIE1vbnRoLkpVTFk6XG4gICAgICAgIHJldHVybiAnSlVMWSc7XG5cbiAgICAgIGNhc2UgTW9udGguQVVHVVNUOlxuICAgICAgICByZXR1cm4gJ0FVR1VTVCc7XG5cbiAgICAgIGNhc2UgTW9udGguU0VQVEVNQkVSOlxuICAgICAgICByZXR1cm4gJ1NFUFRFTUJFUic7XG5cbiAgICAgIGNhc2UgTW9udGguT0NUT0JFUjpcbiAgICAgICAgcmV0dXJuICdPQ1RPQkVSJztcblxuICAgICAgY2FzZSBNb250aC5OT1ZFTUJFUjpcbiAgICAgICAgcmV0dXJuICdOT1ZFTUJFUic7XG5cbiAgICAgIGNhc2UgTW9udGguREVDRU1CRVI6XG4gICAgICAgIHJldHVybiAnREVDRU1CRVInO1xuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gJ3Vua25vd24gTW9udGgsIHZhbHVlOiAnICsgdGhpcy52YWx1ZSgpO1xuICAgIH1cbiAgfTtcblxuICBfcHJvdG8udG9KU09OID0gZnVuY3Rpb24gdG9KU09OKCkge1xuICAgIHJldHVybiB0aGlzLnRvU3RyaW5nKCk7XG4gIH07XG5cbiAgX3Byb3RvLmFkanVzdEludG8gPSBmdW5jdGlvbiBhZGp1c3RJbnRvKHRlbXBvcmFsKSB7XG4gICAgcmV0dXJuIHRlbXBvcmFsLndpdGgoQ2hyb25vRmllbGQuTU9OVEhfT0ZfWUVBUiwgdGhpcy52YWx1ZSgpKTtcbiAgfTtcblxuICBfcHJvdG8uY29tcGFyZVRvID0gZnVuY3Rpb24gY29tcGFyZVRvKG90aGVyKSB7XG4gICAgcmVxdWlyZU5vbk51bGwob3RoZXIsICdvdGhlcicpO1xuICAgIHJlcXVpcmVJbnN0YW5jZShvdGhlciwgTW9udGgsICdvdGhlcicpO1xuICAgIHJldHVybiB0aGlzLl92YWx1ZSAtIG90aGVyLl92YWx1ZTtcbiAgfTtcblxuICBfcHJvdG8uZXF1YWxzID0gZnVuY3Rpb24gZXF1YWxzKG90aGVyKSB7XG4gICAgcmV0dXJuIHRoaXMgPT09IG90aGVyO1xuICB9O1xuXG4gIE1vbnRoLnZhbHVlT2YgPSBmdW5jdGlvbiB2YWx1ZU9mKG5hbWUpIHtcbiAgICB2YXIgb3JkaW5hbCA9IDA7XG5cbiAgICBmb3IgKG9yZGluYWw7IG9yZGluYWwgPCBNT05USFMubGVuZ3RoOyBvcmRpbmFsKyspIHtcbiAgICAgIGlmIChNT05USFNbb3JkaW5hbF0ubmFtZSgpID09PSBuYW1lKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBNb250aC5vZihvcmRpbmFsICsgMSk7XG4gIH07XG5cbiAgTW9udGgudmFsdWVzID0gZnVuY3Rpb24gdmFsdWVzKCkge1xuICAgIHJldHVybiBNT05USFMuc2xpY2UoKTtcbiAgfTtcblxuICBNb250aC5vZiA9IGZ1bmN0aW9uIG9mKG1vbnRoKSB7XG4gICAgaWYgKG1vbnRoIDwgMSB8fCBtb250aCA+IDEyKSB7XG4gICAgICBhc3NlcnQoZmFsc2UsICdJbnZhbGlkIHZhbHVlIGZvciBNb250aE9mWWVhcjogJyArIG1vbnRoLCBEYXRlVGltZUV4Y2VwdGlvbik7XG4gICAgfVxuXG4gICAgcmV0dXJuIE1PTlRIU1ttb250aCAtIDFdO1xuICB9O1xuXG4gIE1vbnRoLmZyb20gPSBmdW5jdGlvbiBmcm9tKHRlbXBvcmFsKSB7XG4gICAgaWYgKHRlbXBvcmFsIGluc3RhbmNlb2YgTW9udGgpIHtcbiAgICAgIHJldHVybiB0ZW1wb3JhbDtcbiAgICB9XG5cbiAgICB0cnkge1xuICAgICAgcmV0dXJuIE1vbnRoLm9mKHRlbXBvcmFsLmdldChDaHJvbm9GaWVsZC5NT05USF9PRl9ZRUFSKSk7XG4gICAgfSBjYXRjaCAoZXgpIHtcbiAgICAgIHRocm93IG5ldyBEYXRlVGltZUV4Y2VwdGlvbignVW5hYmxlIHRvIG9idGFpbiBNb250aCBmcm9tIFRlbXBvcmFsQWNjZXNzb3I6ICcgKyB0ZW1wb3JhbCArICcgb2YgdHlwZSAnICsgKHRlbXBvcmFsICYmIHRlbXBvcmFsLmNvbnN0cnVjdG9yICE9IG51bGwgPyB0ZW1wb3JhbC5jb25zdHJ1Y3Rvci5uYW1lIDogJycpLCBleCk7XG4gICAgfVxuICB9O1xuXG4gIHJldHVybiBNb250aDtcbn0oVGVtcG9yYWxBY2Nlc3Nvcik7XG52YXIgTU9OVEhTO1xuZnVuY3Rpb24gX2luaXQkNSgpIHtcbiAgTW9udGguSkFOVUFSWSA9IG5ldyBNb250aCgxLCAnSkFOVUFSWScpO1xuICBNb250aC5GRUJSVUFSWSA9IG5ldyBNb250aCgyLCAnRkVCUlVBUlknKTtcbiAgTW9udGguTUFSQ0ggPSBuZXcgTW9udGgoMywgJ01BUkNIJyk7XG4gIE1vbnRoLkFQUklMID0gbmV3IE1vbnRoKDQsICdBUFJJTCcpO1xuICBNb250aC5NQVkgPSBuZXcgTW9udGgoNSwgJ01BWScpO1xuICBNb250aC5KVU5FID0gbmV3IE1vbnRoKDYsICdKVU5FJyk7XG4gIE1vbnRoLkpVTFkgPSBuZXcgTW9udGgoNywgJ0pVTFknKTtcbiAgTW9udGguQVVHVVNUID0gbmV3IE1vbnRoKDgsICdBVUdVU1QnKTtcbiAgTW9udGguU0VQVEVNQkVSID0gbmV3IE1vbnRoKDksICdTRVBURU1CRVInKTtcbiAgTW9udGguT0NUT0JFUiA9IG5ldyBNb250aCgxMCwgJ09DVE9CRVInKTtcbiAgTW9udGguTk9WRU1CRVIgPSBuZXcgTW9udGgoMTEsICdOT1ZFTUJFUicpO1xuICBNb250aC5ERUNFTUJFUiA9IG5ldyBNb250aCgxMiwgJ0RFQ0VNQkVSJyk7XG4gIE1PTlRIUyA9IFtNb250aC5KQU5VQVJZLCBNb250aC5GRUJSVUFSWSwgTW9udGguTUFSQ0gsIE1vbnRoLkFQUklMLCBNb250aC5NQVksIE1vbnRoLkpVTkUsIE1vbnRoLkpVTFksIE1vbnRoLkFVR1VTVCwgTW9udGguU0VQVEVNQkVSLCBNb250aC5PQ1RPQkVSLCBNb250aC5OT1ZFTUJFUiwgTW9udGguREVDRU1CRVJdO1xufVxuXG52YXIgUEFUVEVSTiA9IC8oWy0rXT8pUCg/OihbLStdP1swLTldKylZKT8oPzooWy0rXT9bMC05XSspTSk/KD86KFstK10/WzAtOV0rKVcpPyg/OihbLStdP1swLTldKylEKT8vO1xudmFyIFBlcmlvZCA9IGZ1bmN0aW9uIChfVGVtcG9yYWxBbW91bnQpIHtcbiAgX2luaGVyaXRzTG9vc2UoUGVyaW9kLCBfVGVtcG9yYWxBbW91bnQpO1xuXG4gIGZ1bmN0aW9uIFBlcmlvZCh5ZWFycywgbW9udGhzLCBkYXlzKSB7XG4gICAgdmFyIF90aGlzO1xuXG4gICAgX3RoaXMgPSBfVGVtcG9yYWxBbW91bnQuY2FsbCh0aGlzKSB8fCB0aGlzO1xuXG4gICAgdmFyIF95ZWFycyA9IE1hdGhVdGlsLnNhZmVUb0ludCh5ZWFycyk7XG5cbiAgICB2YXIgX21vbnRocyA9IE1hdGhVdGlsLnNhZmVUb0ludChtb250aHMpO1xuXG4gICAgdmFyIF9kYXlzID0gTWF0aFV0aWwuc2FmZVRvSW50KGRheXMpO1xuXG4gICAgaWYgKF95ZWFycyA9PT0gMCAmJiBfbW9udGhzID09PSAwICYmIF9kYXlzID09PSAwKSB7XG4gICAgICBpZiAoIVBlcmlvZC5aRVJPKSB7XG4gICAgICAgIF90aGlzLl95ZWFycyA9IF95ZWFycztcbiAgICAgICAgX3RoaXMuX21vbnRocyA9IF9tb250aHM7XG4gICAgICAgIF90aGlzLl9kYXlzID0gX2RheXM7XG4gICAgICAgIFBlcmlvZC5aRVJPID0gX2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpcyk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBQZXJpb2QuWkVSTyB8fCBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzKTtcbiAgICB9XG5cbiAgICBfdGhpcy5feWVhcnMgPSBfeWVhcnM7XG4gICAgX3RoaXMuX21vbnRocyA9IF9tb250aHM7XG4gICAgX3RoaXMuX2RheXMgPSBfZGF5cztcbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cblxuICBQZXJpb2Qub2ZZZWFycyA9IGZ1bmN0aW9uIG9mWWVhcnMoeWVhcnMpIHtcbiAgICByZXR1cm4gUGVyaW9kLmNyZWF0ZSh5ZWFycywgMCwgMCk7XG4gIH07XG5cbiAgUGVyaW9kLm9mTW9udGhzID0gZnVuY3Rpb24gb2ZNb250aHMobW9udGhzKSB7XG4gICAgcmV0dXJuIFBlcmlvZC5jcmVhdGUoMCwgbW9udGhzLCAwKTtcbiAgfTtcblxuICBQZXJpb2Qub2ZXZWVrcyA9IGZ1bmN0aW9uIG9mV2Vla3Mod2Vla3MpIHtcbiAgICByZXR1cm4gUGVyaW9kLmNyZWF0ZSgwLCAwLCBNYXRoVXRpbC5zYWZlTXVsdGlwbHkod2Vla3MsIDcpKTtcbiAgfTtcblxuICBQZXJpb2Qub2ZEYXlzID0gZnVuY3Rpb24gb2ZEYXlzKGRheXMpIHtcbiAgICByZXR1cm4gUGVyaW9kLmNyZWF0ZSgwLCAwLCBkYXlzKTtcbiAgfTtcblxuICBQZXJpb2Qub2YgPSBmdW5jdGlvbiBvZih5ZWFycywgbW9udGhzLCBkYXlzKSB7XG4gICAgcmV0dXJuIFBlcmlvZC5jcmVhdGUoeWVhcnMsIG1vbnRocywgZGF5cyk7XG4gIH07XG5cbiAgUGVyaW9kLmZyb20gPSBmdW5jdGlvbiBmcm9tKGFtb3VudCkge1xuICAgIGlmIChhbW91bnQgaW5zdGFuY2VvZiBQZXJpb2QpIHtcbiAgICAgIHJldHVybiBhbW91bnQ7XG4gICAgfVxuXG4gICAgcmVxdWlyZU5vbk51bGwoYW1vdW50LCAnYW1vdW50Jyk7XG4gICAgdmFyIHllYXJzID0gMDtcbiAgICB2YXIgbW9udGhzID0gMDtcbiAgICB2YXIgZGF5cyA9IDA7XG4gICAgdmFyIHVuaXRzID0gYW1vdW50LnVuaXRzKCk7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHVuaXRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgdW5pdCA9IHVuaXRzW2ldO1xuICAgICAgdmFyIHVuaXRBbW91bnQgPSBhbW91bnQuZ2V0KHVuaXQpO1xuXG4gICAgICBpZiAodW5pdCA9PT0gQ2hyb25vVW5pdC5ZRUFSUykge1xuICAgICAgICB5ZWFycyA9IE1hdGhVdGlsLnNhZmVUb0ludCh1bml0QW1vdW50KTtcbiAgICAgIH0gZWxzZSBpZiAodW5pdCA9PT0gQ2hyb25vVW5pdC5NT05USFMpIHtcbiAgICAgICAgbW9udGhzID0gTWF0aFV0aWwuc2FmZVRvSW50KHVuaXRBbW91bnQpO1xuICAgICAgfSBlbHNlIGlmICh1bml0ID09PSBDaHJvbm9Vbml0LkRBWVMpIHtcbiAgICAgICAgZGF5cyA9IE1hdGhVdGlsLnNhZmVUb0ludCh1bml0QW1vdW50KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBEYXRlVGltZUV4Y2VwdGlvbignVW5pdCBtdXN0IGJlIFllYXJzLCBNb250aHMgb3IgRGF5cywgYnV0IHdhcyAnICsgdW5pdCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIFBlcmlvZC5jcmVhdGUoeWVhcnMsIG1vbnRocywgZGF5cyk7XG4gIH07XG5cbiAgUGVyaW9kLmJldHdlZW4gPSBmdW5jdGlvbiBiZXR3ZWVuKHN0YXJ0RGF0ZSwgZW5kRGF0ZSkge1xuICAgIHJlcXVpcmVOb25OdWxsKHN0YXJ0RGF0ZSwgJ3N0YXJ0RGF0ZScpO1xuICAgIHJlcXVpcmVOb25OdWxsKGVuZERhdGUsICdlbmREYXRlJyk7XG4gICAgcmVxdWlyZUluc3RhbmNlKHN0YXJ0RGF0ZSwgTG9jYWxEYXRlLCAnc3RhcnREYXRlJyk7XG4gICAgcmVxdWlyZUluc3RhbmNlKGVuZERhdGUsIExvY2FsRGF0ZSwgJ2VuZERhdGUnKTtcbiAgICByZXR1cm4gc3RhcnREYXRlLnVudGlsKGVuZERhdGUpO1xuICB9O1xuXG4gIFBlcmlvZC5wYXJzZSA9IGZ1bmN0aW9uIHBhcnNlKHRleHQpIHtcbiAgICByZXF1aXJlTm9uTnVsbCh0ZXh0LCAndGV4dCcpO1xuXG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBQZXJpb2QuX3BhcnNlKHRleHQpO1xuICAgIH0gY2F0Y2ggKGV4KSB7XG4gICAgICBpZiAoZXggaW5zdGFuY2VvZiBBcml0aG1ldGljRXhjZXB0aW9uKSB7XG4gICAgICAgIHRocm93IG5ldyBEYXRlVGltZVBhcnNlRXhjZXB0aW9uKCdUZXh0IGNhbm5vdCBiZSBwYXJzZWQgdG8gYSBQZXJpb2QnLCB0ZXh0LCAwLCBleCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBleDtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgUGVyaW9kLl9wYXJzZSA9IGZ1bmN0aW9uIF9wYXJzZSh0ZXh0KSB7XG4gICAgdmFyIG1hdGNoZXMgPSBQQVRURVJOLmV4ZWModGV4dCk7XG5cbiAgICBpZiAobWF0Y2hlcyAhPSBudWxsKSB7XG4gICAgICB2YXIgbmVnYXRlID0gJy0nID09PSBtYXRjaGVzWzFdID8gLTEgOiAxO1xuICAgICAgdmFyIHllYXJNYXRjaCA9IG1hdGNoZXNbMl07XG4gICAgICB2YXIgbW9udGhNYXRjaCA9IG1hdGNoZXNbM107XG4gICAgICB2YXIgd2Vla01hdGNoID0gbWF0Y2hlc1s0XTtcbiAgICAgIHZhciBkYXlNYXRjaCA9IG1hdGNoZXNbNV07XG5cbiAgICAgIGlmICh5ZWFyTWF0Y2ggIT0gbnVsbCB8fCBtb250aE1hdGNoICE9IG51bGwgfHwgd2Vla01hdGNoICE9IG51bGwgfHwgZGF5TWF0Y2ggIT0gbnVsbCkge1xuICAgICAgICB2YXIgeWVhcnMgPSBQZXJpb2QuX3BhcnNlTnVtYmVyKHRleHQsIHllYXJNYXRjaCwgbmVnYXRlKTtcblxuICAgICAgICB2YXIgbW9udGhzID0gUGVyaW9kLl9wYXJzZU51bWJlcih0ZXh0LCBtb250aE1hdGNoLCBuZWdhdGUpO1xuXG4gICAgICAgIHZhciB3ZWVrcyA9IFBlcmlvZC5fcGFyc2VOdW1iZXIodGV4dCwgd2Vla01hdGNoLCBuZWdhdGUpO1xuXG4gICAgICAgIHZhciBkYXlzID0gUGVyaW9kLl9wYXJzZU51bWJlcih0ZXh0LCBkYXlNYXRjaCwgbmVnYXRlKTtcblxuICAgICAgICBkYXlzID0gTWF0aFV0aWwuc2FmZUFkZChkYXlzLCBNYXRoVXRpbC5zYWZlTXVsdGlwbHkod2Vla3MsIDcpKTtcbiAgICAgICAgcmV0dXJuIFBlcmlvZC5jcmVhdGUoeWVhcnMsIG1vbnRocywgZGF5cyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdGhyb3cgbmV3IERhdGVUaW1lUGFyc2VFeGNlcHRpb24oJ1RleHQgY2Fubm90IGJlIHBhcnNlZCB0byBhIFBlcmlvZCcsIHRleHQsIDApO1xuICB9O1xuXG4gIFBlcmlvZC5fcGFyc2VOdW1iZXIgPSBmdW5jdGlvbiBfcGFyc2VOdW1iZXIodGV4dCwgc3RyLCBuZWdhdGUpIHtcbiAgICBpZiAoc3RyID09IG51bGwpIHtcbiAgICAgIHJldHVybiAwO1xuICAgIH1cblxuICAgIHZhciB2YWwgPSBNYXRoVXRpbC5wYXJzZUludChzdHIpO1xuICAgIHJldHVybiBNYXRoVXRpbC5zYWZlTXVsdGlwbHkodmFsLCBuZWdhdGUpO1xuICB9O1xuXG4gIFBlcmlvZC5jcmVhdGUgPSBmdW5jdGlvbiBjcmVhdGUoeWVhcnMsIG1vbnRocywgZGF5cykge1xuICAgIHJldHVybiBuZXcgUGVyaW9kKHllYXJzLCBtb250aHMsIGRheXMpO1xuICB9O1xuXG4gIHZhciBfcHJvdG8gPSBQZXJpb2QucHJvdG90eXBlO1xuXG4gIF9wcm90by51bml0cyA9IGZ1bmN0aW9uIHVuaXRzKCkge1xuICAgIHJldHVybiBbQ2hyb25vVW5pdC5ZRUFSUywgQ2hyb25vVW5pdC5NT05USFMsIENocm9ub1VuaXQuREFZU107XG4gIH07XG5cbiAgX3Byb3RvLmNocm9ub2xvZ3kgPSBmdW5jdGlvbiBjaHJvbm9sb2d5KCkge1xuICAgIHJldHVybiBJc29DaHJvbm9sb2d5LklOU1RBTkNFO1xuICB9O1xuXG4gIF9wcm90by5nZXQgPSBmdW5jdGlvbiBnZXQodW5pdCkge1xuICAgIGlmICh1bml0ID09PSBDaHJvbm9Vbml0LllFQVJTKSB7XG4gICAgICByZXR1cm4gdGhpcy5feWVhcnM7XG4gICAgfVxuXG4gICAgaWYgKHVuaXQgPT09IENocm9ub1VuaXQuTU9OVEhTKSB7XG4gICAgICByZXR1cm4gdGhpcy5fbW9udGhzO1xuICAgIH1cblxuICAgIGlmICh1bml0ID09PSBDaHJvbm9Vbml0LkRBWVMpIHtcbiAgICAgIHJldHVybiB0aGlzLl9kYXlzO1xuICAgIH1cblxuICAgIHRocm93IG5ldyBVbnN1cHBvcnRlZFRlbXBvcmFsVHlwZUV4Y2VwdGlvbignVW5zdXBwb3J0ZWQgdW5pdDogJyArIHVuaXQpO1xuICB9O1xuXG4gIF9wcm90by5pc1plcm8gPSBmdW5jdGlvbiBpc1plcm8oKSB7XG4gICAgcmV0dXJuIHRoaXMgPT09IFBlcmlvZC5aRVJPO1xuICB9O1xuXG4gIF9wcm90by5pc05lZ2F0aXZlID0gZnVuY3Rpb24gaXNOZWdhdGl2ZSgpIHtcbiAgICByZXR1cm4gdGhpcy5feWVhcnMgPCAwIHx8IHRoaXMuX21vbnRocyA8IDAgfHwgdGhpcy5fZGF5cyA8IDA7XG4gIH07XG5cbiAgX3Byb3RvLnllYXJzID0gZnVuY3Rpb24geWVhcnMoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3llYXJzO1xuICB9O1xuXG4gIF9wcm90by5tb250aHMgPSBmdW5jdGlvbiBtb250aHMoKSB7XG4gICAgcmV0dXJuIHRoaXMuX21vbnRocztcbiAgfTtcblxuICBfcHJvdG8uZGF5cyA9IGZ1bmN0aW9uIGRheXMoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2RheXM7XG4gIH07XG5cbiAgX3Byb3RvLndpdGhZZWFycyA9IGZ1bmN0aW9uIHdpdGhZZWFycyh5ZWFycykge1xuICAgIGlmICh5ZWFycyA9PT0gdGhpcy5feWVhcnMpIHtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIHJldHVybiBQZXJpb2QuY3JlYXRlKHllYXJzLCB0aGlzLl9tb250aHMsIHRoaXMuX2RheXMpO1xuICB9O1xuXG4gIF9wcm90by53aXRoTW9udGhzID0gZnVuY3Rpb24gd2l0aE1vbnRocyhtb250aHMpIHtcbiAgICBpZiAobW9udGhzID09PSB0aGlzLl9tb250aHMpIHtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIHJldHVybiBQZXJpb2QuY3JlYXRlKHRoaXMuX3llYXJzLCBtb250aHMsIHRoaXMuX2RheXMpO1xuICB9O1xuXG4gIF9wcm90by53aXRoRGF5cyA9IGZ1bmN0aW9uIHdpdGhEYXlzKGRheXMpIHtcbiAgICBpZiAoZGF5cyA9PT0gdGhpcy5fZGF5cykge1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgcmV0dXJuIFBlcmlvZC5jcmVhdGUodGhpcy5feWVhcnMsIHRoaXMuX21vbnRocywgZGF5cyk7XG4gIH07XG5cbiAgX3Byb3RvLnBsdXMgPSBmdW5jdGlvbiBwbHVzKGFtb3VudFRvQWRkKSB7XG4gICAgdmFyIGFtb3VudCA9IFBlcmlvZC5mcm9tKGFtb3VudFRvQWRkKTtcbiAgICByZXR1cm4gUGVyaW9kLmNyZWF0ZShNYXRoVXRpbC5zYWZlQWRkKHRoaXMuX3llYXJzLCBhbW91bnQuX3llYXJzKSwgTWF0aFV0aWwuc2FmZUFkZCh0aGlzLl9tb250aHMsIGFtb3VudC5fbW9udGhzKSwgTWF0aFV0aWwuc2FmZUFkZCh0aGlzLl9kYXlzLCBhbW91bnQuX2RheXMpKTtcbiAgfTtcblxuICBfcHJvdG8ucGx1c1llYXJzID0gZnVuY3Rpb24gcGx1c1llYXJzKHllYXJzVG9BZGQpIHtcbiAgICBpZiAoeWVhcnNUb0FkZCA9PT0gMCkge1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgcmV0dXJuIFBlcmlvZC5jcmVhdGUoTWF0aFV0aWwuc2FmZVRvSW50KE1hdGhVdGlsLnNhZmVBZGQodGhpcy5feWVhcnMsIHllYXJzVG9BZGQpKSwgdGhpcy5fbW9udGhzLCB0aGlzLl9kYXlzKTtcbiAgfTtcblxuICBfcHJvdG8ucGx1c01vbnRocyA9IGZ1bmN0aW9uIHBsdXNNb250aHMobW9udGhzVG9BZGQpIHtcbiAgICBpZiAobW9udGhzVG9BZGQgPT09IDApIHtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIHJldHVybiBQZXJpb2QuY3JlYXRlKHRoaXMuX3llYXJzLCBNYXRoVXRpbC5zYWZlVG9JbnQoTWF0aFV0aWwuc2FmZUFkZCh0aGlzLl9tb250aHMsIG1vbnRoc1RvQWRkKSksIHRoaXMuX2RheXMpO1xuICB9O1xuXG4gIF9wcm90by5wbHVzRGF5cyA9IGZ1bmN0aW9uIHBsdXNEYXlzKGRheXNUb0FkZCkge1xuICAgIGlmIChkYXlzVG9BZGQgPT09IDApIHtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIHJldHVybiBQZXJpb2QuY3JlYXRlKHRoaXMuX3llYXJzLCB0aGlzLl9tb250aHMsIE1hdGhVdGlsLnNhZmVUb0ludChNYXRoVXRpbC5zYWZlQWRkKHRoaXMuX2RheXMsIGRheXNUb0FkZCkpKTtcbiAgfTtcblxuICBfcHJvdG8ubWludXMgPSBmdW5jdGlvbiBtaW51cyhhbW91bnRUb1N1YnRyYWN0KSB7XG4gICAgdmFyIGFtb3VudCA9IFBlcmlvZC5mcm9tKGFtb3VudFRvU3VidHJhY3QpO1xuICAgIHJldHVybiBQZXJpb2QuY3JlYXRlKE1hdGhVdGlsLnNhZmVTdWJ0cmFjdCh0aGlzLl95ZWFycywgYW1vdW50Ll95ZWFycyksIE1hdGhVdGlsLnNhZmVTdWJ0cmFjdCh0aGlzLl9tb250aHMsIGFtb3VudC5fbW9udGhzKSwgTWF0aFV0aWwuc2FmZVN1YnRyYWN0KHRoaXMuX2RheXMsIGFtb3VudC5fZGF5cykpO1xuICB9O1xuXG4gIF9wcm90by5taW51c1llYXJzID0gZnVuY3Rpb24gbWludXNZZWFycyh5ZWFyc1RvU3VidHJhY3QpIHtcbiAgICByZXR1cm4gdGhpcy5wbHVzWWVhcnMoLTEgKiB5ZWFyc1RvU3VidHJhY3QpO1xuICB9O1xuXG4gIF9wcm90by5taW51c01vbnRocyA9IGZ1bmN0aW9uIG1pbnVzTW9udGhzKG1vbnRoc1RvU3VidHJhY3QpIHtcbiAgICByZXR1cm4gdGhpcy5wbHVzTW9udGhzKC0xICogbW9udGhzVG9TdWJ0cmFjdCk7XG4gIH07XG5cbiAgX3Byb3RvLm1pbnVzRGF5cyA9IGZ1bmN0aW9uIG1pbnVzRGF5cyhkYXlzVG9TdWJ0cmFjdCkge1xuICAgIHJldHVybiB0aGlzLnBsdXNEYXlzKC0xICogZGF5c1RvU3VidHJhY3QpO1xuICB9O1xuXG4gIF9wcm90by5tdWx0aXBsaWVkQnkgPSBmdW5jdGlvbiBtdWx0aXBsaWVkQnkoc2NhbGFyKSB7XG4gICAgaWYgKHRoaXMgPT09IFBlcmlvZC5aRVJPIHx8IHNjYWxhciA9PT0gMSkge1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgcmV0dXJuIFBlcmlvZC5jcmVhdGUoTWF0aFV0aWwuc2FmZU11bHRpcGx5KHRoaXMuX3llYXJzLCBzY2FsYXIpLCBNYXRoVXRpbC5zYWZlTXVsdGlwbHkodGhpcy5fbW9udGhzLCBzY2FsYXIpLCBNYXRoVXRpbC5zYWZlTXVsdGlwbHkodGhpcy5fZGF5cywgc2NhbGFyKSk7XG4gIH07XG5cbiAgX3Byb3RvLm5lZ2F0ZWQgPSBmdW5jdGlvbiBuZWdhdGVkKCkge1xuICAgIHJldHVybiB0aGlzLm11bHRpcGxpZWRCeSgtMSk7XG4gIH07XG5cbiAgX3Byb3RvLm5vcm1hbGl6ZWQgPSBmdW5jdGlvbiBub3JtYWxpemVkKCkge1xuICAgIHZhciB0b3RhbE1vbnRocyA9IHRoaXMudG9Ub3RhbE1vbnRocygpO1xuICAgIHZhciBzcGxpdFllYXJzID0gTWF0aFV0aWwuaW50RGl2KHRvdGFsTW9udGhzLCAxMik7XG4gICAgdmFyIHNwbGl0TW9udGhzID0gTWF0aFV0aWwuaW50TW9kKHRvdGFsTW9udGhzLCAxMik7XG5cbiAgICBpZiAoc3BsaXRZZWFycyA9PT0gdGhpcy5feWVhcnMgJiYgc3BsaXRNb250aHMgPT09IHRoaXMuX21vbnRocykge1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgcmV0dXJuIFBlcmlvZC5jcmVhdGUoTWF0aFV0aWwuc2FmZVRvSW50KHNwbGl0WWVhcnMpLCBzcGxpdE1vbnRocywgdGhpcy5fZGF5cyk7XG4gIH07XG5cbiAgX3Byb3RvLnRvVG90YWxNb250aHMgPSBmdW5jdGlvbiB0b1RvdGFsTW9udGhzKCkge1xuICAgIHJldHVybiB0aGlzLl95ZWFycyAqIDEyICsgdGhpcy5fbW9udGhzO1xuICB9O1xuXG4gIF9wcm90by5hZGRUbyA9IGZ1bmN0aW9uIGFkZFRvKHRlbXBvcmFsKSB7XG4gICAgcmVxdWlyZU5vbk51bGwodGVtcG9yYWwsICd0ZW1wb3JhbCcpO1xuXG4gICAgaWYgKHRoaXMuX3llYXJzICE9PSAwKSB7XG4gICAgICBpZiAodGhpcy5fbW9udGhzICE9PSAwKSB7XG4gICAgICAgIHRlbXBvcmFsID0gdGVtcG9yYWwucGx1cyh0aGlzLnRvVG90YWxNb250aHMoKSwgQ2hyb25vVW5pdC5NT05USFMpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGVtcG9yYWwgPSB0ZW1wb3JhbC5wbHVzKHRoaXMuX3llYXJzLCBDaHJvbm9Vbml0LllFQVJTKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHRoaXMuX21vbnRocyAhPT0gMCkge1xuICAgICAgdGVtcG9yYWwgPSB0ZW1wb3JhbC5wbHVzKHRoaXMuX21vbnRocywgQ2hyb25vVW5pdC5NT05USFMpO1xuICAgIH1cblxuICAgIGlmICh0aGlzLl9kYXlzICE9PSAwKSB7XG4gICAgICB0ZW1wb3JhbCA9IHRlbXBvcmFsLnBsdXModGhpcy5fZGF5cywgQ2hyb25vVW5pdC5EQVlTKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGVtcG9yYWw7XG4gIH07XG5cbiAgX3Byb3RvLnN1YnRyYWN0RnJvbSA9IGZ1bmN0aW9uIHN1YnRyYWN0RnJvbSh0ZW1wb3JhbCkge1xuICAgIHJlcXVpcmVOb25OdWxsKHRlbXBvcmFsLCAndGVtcG9yYWwnKTtcblxuICAgIGlmICh0aGlzLl95ZWFycyAhPT0gMCkge1xuICAgICAgaWYgKHRoaXMuX21vbnRocyAhPT0gMCkge1xuICAgICAgICB0ZW1wb3JhbCA9IHRlbXBvcmFsLm1pbnVzKHRoaXMudG9Ub3RhbE1vbnRocygpLCBDaHJvbm9Vbml0Lk1PTlRIUyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0ZW1wb3JhbCA9IHRlbXBvcmFsLm1pbnVzKHRoaXMuX3llYXJzLCBDaHJvbm9Vbml0LllFQVJTKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHRoaXMuX21vbnRocyAhPT0gMCkge1xuICAgICAgdGVtcG9yYWwgPSB0ZW1wb3JhbC5taW51cyh0aGlzLl9tb250aHMsIENocm9ub1VuaXQuTU9OVEhTKTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5fZGF5cyAhPT0gMCkge1xuICAgICAgdGVtcG9yYWwgPSB0ZW1wb3JhbC5taW51cyh0aGlzLl9kYXlzLCBDaHJvbm9Vbml0LkRBWVMpO1xuICAgIH1cblxuICAgIHJldHVybiB0ZW1wb3JhbDtcbiAgfTtcblxuICBfcHJvdG8uZXF1YWxzID0gZnVuY3Rpb24gZXF1YWxzKG9iaikge1xuICAgIGlmICh0aGlzID09PSBvYmopIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIGlmIChvYmogaW5zdGFuY2VvZiBQZXJpb2QpIHtcbiAgICAgIHZhciBvdGhlciA9IG9iajtcbiAgICAgIHJldHVybiB0aGlzLl95ZWFycyA9PT0gb3RoZXIuX3llYXJzICYmIHRoaXMuX21vbnRocyA9PT0gb3RoZXIuX21vbnRocyAmJiB0aGlzLl9kYXlzID09PSBvdGhlci5fZGF5cztcbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2U7XG4gIH07XG5cbiAgX3Byb3RvLmhhc2hDb2RlID0gZnVuY3Rpb24gaGFzaENvZGUoKSB7XG4gICAgcmV0dXJuIE1hdGhVdGlsLmhhc2hDb2RlKHRoaXMuX3llYXJzLCB0aGlzLl9tb250aHMsIHRoaXMuX2RheXMpO1xuICB9O1xuXG4gIF9wcm90by50b1N0cmluZyA9IGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuICAgIGlmICh0aGlzID09PSBQZXJpb2QuWkVSTykge1xuICAgICAgcmV0dXJuICdQMEQnO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgYnVmID0gJ1AnO1xuXG4gICAgICBpZiAodGhpcy5feWVhcnMgIT09IDApIHtcbiAgICAgICAgYnVmICs9ICcnICsgdGhpcy5feWVhcnMgKyAnWSc7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLl9tb250aHMgIT09IDApIHtcbiAgICAgICAgYnVmICs9ICcnICsgdGhpcy5fbW9udGhzICsgJ00nO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5fZGF5cyAhPT0gMCkge1xuICAgICAgICBidWYgKz0gJycgKyB0aGlzLl9kYXlzICsgJ0QnO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gYnVmO1xuICAgIH1cbiAgfTtcblxuICBfcHJvdG8udG9KU09OID0gZnVuY3Rpb24gdG9KU09OKCkge1xuICAgIHJldHVybiB0aGlzLnRvU3RyaW5nKCk7XG4gIH07XG5cbiAgcmV0dXJuIFBlcmlvZDtcbn0oVGVtcG9yYWxBbW91bnQpO1xuZnVuY3Rpb24gX2luaXQkNigpIHtcbiAgUGVyaW9kLm9mRGF5cygwKTtcbn1cblxuLypcbiAqIEBjb3B5cmlnaHQgKGMpIDIwMTYsIFBoaWxpcHAgVGjDvHJ3w6RjaHRlciAmIFBhdHRyaWNrIEjDvHBlclxuICogQGNvcHlyaWdodCAoYykgMjAwNy1wcmVzZW50LCBTdGVwaGVuIENvbGVib3VybmUgJiBNaWNoYWVsIE5hc2NpbWVudG8gU2FudG9zXG4gKiBAbGljZW5zZSBCU0QtMy1DbGF1c2UgKHNlZSBMSUNFTlNFIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlKVxuICovXG52YXIgUGFyc2VQb3NpdGlvbiA9IGZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gUGFyc2VQb3NpdGlvbihpbmRleCkge1xuICAgIHRoaXMuX2luZGV4ID0gaW5kZXg7XG4gICAgdGhpcy5fZXJyb3JJbmRleCA9IC0xO1xuICB9XG5cbiAgdmFyIF9wcm90byA9IFBhcnNlUG9zaXRpb24ucHJvdG90eXBlO1xuXG4gIF9wcm90by5nZXRJbmRleCA9IGZ1bmN0aW9uIGdldEluZGV4KCkge1xuICAgIHJldHVybiB0aGlzLl9pbmRleDtcbiAgfTtcblxuICBfcHJvdG8uc2V0SW5kZXggPSBmdW5jdGlvbiBzZXRJbmRleChpbmRleCkge1xuICAgIHRoaXMuX2luZGV4ID0gaW5kZXg7XG4gIH07XG5cbiAgX3Byb3RvLmdldEVycm9ySW5kZXggPSBmdW5jdGlvbiBnZXRFcnJvckluZGV4KCkge1xuICAgIHJldHVybiB0aGlzLl9lcnJvckluZGV4O1xuICB9O1xuXG4gIF9wcm90by5zZXRFcnJvckluZGV4ID0gZnVuY3Rpb24gc2V0RXJyb3JJbmRleChlcnJvckluZGV4KSB7XG4gICAgdGhpcy5fZXJyb3JJbmRleCA9IGVycm9ySW5kZXg7XG4gIH07XG5cbiAgcmV0dXJuIFBhcnNlUG9zaXRpb247XG59KCk7XG5cbi8qXG4gKiBAY29weXJpZ2h0IChjKSAyMDE2LCBQaGlsaXBwIFRow7xyd8OkY2h0ZXIgJiBQYXR0cmljayBIw7xwZXJcbiAqIEBsaWNlbnNlIEJTRC0zLUNsYXVzZSAoc2VlIExJQ0VOU0UgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUpXG4gKi9cbnZhciBFbnVtTWFwID0gZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBFbnVtTWFwKCkge1xuICAgIHRoaXMuX21hcCA9IHt9O1xuICB9XG5cbiAgdmFyIF9wcm90byA9IEVudW1NYXAucHJvdG90eXBlO1xuXG4gIF9wcm90by5wdXRBbGwgPSBmdW5jdGlvbiBwdXRBbGwob3RoZXJNYXApIHtcbiAgICBmb3IgKHZhciBrZXkgaW4gb3RoZXJNYXAuX21hcCkge1xuICAgICAgdGhpcy5fbWFwW2tleV0gPSBvdGhlck1hcC5fbWFwW2tleV07XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgX3Byb3RvLmNvbnRhaW5zS2V5ID0gZnVuY3Rpb24gY29udGFpbnNLZXkoa2V5KSB7XG4gICAgcmV0dXJuIHRoaXMuX21hcC5oYXNPd25Qcm9wZXJ0eShrZXkubmFtZSgpKSAmJiB0aGlzLmdldChrZXkpICE9PSB1bmRlZmluZWQ7XG4gIH07XG5cbiAgX3Byb3RvLmdldCA9IGZ1bmN0aW9uIGdldChrZXkpIHtcbiAgICByZXR1cm4gdGhpcy5fbWFwW2tleS5uYW1lKCldO1xuICB9O1xuXG4gIF9wcm90by5wdXQgPSBmdW5jdGlvbiBwdXQoa2V5LCB2YWwpIHtcbiAgICByZXR1cm4gdGhpcy5zZXQoa2V5LCB2YWwpO1xuICB9O1xuXG4gIF9wcm90by5zZXQgPSBmdW5jdGlvbiBzZXQoa2V5LCB2YWwpIHtcbiAgICB0aGlzLl9tYXBba2V5Lm5hbWUoKV0gPSB2YWw7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgX3Byb3RvLnJldGFpbkFsbCA9IGZ1bmN0aW9uIHJldGFpbkFsbChrZXlMaXN0KSB7XG4gICAgdmFyIG1hcCA9IHt9O1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBrZXlMaXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIga2V5ID0ga2V5TGlzdFtpXS5uYW1lKCk7XG4gICAgICBtYXBba2V5XSA9IHRoaXMuX21hcFtrZXldO1xuICAgIH1cblxuICAgIHRoaXMuX21hcCA9IG1hcDtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICBfcHJvdG8ucmVtb3ZlID0gZnVuY3Rpb24gcmVtb3ZlKGtleSkge1xuICAgIHZhciBrZXlOYW1lID0ga2V5Lm5hbWUoKTtcbiAgICB2YXIgdmFsID0gdGhpcy5fbWFwW2tleU5hbWVdO1xuICAgIHRoaXMuX21hcFtrZXlOYW1lXSA9IHVuZGVmaW5lZDtcbiAgICByZXR1cm4gdmFsO1xuICB9O1xuXG4gIF9wcm90by5rZXlTZXQgPSBmdW5jdGlvbiBrZXlTZXQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX21hcDtcbiAgfTtcblxuICBfcHJvdG8uY2xlYXIgPSBmdW5jdGlvbiBjbGVhcigpIHtcbiAgICB0aGlzLl9tYXAgPSB7fTtcbiAgfTtcblxuICByZXR1cm4gRW51bU1hcDtcbn0oKTtcblxudmFyIFJlc29sdmVyU3R5bGUgPSBmdW5jdGlvbiAoX0VudW0pIHtcbiAgX2luaGVyaXRzTG9vc2UoUmVzb2x2ZXJTdHlsZSwgX0VudW0pO1xuXG4gIGZ1bmN0aW9uIFJlc29sdmVyU3R5bGUoKSB7XG4gICAgcmV0dXJuIF9FbnVtLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgfVxuXG4gIHJldHVybiBSZXNvbHZlclN0eWxlO1xufShFbnVtKTtcblJlc29sdmVyU3R5bGUuU1RSSUNUID0gbmV3IFJlc29sdmVyU3R5bGUoJ1NUUklDVCcpO1xuUmVzb2x2ZXJTdHlsZS5TTUFSVCA9IG5ldyBSZXNvbHZlclN0eWxlKCdTTUFSVCcpO1xuUmVzb2x2ZXJTdHlsZS5MRU5JRU5UID0gbmV3IFJlc29sdmVyU3R5bGUoJ0xFTklFTlQnKTtcblxuLypcbiAqIEBjb3B5cmlnaHQgKGMpIDIwMTYsIFBoaWxpcHAgVGjDvHJ3w6RjaHRlciAmIFBhdHRyaWNrIEjDvHBlclxuICogQGNvcHlyaWdodCAoYykgMjAwNy1wcmVzZW50LCBTdGVwaGVuIENvbGVib3VybmUgJiBNaWNoYWVsIE5hc2NpbWVudG8gU2FudG9zXG4gKiBAbGljZW5zZSBCU0QtMy1DbGF1c2UgKHNlZSBMSUNFTlNFIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlKVxuICovXG52YXIgVGVtcG9yYWxBZGp1c3RlciA9IGZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gVGVtcG9yYWxBZGp1c3RlcigpIHt9XG5cbiAgdmFyIF9wcm90byA9IFRlbXBvcmFsQWRqdXN0ZXIucHJvdG90eXBlO1xuXG4gIF9wcm90by5hZGp1c3RJbnRvID0gZnVuY3Rpb24gYWRqdXN0SW50byh0ZW1wb3JhbCkge1xuICAgIGFic3RyYWN0TWV0aG9kRmFpbCgnYWRqdXN0SW50bycpO1xuICB9O1xuXG4gIHJldHVybiBUZW1wb3JhbEFkanVzdGVyO1xufSgpO1xuXG52YXIgVGVtcG9yYWwgPSBmdW5jdGlvbiAoX1RlbXBvcmFsQWNjZXNzb3IpIHtcbiAgX2luaGVyaXRzTG9vc2UoVGVtcG9yYWwsIF9UZW1wb3JhbEFjY2Vzc29yKTtcblxuICBmdW5jdGlvbiBUZW1wb3JhbCgpIHtcbiAgICByZXR1cm4gX1RlbXBvcmFsQWNjZXNzb3IuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICB9XG5cbiAgdmFyIF9wcm90byA9IFRlbXBvcmFsLnByb3RvdHlwZTtcblxuICBfcHJvdG8uaXNTdXBwb3J0ZWQgPSBmdW5jdGlvbiBpc1N1cHBvcnRlZCh1bml0KSB7XG4gICAgYWJzdHJhY3RNZXRob2RGYWlsKCdpc1N1cHBvcnRlZCcpO1xuICB9O1xuXG4gIF9wcm90by5taW51cyA9IGZ1bmN0aW9uIG1pbnVzKHAxLCBwMikge1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoIDwgMikge1xuICAgICAgcmV0dXJuIHRoaXMubWludXNBbW91bnQocDEpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gdGhpcy5taW51c0Ftb3VudFVuaXQocDEsIHAyKTtcbiAgICB9XG4gIH07XG5cbiAgX3Byb3RvLm1pbnVzQW1vdW50ID0gZnVuY3Rpb24gbWludXNBbW91bnQoYW1vdW50KSB7XG4gICAgYWJzdHJhY3RNZXRob2RGYWlsKCdtaW51c0Ftb3VudCcpO1xuICB9O1xuXG4gIF9wcm90by5taW51c0Ftb3VudFVuaXQgPSBmdW5jdGlvbiBtaW51c0Ftb3VudFVuaXQoYW1vdW50VG9TdWJ0cmFjdCwgdW5pdCkge1xuICAgIGFic3RyYWN0TWV0aG9kRmFpbCgnbWludXNBbW91bnRVbml0Jyk7XG4gIH07XG5cbiAgX3Byb3RvLnBsdXMgPSBmdW5jdGlvbiBwbHVzKHAxLCBwMikge1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoIDwgMikge1xuICAgICAgcmV0dXJuIHRoaXMucGx1c0Ftb3VudChwMSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB0aGlzLnBsdXNBbW91bnRVbml0KHAxLCBwMik7XG4gICAgfVxuICB9O1xuXG4gIF9wcm90by5wbHVzQW1vdW50ID0gZnVuY3Rpb24gcGx1c0Ftb3VudChhbW91bnQpIHtcbiAgICBhYnN0cmFjdE1ldGhvZEZhaWwoJ3BsdXNBbW91bnQnKTtcbiAgfTtcblxuICBfcHJvdG8ucGx1c0Ftb3VudFVuaXQgPSBmdW5jdGlvbiBwbHVzQW1vdW50VW5pdChhbW91bnRUb0FkZCwgdW5pdCkge1xuICAgIGFic3RyYWN0TWV0aG9kRmFpbCgncGx1c0Ftb3VudFVuaXQnKTtcbiAgfTtcblxuICBfcHJvdG8udW50aWwgPSBmdW5jdGlvbiB1bnRpbChlbmRUZW1wb3JhbCwgdW5pdCkge1xuICAgIGFic3RyYWN0TWV0aG9kRmFpbCgndW50aWwnKTtcbiAgfTtcblxuICBfcHJvdG8ud2l0aCA9IGZ1bmN0aW9uIF93aXRoKHAxLCBwMikge1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoIDwgMikge1xuICAgICAgcmV0dXJuIHRoaXMud2l0aEFkanVzdGVyKHAxKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHRoaXMud2l0aEZpZWxkVmFsdWUocDEsIHAyKTtcbiAgICB9XG4gIH07XG5cbiAgX3Byb3RvLndpdGhBZGp1c3RlciA9IGZ1bmN0aW9uIHdpdGhBZGp1c3RlcihhZGp1c3Rlcikge1xuICAgIGFic3RyYWN0TWV0aG9kRmFpbCgnd2l0aEFkanVzdGVyJyk7XG4gIH07XG5cbiAgX3Byb3RvLndpdGhGaWVsZFZhbHVlID0gZnVuY3Rpb24gd2l0aEZpZWxkVmFsdWUoZmllbGQsIG5ld1ZhbHVlKSB7XG4gICAgYWJzdHJhY3RNZXRob2RGYWlsKCd3aXRoRmllbGRWYWx1ZScpO1xuICB9O1xuXG4gIHJldHVybiBUZW1wb3JhbDtcbn0oVGVtcG9yYWxBY2Nlc3Nvcik7XG5cbnZhciBEZWZhdWx0SW50ZXJmYWNlVGVtcG9yYWwgPSBmdW5jdGlvbiAoX1RlbXBvcmFsKSB7XG4gIF9pbmhlcml0c0xvb3NlKERlZmF1bHRJbnRlcmZhY2VUZW1wb3JhbCwgX1RlbXBvcmFsKTtcblxuICBmdW5jdGlvbiBEZWZhdWx0SW50ZXJmYWNlVGVtcG9yYWwoKSB7XG4gICAgcmV0dXJuIF9UZW1wb3JhbC5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gIH1cblxuICB2YXIgX3Byb3RvID0gRGVmYXVsdEludGVyZmFjZVRlbXBvcmFsLnByb3RvdHlwZTtcblxuICBfcHJvdG8ud2l0aEFkanVzdGVyID0gZnVuY3Rpb24gd2l0aEFkanVzdGVyKGFkanVzdGVyKSB7XG4gICAgcmVxdWlyZU5vbk51bGwoYWRqdXN0ZXIsICdhZGp1c3RlcicpO1xuICAgIHJlcXVpcmVJbnN0YW5jZShhZGp1c3RlciwgVGVtcG9yYWxBZGp1c3RlciwgJ2FkanVzdGVyJyk7XG4gICAgcmV0dXJuIGFkanVzdGVyLmFkanVzdEludG8odGhpcyk7XG4gIH07XG5cbiAgX3Byb3RvLnBsdXNBbW91bnQgPSBmdW5jdGlvbiBwbHVzQW1vdW50KGFtb3VudCkge1xuICAgIHJlcXVpcmVOb25OdWxsKGFtb3VudCwgJ2Ftb3VudCcpO1xuICAgIHJlcXVpcmVJbnN0YW5jZShhbW91bnQsIFRlbXBvcmFsQW1vdW50LCAnYW1vdW50Jyk7XG4gICAgcmV0dXJuIGFtb3VudC5hZGRUbyh0aGlzKTtcbiAgfTtcblxuICBfcHJvdG8ubWludXNBbW91bnQgPSBmdW5jdGlvbiBtaW51c0Ftb3VudChhbW91bnQpIHtcbiAgICByZXF1aXJlTm9uTnVsbChhbW91bnQsICdhbW91bnQnKTtcbiAgICByZXF1aXJlSW5zdGFuY2UoYW1vdW50LCBUZW1wb3JhbEFtb3VudCwgJ2Ftb3VudCcpO1xuICAgIHJldHVybiBhbW91bnQuc3VidHJhY3RGcm9tKHRoaXMpO1xuICB9O1xuXG4gIF9wcm90by5taW51c0Ftb3VudFVuaXQgPSBmdW5jdGlvbiBtaW51c0Ftb3VudFVuaXQoYW1vdW50VG9TdWJ0cmFjdCwgdW5pdCkge1xuICAgIHJlcXVpcmVOb25OdWxsKGFtb3VudFRvU3VidHJhY3QsICdhbW91bnRUb1N1YnRyYWN0Jyk7XG4gICAgcmVxdWlyZU5vbk51bGwodW5pdCwgJ3VuaXQnKTtcbiAgICByZXF1aXJlSW5zdGFuY2UodW5pdCwgVGVtcG9yYWxVbml0LCAndW5pdCcpO1xuICAgIHJldHVybiBhbW91bnRUb1N1YnRyYWN0ID09PSBNSU5fU0FGRV9JTlRFR0VSID8gdGhpcy5wbHVzQW1vdW50VW5pdChNQVhfU0FGRV9JTlRFR0VSLCB1bml0KS5wbHVzQW1vdW50VW5pdCgxLCB1bml0KSA6IHRoaXMucGx1c0Ftb3VudCgtYW1vdW50VG9TdWJ0cmFjdCwgdW5pdCk7XG4gIH07XG5cbiAgcmV0dXJuIERlZmF1bHRJbnRlcmZhY2VUZW1wb3JhbDtcbn0oVGVtcG9yYWwpO1xuXG52YXIgQ2hyb25vTG9jYWxEYXRlID0gZnVuY3Rpb24gKF9EZWZhdWx0SW50ZXJmYWNlVGVtcCkge1xuICBfaW5oZXJpdHNMb29zZShDaHJvbm9Mb2NhbERhdGUsIF9EZWZhdWx0SW50ZXJmYWNlVGVtcCk7XG5cbiAgZnVuY3Rpb24gQ2hyb25vTG9jYWxEYXRlKCkge1xuICAgIHJldHVybiBfRGVmYXVsdEludGVyZmFjZVRlbXAuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICB9XG5cbiAgdmFyIF9wcm90byA9IENocm9ub0xvY2FsRGF0ZS5wcm90b3R5cGU7XG5cbiAgX3Byb3RvLmlzU3VwcG9ydGVkID0gZnVuY3Rpb24gaXNTdXBwb3J0ZWQoZmllbGRPclVuaXQpIHtcbiAgICBpZiAoZmllbGRPclVuaXQgaW5zdGFuY2VvZiBDaHJvbm9GaWVsZCkge1xuICAgICAgcmV0dXJuIGZpZWxkT3JVbml0LmlzRGF0ZUJhc2VkKCk7XG4gICAgfSBlbHNlIGlmIChmaWVsZE9yVW5pdCBpbnN0YW5jZW9mIENocm9ub1VuaXQpIHtcbiAgICAgIHJldHVybiBmaWVsZE9yVW5pdC5pc0RhdGVCYXNlZCgpO1xuICAgIH1cblxuICAgIHJldHVybiBmaWVsZE9yVW5pdCAhPSBudWxsICYmIGZpZWxkT3JVbml0LmlzU3VwcG9ydGVkQnkodGhpcyk7XG4gIH07XG5cbiAgX3Byb3RvLnF1ZXJ5ID0gZnVuY3Rpb24gcXVlcnkoX3F1ZXJ5KSB7XG4gICAgaWYgKF9xdWVyeSA9PT0gVGVtcG9yYWxRdWVyaWVzLmNocm9ub2xvZ3koKSkge1xuICAgICAgcmV0dXJuIHRoaXMuY2hyb25vbG9neSgpO1xuICAgIH0gZWxzZSBpZiAoX3F1ZXJ5ID09PSBUZW1wb3JhbFF1ZXJpZXMucHJlY2lzaW9uKCkpIHtcbiAgICAgIHJldHVybiBDaHJvbm9Vbml0LkRBWVM7XG4gICAgfSBlbHNlIGlmIChfcXVlcnkgPT09IFRlbXBvcmFsUXVlcmllcy5sb2NhbERhdGUoKSkge1xuICAgICAgcmV0dXJuIExvY2FsRGF0ZS5vZkVwb2NoRGF5KHRoaXMudG9FcG9jaERheSgpKTtcbiAgICB9IGVsc2UgaWYgKF9xdWVyeSA9PT0gVGVtcG9yYWxRdWVyaWVzLmxvY2FsVGltZSgpIHx8IF9xdWVyeSA9PT0gVGVtcG9yYWxRdWVyaWVzLnpvbmUoKSB8fCBfcXVlcnkgPT09IFRlbXBvcmFsUXVlcmllcy56b25lSWQoKSB8fCBfcXVlcnkgPT09IFRlbXBvcmFsUXVlcmllcy5vZmZzZXQoKSkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgcmV0dXJuIF9EZWZhdWx0SW50ZXJmYWNlVGVtcC5wcm90b3R5cGUucXVlcnkuY2FsbCh0aGlzLCBfcXVlcnkpO1xuICB9O1xuXG4gIF9wcm90by5hZGp1c3RJbnRvID0gZnVuY3Rpb24gYWRqdXN0SW50byh0ZW1wb3JhbCkge1xuICAgIHJldHVybiB0ZW1wb3JhbC53aXRoKENocm9ub0ZpZWxkLkVQT0NIX0RBWSwgdGhpcy50b0Vwb2NoRGF5KCkpO1xuICB9O1xuXG4gIF9wcm90by5mb3JtYXQgPSBmdW5jdGlvbiBmb3JtYXQoZm9ybWF0dGVyKSB7XG4gICAgcmVxdWlyZU5vbk51bGwoZm9ybWF0dGVyLCAnZm9ybWF0dGVyJyk7XG4gICAgcmVxdWlyZUluc3RhbmNlKGZvcm1hdHRlciwgRGF0ZVRpbWVGb3JtYXR0ZXIsICdmb3JtYXR0ZXInKTtcbiAgICByZXR1cm4gZm9ybWF0dGVyLmZvcm1hdCh0aGlzKTtcbiAgfTtcblxuICByZXR1cm4gQ2hyb25vTG9jYWxEYXRlO1xufShEZWZhdWx0SW50ZXJmYWNlVGVtcG9yYWwpO1xuXG4vKlxuICogQGNvcHlyaWdodCAoYykgMjAxNiwgUGhpbGlwcCBUaMO8cnfDpGNodGVyICYgUGF0dHJpY2sgSMO8cGVyXG4gKiBAbGljZW5zZSBCU0QtMy1DbGF1c2UgKHNlZSBMSUNFTlNFIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlKVxuICovXG52YXIgU3RyaW5nVXRpbCA9IGZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gU3RyaW5nVXRpbCgpIHt9XG5cbiAgU3RyaW5nVXRpbC5zdGFydHNXaXRoID0gZnVuY3Rpb24gc3RhcnRzV2l0aCh0ZXh0LCBwYXR0ZXJuKSB7XG4gICAgcmV0dXJuIHRleHQuaW5kZXhPZihwYXR0ZXJuKSA9PT0gMDtcbiAgfTtcblxuICBTdHJpbmdVdGlsLmhhc2hDb2RlID0gZnVuY3Rpb24gaGFzaENvZGUodGV4dCkge1xuICAgIHZhciBsZW4gPSB0ZXh0Lmxlbmd0aDtcblxuICAgIGlmIChsZW4gPT09IDApIHtcbiAgICAgIHJldHVybiAwO1xuICAgIH1cblxuICAgIHZhciBoYXNoID0gMDtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIHZhciBjaHIgPSB0ZXh0LmNoYXJDb2RlQXQoaSk7XG4gICAgICBoYXNoID0gKGhhc2ggPDwgNSkgLSBoYXNoICsgY2hyO1xuICAgICAgaGFzaCB8PSAwO1xuICAgIH1cblxuICAgIHJldHVybiBNYXRoVXRpbC5zbWkoaGFzaCk7XG4gIH07XG5cbiAgcmV0dXJuIFN0cmluZ1V0aWw7XG59KCk7XG5cbi8qXG4gKiBAY29weXJpZ2h0IChjKSAyMDE2LCBQaGlsaXBwIFRow7xyd8OkY2h0ZXIgJiBQYXR0cmljayBIw7xwZXJcbiAqIEBjb3B5cmlnaHQgKGMpIDIwMDctcHJlc2VudCwgU3RlcGhlbiBDb2xlYm91cm5lICYgTWljaGFlbCBOYXNjaW1lbnRvIFNhbnRvc1xuICogQGxpY2Vuc2UgQlNELTMtQ2xhdXNlIChzZWUgTElDRU5TRSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZSlcbiAqL1xudmFyIFpvbmVJZCA9IGZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gWm9uZUlkKCkge31cblxuICBab25lSWQuc3lzdGVtRGVmYXVsdCA9IGZ1bmN0aW9uIHN5c3RlbURlZmF1bHQoKSB7XG4gICAgdGhyb3cgbmV3IERhdGVUaW1lRXhjZXB0aW9uKCdub3Qgc3VwcG9ydGVkIG9wZXJhdGlvbicpO1xuICB9O1xuXG4gIFpvbmVJZC5nZXRBdmFpbGFibGVab25lSWRzID0gZnVuY3Rpb24gZ2V0QXZhaWxhYmxlWm9uZUlkcygpIHtcbiAgICB0aHJvdyBuZXcgRGF0ZVRpbWVFeGNlcHRpb24oJ25vdCBzdXBwb3J0ZWQgb3BlcmF0aW9uJyk7XG4gIH07XG5cbiAgWm9uZUlkLm9mID0gZnVuY3Rpb24gb2Yoem9uZUlkKSB7XG4gICAgdGhyb3cgbmV3IERhdGVUaW1lRXhjZXB0aW9uKCdub3Qgc3VwcG9ydGVkIG9wZXJhdGlvbicgKyB6b25lSWQpO1xuICB9O1xuXG4gIFpvbmVJZC5vZk9mZnNldCA9IGZ1bmN0aW9uIG9mT2Zmc2V0KHByZWZpeCwgb2Zmc2V0KSB7XG4gICAgdGhyb3cgbmV3IERhdGVUaW1lRXhjZXB0aW9uKCdub3Qgc3VwcG9ydGVkIG9wZXJhdGlvbicgKyBwcmVmaXggKyBvZmZzZXQpO1xuICB9O1xuXG4gIFpvbmVJZC5mcm9tID0gZnVuY3Rpb24gZnJvbSh0ZW1wb3JhbCkge1xuICAgIHRocm93IG5ldyBEYXRlVGltZUV4Y2VwdGlvbignbm90IHN1cHBvcnRlZCBvcGVyYXRpb24nICsgdGVtcG9yYWwpO1xuICB9O1xuXG4gIHZhciBfcHJvdG8gPSBab25lSWQucHJvdG90eXBlO1xuXG4gIF9wcm90by5pZCA9IGZ1bmN0aW9uIGlkKCkge1xuICAgIGFic3RyYWN0TWV0aG9kRmFpbCgnWm9uZUlkLmlkJyk7XG4gIH07XG5cbiAgX3Byb3RvLnJ1bGVzID0gZnVuY3Rpb24gcnVsZXMoKSB7XG4gICAgYWJzdHJhY3RNZXRob2RGYWlsKCdab25lSWQucnVsZXMnKTtcbiAgfTtcblxuICBfcHJvdG8ubm9ybWFsaXplZCA9IGZ1bmN0aW9uIG5vcm1hbGl6ZWQoKSB7XG4gICAgdmFyIHJ1bGVzID0gdGhpcy5ydWxlcygpO1xuXG4gICAgaWYgKHJ1bGVzLmlzRml4ZWRPZmZzZXQoKSkge1xuICAgICAgcmV0dXJuIHJ1bGVzLm9mZnNldChJbnN0YW50LkVQT0NIKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICBfcHJvdG8uZXF1YWxzID0gZnVuY3Rpb24gZXF1YWxzKG90aGVyKSB7XG4gICAgaWYgKHRoaXMgPT09IG90aGVyKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICBpZiAob3RoZXIgaW5zdGFuY2VvZiBab25lSWQpIHtcbiAgICAgIHJldHVybiB0aGlzLmlkKCkgPT09IG90aGVyLmlkKCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9O1xuXG4gIF9wcm90by5oYXNoQ29kZSA9IGZ1bmN0aW9uIGhhc2hDb2RlKCkge1xuICAgIHJldHVybiBTdHJpbmdVdGlsLmhhc2hDb2RlKHRoaXMuaWQoKSk7XG4gIH07XG5cbiAgX3Byb3RvLnRvU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG4gICAgcmV0dXJuIHRoaXMuaWQoKTtcbiAgfTtcblxuICBfcHJvdG8udG9KU09OID0gZnVuY3Rpb24gdG9KU09OKCkge1xuICAgIHJldHVybiB0aGlzLnRvU3RyaW5nKCk7XG4gIH07XG5cbiAgcmV0dXJuIFpvbmVJZDtcbn0oKTtcblxudmFyIFpvbmVSdWxlcyA9IGZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gWm9uZVJ1bGVzKCkge31cblxuICBab25lUnVsZXMub2YgPSBmdW5jdGlvbiBvZihvZmZzZXQpIHtcbiAgICByZXF1aXJlTm9uTnVsbChvZmZzZXQsICdvZmZzZXQnKTtcbiAgICByZXR1cm4gbmV3IEZpeGVkKG9mZnNldCk7XG4gIH07XG5cbiAgdmFyIF9wcm90byA9IFpvbmVSdWxlcy5wcm90b3R5cGU7XG5cbiAgX3Byb3RvLmlzRml4ZWRPZmZzZXQgPSBmdW5jdGlvbiBpc0ZpeGVkT2Zmc2V0KCkge1xuICAgIGFic3RyYWN0TWV0aG9kRmFpbCgnWm9uZVJ1bGVzLmlzRml4ZWRPZmZzZXQnKTtcbiAgfTtcblxuICBfcHJvdG8ub2Zmc2V0ID0gZnVuY3Rpb24gb2Zmc2V0KGluc3RhbnRPckxvY2FsRGF0ZVRpbWUpIHtcbiAgICBpZiAoaW5zdGFudE9yTG9jYWxEYXRlVGltZSBpbnN0YW5jZW9mIEluc3RhbnQpIHtcbiAgICAgIHJldHVybiB0aGlzLm9mZnNldE9mSW5zdGFudChpbnN0YW50T3JMb2NhbERhdGVUaW1lKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHRoaXMub2Zmc2V0T2ZMb2NhbERhdGVUaW1lKGluc3RhbnRPckxvY2FsRGF0ZVRpbWUpO1xuICAgIH1cbiAgfTtcblxuICBfcHJvdG8ub2Zmc2V0T2ZJbnN0YW50ID0gZnVuY3Rpb24gb2Zmc2V0T2ZJbnN0YW50KGluc3RhbnQpIHtcbiAgICBhYnN0cmFjdE1ldGhvZEZhaWwoJ1pvbmVSdWxlcy5vZmZzZXRJbnN0YW50Jyk7XG4gIH07XG5cbiAgX3Byb3RvLm9mZnNldE9mRXBvY2hNaWxsaSA9IGZ1bmN0aW9uIG9mZnNldE9mRXBvY2hNaWxsaShlcG9jaE1pbGxpKSB7XG4gICAgYWJzdHJhY3RNZXRob2RGYWlsKCdab25lUnVsZXMub2Zmc2V0T2ZFcG9jaE1pbGxpJyk7XG4gIH07XG5cbiAgX3Byb3RvLm9mZnNldE9mTG9jYWxEYXRlVGltZSA9IGZ1bmN0aW9uIG9mZnNldE9mTG9jYWxEYXRlVGltZShsb2NhbERhdGVUaW1lKSB7XG4gICAgYWJzdHJhY3RNZXRob2RGYWlsKCdab25lUnVsZXMub2Zmc2V0TG9jYWxEYXRlVGltZScpO1xuICB9O1xuXG4gIF9wcm90by52YWxpZE9mZnNldHMgPSBmdW5jdGlvbiB2YWxpZE9mZnNldHMobG9jYWxEYXRlVGltZSkge1xuICAgIGFic3RyYWN0TWV0aG9kRmFpbCgnWm9uZVJ1bGVzLnZhbGlkT2Zmc2V0cycpO1xuICB9O1xuXG4gIF9wcm90by50cmFuc2l0aW9uID0gZnVuY3Rpb24gdHJhbnNpdGlvbihsb2NhbERhdGVUaW1lKSB7XG4gICAgYWJzdHJhY3RNZXRob2RGYWlsKCdab25lUnVsZXMudHJhbnNpdGlvbicpO1xuICB9O1xuXG4gIF9wcm90by5zdGFuZGFyZE9mZnNldCA9IGZ1bmN0aW9uIHN0YW5kYXJkT2Zmc2V0KGluc3RhbnQpIHtcbiAgICBhYnN0cmFjdE1ldGhvZEZhaWwoJ1pvbmVSdWxlcy5zdGFuZGFyZE9mZnNldCcpO1xuICB9O1xuXG4gIF9wcm90by5kYXlsaWdodFNhdmluZ3MgPSBmdW5jdGlvbiBkYXlsaWdodFNhdmluZ3MoaW5zdGFudCkge1xuICAgIGFic3RyYWN0TWV0aG9kRmFpbCgnWm9uZVJ1bGVzLmRheWxpZ2h0U2F2aW5ncycpO1xuICB9O1xuXG4gIF9wcm90by5pc0RheWxpZ2h0U2F2aW5ncyA9IGZ1bmN0aW9uIGlzRGF5bGlnaHRTYXZpbmdzKGluc3RhbnQpIHtcbiAgICBhYnN0cmFjdE1ldGhvZEZhaWwoJ1pvbmVSdWxlcy5pc0RheWxpZ2h0U2F2aW5ncycpO1xuICB9O1xuXG4gIF9wcm90by5pc1ZhbGlkT2Zmc2V0ID0gZnVuY3Rpb24gaXNWYWxpZE9mZnNldChsb2NhbERhdGVUaW1lLCBvZmZzZXQpIHtcbiAgICBhYnN0cmFjdE1ldGhvZEZhaWwoJ1pvbmVSdWxlcy5pc1ZhbGlkT2Zmc2V0Jyk7XG4gIH07XG5cbiAgX3Byb3RvLm5leHRUcmFuc2l0aW9uID0gZnVuY3Rpb24gbmV4dFRyYW5zaXRpb24oaW5zdGFudCkge1xuICAgIGFic3RyYWN0TWV0aG9kRmFpbCgnWm9uZVJ1bGVzLm5leHRUcmFuc2l0aW9uJyk7XG4gIH07XG5cbiAgX3Byb3RvLnByZXZpb3VzVHJhbnNpdGlvbiA9IGZ1bmN0aW9uIHByZXZpb3VzVHJhbnNpdGlvbihpbnN0YW50KSB7XG4gICAgYWJzdHJhY3RNZXRob2RGYWlsKCdab25lUnVsZXMucHJldmlvdXNUcmFuc2l0aW9uJyk7XG4gIH07XG5cbiAgX3Byb3RvLnRyYW5zaXRpb25zID0gZnVuY3Rpb24gdHJhbnNpdGlvbnMoKSB7XG4gICAgYWJzdHJhY3RNZXRob2RGYWlsKCdab25lUnVsZXMudHJhbnNpdGlvbnMnKTtcbiAgfTtcblxuICBfcHJvdG8udHJhbnNpdGlvblJ1bGVzID0gZnVuY3Rpb24gdHJhbnNpdGlvblJ1bGVzKCkge1xuICAgIGFic3RyYWN0TWV0aG9kRmFpbCgnWm9uZVJ1bGVzLnRyYW5zaXRpb25SdWxlcycpO1xuICB9O1xuXG4gIF9wcm90by50b1N0cmluZyA9IGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuICAgIGFic3RyYWN0TWV0aG9kRmFpbCgnWm9uZVJ1bGVzLnRvU3RyaW5nJyk7XG4gIH07XG5cbiAgX3Byb3RvLnRvSlNPTiA9IGZ1bmN0aW9uIHRvSlNPTigpIHtcbiAgICByZXR1cm4gdGhpcy50b1N0cmluZygpO1xuICB9O1xuXG4gIHJldHVybiBab25lUnVsZXM7XG59KCk7XG5cbnZhciBGaXhlZCA9IGZ1bmN0aW9uIChfWm9uZVJ1bGVzKSB7XG4gIF9pbmhlcml0c0xvb3NlKEZpeGVkLCBfWm9uZVJ1bGVzKTtcblxuICBmdW5jdGlvbiBGaXhlZChvZmZzZXQpIHtcbiAgICB2YXIgX3RoaXM7XG5cbiAgICBfdGhpcyA9IF9ab25lUnVsZXMuY2FsbCh0aGlzKSB8fCB0aGlzO1xuICAgIF90aGlzLl9vZmZzZXQgPSBvZmZzZXQ7XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG5cbiAgdmFyIF9wcm90bzIgPSBGaXhlZC5wcm90b3R5cGU7XG5cbiAgX3Byb3RvMi5pc0ZpeGVkT2Zmc2V0ID0gZnVuY3Rpb24gaXNGaXhlZE9mZnNldCgpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfTtcblxuICBfcHJvdG8yLm9mZnNldE9mSW5zdGFudCA9IGZ1bmN0aW9uIG9mZnNldE9mSW5zdGFudCgpIHtcbiAgICByZXR1cm4gdGhpcy5fb2Zmc2V0O1xuICB9O1xuXG4gIF9wcm90bzIub2Zmc2V0T2ZFcG9jaE1pbGxpID0gZnVuY3Rpb24gb2Zmc2V0T2ZFcG9jaE1pbGxpKCkge1xuICAgIHJldHVybiB0aGlzLl9vZmZzZXQ7XG4gIH07XG5cbiAgX3Byb3RvMi5vZmZzZXRPZkxvY2FsRGF0ZVRpbWUgPSBmdW5jdGlvbiBvZmZzZXRPZkxvY2FsRGF0ZVRpbWUoKSB7XG4gICAgcmV0dXJuIHRoaXMuX29mZnNldDtcbiAgfTtcblxuICBfcHJvdG8yLnZhbGlkT2Zmc2V0cyA9IGZ1bmN0aW9uIHZhbGlkT2Zmc2V0cygpIHtcbiAgICByZXR1cm4gW3RoaXMuX29mZnNldF07XG4gIH07XG5cbiAgX3Byb3RvMi50cmFuc2l0aW9uID0gZnVuY3Rpb24gdHJhbnNpdGlvbigpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfTtcblxuICBfcHJvdG8yLnN0YW5kYXJkT2Zmc2V0ID0gZnVuY3Rpb24gc3RhbmRhcmRPZmZzZXQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX29mZnNldDtcbiAgfTtcblxuICBfcHJvdG8yLmRheWxpZ2h0U2F2aW5ncyA9IGZ1bmN0aW9uIGRheWxpZ2h0U2F2aW5ncygpIHtcbiAgICByZXR1cm4gRHVyYXRpb24uWkVSTztcbiAgfTtcblxuICBfcHJvdG8yLmlzRGF5bGlnaHRTYXZpbmdzID0gZnVuY3Rpb24gaXNEYXlsaWdodFNhdmluZ3MoKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9O1xuXG4gIF9wcm90bzIuaXNWYWxpZE9mZnNldCA9IGZ1bmN0aW9uIGlzVmFsaWRPZmZzZXQobG9jYWxEYXRlVGltZSwgb2Zmc2V0KSB7XG4gICAgcmV0dXJuIHRoaXMuX29mZnNldC5lcXVhbHMob2Zmc2V0KTtcbiAgfTtcblxuICBfcHJvdG8yLm5leHRUcmFuc2l0aW9uID0gZnVuY3Rpb24gbmV4dFRyYW5zaXRpb24oKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH07XG5cbiAgX3Byb3RvMi5wcmV2aW91c1RyYW5zaXRpb24gPSBmdW5jdGlvbiBwcmV2aW91c1RyYW5zaXRpb24oKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH07XG5cbiAgX3Byb3RvMi50cmFuc2l0aW9ucyA9IGZ1bmN0aW9uIHRyYW5zaXRpb25zKCkge1xuICAgIHJldHVybiBbXTtcbiAgfTtcblxuICBfcHJvdG8yLnRyYW5zaXRpb25SdWxlcyA9IGZ1bmN0aW9uIHRyYW5zaXRpb25SdWxlcygpIHtcbiAgICByZXR1cm4gW107XG4gIH07XG5cbiAgX3Byb3RvMi5lcXVhbHMgPSBmdW5jdGlvbiBlcXVhbHMob3RoZXIpIHtcbiAgICBpZiAodGhpcyA9PT0gb3RoZXIpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIGlmIChvdGhlciBpbnN0YW5jZW9mIEZpeGVkKSB7XG4gICAgICByZXR1cm4gdGhpcy5fb2Zmc2V0LmVxdWFscyhvdGhlci5fb2Zmc2V0KTtcbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2U7XG4gIH07XG5cbiAgX3Byb3RvMi50b1N0cmluZyA9IGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuICAgIHJldHVybiAnRml4ZWRSdWxlczonICsgdGhpcy5fb2Zmc2V0LnRvU3RyaW5nKCk7XG4gIH07XG5cbiAgcmV0dXJuIEZpeGVkO1xufShab25lUnVsZXMpO1xuXG52YXIgU0VDT05EU19DQUNIRSA9IHt9O1xudmFyIElEX0NBQ0hFID0ge307XG52YXIgWm9uZU9mZnNldCA9IGZ1bmN0aW9uIChfWm9uZUlkKSB7XG4gIF9pbmhlcml0c0xvb3NlKFpvbmVPZmZzZXQsIF9ab25lSWQpO1xuXG4gIGZ1bmN0aW9uIFpvbmVPZmZzZXQodG90YWxTZWNvbmRzKSB7XG4gICAgdmFyIF90aGlzO1xuXG4gICAgX3RoaXMgPSBfWm9uZUlkLmNhbGwodGhpcykgfHwgdGhpcztcblxuICAgIFpvbmVPZmZzZXQuX3ZhbGlkYXRlVG90YWxTZWNvbmRzKHRvdGFsU2Vjb25kcyk7XG5cbiAgICBfdGhpcy5fdG90YWxTZWNvbmRzID0gTWF0aFV0aWwuc2FmZVRvSW50KHRvdGFsU2Vjb25kcyk7XG4gICAgX3RoaXMuX3J1bGVzID0gWm9uZVJ1bGVzLm9mKF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMpKTtcbiAgICBfdGhpcy5faWQgPSBab25lT2Zmc2V0Ll9idWlsZElkKHRvdGFsU2Vjb25kcyk7XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG5cbiAgdmFyIF9wcm90byA9IFpvbmVPZmZzZXQucHJvdG90eXBlO1xuXG4gIF9wcm90by50b3RhbFNlY29uZHMgPSBmdW5jdGlvbiB0b3RhbFNlY29uZHMoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3RvdGFsU2Vjb25kcztcbiAgfTtcblxuICBfcHJvdG8uaWQgPSBmdW5jdGlvbiBpZCgpIHtcbiAgICByZXR1cm4gdGhpcy5faWQ7XG4gIH07XG5cbiAgWm9uZU9mZnNldC5fYnVpbGRJZCA9IGZ1bmN0aW9uIF9idWlsZElkKHRvdGFsU2Vjb25kcykge1xuICAgIGlmICh0b3RhbFNlY29uZHMgPT09IDApIHtcbiAgICAgIHJldHVybiAnWic7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBhYnNUb3RhbFNlY29uZHMgPSBNYXRoLmFicyh0b3RhbFNlY29uZHMpO1xuICAgICAgdmFyIGFic0hvdXJzID0gTWF0aFV0aWwuaW50RGl2KGFic1RvdGFsU2Vjb25kcywgTG9jYWxUaW1lLlNFQ09ORFNfUEVSX0hPVVIpO1xuICAgICAgdmFyIGFic01pbnV0ZXMgPSBNYXRoVXRpbC5pbnRNb2QoTWF0aFV0aWwuaW50RGl2KGFic1RvdGFsU2Vjb25kcywgTG9jYWxUaW1lLlNFQ09ORFNfUEVSX01JTlVURSksIExvY2FsVGltZS5NSU5VVEVTX1BFUl9IT1VSKTtcbiAgICAgIHZhciBidWYgPSAnJyArICh0b3RhbFNlY29uZHMgPCAwID8gJy0nIDogJysnKSArIChhYnNIb3VycyA8IDEwID8gJzAnIDogJycpICsgYWJzSG91cnMgKyAoYWJzTWludXRlcyA8IDEwID8gJzowJyA6ICc6JykgKyBhYnNNaW51dGVzO1xuICAgICAgdmFyIGFic1NlY29uZHMgPSBNYXRoVXRpbC5pbnRNb2QoYWJzVG90YWxTZWNvbmRzLCBMb2NhbFRpbWUuU0VDT05EU19QRVJfTUlOVVRFKTtcblxuICAgICAgaWYgKGFic1NlY29uZHMgIT09IDApIHtcbiAgICAgICAgYnVmICs9IChhYnNTZWNvbmRzIDwgMTAgPyAnOjAnIDogJzonKSArIGFic1NlY29uZHM7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBidWY7XG4gICAgfVxuICB9O1xuXG4gIFpvbmVPZmZzZXQuX3ZhbGlkYXRlVG90YWxTZWNvbmRzID0gZnVuY3Rpb24gX3ZhbGlkYXRlVG90YWxTZWNvbmRzKHRvdGFsU2Vjb25kcykge1xuICAgIGlmIChNYXRoLmFicyh0b3RhbFNlY29uZHMpID4gWm9uZU9mZnNldC5NQVhfU0VDT05EUykge1xuICAgICAgdGhyb3cgbmV3IERhdGVUaW1lRXhjZXB0aW9uKCdab25lIG9mZnNldCBub3QgaW4gdmFsaWQgcmFuZ2U6IC0xODowMCB0byArMTg6MDAnKTtcbiAgICB9XG4gIH07XG5cbiAgWm9uZU9mZnNldC5fdmFsaWRhdGUgPSBmdW5jdGlvbiBfdmFsaWRhdGUoaG91cnMsIG1pbnV0ZXMsIHNlY29uZHMpIHtcbiAgICBpZiAoaG91cnMgPCAtMTggfHwgaG91cnMgPiAxOCkge1xuICAgICAgdGhyb3cgbmV3IERhdGVUaW1lRXhjZXB0aW9uKCdab25lIG9mZnNldCBob3VycyBub3QgaW4gdmFsaWQgcmFuZ2U6IHZhbHVlICcgKyBob3VycyArICcgaXMgbm90IGluIHRoZSByYW5nZSAtMTggdG8gMTgnKTtcbiAgICB9XG5cbiAgICBpZiAoaG91cnMgPiAwKSB7XG4gICAgICBpZiAobWludXRlcyA8IDAgfHwgc2Vjb25kcyA8IDApIHtcbiAgICAgICAgdGhyb3cgbmV3IERhdGVUaW1lRXhjZXB0aW9uKCdab25lIG9mZnNldCBtaW51dGVzIGFuZCBzZWNvbmRzIG11c3QgYmUgcG9zaXRpdmUgYmVjYXVzZSBob3VycyBpcyBwb3NpdGl2ZScpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoaG91cnMgPCAwKSB7XG4gICAgICBpZiAobWludXRlcyA+IDAgfHwgc2Vjb25kcyA+IDApIHtcbiAgICAgICAgdGhyb3cgbmV3IERhdGVUaW1lRXhjZXB0aW9uKCdab25lIG9mZnNldCBtaW51dGVzIGFuZCBzZWNvbmRzIG11c3QgYmUgbmVnYXRpdmUgYmVjYXVzZSBob3VycyBpcyBuZWdhdGl2ZScpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAobWludXRlcyA+IDAgJiYgc2Vjb25kcyA8IDAgfHwgbWludXRlcyA8IDAgJiYgc2Vjb25kcyA+IDApIHtcbiAgICAgIHRocm93IG5ldyBEYXRlVGltZUV4Y2VwdGlvbignWm9uZSBvZmZzZXQgbWludXRlcyBhbmQgc2Vjb25kcyBtdXN0IGhhdmUgdGhlIHNhbWUgc2lnbicpO1xuICAgIH1cblxuICAgIGlmIChNYXRoLmFicyhtaW51dGVzKSA+IDU5KSB7XG4gICAgICB0aHJvdyBuZXcgRGF0ZVRpbWVFeGNlcHRpb24oJ1pvbmUgb2Zmc2V0IG1pbnV0ZXMgbm90IGluIHZhbGlkIHJhbmdlOiBhYnModmFsdWUpICcgKyBNYXRoLmFicyhtaW51dGVzKSArICcgaXMgbm90IGluIHRoZSByYW5nZSAwIHRvIDU5Jyk7XG4gICAgfVxuXG4gICAgaWYgKE1hdGguYWJzKHNlY29uZHMpID4gNTkpIHtcbiAgICAgIHRocm93IG5ldyBEYXRlVGltZUV4Y2VwdGlvbignWm9uZSBvZmZzZXQgc2Vjb25kcyBub3QgaW4gdmFsaWQgcmFuZ2U6IGFicyh2YWx1ZSkgJyArIE1hdGguYWJzKHNlY29uZHMpICsgJyBpcyBub3QgaW4gdGhlIHJhbmdlIDAgdG8gNTknKTtcbiAgICB9XG5cbiAgICBpZiAoTWF0aC5hYnMoaG91cnMpID09PSAxOCAmJiAoTWF0aC5hYnMobWludXRlcykgPiAwIHx8IE1hdGguYWJzKHNlY29uZHMpID4gMCkpIHtcbiAgICAgIHRocm93IG5ldyBEYXRlVGltZUV4Y2VwdGlvbignWm9uZSBvZmZzZXQgbm90IGluIHZhbGlkIHJhbmdlOiAtMTg6MDAgdG8gKzE4OjAwJyk7XG4gICAgfVxuICB9O1xuXG4gIFpvbmVPZmZzZXQub2YgPSBmdW5jdGlvbiBvZihvZmZzZXRJZCkge1xuICAgIHJlcXVpcmVOb25OdWxsKG9mZnNldElkLCAnb2Zmc2V0SWQnKTtcbiAgICB2YXIgb2Zmc2V0ID0gSURfQ0FDSEVbb2Zmc2V0SWRdO1xuXG4gICAgaWYgKG9mZnNldCAhPSBudWxsKSB7XG4gICAgICByZXR1cm4gb2Zmc2V0O1xuICAgIH1cblxuICAgIHZhciBob3VycywgbWludXRlcywgc2Vjb25kcztcblxuICAgIHN3aXRjaCAob2Zmc2V0SWQubGVuZ3RoKSB7XG4gICAgICBjYXNlIDI6XG4gICAgICAgIG9mZnNldElkID0gb2Zmc2V0SWRbMF0gKyAnMCcgKyBvZmZzZXRJZFsxXTtcblxuICAgICAgY2FzZSAzOlxuICAgICAgICBob3VycyA9IFpvbmVPZmZzZXQuX3BhcnNlTnVtYmVyKG9mZnNldElkLCAxLCBmYWxzZSk7XG4gICAgICAgIG1pbnV0ZXMgPSAwO1xuICAgICAgICBzZWNvbmRzID0gMDtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgNTpcbiAgICAgICAgaG91cnMgPSBab25lT2Zmc2V0Ll9wYXJzZU51bWJlcihvZmZzZXRJZCwgMSwgZmFsc2UpO1xuICAgICAgICBtaW51dGVzID0gWm9uZU9mZnNldC5fcGFyc2VOdW1iZXIob2Zmc2V0SWQsIDMsIGZhbHNlKTtcbiAgICAgICAgc2Vjb25kcyA9IDA7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlIDY6XG4gICAgICAgIGhvdXJzID0gWm9uZU9mZnNldC5fcGFyc2VOdW1iZXIob2Zmc2V0SWQsIDEsIGZhbHNlKTtcbiAgICAgICAgbWludXRlcyA9IFpvbmVPZmZzZXQuX3BhcnNlTnVtYmVyKG9mZnNldElkLCA0LCB0cnVlKTtcbiAgICAgICAgc2Vjb25kcyA9IDA7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlIDc6XG4gICAgICAgIGhvdXJzID0gWm9uZU9mZnNldC5fcGFyc2VOdW1iZXIob2Zmc2V0SWQsIDEsIGZhbHNlKTtcbiAgICAgICAgbWludXRlcyA9IFpvbmVPZmZzZXQuX3BhcnNlTnVtYmVyKG9mZnNldElkLCAzLCBmYWxzZSk7XG4gICAgICAgIHNlY29uZHMgPSBab25lT2Zmc2V0Ll9wYXJzZU51bWJlcihvZmZzZXRJZCwgNSwgZmFsc2UpO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSA5OlxuICAgICAgICBob3VycyA9IFpvbmVPZmZzZXQuX3BhcnNlTnVtYmVyKG9mZnNldElkLCAxLCBmYWxzZSk7XG4gICAgICAgIG1pbnV0ZXMgPSBab25lT2Zmc2V0Ll9wYXJzZU51bWJlcihvZmZzZXRJZCwgNCwgdHJ1ZSk7XG4gICAgICAgIHNlY29uZHMgPSBab25lT2Zmc2V0Ll9wYXJzZU51bWJlcihvZmZzZXRJZCwgNywgdHJ1ZSk7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICB0aHJvdyBuZXcgRGF0ZVRpbWVFeGNlcHRpb24oJ0ludmFsaWQgSUQgZm9yIFpvbmVPZmZzZXQsIGludmFsaWQgZm9ybWF0OiAnICsgb2Zmc2V0SWQpO1xuICAgIH1cblxuICAgIHZhciBmaXJzdCA9IG9mZnNldElkWzBdO1xuXG4gICAgaWYgKGZpcnN0ICE9PSAnKycgJiYgZmlyc3QgIT09ICctJykge1xuICAgICAgdGhyb3cgbmV3IERhdGVUaW1lRXhjZXB0aW9uKCdJbnZhbGlkIElEIGZvciBab25lT2Zmc2V0LCBwbHVzL21pbnVzIG5vdCBmb3VuZCB3aGVuIGV4cGVjdGVkOiAnICsgb2Zmc2V0SWQpO1xuICAgIH1cblxuICAgIGlmIChmaXJzdCA9PT0gJy0nKSB7XG4gICAgICByZXR1cm4gWm9uZU9mZnNldC5vZkhvdXJzTWludXRlc1NlY29uZHMoLWhvdXJzLCAtbWludXRlcywgLXNlY29uZHMpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gWm9uZU9mZnNldC5vZkhvdXJzTWludXRlc1NlY29uZHMoaG91cnMsIG1pbnV0ZXMsIHNlY29uZHMpO1xuICAgIH1cbiAgfTtcblxuICBab25lT2Zmc2V0Ll9wYXJzZU51bWJlciA9IGZ1bmN0aW9uIF9wYXJzZU51bWJlcihvZmZzZXRJZCwgcG9zLCBwcmVjZWRlZEJ5Q29sb24pIHtcbiAgICBpZiAocHJlY2VkZWRCeUNvbG9uICYmIG9mZnNldElkW3BvcyAtIDFdICE9PSAnOicpIHtcbiAgICAgIHRocm93IG5ldyBEYXRlVGltZUV4Y2VwdGlvbignSW52YWxpZCBJRCBmb3IgWm9uZU9mZnNldCwgY29sb24gbm90IGZvdW5kIHdoZW4gZXhwZWN0ZWQ6ICcgKyBvZmZzZXRJZCk7XG4gICAgfVxuXG4gICAgdmFyIGNoMSA9IG9mZnNldElkW3Bvc107XG4gICAgdmFyIGNoMiA9IG9mZnNldElkW3BvcyArIDFdO1xuXG4gICAgaWYgKGNoMSA8ICcwJyB8fCBjaDEgPiAnOScgfHwgY2gyIDwgJzAnIHx8IGNoMiA+ICc5Jykge1xuICAgICAgdGhyb3cgbmV3IERhdGVUaW1lRXhjZXB0aW9uKCdJbnZhbGlkIElEIGZvciBab25lT2Zmc2V0LCBub24gbnVtZXJpYyBjaGFyYWN0ZXJzIGZvdW5kOiAnICsgb2Zmc2V0SWQpO1xuICAgIH1cblxuICAgIHJldHVybiAoY2gxLmNoYXJDb2RlQXQoMCkgLSA0OCkgKiAxMCArIChjaDIuY2hhckNvZGVBdCgwKSAtIDQ4KTtcbiAgfTtcblxuICBab25lT2Zmc2V0Lm9mSG91cnMgPSBmdW5jdGlvbiBvZkhvdXJzKGhvdXJzKSB7XG4gICAgcmV0dXJuIFpvbmVPZmZzZXQub2ZIb3Vyc01pbnV0ZXNTZWNvbmRzKGhvdXJzLCAwLCAwKTtcbiAgfTtcblxuICBab25lT2Zmc2V0Lm9mSG91cnNNaW51dGVzID0gZnVuY3Rpb24gb2ZIb3Vyc01pbnV0ZXMoaG91cnMsIG1pbnV0ZXMpIHtcbiAgICByZXR1cm4gWm9uZU9mZnNldC5vZkhvdXJzTWludXRlc1NlY29uZHMoaG91cnMsIG1pbnV0ZXMsIDApO1xuICB9O1xuXG4gIFpvbmVPZmZzZXQub2ZIb3Vyc01pbnV0ZXNTZWNvbmRzID0gZnVuY3Rpb24gb2ZIb3Vyc01pbnV0ZXNTZWNvbmRzKGhvdXJzLCBtaW51dGVzLCBzZWNvbmRzKSB7XG4gICAgWm9uZU9mZnNldC5fdmFsaWRhdGUoaG91cnMsIG1pbnV0ZXMsIHNlY29uZHMpO1xuXG4gICAgdmFyIHRvdGFsU2Vjb25kcyA9IGhvdXJzICogTG9jYWxUaW1lLlNFQ09ORFNfUEVSX0hPVVIgKyBtaW51dGVzICogTG9jYWxUaW1lLlNFQ09ORFNfUEVSX01JTlVURSArIHNlY29uZHM7XG4gICAgcmV0dXJuIFpvbmVPZmZzZXQub2ZUb3RhbFNlY29uZHModG90YWxTZWNvbmRzKTtcbiAgfTtcblxuICBab25lT2Zmc2V0Lm9mVG90YWxNaW51dGVzID0gZnVuY3Rpb24gb2ZUb3RhbE1pbnV0ZXModG90YWxNaW51dGVzKSB7XG4gICAgdmFyIHRvdGFsU2Vjb25kcyA9IHRvdGFsTWludXRlcyAqIExvY2FsVGltZS5TRUNPTkRTX1BFUl9NSU5VVEU7XG4gICAgcmV0dXJuIFpvbmVPZmZzZXQub2ZUb3RhbFNlY29uZHModG90YWxTZWNvbmRzKTtcbiAgfTtcblxuICBab25lT2Zmc2V0Lm9mVG90YWxTZWNvbmRzID0gZnVuY3Rpb24gb2ZUb3RhbFNlY29uZHModG90YWxTZWNvbmRzKSB7XG4gICAgaWYgKHRvdGFsU2Vjb25kcyAlICgxNSAqIExvY2FsVGltZS5TRUNPTkRTX1BFUl9NSU5VVEUpID09PSAwKSB7XG4gICAgICB2YXIgdG90YWxTZWNzID0gdG90YWxTZWNvbmRzO1xuICAgICAgdmFyIHJlc3VsdCA9IFNFQ09ORFNfQ0FDSEVbdG90YWxTZWNzXTtcblxuICAgICAgaWYgKHJlc3VsdCA9PSBudWxsKSB7XG4gICAgICAgIHJlc3VsdCA9IG5ldyBab25lT2Zmc2V0KHRvdGFsU2Vjb25kcyk7XG4gICAgICAgIFNFQ09ORFNfQ0FDSEVbdG90YWxTZWNzXSA9IHJlc3VsdDtcbiAgICAgICAgSURfQ0FDSEVbcmVzdWx0LmlkKCldID0gcmVzdWx0O1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gbmV3IFpvbmVPZmZzZXQodG90YWxTZWNvbmRzKTtcbiAgICB9XG4gIH07XG5cbiAgX3Byb3RvLnJ1bGVzID0gZnVuY3Rpb24gcnVsZXMoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3J1bGVzO1xuICB9O1xuXG4gIF9wcm90by5nZXQgPSBmdW5jdGlvbiBnZXQoZmllbGQpIHtcbiAgICByZXR1cm4gdGhpcy5nZXRMb25nKGZpZWxkKTtcbiAgfTtcblxuICBfcHJvdG8uZ2V0TG9uZyA9IGZ1bmN0aW9uIGdldExvbmcoZmllbGQpIHtcbiAgICBpZiAoZmllbGQgPT09IENocm9ub0ZpZWxkLk9GRlNFVF9TRUNPTkRTKSB7XG4gICAgICByZXR1cm4gdGhpcy5fdG90YWxTZWNvbmRzO1xuICAgIH0gZWxzZSBpZiAoZmllbGQgaW5zdGFuY2VvZiBDaHJvbm9GaWVsZCkge1xuICAgICAgdGhyb3cgbmV3IERhdGVUaW1lRXhjZXB0aW9uKCdVbnN1cHBvcnRlZCBmaWVsZDogJyArIGZpZWxkKTtcbiAgICB9XG5cbiAgICByZXR1cm4gZmllbGQuZ2V0RnJvbSh0aGlzKTtcbiAgfTtcblxuICBfcHJvdG8ucXVlcnkgPSBmdW5jdGlvbiBxdWVyeShfcXVlcnkpIHtcbiAgICByZXF1aXJlTm9uTnVsbChfcXVlcnksICdxdWVyeScpO1xuXG4gICAgaWYgKF9xdWVyeSA9PT0gVGVtcG9yYWxRdWVyaWVzLm9mZnNldCgpIHx8IF9xdWVyeSA9PT0gVGVtcG9yYWxRdWVyaWVzLnpvbmUoKSkge1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSBlbHNlIGlmIChfcXVlcnkgPT09IFRlbXBvcmFsUXVlcmllcy5sb2NhbERhdGUoKSB8fCBfcXVlcnkgPT09IFRlbXBvcmFsUXVlcmllcy5sb2NhbFRpbWUoKSB8fCBfcXVlcnkgPT09IFRlbXBvcmFsUXVlcmllcy5wcmVjaXNpb24oKSB8fCBfcXVlcnkgPT09IFRlbXBvcmFsUXVlcmllcy5jaHJvbm9sb2d5KCkgfHwgX3F1ZXJ5ID09PSBUZW1wb3JhbFF1ZXJpZXMuem9uZUlkKCkpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIHJldHVybiBfcXVlcnkucXVlcnlGcm9tKHRoaXMpO1xuICB9O1xuXG4gIF9wcm90by5hZGp1c3RJbnRvID0gZnVuY3Rpb24gYWRqdXN0SW50byh0ZW1wb3JhbCkge1xuICAgIHJldHVybiB0ZW1wb3JhbC53aXRoKENocm9ub0ZpZWxkLk9GRlNFVF9TRUNPTkRTLCB0aGlzLl90b3RhbFNlY29uZHMpO1xuICB9O1xuXG4gIF9wcm90by5jb21wYXJlVG8gPSBmdW5jdGlvbiBjb21wYXJlVG8ob3RoZXIpIHtcbiAgICByZXF1aXJlTm9uTnVsbChvdGhlciwgJ290aGVyJyk7XG4gICAgcmV0dXJuIG90aGVyLl90b3RhbFNlY29uZHMgLSB0aGlzLl90b3RhbFNlY29uZHM7XG4gIH07XG5cbiAgX3Byb3RvLmVxdWFscyA9IGZ1bmN0aW9uIGVxdWFscyhvYmopIHtcbiAgICBpZiAodGhpcyA9PT0gb2JqKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICBpZiAob2JqIGluc3RhbmNlb2YgWm9uZU9mZnNldCkge1xuICAgICAgcmV0dXJuIHRoaXMuX3RvdGFsU2Vjb25kcyA9PT0gb2JqLl90b3RhbFNlY29uZHM7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9O1xuXG4gIF9wcm90by5oYXNoQ29kZSA9IGZ1bmN0aW9uIGhhc2hDb2RlKCkge1xuICAgIHJldHVybiB0aGlzLl90b3RhbFNlY29uZHM7XG4gIH07XG5cbiAgX3Byb3RvLnRvU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2lkO1xuICB9O1xuXG4gIHJldHVybiBab25lT2Zmc2V0O1xufShab25lSWQpO1xuZnVuY3Rpb24gX2luaXQkNygpIHtcbiAgWm9uZU9mZnNldC5NQVhfU0VDT05EUyA9IDE4ICogTG9jYWxUaW1lLlNFQ09ORFNfUEVSX0hPVVI7XG4gIFpvbmVPZmZzZXQuVVRDID0gWm9uZU9mZnNldC5vZlRvdGFsU2Vjb25kcygwKTtcbiAgWm9uZU9mZnNldC5NSU4gPSBab25lT2Zmc2V0Lm9mVG90YWxTZWNvbmRzKC1ab25lT2Zmc2V0Lk1BWF9TRUNPTkRTKTtcbiAgWm9uZU9mZnNldC5NQVggPSBab25lT2Zmc2V0Lm9mVG90YWxTZWNvbmRzKFpvbmVPZmZzZXQuTUFYX1NFQ09ORFMpO1xufVxuXG52YXIgRGF0ZVRpbWVCdWlsZGVyID0gZnVuY3Rpb24gKF9UZW1wb3JhbEFjY2Vzc29yKSB7XG4gIF9pbmhlcml0c0xvb3NlKERhdGVUaW1lQnVpbGRlciwgX1RlbXBvcmFsQWNjZXNzb3IpO1xuXG4gIERhdGVUaW1lQnVpbGRlci5jcmVhdGUgPSBmdW5jdGlvbiBjcmVhdGUoZmllbGQsIHZhbHVlKSB7XG4gICAgdmFyIGR0YiA9IG5ldyBEYXRlVGltZUJ1aWxkZXIoKTtcblxuICAgIGR0Yi5fYWRkRmllbGRWYWx1ZShmaWVsZCwgdmFsdWUpO1xuXG4gICAgcmV0dXJuIGR0YjtcbiAgfTtcblxuICBmdW5jdGlvbiBEYXRlVGltZUJ1aWxkZXIoKSB7XG4gICAgdmFyIF90aGlzO1xuXG4gICAgX3RoaXMgPSBfVGVtcG9yYWxBY2Nlc3Nvci5jYWxsKHRoaXMpIHx8IHRoaXM7XG4gICAgX3RoaXMuZmllbGRWYWx1ZXMgPSBuZXcgRW51bU1hcCgpO1xuICAgIF90aGlzLmNocm9ubyA9IG51bGw7XG4gICAgX3RoaXMuem9uZSA9IG51bGw7XG4gICAgX3RoaXMuZGF0ZSA9IG51bGw7XG4gICAgX3RoaXMudGltZSA9IG51bGw7XG4gICAgX3RoaXMubGVhcFNlY29uZCA9IGZhbHNlO1xuICAgIF90aGlzLmV4Y2Vzc0RheXMgPSBudWxsO1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuXG4gIHZhciBfcHJvdG8gPSBEYXRlVGltZUJ1aWxkZXIucHJvdG90eXBlO1xuXG4gIF9wcm90by5nZXRGaWVsZFZhbHVlMCA9IGZ1bmN0aW9uIGdldEZpZWxkVmFsdWUwKGZpZWxkKSB7XG4gICAgcmV0dXJuIHRoaXMuZmllbGRWYWx1ZXMuZ2V0KGZpZWxkKTtcbiAgfTtcblxuICBfcHJvdG8uX2FkZEZpZWxkVmFsdWUgPSBmdW5jdGlvbiBfYWRkRmllbGRWYWx1ZShmaWVsZCwgdmFsdWUpIHtcbiAgICByZXF1aXJlTm9uTnVsbChmaWVsZCwgJ2ZpZWxkJyk7XG4gICAgdmFyIG9sZCA9IHRoaXMuZ2V0RmllbGRWYWx1ZTAoZmllbGQpO1xuXG4gICAgaWYgKG9sZCAhPSBudWxsICYmIG9sZCAhPT0gdmFsdWUpIHtcbiAgICAgIHRocm93IG5ldyBEYXRlVGltZUV4Y2VwdGlvbignQ29uZmxpY3QgZm91bmQ6ICcgKyBmaWVsZCArICcgJyArIG9sZCArICcgZGlmZmVycyBmcm9tICcgKyBmaWVsZCArICcgJyArIHZhbHVlICsgJzogJyArIHRoaXMpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLl9wdXRGaWVsZFZhbHVlMChmaWVsZCwgdmFsdWUpO1xuICB9O1xuXG4gIF9wcm90by5fcHV0RmllbGRWYWx1ZTAgPSBmdW5jdGlvbiBfcHV0RmllbGRWYWx1ZTAoZmllbGQsIHZhbHVlKSB7XG4gICAgdGhpcy5maWVsZFZhbHVlcy5wdXQoZmllbGQsIHZhbHVlKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICBfcHJvdG8ucmVzb2x2ZSA9IGZ1bmN0aW9uIHJlc29sdmUocmVzb2x2ZXJTdHlsZSwgcmVzb2x2ZXJGaWVsZHMpIHtcbiAgICBpZiAocmVzb2x2ZXJGaWVsZHMgIT0gbnVsbCkge1xuICAgICAgdGhpcy5maWVsZFZhbHVlcy5yZXRhaW5BbGwocmVzb2x2ZXJGaWVsZHMpO1xuICAgIH1cblxuICAgIHRoaXMuX21lcmdlRGF0ZShyZXNvbHZlclN0eWxlKTtcblxuICAgIHRoaXMuX21lcmdlVGltZShyZXNvbHZlclN0eWxlKTtcblxuICAgIHRoaXMuX3Jlc29sdmVUaW1lSW5mZXJaZXJvZXMocmVzb2x2ZXJTdHlsZSk7XG5cbiAgICBpZiAodGhpcy5leGNlc3NEYXlzICE9IG51bGwgJiYgdGhpcy5leGNlc3NEYXlzLmlzWmVybygpID09PSBmYWxzZSAmJiB0aGlzLmRhdGUgIT0gbnVsbCAmJiB0aGlzLnRpbWUgIT0gbnVsbCkge1xuICAgICAgdGhpcy5kYXRlID0gdGhpcy5kYXRlLnBsdXModGhpcy5leGNlc3NEYXlzKTtcbiAgICAgIHRoaXMuZXhjZXNzRGF5cyA9IFBlcmlvZC5aRVJPO1xuICAgIH1cblxuICAgIHRoaXMuX3Jlc29sdmVJbnN0YW50KCk7XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICBfcHJvdG8uX21lcmdlRGF0ZSA9IGZ1bmN0aW9uIF9tZXJnZURhdGUocmVzb2x2ZXJTdHlsZSkge1xuICAgIHRoaXMuX2NoZWNrRGF0ZShJc29DaHJvbm9sb2d5LklOU1RBTkNFLnJlc29sdmVEYXRlKHRoaXMuZmllbGRWYWx1ZXMsIHJlc29sdmVyU3R5bGUpKTtcbiAgfTtcblxuICBfcHJvdG8uX2NoZWNrRGF0ZSA9IGZ1bmN0aW9uIF9jaGVja0RhdGUoZGF0ZSkge1xuICAgIGlmIChkYXRlICE9IG51bGwpIHtcbiAgICAgIHRoaXMuX2FkZE9iamVjdChkYXRlKTtcblxuICAgICAgZm9yICh2YXIgZmllbGROYW1lIGluIHRoaXMuZmllbGRWYWx1ZXMua2V5U2V0KCkpIHtcbiAgICAgICAgdmFyIGZpZWxkID0gQ2hyb25vRmllbGQuYnlOYW1lKGZpZWxkTmFtZSk7XG5cbiAgICAgICAgaWYgKGZpZWxkKSB7XG4gICAgICAgICAgaWYgKHRoaXMuZmllbGRWYWx1ZXMuZ2V0KGZpZWxkKSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBpZiAoZmllbGQuaXNEYXRlQmFzZWQoKSkge1xuICAgICAgICAgICAgICB2YXIgdmFsMSA9IHZvaWQgMDtcblxuICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHZhbDEgPSBkYXRlLmdldExvbmcoZmllbGQpO1xuICAgICAgICAgICAgICB9IGNhdGNoIChleCkge1xuICAgICAgICAgICAgICAgIGlmIChleCBpbnN0YW5jZW9mIERhdGVUaW1lRXhjZXB0aW9uKSB7XG4gICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgdGhyb3cgZXg7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgdmFyIHZhbDIgPSB0aGlzLmZpZWxkVmFsdWVzLmdldChmaWVsZCk7XG5cbiAgICAgICAgICAgICAgaWYgKHZhbDEgIT09IHZhbDIpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRGF0ZVRpbWVFeGNlcHRpb24oJ0NvbmZsaWN0IGZvdW5kOiBGaWVsZCAnICsgZmllbGQgKyAnICcgKyB2YWwxICsgJyBkaWZmZXJzIGZyb20gJyArIGZpZWxkICsgJyAnICsgdmFsMiArICcgZGVyaXZlZCBmcm9tICcgKyBkYXRlKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICBfcHJvdG8uX21lcmdlVGltZSA9IGZ1bmN0aW9uIF9tZXJnZVRpbWUocmVzb2x2ZXJTdHlsZSkge1xuICAgIGlmICh0aGlzLmZpZWxkVmFsdWVzLmNvbnRhaW5zS2V5KENocm9ub0ZpZWxkLkNMT0NLX0hPVVJfT0ZfREFZKSkge1xuICAgICAgdmFyIGNoID0gdGhpcy5maWVsZFZhbHVlcy5yZW1vdmUoQ2hyb25vRmllbGQuQ0xPQ0tfSE9VUl9PRl9EQVkpO1xuXG4gICAgICBpZiAocmVzb2x2ZXJTdHlsZSAhPT0gUmVzb2x2ZXJTdHlsZS5MRU5JRU5UKSB7XG4gICAgICAgIGlmIChyZXNvbHZlclN0eWxlID09PSBSZXNvbHZlclN0eWxlLlNNQVJUICYmIGNoID09PSAwKSA7IGVsc2Uge1xuICAgICAgICAgIENocm9ub0ZpZWxkLkNMT0NLX0hPVVJfT0ZfREFZLmNoZWNrVmFsaWRWYWx1ZShjaCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdGhpcy5fYWRkRmllbGRWYWx1ZShDaHJvbm9GaWVsZC5IT1VSX09GX0RBWSwgY2ggPT09IDI0ID8gMCA6IGNoKTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5maWVsZFZhbHVlcy5jb250YWluc0tleShDaHJvbm9GaWVsZC5DTE9DS19IT1VSX09GX0FNUE0pKSB7XG4gICAgICB2YXIgX2NoID0gdGhpcy5maWVsZFZhbHVlcy5yZW1vdmUoQ2hyb25vRmllbGQuQ0xPQ0tfSE9VUl9PRl9BTVBNKTtcblxuICAgICAgaWYgKHJlc29sdmVyU3R5bGUgIT09IFJlc29sdmVyU3R5bGUuTEVOSUVOVCkge1xuICAgICAgICBpZiAocmVzb2x2ZXJTdHlsZSA9PT0gUmVzb2x2ZXJTdHlsZS5TTUFSVCAmJiBfY2ggPT09IDApIDsgZWxzZSB7XG4gICAgICAgICAgQ2hyb25vRmllbGQuQ0xPQ0tfSE9VUl9PRl9BTVBNLmNoZWNrVmFsaWRWYWx1ZShfY2gpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHRoaXMuX2FkZEZpZWxkVmFsdWUoQ2hyb25vRmllbGQuSE9VUl9PRl9BTVBNLCBfY2ggPT09IDEyID8gMCA6IF9jaCk7XG4gICAgfVxuXG4gICAgaWYgKHJlc29sdmVyU3R5bGUgIT09IFJlc29sdmVyU3R5bGUuTEVOSUVOVCkge1xuICAgICAgaWYgKHRoaXMuZmllbGRWYWx1ZXMuY29udGFpbnNLZXkoQ2hyb25vRmllbGQuQU1QTV9PRl9EQVkpKSB7XG4gICAgICAgIENocm9ub0ZpZWxkLkFNUE1fT0ZfREFZLmNoZWNrVmFsaWRWYWx1ZSh0aGlzLmZpZWxkVmFsdWVzLmdldChDaHJvbm9GaWVsZC5BTVBNX09GX0RBWSkpO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5maWVsZFZhbHVlcy5jb250YWluc0tleShDaHJvbm9GaWVsZC5IT1VSX09GX0FNUE0pKSB7XG4gICAgICAgIENocm9ub0ZpZWxkLkhPVVJfT0ZfQU1QTS5jaGVja1ZhbGlkVmFsdWUodGhpcy5maWVsZFZhbHVlcy5nZXQoQ2hyb25vRmllbGQuSE9VUl9PRl9BTVBNKSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuZmllbGRWYWx1ZXMuY29udGFpbnNLZXkoQ2hyb25vRmllbGQuQU1QTV9PRl9EQVkpICYmIHRoaXMuZmllbGRWYWx1ZXMuY29udGFpbnNLZXkoQ2hyb25vRmllbGQuSE9VUl9PRl9BTVBNKSkge1xuICAgICAgdmFyIGFwID0gdGhpcy5maWVsZFZhbHVlcy5yZW1vdmUoQ2hyb25vRmllbGQuQU1QTV9PRl9EQVkpO1xuICAgICAgdmFyIGhhcCA9IHRoaXMuZmllbGRWYWx1ZXMucmVtb3ZlKENocm9ub0ZpZWxkLkhPVVJfT0ZfQU1QTSk7XG5cbiAgICAgIHRoaXMuX2FkZEZpZWxkVmFsdWUoQ2hyb25vRmllbGQuSE9VUl9PRl9EQVksIGFwICogMTIgKyBoYXApO1xuICAgIH1cblxuICAgIGlmICh0aGlzLmZpZWxkVmFsdWVzLmNvbnRhaW5zS2V5KENocm9ub0ZpZWxkLk5BTk9fT0ZfREFZKSkge1xuICAgICAgdmFyIG5vZCA9IHRoaXMuZmllbGRWYWx1ZXMucmVtb3ZlKENocm9ub0ZpZWxkLk5BTk9fT0ZfREFZKTtcblxuICAgICAgaWYgKHJlc29sdmVyU3R5bGUgIT09IFJlc29sdmVyU3R5bGUuTEVOSUVOVCkge1xuICAgICAgICBDaHJvbm9GaWVsZC5OQU5PX09GX0RBWS5jaGVja1ZhbGlkVmFsdWUobm9kKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5fYWRkRmllbGRWYWx1ZShDaHJvbm9GaWVsZC5TRUNPTkRfT0ZfREFZLCBNYXRoVXRpbC5pbnREaXYobm9kLCAxMDAwMDAwMDAwKSk7XG5cbiAgICAgIHRoaXMuX2FkZEZpZWxkVmFsdWUoQ2hyb25vRmllbGQuTkFOT19PRl9TRUNPTkQsIE1hdGhVdGlsLmludE1vZChub2QsIDEwMDAwMDAwMDApKTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5maWVsZFZhbHVlcy5jb250YWluc0tleShDaHJvbm9GaWVsZC5NSUNST19PRl9EQVkpKSB7XG4gICAgICB2YXIgY29kID0gdGhpcy5maWVsZFZhbHVlcy5yZW1vdmUoQ2hyb25vRmllbGQuTUlDUk9fT0ZfREFZKTtcblxuICAgICAgaWYgKHJlc29sdmVyU3R5bGUgIT09IFJlc29sdmVyU3R5bGUuTEVOSUVOVCkge1xuICAgICAgICBDaHJvbm9GaWVsZC5NSUNST19PRl9EQVkuY2hlY2tWYWxpZFZhbHVlKGNvZCk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuX2FkZEZpZWxkVmFsdWUoQ2hyb25vRmllbGQuU0VDT05EX09GX0RBWSwgTWF0aFV0aWwuaW50RGl2KGNvZCwgMTAwMDAwMCkpO1xuXG4gICAgICB0aGlzLl9hZGRGaWVsZFZhbHVlKENocm9ub0ZpZWxkLk1JQ1JPX09GX1NFQ09ORCwgTWF0aFV0aWwuaW50TW9kKGNvZCwgMTAwMDAwMCkpO1xuICAgIH1cblxuICAgIGlmICh0aGlzLmZpZWxkVmFsdWVzLmNvbnRhaW5zS2V5KENocm9ub0ZpZWxkLk1JTExJX09GX0RBWSkpIHtcbiAgICAgIHZhciBsb2QgPSB0aGlzLmZpZWxkVmFsdWVzLnJlbW92ZShDaHJvbm9GaWVsZC5NSUxMSV9PRl9EQVkpO1xuXG4gICAgICBpZiAocmVzb2x2ZXJTdHlsZSAhPT0gUmVzb2x2ZXJTdHlsZS5MRU5JRU5UKSB7XG4gICAgICAgIENocm9ub0ZpZWxkLk1JTExJX09GX0RBWS5jaGVja1ZhbGlkVmFsdWUobG9kKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5fYWRkRmllbGRWYWx1ZShDaHJvbm9GaWVsZC5TRUNPTkRfT0ZfREFZLCBNYXRoVXRpbC5pbnREaXYobG9kLCAxMDAwKSk7XG5cbiAgICAgIHRoaXMuX2FkZEZpZWxkVmFsdWUoQ2hyb25vRmllbGQuTUlMTElfT0ZfU0VDT05ELCBNYXRoVXRpbC5pbnRNb2QobG9kLCAxMDAwKSk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuZmllbGRWYWx1ZXMuY29udGFpbnNLZXkoQ2hyb25vRmllbGQuU0VDT05EX09GX0RBWSkpIHtcbiAgICAgIHZhciBzb2QgPSB0aGlzLmZpZWxkVmFsdWVzLnJlbW92ZShDaHJvbm9GaWVsZC5TRUNPTkRfT0ZfREFZKTtcblxuICAgICAgaWYgKHJlc29sdmVyU3R5bGUgIT09IFJlc29sdmVyU3R5bGUuTEVOSUVOVCkge1xuICAgICAgICBDaHJvbm9GaWVsZC5TRUNPTkRfT0ZfREFZLmNoZWNrVmFsaWRWYWx1ZShzb2QpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLl9hZGRGaWVsZFZhbHVlKENocm9ub0ZpZWxkLkhPVVJfT0ZfREFZLCBNYXRoVXRpbC5pbnREaXYoc29kLCAzNjAwKSk7XG5cbiAgICAgIHRoaXMuX2FkZEZpZWxkVmFsdWUoQ2hyb25vRmllbGQuTUlOVVRFX09GX0hPVVIsIE1hdGhVdGlsLmludE1vZChNYXRoVXRpbC5pbnREaXYoc29kLCA2MCksIDYwKSk7XG5cbiAgICAgIHRoaXMuX2FkZEZpZWxkVmFsdWUoQ2hyb25vRmllbGQuU0VDT05EX09GX01JTlVURSwgTWF0aFV0aWwuaW50TW9kKHNvZCwgNjApKTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5maWVsZFZhbHVlcy5jb250YWluc0tleShDaHJvbm9GaWVsZC5NSU5VVEVfT0ZfREFZKSkge1xuICAgICAgdmFyIG1vZCA9IHRoaXMuZmllbGRWYWx1ZXMucmVtb3ZlKENocm9ub0ZpZWxkLk1JTlVURV9PRl9EQVkpO1xuXG4gICAgICBpZiAocmVzb2x2ZXJTdHlsZSAhPT0gUmVzb2x2ZXJTdHlsZS5MRU5JRU5UKSB7XG4gICAgICAgIENocm9ub0ZpZWxkLk1JTlVURV9PRl9EQVkuY2hlY2tWYWxpZFZhbHVlKG1vZCk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuX2FkZEZpZWxkVmFsdWUoQ2hyb25vRmllbGQuSE9VUl9PRl9EQVksIE1hdGhVdGlsLmludERpdihtb2QsIDYwKSk7XG5cbiAgICAgIHRoaXMuX2FkZEZpZWxkVmFsdWUoQ2hyb25vRmllbGQuTUlOVVRFX09GX0hPVVIsIE1hdGhVdGlsLmludE1vZChtb2QsIDYwKSk7XG4gICAgfVxuXG4gICAgaWYgKHJlc29sdmVyU3R5bGUgIT09IFJlc29sdmVyU3R5bGUuTEVOSUVOVCkge1xuICAgICAgaWYgKHRoaXMuZmllbGRWYWx1ZXMuY29udGFpbnNLZXkoQ2hyb25vRmllbGQuTUlMTElfT0ZfU0VDT05EKSkge1xuICAgICAgICBDaHJvbm9GaWVsZC5NSUxMSV9PRl9TRUNPTkQuY2hlY2tWYWxpZFZhbHVlKHRoaXMuZmllbGRWYWx1ZXMuZ2V0KENocm9ub0ZpZWxkLk1JTExJX09GX1NFQ09ORCkpO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5maWVsZFZhbHVlcy5jb250YWluc0tleShDaHJvbm9GaWVsZC5NSUNST19PRl9TRUNPTkQpKSB7XG4gICAgICAgIENocm9ub0ZpZWxkLk1JQ1JPX09GX1NFQ09ORC5jaGVja1ZhbGlkVmFsdWUodGhpcy5maWVsZFZhbHVlcy5nZXQoQ2hyb25vRmllbGQuTUlDUk9fT0ZfU0VDT05EKSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuZmllbGRWYWx1ZXMuY29udGFpbnNLZXkoQ2hyb25vRmllbGQuTUlMTElfT0ZfU0VDT05EKSAmJiB0aGlzLmZpZWxkVmFsdWVzLmNvbnRhaW5zS2V5KENocm9ub0ZpZWxkLk1JQ1JPX09GX1NFQ09ORCkpIHtcbiAgICAgIHZhciBsb3MgPSB0aGlzLmZpZWxkVmFsdWVzLnJlbW92ZShDaHJvbm9GaWVsZC5NSUxMSV9PRl9TRUNPTkQpO1xuICAgICAgdmFyIGNvcyA9IHRoaXMuZmllbGRWYWx1ZXMuZ2V0KENocm9ub0ZpZWxkLk1JQ1JPX09GX1NFQ09ORCk7XG5cbiAgICAgIHRoaXMuX3B1dEZpZWxkVmFsdWUwKENocm9ub0ZpZWxkLk1JQ1JPX09GX1NFQ09ORCwgbG9zICogMTAwMCArIE1hdGhVdGlsLmludE1vZChjb3MsIDEwMDApKTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5maWVsZFZhbHVlcy5jb250YWluc0tleShDaHJvbm9GaWVsZC5NSUNST19PRl9TRUNPTkQpICYmIHRoaXMuZmllbGRWYWx1ZXMuY29udGFpbnNLZXkoQ2hyb25vRmllbGQuTkFOT19PRl9TRUNPTkQpKSB7XG4gICAgICB2YXIgbm9zID0gdGhpcy5maWVsZFZhbHVlcy5nZXQoQ2hyb25vRmllbGQuTkFOT19PRl9TRUNPTkQpO1xuXG4gICAgICB0aGlzLl9wdXRGaWVsZFZhbHVlMChDaHJvbm9GaWVsZC5NSUNST19PRl9TRUNPTkQsIE1hdGhVdGlsLmludERpdihub3MsIDEwMDApKTtcblxuICAgICAgdGhpcy5maWVsZFZhbHVlcy5yZW1vdmUoQ2hyb25vRmllbGQuTUlDUk9fT0ZfU0VDT05EKTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5maWVsZFZhbHVlcy5jb250YWluc0tleShDaHJvbm9GaWVsZC5NSUxMSV9PRl9TRUNPTkQpICYmIHRoaXMuZmllbGRWYWx1ZXMuY29udGFpbnNLZXkoQ2hyb25vRmllbGQuTkFOT19PRl9TRUNPTkQpKSB7XG4gICAgICB2YXIgX25vcyA9IHRoaXMuZmllbGRWYWx1ZXMuZ2V0KENocm9ub0ZpZWxkLk5BTk9fT0ZfU0VDT05EKTtcblxuICAgICAgdGhpcy5fcHV0RmllbGRWYWx1ZTAoQ2hyb25vRmllbGQuTUlMTElfT0ZfU0VDT05ELCBNYXRoVXRpbC5pbnREaXYoX25vcywgMTAwMDAwMCkpO1xuXG4gICAgICB0aGlzLmZpZWxkVmFsdWVzLnJlbW92ZShDaHJvbm9GaWVsZC5NSUxMSV9PRl9TRUNPTkQpO1xuICAgIH1cblxuICAgIGlmICh0aGlzLmZpZWxkVmFsdWVzLmNvbnRhaW5zS2V5KENocm9ub0ZpZWxkLk1JQ1JPX09GX1NFQ09ORCkpIHtcbiAgICAgIHZhciBfY29zID0gdGhpcy5maWVsZFZhbHVlcy5yZW1vdmUoQ2hyb25vRmllbGQuTUlDUk9fT0ZfU0VDT05EKTtcblxuICAgICAgdGhpcy5fcHV0RmllbGRWYWx1ZTAoQ2hyb25vRmllbGQuTkFOT19PRl9TRUNPTkQsIF9jb3MgKiAxMDAwKTtcbiAgICB9IGVsc2UgaWYgKHRoaXMuZmllbGRWYWx1ZXMuY29udGFpbnNLZXkoQ2hyb25vRmllbGQuTUlMTElfT0ZfU0VDT05EKSkge1xuICAgICAgdmFyIF9sb3MgPSB0aGlzLmZpZWxkVmFsdWVzLnJlbW92ZShDaHJvbm9GaWVsZC5NSUxMSV9PRl9TRUNPTkQpO1xuXG4gICAgICB0aGlzLl9wdXRGaWVsZFZhbHVlMChDaHJvbm9GaWVsZC5OQU5PX09GX1NFQ09ORCwgX2xvcyAqIDEwMDAwMDApO1xuICAgIH1cbiAgfTtcblxuICBfcHJvdG8uX3Jlc29sdmVUaW1lSW5mZXJaZXJvZXMgPSBmdW5jdGlvbiBfcmVzb2x2ZVRpbWVJbmZlclplcm9lcyhyZXNvbHZlclN0eWxlKSB7XG4gICAgdmFyIGhvZCA9IHRoaXMuZmllbGRWYWx1ZXMuZ2V0KENocm9ub0ZpZWxkLkhPVVJfT0ZfREFZKTtcbiAgICB2YXIgbW9oID0gdGhpcy5maWVsZFZhbHVlcy5nZXQoQ2hyb25vRmllbGQuTUlOVVRFX09GX0hPVVIpO1xuICAgIHZhciBzb20gPSB0aGlzLmZpZWxkVmFsdWVzLmdldChDaHJvbm9GaWVsZC5TRUNPTkRfT0ZfTUlOVVRFKTtcbiAgICB2YXIgbm9zID0gdGhpcy5maWVsZFZhbHVlcy5nZXQoQ2hyb25vRmllbGQuTkFOT19PRl9TRUNPTkQpO1xuXG4gICAgaWYgKGhvZCA9PSBudWxsKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKG1vaCA9PSBudWxsICYmIChzb20gIT0gbnVsbCB8fCBub3MgIT0gbnVsbCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAobW9oICE9IG51bGwgJiYgc29tID09IG51bGwgJiYgbm9zICE9IG51bGwpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAocmVzb2x2ZXJTdHlsZSAhPT0gUmVzb2x2ZXJTdHlsZS5MRU5JRU5UKSB7XG4gICAgICBpZiAoaG9kICE9IG51bGwpIHtcbiAgICAgICAgaWYgKHJlc29sdmVyU3R5bGUgPT09IFJlc29sdmVyU3R5bGUuU01BUlQgJiYgaG9kID09PSAyNCAmJiAobW9oID09IG51bGwgfHwgbW9oID09PSAwKSAmJiAoc29tID09IG51bGwgfHwgc29tID09PSAwKSAmJiAobm9zID09IG51bGwgfHwgbm9zID09PSAwKSkge1xuICAgICAgICAgIGhvZCA9IDA7XG4gICAgICAgICAgdGhpcy5leGNlc3NEYXlzID0gUGVyaW9kLm9mRGF5cygxKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBob2RWYWwgPSBDaHJvbm9GaWVsZC5IT1VSX09GX0RBWS5jaGVja1ZhbGlkSW50VmFsdWUoaG9kKTtcblxuICAgICAgICBpZiAobW9oICE9IG51bGwpIHtcbiAgICAgICAgICB2YXIgbW9oVmFsID0gQ2hyb25vRmllbGQuTUlOVVRFX09GX0hPVVIuY2hlY2tWYWxpZEludFZhbHVlKG1vaCk7XG5cbiAgICAgICAgICBpZiAoc29tICE9IG51bGwpIHtcbiAgICAgICAgICAgIHZhciBzb21WYWwgPSBDaHJvbm9GaWVsZC5TRUNPTkRfT0ZfTUlOVVRFLmNoZWNrVmFsaWRJbnRWYWx1ZShzb20pO1xuXG4gICAgICAgICAgICBpZiAobm9zICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgdmFyIG5vc1ZhbCA9IENocm9ub0ZpZWxkLk5BTk9fT0ZfU0VDT05ELmNoZWNrVmFsaWRJbnRWYWx1ZShub3MpO1xuXG4gICAgICAgICAgICAgIHRoaXMuX2FkZE9iamVjdChMb2NhbFRpbWUub2YoaG9kVmFsLCBtb2hWYWwsIHNvbVZhbCwgbm9zVmFsKSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICB0aGlzLl9hZGRPYmplY3QoTG9jYWxUaW1lLm9mKGhvZFZhbCwgbW9oVmFsLCBzb21WYWwpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKG5vcyA9PSBudWxsKSB7XG4gICAgICAgICAgICAgIHRoaXMuX2FkZE9iamVjdChMb2NhbFRpbWUub2YoaG9kVmFsLCBtb2hWYWwpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKHNvbSA9PSBudWxsICYmIG5vcyA9PSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLl9hZGRPYmplY3QoTG9jYWxUaW1lLm9mKGhvZFZhbCwgMCkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoaG9kICE9IG51bGwpIHtcbiAgICAgICAgdmFyIF9ob2RWYWwgPSBob2Q7XG5cbiAgICAgICAgaWYgKG1vaCAhPSBudWxsKSB7XG4gICAgICAgICAgaWYgKHNvbSAhPSBudWxsKSB7XG4gICAgICAgICAgICBpZiAobm9zID09IG51bGwpIHtcbiAgICAgICAgICAgICAgbm9zID0gMDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIHRvdGFsTmFub3MgPSBNYXRoVXRpbC5zYWZlTXVsdGlwbHkoX2hvZFZhbCwgMzYwMDAwMDAwMDAwMCk7XG4gICAgICAgICAgICB0b3RhbE5hbm9zID0gTWF0aFV0aWwuc2FmZUFkZCh0b3RhbE5hbm9zLCBNYXRoVXRpbC5zYWZlTXVsdGlwbHkobW9oLCA2MDAwMDAwMDAwMCkpO1xuICAgICAgICAgICAgdG90YWxOYW5vcyA9IE1hdGhVdGlsLnNhZmVBZGQodG90YWxOYW5vcywgTWF0aFV0aWwuc2FmZU11bHRpcGx5KHNvbSwgMTAwMDAwMDAwMCkpO1xuICAgICAgICAgICAgdG90YWxOYW5vcyA9IE1hdGhVdGlsLnNhZmVBZGQodG90YWxOYW5vcywgbm9zKTtcbiAgICAgICAgICAgIHZhciBleGNlc3NEYXlzID0gTWF0aFV0aWwuZmxvb3JEaXYodG90YWxOYW5vcywgODY0MDAwMDAwMDAwMDApO1xuICAgICAgICAgICAgdmFyIG5vZCA9IE1hdGhVdGlsLmZsb29yTW9kKHRvdGFsTmFub3MsIDg2NDAwMDAwMDAwMDAwKTtcblxuICAgICAgICAgICAgdGhpcy5fYWRkT2JqZWN0KExvY2FsVGltZS5vZk5hbm9PZkRheShub2QpKTtcblxuICAgICAgICAgICAgdGhpcy5leGNlc3NEYXlzID0gUGVyaW9kLm9mRGF5cyhleGNlc3NEYXlzKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFyIHRvdGFsU2VjcyA9IE1hdGhVdGlsLnNhZmVNdWx0aXBseShfaG9kVmFsLCAzNjAwKTtcbiAgICAgICAgICAgIHRvdGFsU2VjcyA9IE1hdGhVdGlsLnNhZmVBZGQodG90YWxTZWNzLCBNYXRoVXRpbC5zYWZlTXVsdGlwbHkobW9oLCA2MCkpO1xuXG4gICAgICAgICAgICB2YXIgX2V4Y2Vzc0RheXMgPSBNYXRoVXRpbC5mbG9vckRpdih0b3RhbFNlY3MsIDg2NDAwKTtcblxuICAgICAgICAgICAgdmFyIHNvZCA9IE1hdGhVdGlsLmZsb29yTW9kKHRvdGFsU2VjcywgODY0MDApO1xuXG4gICAgICAgICAgICB0aGlzLl9hZGRPYmplY3QoTG9jYWxUaW1lLm9mU2Vjb25kT2ZEYXkoc29kKSk7XG5cbiAgICAgICAgICAgIHRoaXMuZXhjZXNzRGF5cyA9IFBlcmlvZC5vZkRheXMoX2V4Y2Vzc0RheXMpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YXIgX2V4Y2Vzc0RheXMyID0gTWF0aFV0aWwuc2FmZVRvSW50KE1hdGhVdGlsLmZsb29yRGl2KF9ob2RWYWwsIDI0KSk7XG5cbiAgICAgICAgICBfaG9kVmFsID0gTWF0aFV0aWwuZmxvb3JNb2QoX2hvZFZhbCwgMjQpO1xuXG4gICAgICAgICAgdGhpcy5fYWRkT2JqZWN0KExvY2FsVGltZS5vZihfaG9kVmFsLCAwKSk7XG5cbiAgICAgICAgICB0aGlzLmV4Y2Vzc0RheXMgPSBQZXJpb2Qub2ZEYXlzKF9leGNlc3NEYXlzMik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLmZpZWxkVmFsdWVzLnJlbW92ZShDaHJvbm9GaWVsZC5IT1VSX09GX0RBWSk7XG4gICAgdGhpcy5maWVsZFZhbHVlcy5yZW1vdmUoQ2hyb25vRmllbGQuTUlOVVRFX09GX0hPVVIpO1xuICAgIHRoaXMuZmllbGRWYWx1ZXMucmVtb3ZlKENocm9ub0ZpZWxkLlNFQ09ORF9PRl9NSU5VVEUpO1xuICAgIHRoaXMuZmllbGRWYWx1ZXMucmVtb3ZlKENocm9ub0ZpZWxkLk5BTk9fT0ZfU0VDT05EKTtcbiAgfTtcblxuICBfcHJvdG8uX2FkZE9iamVjdCA9IGZ1bmN0aW9uIF9hZGRPYmplY3QoZGF0ZU9yVGltZSkge1xuICAgIGlmIChkYXRlT3JUaW1lIGluc3RhbmNlb2YgQ2hyb25vTG9jYWxEYXRlKSB7XG4gICAgICB0aGlzLmRhdGUgPSBkYXRlT3JUaW1lO1xuICAgIH0gZWxzZSBpZiAoZGF0ZU9yVGltZSBpbnN0YW5jZW9mIExvY2FsVGltZSkge1xuICAgICAgdGhpcy50aW1lID0gZGF0ZU9yVGltZTtcbiAgICB9XG4gIH07XG5cbiAgX3Byb3RvLl9yZXNvbHZlSW5zdGFudCA9IGZ1bmN0aW9uIF9yZXNvbHZlSW5zdGFudCgpIHtcbiAgICBpZiAodGhpcy5kYXRlICE9IG51bGwgJiYgdGhpcy50aW1lICE9IG51bGwpIHtcbiAgICAgIHZhciBvZmZzZXRTZWNzID0gdGhpcy5maWVsZFZhbHVlcy5nZXQoQ2hyb25vRmllbGQuT0ZGU0VUX1NFQ09ORFMpO1xuXG4gICAgICBpZiAob2Zmc2V0U2VjcyAhPSBudWxsKSB7XG4gICAgICAgIHZhciBvZmZzZXQgPSBab25lT2Zmc2V0Lm9mVG90YWxTZWNvbmRzKG9mZnNldFNlY3MpO1xuICAgICAgICB2YXIgaW5zdGFudCA9IHRoaXMuZGF0ZS5hdFRpbWUodGhpcy50aW1lKS5hdFpvbmUob2Zmc2V0KS5nZXRMb25nKENocm9ub0ZpZWxkLklOU1RBTlRfU0VDT05EUyk7XG4gICAgICAgIHRoaXMuZmllbGRWYWx1ZXMucHV0KENocm9ub0ZpZWxkLklOU1RBTlRfU0VDT05EUywgaW5zdGFudCk7XG4gICAgICB9IGVsc2UgaWYgKHRoaXMuem9uZSAhPSBudWxsKSB7XG4gICAgICAgIHZhciBfaW5zdGFudCA9IHRoaXMuZGF0ZS5hdFRpbWUodGhpcy50aW1lKS5hdFpvbmUodGhpcy56b25lKS5nZXRMb25nKENocm9ub0ZpZWxkLklOU1RBTlRfU0VDT05EUyk7XG5cbiAgICAgICAgdGhpcy5maWVsZFZhbHVlcy5wdXQoQ2hyb25vRmllbGQuSU5TVEFOVF9TRUNPTkRTLCBfaW5zdGFudCk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIF9wcm90by5idWlsZCA9IGZ1bmN0aW9uIGJ1aWxkKHR5cGUpIHtcbiAgICByZXR1cm4gdHlwZS5xdWVyeUZyb20odGhpcyk7XG4gIH07XG5cbiAgX3Byb3RvLmlzU3VwcG9ydGVkID0gZnVuY3Rpb24gaXNTdXBwb3J0ZWQoZmllbGQpIHtcbiAgICBpZiAoZmllbGQgPT0gbnVsbCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLmZpZWxkVmFsdWVzLmNvbnRhaW5zS2V5KGZpZWxkKSAmJiB0aGlzLmZpZWxkVmFsdWVzLmdldChmaWVsZCkgIT09IHVuZGVmaW5lZCB8fCB0aGlzLmRhdGUgIT0gbnVsbCAmJiB0aGlzLmRhdGUuaXNTdXBwb3J0ZWQoZmllbGQpIHx8IHRoaXMudGltZSAhPSBudWxsICYmIHRoaXMudGltZS5pc1N1cHBvcnRlZChmaWVsZCk7XG4gIH07XG5cbiAgX3Byb3RvLmdldExvbmcgPSBmdW5jdGlvbiBnZXRMb25nKGZpZWxkKSB7XG4gICAgcmVxdWlyZU5vbk51bGwoZmllbGQsICdmaWVsZCcpO1xuICAgIHZhciB2YWx1ZSA9IHRoaXMuZ2V0RmllbGRWYWx1ZTAoZmllbGQpO1xuXG4gICAgaWYgKHZhbHVlID09IG51bGwpIHtcbiAgICAgIGlmICh0aGlzLmRhdGUgIT0gbnVsbCAmJiB0aGlzLmRhdGUuaXNTdXBwb3J0ZWQoZmllbGQpKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRhdGUuZ2V0TG9uZyhmaWVsZCk7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLnRpbWUgIT0gbnVsbCAmJiB0aGlzLnRpbWUuaXNTdXBwb3J0ZWQoZmllbGQpKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRpbWUuZ2V0TG9uZyhmaWVsZCk7XG4gICAgICB9XG5cbiAgICAgIHRocm93IG5ldyBEYXRlVGltZUV4Y2VwdGlvbignRmllbGQgbm90IGZvdW5kOiAnICsgZmllbGQpO1xuICAgIH1cblxuICAgIHJldHVybiB2YWx1ZTtcbiAgfTtcblxuICBfcHJvdG8ucXVlcnkgPSBmdW5jdGlvbiBxdWVyeShfcXVlcnkpIHtcbiAgICBpZiAoX3F1ZXJ5ID09PSBUZW1wb3JhbFF1ZXJpZXMuem9uZUlkKCkpIHtcbiAgICAgIHJldHVybiB0aGlzLnpvbmU7XG4gICAgfSBlbHNlIGlmIChfcXVlcnkgPT09IFRlbXBvcmFsUXVlcmllcy5jaHJvbm9sb2d5KCkpIHtcbiAgICAgIHJldHVybiB0aGlzLmNocm9ubztcbiAgICB9IGVsc2UgaWYgKF9xdWVyeSA9PT0gVGVtcG9yYWxRdWVyaWVzLmxvY2FsRGF0ZSgpKSB7XG4gICAgICByZXR1cm4gdGhpcy5kYXRlICE9IG51bGwgPyBMb2NhbERhdGUuZnJvbSh0aGlzLmRhdGUpIDogbnVsbDtcbiAgICB9IGVsc2UgaWYgKF9xdWVyeSA9PT0gVGVtcG9yYWxRdWVyaWVzLmxvY2FsVGltZSgpKSB7XG4gICAgICByZXR1cm4gdGhpcy50aW1lO1xuICAgIH0gZWxzZSBpZiAoX3F1ZXJ5ID09PSBUZW1wb3JhbFF1ZXJpZXMuem9uZSgpIHx8IF9xdWVyeSA9PT0gVGVtcG9yYWxRdWVyaWVzLm9mZnNldCgpKSB7XG4gICAgICByZXR1cm4gX3F1ZXJ5LnF1ZXJ5RnJvbSh0aGlzKTtcbiAgICB9IGVsc2UgaWYgKF9xdWVyeSA9PT0gVGVtcG9yYWxRdWVyaWVzLnByZWNpc2lvbigpKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICByZXR1cm4gX3F1ZXJ5LnF1ZXJ5RnJvbSh0aGlzKTtcbiAgfTtcblxuICByZXR1cm4gRGF0ZVRpbWVCdWlsZGVyO1xufShUZW1wb3JhbEFjY2Vzc29yKTtcblxudmFyIERhdGVUaW1lUGFyc2VDb250ZXh0ID0gZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBEYXRlVGltZVBhcnNlQ29udGV4dCgpIHtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgaWYgKGFyZ3VtZW50c1swXSBpbnN0YW5jZW9mIERhdGVUaW1lUGFyc2VDb250ZXh0KSB7XG4gICAgICAgIHRoaXMuX2NvbnN0cnVjdG9yU2VsZi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXG4gICAgICAgIHJldHVybjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuX2NvbnN0cnVjdG9yRm9ybWF0dGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX2NvbnN0cnVjdG9yUGFyYW0uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG5cbiAgICB0aGlzLl9jYXNlU2Vuc2l0aXZlID0gdHJ1ZTtcbiAgICB0aGlzLl9zdHJpY3QgPSB0cnVlO1xuICAgIHRoaXMuX3BhcnNlZCA9IFtuZXcgUGFyc2VkKHRoaXMpXTtcbiAgfVxuXG4gIHZhciBfcHJvdG8gPSBEYXRlVGltZVBhcnNlQ29udGV4dC5wcm90b3R5cGU7XG5cbiAgX3Byb3RvLl9jb25zdHJ1Y3RvclBhcmFtID0gZnVuY3Rpb24gX2NvbnN0cnVjdG9yUGFyYW0obG9jYWxlLCBzeW1ib2xzLCBjaHJvbm9sb2d5KSB7XG4gICAgdGhpcy5fbG9jYWxlID0gbG9jYWxlO1xuICAgIHRoaXMuX3N5bWJvbHMgPSBzeW1ib2xzO1xuICAgIHRoaXMuX292ZXJyaWRlQ2hyb25vbG9neSA9IGNocm9ub2xvZ3k7XG4gIH07XG5cbiAgX3Byb3RvLl9jb25zdHJ1Y3RvckZvcm1hdHRlciA9IGZ1bmN0aW9uIF9jb25zdHJ1Y3RvckZvcm1hdHRlcihmb3JtYXR0ZXIpIHtcbiAgICB0aGlzLl9sb2NhbGUgPSBmb3JtYXR0ZXIubG9jYWxlKCk7XG4gICAgdGhpcy5fc3ltYm9scyA9IGZvcm1hdHRlci5kZWNpbWFsU3R5bGUoKTtcbiAgICB0aGlzLl9vdmVycmlkZUNocm9ub2xvZ3kgPSBmb3JtYXR0ZXIuY2hyb25vbG9neSgpO1xuICB9O1xuXG4gIF9wcm90by5fY29uc3RydWN0b3JTZWxmID0gZnVuY3Rpb24gX2NvbnN0cnVjdG9yU2VsZihvdGhlcikge1xuICAgIHRoaXMuX2xvY2FsZSA9IG90aGVyLl9sb2NhbGU7XG4gICAgdGhpcy5fc3ltYm9scyA9IG90aGVyLl9zeW1ib2xzO1xuICAgIHRoaXMuX292ZXJyaWRlQ2hyb25vbG9neSA9IG90aGVyLl9vdmVycmlkZUNocm9ub2xvZ3k7XG4gICAgdGhpcy5fb3ZlcnJpZGVab25lID0gb3RoZXIuX292ZXJyaWRlWm9uZTtcbiAgICB0aGlzLl9jYXNlU2Vuc2l0aXZlID0gb3RoZXIuX2Nhc2VTZW5zaXRpdmU7XG4gICAgdGhpcy5fc3RyaWN0ID0gb3RoZXIuX3N0cmljdDtcbiAgICB0aGlzLl9wYXJzZWQgPSBbbmV3IFBhcnNlZCh0aGlzKV07XG4gIH07XG5cbiAgX3Byb3RvLmNvcHkgPSBmdW5jdGlvbiBjb3B5KCkge1xuICAgIHJldHVybiBuZXcgRGF0ZVRpbWVQYXJzZUNvbnRleHQodGhpcyk7XG4gIH07XG5cbiAgX3Byb3RvLnN5bWJvbHMgPSBmdW5jdGlvbiBzeW1ib2xzKCkge1xuICAgIHJldHVybiB0aGlzLl9zeW1ib2xzO1xuICB9O1xuXG4gIF9wcm90by5pc1N0cmljdCA9IGZ1bmN0aW9uIGlzU3RyaWN0KCkge1xuICAgIHJldHVybiB0aGlzLl9zdHJpY3Q7XG4gIH07XG5cbiAgX3Byb3RvLnNldFN0cmljdCA9IGZ1bmN0aW9uIHNldFN0cmljdChzdHJpY3QpIHtcbiAgICB0aGlzLl9zdHJpY3QgPSBzdHJpY3Q7XG4gIH07XG5cbiAgX3Byb3RvLmxvY2FsZSA9IGZ1bmN0aW9uIGxvY2FsZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fbG9jYWxlO1xuICB9O1xuXG4gIF9wcm90by5zZXRMb2NhbGUgPSBmdW5jdGlvbiBzZXRMb2NhbGUobG9jYWxlKSB7XG4gICAgdGhpcy5fbG9jYWxlID0gbG9jYWxlO1xuICB9O1xuXG4gIF9wcm90by5zdGFydE9wdGlvbmFsID0gZnVuY3Rpb24gc3RhcnRPcHRpb25hbCgpIHtcbiAgICB0aGlzLl9wYXJzZWQucHVzaCh0aGlzLmN1cnJlbnRQYXJzZWQoKS5jb3B5KCkpO1xuICB9O1xuXG4gIF9wcm90by5lbmRPcHRpb25hbCA9IGZ1bmN0aW9uIGVuZE9wdGlvbmFsKHN1Y2Nlc3NmdWwpIHtcbiAgICBpZiAoc3VjY2Vzc2Z1bCkge1xuICAgICAgdGhpcy5fcGFyc2VkLnNwbGljZSh0aGlzLl9wYXJzZWQubGVuZ3RoIC0gMiwgMSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX3BhcnNlZC5zcGxpY2UodGhpcy5fcGFyc2VkLmxlbmd0aCAtIDEsIDEpO1xuICAgIH1cbiAgfTtcblxuICBfcHJvdG8uaXNDYXNlU2Vuc2l0aXZlID0gZnVuY3Rpb24gaXNDYXNlU2Vuc2l0aXZlKCkge1xuICAgIHJldHVybiB0aGlzLl9jYXNlU2Vuc2l0aXZlO1xuICB9O1xuXG4gIF9wcm90by5zZXRDYXNlU2Vuc2l0aXZlID0gZnVuY3Rpb24gc2V0Q2FzZVNlbnNpdGl2ZShjYXNlU2Vuc2l0aXZlKSB7XG4gICAgdGhpcy5fY2FzZVNlbnNpdGl2ZSA9IGNhc2VTZW5zaXRpdmU7XG4gIH07XG5cbiAgX3Byb3RvLnN1YlNlcXVlbmNlRXF1YWxzID0gZnVuY3Rpb24gc3ViU2VxdWVuY2VFcXVhbHMoY3MxLCBvZmZzZXQxLCBjczIsIG9mZnNldDIsIGxlbmd0aCkge1xuICAgIGlmIChvZmZzZXQxICsgbGVuZ3RoID4gY3MxLmxlbmd0aCB8fCBvZmZzZXQyICsgbGVuZ3RoID4gY3MyLmxlbmd0aCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGlmICghdGhpcy5pc0Nhc2VTZW5zaXRpdmUoKSkge1xuICAgICAgY3MxID0gY3MxLnRvTG93ZXJDYXNlKCk7XG4gICAgICBjczIgPSBjczIudG9Mb3dlckNhc2UoKTtcbiAgICB9XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgY2gxID0gY3MxW29mZnNldDEgKyBpXTtcbiAgICAgIHZhciBjaDIgPSBjczJbb2Zmc2V0MiArIGldO1xuXG4gICAgICBpZiAoY2gxICE9PSBjaDIpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0cnVlO1xuICB9O1xuXG4gIF9wcm90by5jaGFyRXF1YWxzID0gZnVuY3Rpb24gY2hhckVxdWFscyhjaDEsIGNoMikge1xuICAgIGlmICh0aGlzLmlzQ2FzZVNlbnNpdGl2ZSgpKSB7XG4gICAgICByZXR1cm4gY2gxID09PSBjaDI7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuY2hhckVxdWFsc0lnbm9yZUNhc2UoY2gxLCBjaDIpO1xuICB9O1xuXG4gIF9wcm90by5jaGFyRXF1YWxzSWdub3JlQ2FzZSA9IGZ1bmN0aW9uIGNoYXJFcXVhbHNJZ25vcmVDYXNlKGMxLCBjMikge1xuICAgIHJldHVybiBjMSA9PT0gYzIgfHwgYzEudG9Mb3dlckNhc2UoKSA9PT0gYzIudG9Mb3dlckNhc2UoKTtcbiAgfTtcblxuICBfcHJvdG8uc2V0UGFyc2VkRmllbGQgPSBmdW5jdGlvbiBzZXRQYXJzZWRGaWVsZChmaWVsZCwgdmFsdWUsIGVycm9yUG9zLCBzdWNjZXNzUG9zKSB7XG4gICAgdmFyIGN1cnJlbnRQYXJzZWRGaWVsZFZhbHVlcyA9IHRoaXMuY3VycmVudFBhcnNlZCgpLmZpZWxkVmFsdWVzO1xuICAgIHZhciBvbGQgPSBjdXJyZW50UGFyc2VkRmllbGRWYWx1ZXMuZ2V0KGZpZWxkKTtcbiAgICBjdXJyZW50UGFyc2VkRmllbGRWYWx1ZXMuc2V0KGZpZWxkLCB2YWx1ZSk7XG4gICAgcmV0dXJuIG9sZCAhPSBudWxsICYmIG9sZCAhPT0gdmFsdWUgPyB+ZXJyb3JQb3MgOiBzdWNjZXNzUG9zO1xuICB9O1xuXG4gIF9wcm90by5zZXRQYXJzZWRab25lID0gZnVuY3Rpb24gc2V0UGFyc2VkWm9uZSh6b25lKSB7XG4gICAgcmVxdWlyZU5vbk51bGwoem9uZSwgJ3pvbmUnKTtcbiAgICB0aGlzLmN1cnJlbnRQYXJzZWQoKS56b25lID0gem9uZTtcbiAgfTtcblxuICBfcHJvdG8uZ2V0UGFyc2VkID0gZnVuY3Rpb24gZ2V0UGFyc2VkKGZpZWxkKSB7XG4gICAgcmV0dXJuIHRoaXMuY3VycmVudFBhcnNlZCgpLmZpZWxkVmFsdWVzLmdldChmaWVsZCk7XG4gIH07XG5cbiAgX3Byb3RvLnRvUGFyc2VkID0gZnVuY3Rpb24gdG9QYXJzZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuY3VycmVudFBhcnNlZCgpO1xuICB9O1xuXG4gIF9wcm90by5jdXJyZW50UGFyc2VkID0gZnVuY3Rpb24gY3VycmVudFBhcnNlZCgpIHtcbiAgICByZXR1cm4gdGhpcy5fcGFyc2VkW3RoaXMuX3BhcnNlZC5sZW5ndGggLSAxXTtcbiAgfTtcblxuICBfcHJvdG8uc2V0UGFyc2VkTGVhcFNlY29uZCA9IGZ1bmN0aW9uIHNldFBhcnNlZExlYXBTZWNvbmQoKSB7XG4gICAgdGhpcy5jdXJyZW50UGFyc2VkKCkubGVhcFNlY29uZCA9IHRydWU7XG4gIH07XG5cbiAgX3Byb3RvLmdldEVmZmVjdGl2ZUNocm9ub2xvZ3kgPSBmdW5jdGlvbiBnZXRFZmZlY3RpdmVDaHJvbm9sb2d5KCkge1xuICAgIHZhciBjaHJvbm8gPSB0aGlzLmN1cnJlbnRQYXJzZWQoKS5jaHJvbm87XG5cbiAgICBpZiAoY2hyb25vID09IG51bGwpIHtcbiAgICAgIGNocm9ubyA9IHRoaXMuX292ZXJyaWRlQ2hyb25vbG9neTtcblxuICAgICAgaWYgKGNocm9ubyA9PSBudWxsKSB7XG4gICAgICAgIGNocm9ubyA9IElzb0Nocm9ub2xvZ3kuSU5TVEFOQ0U7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGNocm9ubztcbiAgfTtcblxuICByZXR1cm4gRGF0ZVRpbWVQYXJzZUNvbnRleHQ7XG59KCk7XG5cbnZhciBQYXJzZWQgPSBmdW5jdGlvbiAoX1RlbXBvcmFsKSB7XG4gIF9pbmhlcml0c0xvb3NlKFBhcnNlZCwgX1RlbXBvcmFsKTtcblxuICBmdW5jdGlvbiBQYXJzZWQoZGF0ZVRpbWVQYXJzZUNvbnRleHQpIHtcbiAgICB2YXIgX3RoaXM7XG5cbiAgICBfdGhpcyA9IF9UZW1wb3JhbC5jYWxsKHRoaXMpIHx8IHRoaXM7XG4gICAgX3RoaXMuY2hyb25vID0gbnVsbDtcbiAgICBfdGhpcy56b25lID0gbnVsbDtcbiAgICBfdGhpcy5maWVsZFZhbHVlcyA9IG5ldyBFbnVtTWFwKCk7XG4gICAgX3RoaXMubGVhcFNlY29uZCA9IGZhbHNlO1xuICAgIF90aGlzLmRhdGVUaW1lUGFyc2VDb250ZXh0ID0gZGF0ZVRpbWVQYXJzZUNvbnRleHQ7XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG5cbiAgdmFyIF9wcm90bzIgPSBQYXJzZWQucHJvdG90eXBlO1xuXG4gIF9wcm90bzIuY29weSA9IGZ1bmN0aW9uIGNvcHkoKSB7XG4gICAgdmFyIGNsb25lZCA9IG5ldyBQYXJzZWQoKTtcbiAgICBjbG9uZWQuY2hyb25vID0gdGhpcy5jaHJvbm87XG4gICAgY2xvbmVkLnpvbmUgPSB0aGlzLnpvbmU7XG4gICAgY2xvbmVkLmZpZWxkVmFsdWVzLnB1dEFsbCh0aGlzLmZpZWxkVmFsdWVzKTtcbiAgICBjbG9uZWQubGVhcFNlY29uZCA9IHRoaXMubGVhcFNlY29uZDtcbiAgICBjbG9uZWQuZGF0ZVRpbWVQYXJzZUNvbnRleHQgPSB0aGlzLmRhdGVUaW1lUGFyc2VDb250ZXh0O1xuICAgIHJldHVybiBjbG9uZWQ7XG4gIH07XG5cbiAgX3Byb3RvMi50b1N0cmluZyA9IGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuICAgIHJldHVybiB0aGlzLmZpZWxkVmFsdWVzICsgXCIsIFwiICsgdGhpcy5jaHJvbm8gKyBcIiwgXCIgKyB0aGlzLnpvbmU7XG4gIH07XG5cbiAgX3Byb3RvMi5pc1N1cHBvcnRlZCA9IGZ1bmN0aW9uIGlzU3VwcG9ydGVkKGZpZWxkKSB7XG4gICAgcmV0dXJuIHRoaXMuZmllbGRWYWx1ZXMuY29udGFpbnNLZXkoZmllbGQpO1xuICB9O1xuXG4gIF9wcm90bzIuZ2V0ID0gZnVuY3Rpb24gZ2V0KGZpZWxkKSB7XG4gICAgdmFyIHZhbCA9IHRoaXMuZmllbGRWYWx1ZXMuZ2V0KGZpZWxkKTtcbiAgICBhc3NlcnQodmFsICE9IG51bGwpO1xuICAgIHJldHVybiB2YWw7XG4gIH07XG5cbiAgX3Byb3RvMi5xdWVyeSA9IGZ1bmN0aW9uIHF1ZXJ5KF9xdWVyeSkge1xuICAgIGlmIChfcXVlcnkgPT09IFRlbXBvcmFsUXVlcmllcy5jaHJvbm9sb2d5KCkpIHtcbiAgICAgIHJldHVybiB0aGlzLmNocm9ubztcbiAgICB9XG5cbiAgICBpZiAoX3F1ZXJ5ID09PSBUZW1wb3JhbFF1ZXJpZXMuem9uZUlkKCkgfHwgX3F1ZXJ5ID09PSBUZW1wb3JhbFF1ZXJpZXMuem9uZSgpKSB7XG4gICAgICByZXR1cm4gdGhpcy56b25lO1xuICAgIH1cblxuICAgIHJldHVybiBfVGVtcG9yYWwucHJvdG90eXBlLnF1ZXJ5LmNhbGwodGhpcywgX3F1ZXJ5KTtcbiAgfTtcblxuICBfcHJvdG8yLnRvQnVpbGRlciA9IGZ1bmN0aW9uIHRvQnVpbGRlcigpIHtcbiAgICB2YXIgYnVpbGRlciA9IG5ldyBEYXRlVGltZUJ1aWxkZXIoKTtcbiAgICBidWlsZGVyLmZpZWxkVmFsdWVzLnB1dEFsbCh0aGlzLmZpZWxkVmFsdWVzKTtcbiAgICBidWlsZGVyLmNocm9ubyA9IHRoaXMuZGF0ZVRpbWVQYXJzZUNvbnRleHQuZ2V0RWZmZWN0aXZlQ2hyb25vbG9neSgpO1xuXG4gICAgaWYgKHRoaXMuem9uZSAhPSBudWxsKSB7XG4gICAgICBidWlsZGVyLnpvbmUgPSB0aGlzLnpvbmU7XG4gICAgfSBlbHNlIHtcbiAgICAgIGJ1aWxkZXIuem9uZSA9IHRoaXMub3ZlcnJpZGVab25lO1xuICAgIH1cblxuICAgIGJ1aWxkZXIubGVhcFNlY29uZCA9IHRoaXMubGVhcFNlY29uZDtcbiAgICBidWlsZGVyLmV4Y2Vzc0RheXMgPSB0aGlzLmV4Y2Vzc0RheXM7XG4gICAgcmV0dXJuIGJ1aWxkZXI7XG4gIH07XG5cbiAgcmV0dXJuIFBhcnNlZDtcbn0oVGVtcG9yYWwpO1xuXG4vKlxuICogQGNvcHlyaWdodCAoYykgMjAxNiwgUGhpbGlwcCBUaMO8cnfDpGNodGVyICYgUGF0dHJpY2sgSMO8cGVyXG4gKiBAY29weXJpZ2h0IChjKSAyMDA3LXByZXNlbnQsIFN0ZXBoZW4gQ29sZWJvdXJuZSAmIE1pY2hhZWwgTmFzY2ltZW50byBTYW50b3NcbiAqIEBsaWNlbnNlIEJTRC0zLUNsYXVzZSAoc2VlIExJQ0VOU0UgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUpXG4gKi9cbnZhciBEYXRlVGltZVByaW50Q29udGV4dCA9IGZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gRGF0ZVRpbWVQcmludENvbnRleHQodGVtcG9yYWwsIGxvY2FsZU9yRm9ybWF0dGVyLCBzeW1ib2xzKSB7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDIgJiYgYXJndW1lbnRzWzFdIGluc3RhbmNlb2YgRGF0ZVRpbWVGb3JtYXR0ZXIpIHtcbiAgICAgIHRoaXMuX3RlbXBvcmFsID0gRGF0ZVRpbWVQcmludENvbnRleHQuYWRqdXN0KHRlbXBvcmFsLCBsb2NhbGVPckZvcm1hdHRlcik7XG4gICAgICB0aGlzLl9sb2NhbGUgPSBsb2NhbGVPckZvcm1hdHRlci5sb2NhbGUoKTtcbiAgICAgIHRoaXMuX3N5bWJvbHMgPSBsb2NhbGVPckZvcm1hdHRlci5kZWNpbWFsU3R5bGUoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5fdGVtcG9yYWwgPSB0ZW1wb3JhbDtcbiAgICAgIHRoaXMuX2xvY2FsZSA9IGxvY2FsZU9yRm9ybWF0dGVyO1xuICAgICAgdGhpcy5fc3ltYm9scyA9IHN5bWJvbHM7XG4gICAgfVxuXG4gICAgdGhpcy5fb3B0aW9uYWwgPSAwO1xuICB9XG5cbiAgRGF0ZVRpbWVQcmludENvbnRleHQuYWRqdXN0ID0gZnVuY3Rpb24gYWRqdXN0KHRlbXBvcmFsLCBmb3JtYXR0ZXIpIHtcbiAgICByZXR1cm4gdGVtcG9yYWw7XG4gIH07XG5cbiAgdmFyIF9wcm90byA9IERhdGVUaW1lUHJpbnRDb250ZXh0LnByb3RvdHlwZTtcblxuICBfcHJvdG8uc3ltYm9scyA9IGZ1bmN0aW9uIHN5bWJvbHMoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3N5bWJvbHM7XG4gIH07XG5cbiAgX3Byb3RvLnN0YXJ0T3B0aW9uYWwgPSBmdW5jdGlvbiBzdGFydE9wdGlvbmFsKCkge1xuICAgIHRoaXMuX29wdGlvbmFsKys7XG4gIH07XG5cbiAgX3Byb3RvLmVuZE9wdGlvbmFsID0gZnVuY3Rpb24gZW5kT3B0aW9uYWwoKSB7XG4gICAgdGhpcy5fb3B0aW9uYWwtLTtcbiAgfTtcblxuICBfcHJvdG8uZ2V0VmFsdWVRdWVyeSA9IGZ1bmN0aW9uIGdldFZhbHVlUXVlcnkocXVlcnkpIHtcbiAgICB2YXIgcmVzdWx0ID0gdGhpcy5fdGVtcG9yYWwucXVlcnkocXVlcnkpO1xuXG4gICAgaWYgKHJlc3VsdCA9PSBudWxsICYmIHRoaXMuX29wdGlvbmFsID09PSAwKSB7XG4gICAgICB0aHJvdyBuZXcgRGF0ZVRpbWVFeGNlcHRpb24oJ1VuYWJsZSB0byBleHRyYWN0IHZhbHVlOiAnICsgdGhpcy5fdGVtcG9yYWwpO1xuICAgIH1cblxuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG5cbiAgX3Byb3RvLmdldFZhbHVlID0gZnVuY3Rpb24gZ2V0VmFsdWUoZmllbGQpIHtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIHRoaXMuX3RlbXBvcmFsLmdldExvbmcoZmllbGQpO1xuICAgIH0gY2F0Y2ggKGV4KSB7XG4gICAgICBpZiAoZXggaW5zdGFuY2VvZiBEYXRlVGltZUV4Y2VwdGlvbiAmJiB0aGlzLl9vcHRpb25hbCA+IDApIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG5cbiAgICAgIHRocm93IGV4O1xuICAgIH1cbiAgfTtcblxuICBfcHJvdG8udGVtcG9yYWwgPSBmdW5jdGlvbiB0ZW1wb3JhbCgpIHtcbiAgICByZXR1cm4gdGhpcy5fdGVtcG9yYWw7XG4gIH07XG5cbiAgX3Byb3RvLmxvY2FsZSA9IGZ1bmN0aW9uIGxvY2FsZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fbG9jYWxlO1xuICB9O1xuXG4gIF9wcm90by5zZXREYXRlVGltZSA9IGZ1bmN0aW9uIHNldERhdGVUaW1lKHRlbXBvcmFsKSB7XG4gICAgdGhpcy5fdGVtcG9yYWwgPSB0ZW1wb3JhbDtcbiAgfTtcblxuICBfcHJvdG8uc2V0TG9jYWxlID0gZnVuY3Rpb24gc2V0TG9jYWxlKGxvY2FsZSkge1xuICAgIHRoaXMuX2xvY2FsZSA9IGxvY2FsZTtcbiAgfTtcblxuICByZXR1cm4gRGF0ZVRpbWVQcmludENvbnRleHQ7XG59KCk7XG5cbnZhciBJc29GaWVsZHMgPSB7fTtcbnZhciBRVUFSVEVSX0RBWVMgPSBbMCwgOTAsIDE4MSwgMjczLCAwLCA5MSwgMTgyLCAyNzRdO1xuXG52YXIgRmllbGQgPSBmdW5jdGlvbiAoX1RlbXBvcmFsRmllbGQpIHtcbiAgX2luaGVyaXRzTG9vc2UoRmllbGQsIF9UZW1wb3JhbEZpZWxkKTtcblxuICBmdW5jdGlvbiBGaWVsZCgpIHtcbiAgICByZXR1cm4gX1RlbXBvcmFsRmllbGQuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICB9XG5cbiAgdmFyIF9wcm90byA9IEZpZWxkLnByb3RvdHlwZTtcblxuICBfcHJvdG8uaXNEYXRlQmFzZWQgPSBmdW5jdGlvbiBpc0RhdGVCYXNlZCgpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfTtcblxuICBfcHJvdG8uaXNUaW1lQmFzZWQgPSBmdW5jdGlvbiBpc1RpbWVCYXNlZCgpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH07XG5cbiAgX3Byb3RvLl9pc0lzbyA9IGZ1bmN0aW9uIF9pc0lzbygpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfTtcblxuICBGaWVsZC5fZ2V0V2Vla1JhbmdlQnlMb2NhbERhdGUgPSBmdW5jdGlvbiBfZ2V0V2Vla1JhbmdlQnlMb2NhbERhdGUoZGF0ZSkge1xuICAgIHZhciB3YnkgPSBGaWVsZC5fZ2V0V2Vla0Jhc2VkWWVhcihkYXRlKTtcblxuICAgIHJldHVybiBWYWx1ZVJhbmdlLm9mKDEsIEZpZWxkLl9nZXRXZWVrUmFuZ2VCeVllYXIod2J5KSk7XG4gIH07XG5cbiAgRmllbGQuX2dldFdlZWtSYW5nZUJ5WWVhciA9IGZ1bmN0aW9uIF9nZXRXZWVrUmFuZ2VCeVllYXIod2J5KSB7XG4gICAgdmFyIGRhdGUgPSBMb2NhbERhdGUub2Yod2J5LCAxLCAxKTtcblxuICAgIGlmIChkYXRlLmRheU9mV2VlaygpID09PSBEYXlPZldlZWsuVEhVUlNEQVkgfHwgZGF0ZS5kYXlPZldlZWsoKSA9PT0gRGF5T2ZXZWVrLldFRE5FU0RBWSAmJiBkYXRlLmlzTGVhcFllYXIoKSkge1xuICAgICAgcmV0dXJuIDUzO1xuICAgIH1cblxuICAgIHJldHVybiA1MjtcbiAgfTtcblxuICBGaWVsZC5fZ2V0V2VlayA9IGZ1bmN0aW9uIF9nZXRXZWVrKGRhdGUpIHtcbiAgICB2YXIgZG93MCA9IGRhdGUuZGF5T2ZXZWVrKCkub3JkaW5hbCgpO1xuICAgIHZhciBkb3kwID0gZGF0ZS5kYXlPZlllYXIoKSAtIDE7XG4gICAgdmFyIGRveVRodTAgPSBkb3kwICsgKDMgLSBkb3cwKTtcbiAgICB2YXIgYWxpZ25lZFdlZWsgPSBNYXRoVXRpbC5pbnREaXYoZG95VGh1MCwgNyk7XG4gICAgdmFyIGZpcnN0VGh1RG95MCA9IGRveVRodTAgLSBhbGlnbmVkV2VlayAqIDc7XG4gICAgdmFyIGZpcnN0TW9uRG95MCA9IGZpcnN0VGh1RG95MCAtIDM7XG5cbiAgICBpZiAoZmlyc3RNb25Eb3kwIDwgLTMpIHtcbiAgICAgIGZpcnN0TW9uRG95MCArPSA3O1xuICAgIH1cblxuICAgIGlmIChkb3kwIDwgZmlyc3RNb25Eb3kwKSB7XG4gICAgICByZXR1cm4gRmllbGQuX2dldFdlZWtSYW5nZUJ5TG9jYWxEYXRlKGRhdGUud2l0aERheU9mWWVhcigxODApLm1pbnVzWWVhcnMoMSkpLm1heGltdW0oKTtcbiAgICB9XG5cbiAgICB2YXIgd2VlayA9IE1hdGhVdGlsLmludERpdihkb3kwIC0gZmlyc3RNb25Eb3kwLCA3KSArIDE7XG5cbiAgICBpZiAod2VlayA9PT0gNTMpIHtcbiAgICAgIGlmICgoZmlyc3RNb25Eb3kwID09PSAtMyB8fCBmaXJzdE1vbkRveTAgPT09IC0yICYmIGRhdGUuaXNMZWFwWWVhcigpKSA9PT0gZmFsc2UpIHtcbiAgICAgICAgd2VlayA9IDE7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHdlZWs7XG4gIH07XG5cbiAgRmllbGQuX2dldFdlZWtCYXNlZFllYXIgPSBmdW5jdGlvbiBfZ2V0V2Vla0Jhc2VkWWVhcihkYXRlKSB7XG4gICAgdmFyIHllYXIgPSBkYXRlLnllYXIoKTtcbiAgICB2YXIgZG95ID0gZGF0ZS5kYXlPZlllYXIoKTtcblxuICAgIGlmIChkb3kgPD0gMykge1xuICAgICAgdmFyIGRvdyA9IGRhdGUuZGF5T2ZXZWVrKCkub3JkaW5hbCgpO1xuXG4gICAgICBpZiAoZG95IC0gZG93IDwgLTIpIHtcbiAgICAgICAgeWVhci0tO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoZG95ID49IDM2Mykge1xuICAgICAgdmFyIF9kb3cgPSBkYXRlLmRheU9mV2VlaygpLm9yZGluYWwoKTtcblxuICAgICAgZG95ID0gZG95IC0gMzYzIC0gKGRhdGUuaXNMZWFwWWVhcigpID8gMSA6IDApO1xuXG4gICAgICBpZiAoZG95IC0gX2RvdyA+PSAwKSB7XG4gICAgICAgIHllYXIrKztcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4geWVhcjtcbiAgfTtcblxuICBfcHJvdG8uZGlzcGxheU5hbWUgPSBmdW5jdGlvbiBkaXNwbGF5TmFtZSgpIHtcbiAgICByZXR1cm4gdGhpcy50b1N0cmluZygpO1xuICB9O1xuXG4gIF9wcm90by5yZXNvbHZlID0gZnVuY3Rpb24gcmVzb2x2ZSgpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfTtcblxuICBfcHJvdG8ubmFtZSA9IGZ1bmN0aW9uIG5hbWUoKSB7XG4gICAgcmV0dXJuIHRoaXMudG9TdHJpbmcoKTtcbiAgfTtcblxuICByZXR1cm4gRmllbGQ7XG59KFRlbXBvcmFsRmllbGQpO1xuXG52YXIgREFZX09GX1FVQVJURVJfRklFTEQgPSBmdW5jdGlvbiAoX0ZpZWxkKSB7XG4gIF9pbmhlcml0c0xvb3NlKERBWV9PRl9RVUFSVEVSX0ZJRUxELCBfRmllbGQpO1xuXG4gIGZ1bmN0aW9uIERBWV9PRl9RVUFSVEVSX0ZJRUxEKCkge1xuICAgIHJldHVybiBfRmllbGQuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICB9XG5cbiAgdmFyIF9wcm90bzIgPSBEQVlfT0ZfUVVBUlRFUl9GSUVMRC5wcm90b3R5cGU7XG5cbiAgX3Byb3RvMi50b1N0cmluZyA9IGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuICAgIHJldHVybiAnRGF5T2ZRdWFydGVyJztcbiAgfTtcblxuICBfcHJvdG8yLmJhc2VVbml0ID0gZnVuY3Rpb24gYmFzZVVuaXQoKSB7XG4gICAgcmV0dXJuIENocm9ub1VuaXQuREFZUztcbiAgfTtcblxuICBfcHJvdG8yLnJhbmdlVW5pdCA9IGZ1bmN0aW9uIHJhbmdlVW5pdCgpIHtcbiAgICByZXR1cm4gUVVBUlRFUl9ZRUFSUztcbiAgfTtcblxuICBfcHJvdG8yLnJhbmdlID0gZnVuY3Rpb24gcmFuZ2UoKSB7XG4gICAgcmV0dXJuIFZhbHVlUmFuZ2Uub2YoMSwgOTAsIDkyKTtcbiAgfTtcblxuICBfcHJvdG8yLmlzU3VwcG9ydGVkQnkgPSBmdW5jdGlvbiBpc1N1cHBvcnRlZEJ5KHRlbXBvcmFsKSB7XG4gICAgcmV0dXJuIHRlbXBvcmFsLmlzU3VwcG9ydGVkKENocm9ub0ZpZWxkLkRBWV9PRl9ZRUFSKSAmJiB0ZW1wb3JhbC5pc1N1cHBvcnRlZChDaHJvbm9GaWVsZC5NT05USF9PRl9ZRUFSKSAmJiB0ZW1wb3JhbC5pc1N1cHBvcnRlZChDaHJvbm9GaWVsZC5ZRUFSKSAmJiB0aGlzLl9pc0lzbyh0ZW1wb3JhbCk7XG4gIH07XG5cbiAgX3Byb3RvMi5yYW5nZVJlZmluZWRCeSA9IGZ1bmN0aW9uIHJhbmdlUmVmaW5lZEJ5KHRlbXBvcmFsKSB7XG4gICAgaWYgKHRlbXBvcmFsLmlzU3VwcG9ydGVkKHRoaXMpID09PSBmYWxzZSkge1xuICAgICAgdGhyb3cgbmV3IFVuc3VwcG9ydGVkVGVtcG9yYWxUeXBlRXhjZXB0aW9uKCdVbnN1cHBvcnRlZCBmaWVsZDogRGF5T2ZRdWFydGVyJyk7XG4gICAgfVxuXG4gICAgdmFyIHFveSA9IHRlbXBvcmFsLmdldExvbmcoUVVBUlRFUl9PRl9ZRUFSKTtcblxuICAgIGlmIChxb3kgPT09IDEpIHtcbiAgICAgIHZhciB5ZWFyID0gdGVtcG9yYWwuZ2V0TG9uZyhDaHJvbm9GaWVsZC5ZRUFSKTtcbiAgICAgIHJldHVybiBJc29DaHJvbm9sb2d5LmlzTGVhcFllYXIoeWVhcikgPyBWYWx1ZVJhbmdlLm9mKDEsIDkxKSA6IFZhbHVlUmFuZ2Uub2YoMSwgOTApO1xuICAgIH0gZWxzZSBpZiAocW95ID09PSAyKSB7XG4gICAgICByZXR1cm4gVmFsdWVSYW5nZS5vZigxLCA5MSk7XG4gICAgfSBlbHNlIGlmIChxb3kgPT09IDMgfHwgcW95ID09PSA0KSB7XG4gICAgICByZXR1cm4gVmFsdWVSYW5nZS5vZigxLCA5Mik7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMucmFuZ2UoKTtcbiAgfTtcblxuICBfcHJvdG8yLmdldEZyb20gPSBmdW5jdGlvbiBnZXRGcm9tKHRlbXBvcmFsKSB7XG4gICAgaWYgKHRlbXBvcmFsLmlzU3VwcG9ydGVkKHRoaXMpID09PSBmYWxzZSkge1xuICAgICAgdGhyb3cgbmV3IFVuc3VwcG9ydGVkVGVtcG9yYWxUeXBlRXhjZXB0aW9uKCdVbnN1cHBvcnRlZCBmaWVsZDogRGF5T2ZRdWFydGVyJyk7XG4gICAgfVxuXG4gICAgdmFyIGRveSA9IHRlbXBvcmFsLmdldChDaHJvbm9GaWVsZC5EQVlfT0ZfWUVBUik7XG4gICAgdmFyIG1veSA9IHRlbXBvcmFsLmdldChDaHJvbm9GaWVsZC5NT05USF9PRl9ZRUFSKTtcbiAgICB2YXIgeWVhciA9IHRlbXBvcmFsLmdldExvbmcoQ2hyb25vRmllbGQuWUVBUik7XG4gICAgcmV0dXJuIGRveSAtIFFVQVJURVJfREFZU1tNYXRoVXRpbC5pbnREaXYobW95IC0gMSwgMykgKyAoSXNvQ2hyb25vbG9neS5pc0xlYXBZZWFyKHllYXIpID8gNCA6IDApXTtcbiAgfTtcblxuICBfcHJvdG8yLmFkanVzdEludG8gPSBmdW5jdGlvbiBhZGp1c3RJbnRvKHRlbXBvcmFsLCBuZXdWYWx1ZSkge1xuICAgIHZhciBjdXJWYWx1ZSA9IHRoaXMuZ2V0RnJvbSh0ZW1wb3JhbCk7XG4gICAgdGhpcy5yYW5nZSgpLmNoZWNrVmFsaWRWYWx1ZShuZXdWYWx1ZSwgdGhpcyk7XG4gICAgcmV0dXJuIHRlbXBvcmFsLndpdGgoQ2hyb25vRmllbGQuREFZX09GX1lFQVIsIHRlbXBvcmFsLmdldExvbmcoQ2hyb25vRmllbGQuREFZX09GX1lFQVIpICsgKG5ld1ZhbHVlIC0gY3VyVmFsdWUpKTtcbiAgfTtcblxuICBfcHJvdG8yLnJlc29sdmUgPSBmdW5jdGlvbiByZXNvbHZlKGZpZWxkVmFsdWVzLCBwYXJ0aWFsVGVtcG9yYWwsIHJlc29sdmVyU3R5bGUpIHtcbiAgICB2YXIgeWVhckxvbmcgPSBmaWVsZFZhbHVlcy5nZXQoQ2hyb25vRmllbGQuWUVBUik7XG4gICAgdmFyIHFveUxvbmcgPSBmaWVsZFZhbHVlcy5nZXQoUVVBUlRFUl9PRl9ZRUFSKTtcblxuICAgIGlmICh5ZWFyTG9uZyA9PSBudWxsIHx8IHFveUxvbmcgPT0gbnVsbCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgdmFyIHkgPSBDaHJvbm9GaWVsZC5ZRUFSLmNoZWNrVmFsaWRJbnRWYWx1ZSh5ZWFyTG9uZyk7XG4gICAgdmFyIGRvcSA9IGZpZWxkVmFsdWVzLmdldChEQVlfT0ZfUVVBUlRFUik7XG4gICAgdmFyIGRhdGU7XG5cbiAgICBpZiAocmVzb2x2ZXJTdHlsZSA9PT0gUmVzb2x2ZXJTdHlsZS5MRU5JRU5UKSB7XG4gICAgICB2YXIgcW95ID0gcW95TG9uZztcbiAgICAgIGRhdGUgPSBMb2NhbERhdGUub2YoeSwgMSwgMSk7XG4gICAgICBkYXRlID0gZGF0ZS5wbHVzTW9udGhzKE1hdGhVdGlsLnNhZmVNdWx0aXBseShNYXRoVXRpbC5zYWZlU3VidHJhY3QocW95LCAxKSwgMykpO1xuICAgICAgZGF0ZSA9IGRhdGUucGx1c0RheXMoTWF0aFV0aWwuc2FmZVN1YnRyYWN0KGRvcSwgMSkpO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgX3FveSA9IFFVQVJURVJfT0ZfWUVBUi5yYW5nZSgpLmNoZWNrVmFsaWRJbnRWYWx1ZShxb3lMb25nLCBRVUFSVEVSX09GX1lFQVIpO1xuXG4gICAgICBpZiAocmVzb2x2ZXJTdHlsZSA9PT0gUmVzb2x2ZXJTdHlsZS5TVFJJQ1QpIHtcbiAgICAgICAgdmFyIG1heCA9IDkyO1xuXG4gICAgICAgIGlmIChfcW95ID09PSAxKSB7XG4gICAgICAgICAgbWF4ID0gSXNvQ2hyb25vbG9neS5pc0xlYXBZZWFyKHkpID8gOTEgOiA5MDtcbiAgICAgICAgfSBlbHNlIGlmIChfcW95ID09PSAyKSB7XG4gICAgICAgICAgbWF4ID0gOTE7XG4gICAgICAgIH1cblxuICAgICAgICBWYWx1ZVJhbmdlLm9mKDEsIG1heCkuY2hlY2tWYWxpZFZhbHVlKGRvcSwgdGhpcyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnJhbmdlKCkuY2hlY2tWYWxpZFZhbHVlKGRvcSwgdGhpcyk7XG4gICAgICB9XG5cbiAgICAgIGRhdGUgPSBMb2NhbERhdGUub2YoeSwgKF9xb3kgLSAxKSAqIDMgKyAxLCAxKS5wbHVzRGF5cyhkb3EgLSAxKTtcbiAgICB9XG5cbiAgICBmaWVsZFZhbHVlcy5yZW1vdmUodGhpcyk7XG4gICAgZmllbGRWYWx1ZXMucmVtb3ZlKENocm9ub0ZpZWxkLllFQVIpO1xuICAgIGZpZWxkVmFsdWVzLnJlbW92ZShRVUFSVEVSX09GX1lFQVIpO1xuICAgIHJldHVybiBkYXRlO1xuICB9O1xuXG4gIHJldHVybiBEQVlfT0ZfUVVBUlRFUl9GSUVMRDtcbn0oRmllbGQpO1xuXG52YXIgUVVBUlRFUl9PRl9ZRUFSX0ZJRUxEID0gZnVuY3Rpb24gKF9GaWVsZDIpIHtcbiAgX2luaGVyaXRzTG9vc2UoUVVBUlRFUl9PRl9ZRUFSX0ZJRUxELCBfRmllbGQyKTtcblxuICBmdW5jdGlvbiBRVUFSVEVSX09GX1lFQVJfRklFTEQoKSB7XG4gICAgcmV0dXJuIF9GaWVsZDIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICB9XG5cbiAgdmFyIF9wcm90bzMgPSBRVUFSVEVSX09GX1lFQVJfRklFTEQucHJvdG90eXBlO1xuXG4gIF9wcm90bzMudG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZygpIHtcbiAgICByZXR1cm4gJ1F1YXJ0ZXJPZlllYXInO1xuICB9O1xuXG4gIF9wcm90bzMuYmFzZVVuaXQgPSBmdW5jdGlvbiBiYXNlVW5pdCgpIHtcbiAgICByZXR1cm4gUVVBUlRFUl9ZRUFSUztcbiAgfTtcblxuICBfcHJvdG8zLnJhbmdlVW5pdCA9IGZ1bmN0aW9uIHJhbmdlVW5pdCgpIHtcbiAgICByZXR1cm4gQ2hyb25vVW5pdC5ZRUFSUztcbiAgfTtcblxuICBfcHJvdG8zLnJhbmdlID0gZnVuY3Rpb24gcmFuZ2UoKSB7XG4gICAgcmV0dXJuIFZhbHVlUmFuZ2Uub2YoMSwgNCk7XG4gIH07XG5cbiAgX3Byb3RvMy5pc1N1cHBvcnRlZEJ5ID0gZnVuY3Rpb24gaXNTdXBwb3J0ZWRCeSh0ZW1wb3JhbCkge1xuICAgIHJldHVybiB0ZW1wb3JhbC5pc1N1cHBvcnRlZChDaHJvbm9GaWVsZC5NT05USF9PRl9ZRUFSKSAmJiB0aGlzLl9pc0lzbyh0ZW1wb3JhbCk7XG4gIH07XG5cbiAgX3Byb3RvMy5yYW5nZVJlZmluZWRCeSA9IGZ1bmN0aW9uIHJhbmdlUmVmaW5lZEJ5KHRlbXBvcmFsKSB7XG4gICAgcmV0dXJuIHRoaXMucmFuZ2UoKTtcbiAgfTtcblxuICBfcHJvdG8zLmdldEZyb20gPSBmdW5jdGlvbiBnZXRGcm9tKHRlbXBvcmFsKSB7XG4gICAgaWYgKHRlbXBvcmFsLmlzU3VwcG9ydGVkKHRoaXMpID09PSBmYWxzZSkge1xuICAgICAgdGhyb3cgbmV3IFVuc3VwcG9ydGVkVGVtcG9yYWxUeXBlRXhjZXB0aW9uKCdVbnN1cHBvcnRlZCBmaWVsZDogUXVhcnRlck9mWWVhcicpO1xuICAgIH1cblxuICAgIHZhciBtb3kgPSB0ZW1wb3JhbC5nZXRMb25nKENocm9ub0ZpZWxkLk1PTlRIX09GX1lFQVIpO1xuICAgIHJldHVybiBNYXRoVXRpbC5pbnREaXYobW95ICsgMiwgMyk7XG4gIH07XG5cbiAgX3Byb3RvMy5hZGp1c3RJbnRvID0gZnVuY3Rpb24gYWRqdXN0SW50byh0ZW1wb3JhbCwgbmV3VmFsdWUpIHtcbiAgICB2YXIgY3VyVmFsdWUgPSB0aGlzLmdldEZyb20odGVtcG9yYWwpO1xuICAgIHRoaXMucmFuZ2UoKS5jaGVja1ZhbGlkVmFsdWUobmV3VmFsdWUsIHRoaXMpO1xuICAgIHJldHVybiB0ZW1wb3JhbC53aXRoKENocm9ub0ZpZWxkLk1PTlRIX09GX1lFQVIsIHRlbXBvcmFsLmdldExvbmcoQ2hyb25vRmllbGQuTU9OVEhfT0ZfWUVBUikgKyAobmV3VmFsdWUgLSBjdXJWYWx1ZSkgKiAzKTtcbiAgfTtcblxuICByZXR1cm4gUVVBUlRFUl9PRl9ZRUFSX0ZJRUxEO1xufShGaWVsZCk7XG5cbnZhciBXRUVLX09GX1dFRUtfQkFTRURfWUVBUl9GSUVMRCA9IGZ1bmN0aW9uIChfRmllbGQzKSB7XG4gIF9pbmhlcml0c0xvb3NlKFdFRUtfT0ZfV0VFS19CQVNFRF9ZRUFSX0ZJRUxELCBfRmllbGQzKTtcblxuICBmdW5jdGlvbiBXRUVLX09GX1dFRUtfQkFTRURfWUVBUl9GSUVMRCgpIHtcbiAgICByZXR1cm4gX0ZpZWxkMy5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gIH1cblxuICB2YXIgX3Byb3RvNCA9IFdFRUtfT0ZfV0VFS19CQVNFRF9ZRUFSX0ZJRUxELnByb3RvdHlwZTtcblxuICBfcHJvdG80LnRvU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG4gICAgcmV0dXJuICdXZWVrT2ZXZWVrQmFzZWRZZWFyJztcbiAgfTtcblxuICBfcHJvdG80LmJhc2VVbml0ID0gZnVuY3Rpb24gYmFzZVVuaXQoKSB7XG4gICAgcmV0dXJuIENocm9ub1VuaXQuV0VFS1M7XG4gIH07XG5cbiAgX3Byb3RvNC5yYW5nZVVuaXQgPSBmdW5jdGlvbiByYW5nZVVuaXQoKSB7XG4gICAgcmV0dXJuIFdFRUtfQkFTRURfWUVBUlM7XG4gIH07XG5cbiAgX3Byb3RvNC5yYW5nZSA9IGZ1bmN0aW9uIHJhbmdlKCkge1xuICAgIHJldHVybiBWYWx1ZVJhbmdlLm9mKDEsIDUyLCA1Myk7XG4gIH07XG5cbiAgX3Byb3RvNC5pc1N1cHBvcnRlZEJ5ID0gZnVuY3Rpb24gaXNTdXBwb3J0ZWRCeSh0ZW1wb3JhbCkge1xuICAgIHJldHVybiB0ZW1wb3JhbC5pc1N1cHBvcnRlZChDaHJvbm9GaWVsZC5FUE9DSF9EQVkpICYmIHRoaXMuX2lzSXNvKHRlbXBvcmFsKTtcbiAgfTtcblxuICBfcHJvdG80LnJhbmdlUmVmaW5lZEJ5ID0gZnVuY3Rpb24gcmFuZ2VSZWZpbmVkQnkodGVtcG9yYWwpIHtcbiAgICBpZiAodGVtcG9yYWwuaXNTdXBwb3J0ZWQodGhpcykgPT09IGZhbHNlKSB7XG4gICAgICB0aHJvdyBuZXcgVW5zdXBwb3J0ZWRUZW1wb3JhbFR5cGVFeGNlcHRpb24oJ1Vuc3VwcG9ydGVkIGZpZWxkOiBXZWVrT2ZXZWVrQmFzZWRZZWFyJyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIEZpZWxkLl9nZXRXZWVrUmFuZ2VCeUxvY2FsRGF0ZShMb2NhbERhdGUuZnJvbSh0ZW1wb3JhbCkpO1xuICB9O1xuXG4gIF9wcm90bzQuZ2V0RnJvbSA9IGZ1bmN0aW9uIGdldEZyb20odGVtcG9yYWwpIHtcbiAgICBpZiAodGVtcG9yYWwuaXNTdXBwb3J0ZWQodGhpcykgPT09IGZhbHNlKSB7XG4gICAgICB0aHJvdyBuZXcgVW5zdXBwb3J0ZWRUZW1wb3JhbFR5cGVFeGNlcHRpb24oJ1Vuc3VwcG9ydGVkIGZpZWxkOiBXZWVrT2ZXZWVrQmFzZWRZZWFyJyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIEZpZWxkLl9nZXRXZWVrKExvY2FsRGF0ZS5mcm9tKHRlbXBvcmFsKSk7XG4gIH07XG5cbiAgX3Byb3RvNC5hZGp1c3RJbnRvID0gZnVuY3Rpb24gYWRqdXN0SW50byh0ZW1wb3JhbCwgbmV3VmFsdWUpIHtcbiAgICB0aGlzLnJhbmdlKCkuY2hlY2tWYWxpZFZhbHVlKG5ld1ZhbHVlLCB0aGlzKTtcbiAgICByZXR1cm4gdGVtcG9yYWwucGx1cyhNYXRoVXRpbC5zYWZlU3VidHJhY3QobmV3VmFsdWUsIHRoaXMuZ2V0RnJvbSh0ZW1wb3JhbCkpLCBDaHJvbm9Vbml0LldFRUtTKTtcbiAgfTtcblxuICBfcHJvdG80LnJlc29sdmUgPSBmdW5jdGlvbiByZXNvbHZlKGZpZWxkVmFsdWVzLCBwYXJ0aWFsVGVtcG9yYWwsIHJlc29sdmVyU3R5bGUpIHtcbiAgICB2YXIgd2J5TG9uZyA9IGZpZWxkVmFsdWVzLmdldChXRUVLX0JBU0VEX1lFQVIpO1xuICAgIHZhciBkb3dMb25nID0gZmllbGRWYWx1ZXMuZ2V0KENocm9ub0ZpZWxkLkRBWV9PRl9XRUVLKTtcblxuICAgIGlmICh3YnlMb25nID09IG51bGwgfHwgZG93TG9uZyA9PSBudWxsKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICB2YXIgd2J5ID0gV0VFS19CQVNFRF9ZRUFSLnJhbmdlKCkuY2hlY2tWYWxpZEludFZhbHVlKHdieUxvbmcsIFdFRUtfQkFTRURfWUVBUik7XG4gICAgdmFyIHdvd2J5ID0gZmllbGRWYWx1ZXMuZ2V0KFdFRUtfT0ZfV0VFS19CQVNFRF9ZRUFSKTtcbiAgICB2YXIgZGF0ZTtcblxuICAgIGlmIChyZXNvbHZlclN0eWxlID09PSBSZXNvbHZlclN0eWxlLkxFTklFTlQpIHtcbiAgICAgIHZhciBkb3cgPSBkb3dMb25nO1xuICAgICAgdmFyIHdlZWtzID0gMDtcblxuICAgICAgaWYgKGRvdyA+IDcpIHtcbiAgICAgICAgd2Vla3MgPSBNYXRoVXRpbC5pbnREaXYoZG93IC0gMSwgNyk7XG4gICAgICAgIGRvdyA9IE1hdGhVdGlsLmludE1vZChkb3cgLSAxLCA3KSArIDE7XG4gICAgICB9IGVsc2UgaWYgKGRvdyA8IDEpIHtcbiAgICAgICAgd2Vla3MgPSBNYXRoVXRpbC5pbnREaXYoZG93LCA3KSAtIDE7XG4gICAgICAgIGRvdyA9IE1hdGhVdGlsLmludE1vZChkb3csIDcpICsgNztcbiAgICAgIH1cblxuICAgICAgZGF0ZSA9IExvY2FsRGF0ZS5vZih3YnksIDEsIDQpLnBsdXNXZWVrcyh3b3dieSAtIDEpLnBsdXNXZWVrcyh3ZWVrcykud2l0aChDaHJvbm9GaWVsZC5EQVlfT0ZfV0VFSywgZG93KTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIF9kb3cyID0gQ2hyb25vRmllbGQuREFZX09GX1dFRUsuY2hlY2tWYWxpZEludFZhbHVlKGRvd0xvbmcpO1xuXG4gICAgICBpZiAocmVzb2x2ZXJTdHlsZSA9PT0gUmVzb2x2ZXJTdHlsZS5TVFJJQ1QpIHtcbiAgICAgICAgdmFyIHRlbXAgPSBMb2NhbERhdGUub2Yod2J5LCAxLCA0KTtcblxuICAgICAgICB2YXIgcmFuZ2UgPSBGaWVsZC5fZ2V0V2Vla1JhbmdlQnlMb2NhbERhdGUodGVtcCk7XG5cbiAgICAgICAgcmFuZ2UuY2hlY2tWYWxpZFZhbHVlKHdvd2J5LCB0aGlzKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMucmFuZ2UoKS5jaGVja1ZhbGlkVmFsdWUod293YnksIHRoaXMpO1xuICAgICAgfVxuXG4gICAgICBkYXRlID0gTG9jYWxEYXRlLm9mKHdieSwgMSwgNCkucGx1c1dlZWtzKHdvd2J5IC0gMSkud2l0aChDaHJvbm9GaWVsZC5EQVlfT0ZfV0VFSywgX2RvdzIpO1xuICAgIH1cblxuICAgIGZpZWxkVmFsdWVzLnJlbW92ZSh0aGlzKTtcbiAgICBmaWVsZFZhbHVlcy5yZW1vdmUoV0VFS19CQVNFRF9ZRUFSKTtcbiAgICBmaWVsZFZhbHVlcy5yZW1vdmUoQ2hyb25vRmllbGQuREFZX09GX1dFRUspO1xuICAgIHJldHVybiBkYXRlO1xuICB9O1xuXG4gIF9wcm90bzQuZGlzcGxheU5hbWUgPSBmdW5jdGlvbiBkaXNwbGF5TmFtZSgpIHtcbiAgICByZXR1cm4gJ1dlZWsnO1xuICB9O1xuXG4gIHJldHVybiBXRUVLX09GX1dFRUtfQkFTRURfWUVBUl9GSUVMRDtcbn0oRmllbGQpO1xuXG52YXIgV0VFS19CQVNFRF9ZRUFSX0ZJRUxEID0gZnVuY3Rpb24gKF9GaWVsZDQpIHtcbiAgX2luaGVyaXRzTG9vc2UoV0VFS19CQVNFRF9ZRUFSX0ZJRUxELCBfRmllbGQ0KTtcblxuICBmdW5jdGlvbiBXRUVLX0JBU0VEX1lFQVJfRklFTEQoKSB7XG4gICAgcmV0dXJuIF9GaWVsZDQuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICB9XG5cbiAgdmFyIF9wcm90bzUgPSBXRUVLX0JBU0VEX1lFQVJfRklFTEQucHJvdG90eXBlO1xuXG4gIF9wcm90bzUudG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZygpIHtcbiAgICByZXR1cm4gJ1dlZWtCYXNlZFllYXInO1xuICB9O1xuXG4gIF9wcm90bzUuYmFzZVVuaXQgPSBmdW5jdGlvbiBiYXNlVW5pdCgpIHtcbiAgICByZXR1cm4gV0VFS19CQVNFRF9ZRUFSUztcbiAgfTtcblxuICBfcHJvdG81LnJhbmdlVW5pdCA9IGZ1bmN0aW9uIHJhbmdlVW5pdCgpIHtcbiAgICByZXR1cm4gQ2hyb25vVW5pdC5GT1JFVkVSO1xuICB9O1xuXG4gIF9wcm90bzUucmFuZ2UgPSBmdW5jdGlvbiByYW5nZSgpIHtcbiAgICByZXR1cm4gQ2hyb25vRmllbGQuWUVBUi5yYW5nZSgpO1xuICB9O1xuXG4gIF9wcm90bzUuaXNTdXBwb3J0ZWRCeSA9IGZ1bmN0aW9uIGlzU3VwcG9ydGVkQnkodGVtcG9yYWwpIHtcbiAgICByZXR1cm4gdGVtcG9yYWwuaXNTdXBwb3J0ZWQoQ2hyb25vRmllbGQuRVBPQ0hfREFZKSAmJiB0aGlzLl9pc0lzbyh0ZW1wb3JhbCk7XG4gIH07XG5cbiAgX3Byb3RvNS5yYW5nZVJlZmluZWRCeSA9IGZ1bmN0aW9uIHJhbmdlUmVmaW5lZEJ5KHRlbXBvcmFsKSB7XG4gICAgcmV0dXJuIENocm9ub0ZpZWxkLllFQVIucmFuZ2UoKTtcbiAgfTtcblxuICBfcHJvdG81LmdldEZyb20gPSBmdW5jdGlvbiBnZXRGcm9tKHRlbXBvcmFsKSB7XG4gICAgaWYgKHRlbXBvcmFsLmlzU3VwcG9ydGVkKHRoaXMpID09PSBmYWxzZSkge1xuICAgICAgdGhyb3cgbmV3IFVuc3VwcG9ydGVkVGVtcG9yYWxUeXBlRXhjZXB0aW9uKCdVbnN1cHBvcnRlZCBmaWVsZDogV2Vla0Jhc2VkWWVhcicpO1xuICAgIH1cblxuICAgIHJldHVybiBGaWVsZC5fZ2V0V2Vla0Jhc2VkWWVhcihMb2NhbERhdGUuZnJvbSh0ZW1wb3JhbCkpO1xuICB9O1xuXG4gIF9wcm90bzUuYWRqdXN0SW50byA9IGZ1bmN0aW9uIGFkanVzdEludG8odGVtcG9yYWwsIG5ld1ZhbHVlKSB7XG4gICAgaWYgKHRoaXMuaXNTdXBwb3J0ZWRCeSh0ZW1wb3JhbCkgPT09IGZhbHNlKSB7XG4gICAgICB0aHJvdyBuZXcgVW5zdXBwb3J0ZWRUZW1wb3JhbFR5cGVFeGNlcHRpb24oJ1Vuc3VwcG9ydGVkIGZpZWxkOiBXZWVrQmFzZWRZZWFyJyk7XG4gICAgfVxuXG4gICAgdmFyIG5ld1dieSA9IHRoaXMucmFuZ2UoKS5jaGVja1ZhbGlkSW50VmFsdWUobmV3VmFsdWUsIFdFRUtfQkFTRURfWUVBUik7XG4gICAgdmFyIGRhdGUgPSBMb2NhbERhdGUuZnJvbSh0ZW1wb3JhbCk7XG4gICAgdmFyIGRvdyA9IGRhdGUuZ2V0KENocm9ub0ZpZWxkLkRBWV9PRl9XRUVLKTtcblxuICAgIHZhciB3ZWVrID0gRmllbGQuX2dldFdlZWsoZGF0ZSk7XG5cbiAgICBpZiAod2VlayA9PT0gNTMgJiYgRmllbGQuX2dldFdlZWtSYW5nZUJ5WWVhcihuZXdXYnkpID09PSA1Mikge1xuICAgICAgd2VlayA9IDUyO1xuICAgIH1cblxuICAgIHZhciByZXNvbHZlZCA9IExvY2FsRGF0ZS5vZihuZXdXYnksIDEsIDQpO1xuICAgIHZhciBkYXlzID0gZG93IC0gcmVzb2x2ZWQuZ2V0KENocm9ub0ZpZWxkLkRBWV9PRl9XRUVLKSArICh3ZWVrIC0gMSkgKiA3O1xuICAgIHJlc29sdmVkID0gcmVzb2x2ZWQucGx1c0RheXMoZGF5cyk7XG4gICAgcmV0dXJuIHRlbXBvcmFsLndpdGgocmVzb2x2ZWQpO1xuICB9O1xuXG4gIHJldHVybiBXRUVLX0JBU0VEX1lFQVJfRklFTEQ7XG59KEZpZWxkKTtcblxudmFyIFVuaXQgPSBmdW5jdGlvbiAoX1RlbXBvcmFsVW5pdCkge1xuICBfaW5oZXJpdHNMb29zZShVbml0LCBfVGVtcG9yYWxVbml0KTtcblxuICBmdW5jdGlvbiBVbml0KG5hbWUsIGVzdGltYXRlZER1cmF0aW9uKSB7XG4gICAgdmFyIF90aGlzO1xuXG4gICAgX3RoaXMgPSBfVGVtcG9yYWxVbml0LmNhbGwodGhpcykgfHwgdGhpcztcbiAgICBfdGhpcy5fbmFtZSA9IG5hbWU7XG4gICAgX3RoaXMuX2R1cmF0aW9uID0gZXN0aW1hdGVkRHVyYXRpb247XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG5cbiAgdmFyIF9wcm90bzYgPSBVbml0LnByb3RvdHlwZTtcblxuICBfcHJvdG82LmR1cmF0aW9uID0gZnVuY3Rpb24gZHVyYXRpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuX2R1cmF0aW9uO1xuICB9O1xuXG4gIF9wcm90bzYuaXNEdXJhdGlvbkVzdGltYXRlZCA9IGZ1bmN0aW9uIGlzRHVyYXRpb25Fc3RpbWF0ZWQoKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH07XG5cbiAgX3Byb3RvNi5pc0RhdGVCYXNlZCA9IGZ1bmN0aW9uIGlzRGF0ZUJhc2VkKCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9O1xuXG4gIF9wcm90bzYuaXNUaW1lQmFzZWQgPSBmdW5jdGlvbiBpc1RpbWVCYXNlZCgpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH07XG5cbiAgX3Byb3RvNi5pc1N1cHBvcnRlZEJ5ID0gZnVuY3Rpb24gaXNTdXBwb3J0ZWRCeSh0ZW1wb3JhbCkge1xuICAgIHJldHVybiB0ZW1wb3JhbC5pc1N1cHBvcnRlZChDaHJvbm9GaWVsZC5FUE9DSF9EQVkpO1xuICB9O1xuXG4gIF9wcm90bzYuYWRkVG8gPSBmdW5jdGlvbiBhZGRUbyh0ZW1wb3JhbCwgcGVyaW9kVG9BZGQpIHtcbiAgICBzd2l0Y2ggKHRoaXMpIHtcbiAgICAgIGNhc2UgV0VFS19CQVNFRF9ZRUFSUzpcbiAgICAgICAge1xuICAgICAgICAgIHZhciBhZGRlZCA9IE1hdGhVdGlsLnNhZmVBZGQodGVtcG9yYWwuZ2V0KFdFRUtfQkFTRURfWUVBUiksIHBlcmlvZFRvQWRkKTtcbiAgICAgICAgICByZXR1cm4gdGVtcG9yYWwud2l0aChXRUVLX0JBU0VEX1lFQVIsIGFkZGVkKTtcbiAgICAgICAgfVxuXG4gICAgICBjYXNlIFFVQVJURVJfWUVBUlM6XG4gICAgICAgIHJldHVybiB0ZW1wb3JhbC5wbHVzKE1hdGhVdGlsLmludERpdihwZXJpb2RUb0FkZCwgMjU2KSwgQ2hyb25vVW5pdC5ZRUFSUykucGx1cyhNYXRoVXRpbC5pbnRNb2QocGVyaW9kVG9BZGQsIDI1NikgKiAzLCBDaHJvbm9Vbml0Lk1PTlRIUyk7XG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHRocm93IG5ldyBJbGxlZ2FsU3RhdGVFeGNlcHRpb24oJ1VucmVhY2hhYmxlJyk7XG4gICAgfVxuICB9O1xuXG4gIF9wcm90bzYuYmV0d2VlbiA9IGZ1bmN0aW9uIGJldHdlZW4odGVtcG9yYWwxLCB0ZW1wb3JhbDIpIHtcbiAgICBzd2l0Y2ggKHRoaXMpIHtcbiAgICAgIGNhc2UgV0VFS19CQVNFRF9ZRUFSUzpcbiAgICAgICAgcmV0dXJuIE1hdGhVdGlsLnNhZmVTdWJ0cmFjdCh0ZW1wb3JhbDIuZ2V0TG9uZyhXRUVLX0JBU0VEX1lFQVIpLCB0ZW1wb3JhbDEuZ2V0TG9uZyhXRUVLX0JBU0VEX1lFQVIpKTtcblxuICAgICAgY2FzZSBRVUFSVEVSX1lFQVJTOlxuICAgICAgICByZXR1cm4gTWF0aFV0aWwuaW50RGl2KHRlbXBvcmFsMS51bnRpbCh0ZW1wb3JhbDIsIENocm9ub1VuaXQuTU9OVEhTKSwgMyk7XG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHRocm93IG5ldyBJbGxlZ2FsU3RhdGVFeGNlcHRpb24oJ1VucmVhY2hhYmxlJyk7XG4gICAgfVxuICB9O1xuXG4gIF9wcm90bzYudG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZygpIHtcbiAgICByZXR1cm4gbmFtZTtcbiAgfTtcblxuICByZXR1cm4gVW5pdDtcbn0oVGVtcG9yYWxVbml0KTtcblxudmFyIERBWV9PRl9RVUFSVEVSID0gbnVsbDtcbnZhciBRVUFSVEVSX09GX1lFQVIgPSBudWxsO1xudmFyIFdFRUtfT0ZfV0VFS19CQVNFRF9ZRUFSID0gbnVsbDtcbnZhciBXRUVLX0JBU0VEX1lFQVIgPSBudWxsO1xudmFyIFdFRUtfQkFTRURfWUVBUlMgPSBudWxsO1xudmFyIFFVQVJURVJfWUVBUlMgPSBudWxsO1xuZnVuY3Rpb24gX2luaXQkOCgpIHtcbiAgREFZX09GX1FVQVJURVIgPSBuZXcgREFZX09GX1FVQVJURVJfRklFTEQoKTtcbiAgUVVBUlRFUl9PRl9ZRUFSID0gbmV3IFFVQVJURVJfT0ZfWUVBUl9GSUVMRCgpO1xuICBXRUVLX09GX1dFRUtfQkFTRURfWUVBUiA9IG5ldyBXRUVLX09GX1dFRUtfQkFTRURfWUVBUl9GSUVMRCgpO1xuICBXRUVLX0JBU0VEX1lFQVIgPSBuZXcgV0VFS19CQVNFRF9ZRUFSX0ZJRUxEKCk7XG4gIFdFRUtfQkFTRURfWUVBUlMgPSBuZXcgVW5pdCgnV2Vla0Jhc2VkWWVhcnMnLCBEdXJhdGlvbi5vZlNlY29uZHMoMzE1NTY5NTIpKTtcbiAgUVVBUlRFUl9ZRUFSUyA9IG5ldyBVbml0KCdRdWFydGVyWWVhcnMnLCBEdXJhdGlvbi5vZlNlY29uZHMoMzE1NTY5NTIgLyA0KSk7XG4gIElzb0ZpZWxkcy5EQVlfT0ZfUVVBUlRFUiA9IERBWV9PRl9RVUFSVEVSO1xuICBJc29GaWVsZHMuUVVBUlRFUl9PRl9ZRUFSID0gUVVBUlRFUl9PRl9ZRUFSO1xuICBJc29GaWVsZHMuV0VFS19PRl9XRUVLX0JBU0VEX1lFQVIgPSBXRUVLX09GX1dFRUtfQkFTRURfWUVBUjtcbiAgSXNvRmllbGRzLldFRUtfQkFTRURfWUVBUiA9IFdFRUtfQkFTRURfWUVBUjtcbiAgSXNvRmllbGRzLldFRUtfQkFTRURfWUVBUlMgPSBXRUVLX0JBU0VEX1lFQVJTO1xuICBJc29GaWVsZHMuUVVBUlRFUl9ZRUFSUyA9IFFVQVJURVJfWUVBUlM7XG5cbiAgTG9jYWxEYXRlLnByb3RvdHlwZS5pc29XZWVrT2ZXZWVreWVhciA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5nZXQoSXNvRmllbGRzLldFRUtfT0ZfV0VFS19CQVNFRF9ZRUFSKTtcbiAgfTtcblxuICBMb2NhbERhdGUucHJvdG90eXBlLmlzb1dlZWt5ZWFyID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLmdldChJc29GaWVsZHMuV0VFS19CQVNFRF9ZRUFSKTtcbiAgfTtcbn1cblxuLyoqXG4gKiBAY29weXJpZ2h0IChjKSAyMDE2LCBQaGlsaXBwIFRow7xyd8OkY2h0ZXIgJiBQYXR0cmljayBIw7xwZXJcbiAqIEBjb3B5cmlnaHQgKGMpIDIwMDctcHJlc2VudCwgU3RlcGhlbiBDb2xlYm91cm5lICYgTWljaGFlbCBOYXNjaW1lbnRvIFNhbnRvc1xuICogQGxpY2Vuc2UgQlNELTMtQ2xhdXNlIChzZWUgTElDRU5TRSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZSlcbiAqL1xudmFyIERlY2ltYWxTdHlsZSA9IGZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gRGVjaW1hbFN0eWxlKHplcm9DaGFyLCBwb3NpdGl2ZVNpZ25DaGFyLCBuZWdhdGl2ZVNpZ25DaGFyLCBkZWNpbWFsUG9pbnRDaGFyKSB7XG4gICAgdGhpcy5femVyb0RpZ2l0ID0gemVyb0NoYXI7XG4gICAgdGhpcy5femVyb0RpZ2l0Q2hhckNvZGUgPSB6ZXJvQ2hhci5jaGFyQ29kZUF0KDApO1xuICAgIHRoaXMuX3Bvc2l0aXZlU2lnbiA9IHBvc2l0aXZlU2lnbkNoYXI7XG4gICAgdGhpcy5fbmVnYXRpdmVTaWduID0gbmVnYXRpdmVTaWduQ2hhcjtcbiAgICB0aGlzLl9kZWNpbWFsU2VwYXJhdG9yID0gZGVjaW1hbFBvaW50Q2hhcjtcbiAgfVxuXG4gIHZhciBfcHJvdG8gPSBEZWNpbWFsU3R5bGUucHJvdG90eXBlO1xuXG4gIF9wcm90by5wb3NpdGl2ZVNpZ24gPSBmdW5jdGlvbiBwb3NpdGl2ZVNpZ24oKSB7XG4gICAgcmV0dXJuIHRoaXMuX3Bvc2l0aXZlU2lnbjtcbiAgfTtcblxuICBfcHJvdG8ud2l0aFBvc2l0aXZlU2lnbiA9IGZ1bmN0aW9uIHdpdGhQb3NpdGl2ZVNpZ24ocG9zaXRpdmVTaWduKSB7XG4gICAgaWYgKHBvc2l0aXZlU2lnbiA9PT0gdGhpcy5fcG9zaXRpdmVTaWduKSB7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICByZXR1cm4gbmV3IERlY2ltYWxTdHlsZSh0aGlzLl96ZXJvRGlnaXQsIHBvc2l0aXZlU2lnbiwgdGhpcy5fbmVnYXRpdmVTaWduLCB0aGlzLl9kZWNpbWFsU2VwYXJhdG9yKTtcbiAgfTtcblxuICBfcHJvdG8ubmVnYXRpdmVTaWduID0gZnVuY3Rpb24gbmVnYXRpdmVTaWduKCkge1xuICAgIHJldHVybiB0aGlzLl9uZWdhdGl2ZVNpZ247XG4gIH07XG5cbiAgX3Byb3RvLndpdGhOZWdhdGl2ZVNpZ24gPSBmdW5jdGlvbiB3aXRoTmVnYXRpdmVTaWduKG5lZ2F0aXZlU2lnbikge1xuICAgIGlmIChuZWdhdGl2ZVNpZ24gPT09IHRoaXMuX25lZ2F0aXZlU2lnbikge1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgcmV0dXJuIG5ldyBEZWNpbWFsU3R5bGUodGhpcy5femVyb0RpZ2l0LCB0aGlzLl9wb3NpdGl2ZVNpZ24sIG5lZ2F0aXZlU2lnbiwgdGhpcy5fZGVjaW1hbFNlcGFyYXRvcik7XG4gIH07XG5cbiAgX3Byb3RvLnplcm9EaWdpdCA9IGZ1bmN0aW9uIHplcm9EaWdpdCgpIHtcbiAgICByZXR1cm4gdGhpcy5femVyb0RpZ2l0O1xuICB9O1xuXG4gIF9wcm90by53aXRoWmVyb0RpZ2l0ID0gZnVuY3Rpb24gd2l0aFplcm9EaWdpdCh6ZXJvRGlnaXQpIHtcbiAgICBpZiAoemVyb0RpZ2l0ID09PSB0aGlzLl96ZXJvRGlnaXQpIHtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIHJldHVybiBuZXcgRGVjaW1hbFN0eWxlKHplcm9EaWdpdCwgdGhpcy5fcG9zaXRpdmVTaWduLCB0aGlzLl9uZWdhdGl2ZVNpZ24sIHRoaXMuX2RlY2ltYWxTZXBhcmF0b3IpO1xuICB9O1xuXG4gIF9wcm90by5kZWNpbWFsU2VwYXJhdG9yID0gZnVuY3Rpb24gZGVjaW1hbFNlcGFyYXRvcigpIHtcbiAgICByZXR1cm4gdGhpcy5fZGVjaW1hbFNlcGFyYXRvcjtcbiAgfTtcblxuICBfcHJvdG8ud2l0aERlY2ltYWxTZXBhcmF0b3IgPSBmdW5jdGlvbiB3aXRoRGVjaW1hbFNlcGFyYXRvcihkZWNpbWFsU2VwYXJhdG9yKSB7XG4gICAgaWYgKGRlY2ltYWxTZXBhcmF0b3IgPT09IHRoaXMuX2RlY2ltYWxTZXBhcmF0b3IpIHtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIHJldHVybiBuZXcgRGVjaW1hbFN0eWxlKHRoaXMuX3plcm9EaWdpdCwgdGhpcy5fcG9zaXRpdmVTaWduLCB0aGlzLl9uZWdhdGl2ZVNpZ24sIGRlY2ltYWxTZXBhcmF0b3IpO1xuICB9O1xuXG4gIF9wcm90by5jb252ZXJ0VG9EaWdpdCA9IGZ1bmN0aW9uIGNvbnZlcnRUb0RpZ2l0KGNoYXIpIHtcbiAgICB2YXIgdmFsID0gY2hhci5jaGFyQ29kZUF0KDApIC0gdGhpcy5femVyb0RpZ2l0Q2hhckNvZGU7XG5cbiAgICByZXR1cm4gdmFsID49IDAgJiYgdmFsIDw9IDkgPyB2YWwgOiAtMTtcbiAgfTtcblxuICBfcHJvdG8uY29udmVydE51bWJlclRvSTE4TiA9IGZ1bmN0aW9uIGNvbnZlcnROdW1iZXJUb0kxOE4obnVtZXJpY1RleHQpIHtcbiAgICBpZiAodGhpcy5femVyb0RpZ2l0ID09PSAnMCcpIHtcbiAgICAgIHJldHVybiBudW1lcmljVGV4dDtcbiAgICB9XG5cbiAgICB2YXIgZGlmZiA9IHRoaXMuX3plcm9EaWdpdENoYXJDb2RlIC0gJzAnLmNoYXJDb2RlQXQoMCk7XG4gICAgdmFyIGNvbnZlcnRlZFRleHQgPSAnJztcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbnVtZXJpY1RleHQubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnZlcnRlZFRleHQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShudW1lcmljVGV4dC5jaGFyQ29kZUF0KGkpICsgZGlmZik7XG4gICAgfVxuXG4gICAgcmV0dXJuIGNvbnZlcnRlZFRleHQ7XG4gIH07XG5cbiAgX3Byb3RvLmVxdWFscyA9IGZ1bmN0aW9uIGVxdWFscyhvdGhlcikge1xuICAgIGlmICh0aGlzID09PSBvdGhlcikge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgaWYgKG90aGVyIGluc3RhbmNlb2YgRGVjaW1hbFN0eWxlKSB7XG4gICAgICByZXR1cm4gdGhpcy5femVyb0RpZ2l0ID09PSBvdGhlci5femVyb0RpZ2l0ICYmIHRoaXMuX3Bvc2l0aXZlU2lnbiA9PT0gb3RoZXIuX3Bvc2l0aXZlU2lnbiAmJiB0aGlzLl9uZWdhdGl2ZVNpZ24gPT09IG90aGVyLl9uZWdhdGl2ZVNpZ24gJiYgdGhpcy5fZGVjaW1hbFNlcGFyYXRvciA9PT0gb3RoZXIuX2RlY2ltYWxTZXBhcmF0b3I7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9O1xuXG4gIF9wcm90by5oYXNoQ29kZSA9IGZ1bmN0aW9uIGhhc2hDb2RlKCkge1xuICAgIHJldHVybiB0aGlzLl96ZXJvRGlnaXQgKyB0aGlzLl9wb3NpdGl2ZVNpZ24gKyB0aGlzLl9uZWdhdGl2ZVNpZ24gKyB0aGlzLl9kZWNpbWFsU2VwYXJhdG9yO1xuICB9O1xuXG4gIF9wcm90by50b1N0cmluZyA9IGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuICAgIHJldHVybiAnRGVjaW1hbFN0eWxlWycgKyB0aGlzLl96ZXJvRGlnaXQgKyB0aGlzLl9wb3NpdGl2ZVNpZ24gKyB0aGlzLl9uZWdhdGl2ZVNpZ24gKyB0aGlzLl9kZWNpbWFsU2VwYXJhdG9yICsgJ10nO1xuICB9O1xuXG4gIERlY2ltYWxTdHlsZS5vZiA9IGZ1bmN0aW9uIG9mKCkge1xuICAgIHRocm93IG5ldyBFcnJvcignbm90IHlldCBzdXBwb3J0ZWQnKTtcbiAgfTtcblxuICBEZWNpbWFsU3R5bGUuYXZhaWxhYmxlTG9jYWxlcyA9IGZ1bmN0aW9uIGF2YWlsYWJsZUxvY2FsZXMoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdub3QgeWV0IHN1cHBvcnRlZCcpO1xuICB9O1xuXG4gIHJldHVybiBEZWNpbWFsU3R5bGU7XG59KCk7XG5EZWNpbWFsU3R5bGUuU1RBTkRBUkQgPSBuZXcgRGVjaW1hbFN0eWxlKCcwJywgJysnLCAnLScsICcuJyk7XG5cbnZhciBTaWduU3R5bGUgPSBmdW5jdGlvbiAoX0VudW0pIHtcbiAgX2luaGVyaXRzTG9vc2UoU2lnblN0eWxlLCBfRW51bSk7XG5cbiAgZnVuY3Rpb24gU2lnblN0eWxlKCkge1xuICAgIHJldHVybiBfRW51bS5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gIH1cblxuICB2YXIgX3Byb3RvID0gU2lnblN0eWxlLnByb3RvdHlwZTtcblxuICBfcHJvdG8ucGFyc2UgPSBmdW5jdGlvbiBwYXJzZShwb3NpdGl2ZSwgc3RyaWN0LCBmaXhlZFdpZHRoKSB7XG4gICAgc3dpdGNoICh0aGlzKSB7XG4gICAgICBjYXNlIFNpZ25TdHlsZS5OT1JNQUw6XG4gICAgICAgIHJldHVybiAhcG9zaXRpdmUgfHwgIXN0cmljdDtcblxuICAgICAgY2FzZSBTaWduU3R5bGUuQUxXQVlTOlxuICAgICAgY2FzZSBTaWduU3R5bGUuRVhDRUVEU19QQUQ6XG4gICAgICAgIHJldHVybiB0cnVlO1xuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gIXN0cmljdCAmJiAhZml4ZWRXaWR0aDtcbiAgICB9XG4gIH07XG5cbiAgcmV0dXJuIFNpZ25TdHlsZTtcbn0oRW51bSk7XG5TaWduU3R5bGUuTk9STUFMID0gbmV3IFNpZ25TdHlsZSgnTk9STUFMJyk7XG5TaWduU3R5bGUuTkVWRVIgPSBuZXcgU2lnblN0eWxlKCdORVZFUicpO1xuU2lnblN0eWxlLkFMV0FZUyA9IG5ldyBTaWduU3R5bGUoJ0FMV0FZUycpO1xuU2lnblN0eWxlLkVYQ0VFRFNfUEFEID0gbmV3IFNpZ25TdHlsZSgnRVhDRUVEU19QQUQnKTtcblNpZ25TdHlsZS5OT1RfTkVHQVRJVkUgPSBuZXcgU2lnblN0eWxlKCdOT1RfTkVHQVRJVkUnKTtcblxudmFyIFRleHRTdHlsZSA9IGZ1bmN0aW9uIChfRW51bSkge1xuICBfaW5oZXJpdHNMb29zZShUZXh0U3R5bGUsIF9FbnVtKTtcblxuICBmdW5jdGlvbiBUZXh0U3R5bGUoKSB7XG4gICAgcmV0dXJuIF9FbnVtLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgfVxuXG4gIHZhciBfcHJvdG8gPSBUZXh0U3R5bGUucHJvdG90eXBlO1xuXG4gIF9wcm90by5pc1N0YW5kYWxvbmUgPSBmdW5jdGlvbiBpc1N0YW5kYWxvbmUoKSB7XG4gICAgc3dpdGNoICh0aGlzKSB7XG4gICAgICBjYXNlIFRleHRTdHlsZS5GVUxMX1NUQU5EQUxPTkU6XG4gICAgICBjYXNlIFRleHRTdHlsZS5TSE9SVF9TVEFOREFMT05FOlxuICAgICAgY2FzZSBUZXh0U3R5bGUuTkFSUk9XX1NUQU5EQUxPTkU6XG4gICAgICAgIHJldHVybiB0cnVlO1xuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9O1xuXG4gIF9wcm90by5hc1N0YW5kYWxvbmUgPSBmdW5jdGlvbiBhc1N0YW5kYWxvbmUoKSB7XG4gICAgc3dpdGNoICh0aGlzKSB7XG4gICAgICBjYXNlIFRleHRTdHlsZS5GVUxMOlxuICAgICAgICByZXR1cm4gVGV4dFN0eWxlLkZVTExfU1RBTkRBTE9ORTtcblxuICAgICAgY2FzZSBUZXh0U3R5bGUuU0hPUlQ6XG4gICAgICAgIHJldHVybiBUZXh0U3R5bGUuU0hPUlRfU1RBTkRBTE9ORTtcblxuICAgICAgY2FzZSBUZXh0U3R5bGUuTkFSUk9XOlxuICAgICAgICByZXR1cm4gVGV4dFN0eWxlLk5BUlJPV19TVEFOREFMT05FO1xuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gIH07XG5cbiAgX3Byb3RvLmFzTm9ybWFsID0gZnVuY3Rpb24gYXNOb3JtYWwoKSB7XG4gICAgc3dpdGNoICh0aGlzKSB7XG4gICAgICBjYXNlIFRleHRTdHlsZS5GVUxMX1NUQU5EQUxPTkU6XG4gICAgICAgIHJldHVybiBUZXh0U3R5bGUuRlVMTDtcblxuICAgICAgY2FzZSBUZXh0U3R5bGUuU0hPUlRfU1RBTkRBTE9ORTpcbiAgICAgICAgcmV0dXJuIFRleHRTdHlsZS5TSE9SVDtcblxuICAgICAgY2FzZSBUZXh0U3R5bGUuTkFSUk9XX1NUQU5EQUxPTkU6XG4gICAgICAgIHJldHVybiBUZXh0U3R5bGUuTkFSUk9XO1xuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gIH07XG5cbiAgcmV0dXJuIFRleHRTdHlsZTtcbn0oRW51bSk7XG5UZXh0U3R5bGUuRlVMTCA9IG5ldyBUZXh0U3R5bGUoJ0ZVTEwnKTtcblRleHRTdHlsZS5GVUxMX1NUQU5EQUxPTkUgPSBuZXcgVGV4dFN0eWxlKCdGVUxMX1NUQU5EQUxPTkUnKTtcblRleHRTdHlsZS5TSE9SVCA9IG5ldyBUZXh0U3R5bGUoJ1NIT1JUJyk7XG5UZXh0U3R5bGUuU0hPUlRfU1RBTkRBTE9ORSA9IG5ldyBUZXh0U3R5bGUoJ1NIT1JUX1NUQU5EQUxPTkUnKTtcblRleHRTdHlsZS5OQVJST1cgPSBuZXcgVGV4dFN0eWxlKCdOQVJST1cnKTtcblRleHRTdHlsZS5OQVJST1dfU1RBTkRBTE9ORSA9IG5ldyBUZXh0U3R5bGUoJ05BUlJPV19TVEFOREFMT05FJyk7XG5cbi8qKlxuICogQGNvcHlyaWdodCAoYykgMjAxNiwgUGhpbGlwcCBUaMO8cnfDpGNodGVyICYgUGF0dHJpY2sgSMO8cGVyXG4gKiBAY29weXJpZ2h0IChjKSAyMDA3LXByZXNlbnQsIFN0ZXBoZW4gQ29sZWJvdXJuZSAmIE1pY2hhZWwgTmFzY2ltZW50byBTYW50b3NcbiAqIEBsaWNlbnNlIEJTRC0zLUNsYXVzZSAoc2VlIExJQ0VOU0UgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUpXG4gKi9cbnZhciBDaGFyTGl0ZXJhbFByaW50ZXJQYXJzZXIgPSBmdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIENoYXJMaXRlcmFsUHJpbnRlclBhcnNlcihsaXRlcmFsKSB7XG4gICAgaWYgKGxpdGVyYWwubGVuZ3RoID4gMSkge1xuICAgICAgdGhyb3cgbmV3IElsbGVnYWxBcmd1bWVudEV4Y2VwdGlvbignaW52YWxpZCBsaXRlcmFsLCB0b28gbG9uZzogXCInICsgbGl0ZXJhbCArICdcIicpO1xuICAgIH1cblxuICAgIHRoaXMuX2xpdGVyYWwgPSBsaXRlcmFsO1xuICB9XG5cbiAgdmFyIF9wcm90byA9IENoYXJMaXRlcmFsUHJpbnRlclBhcnNlci5wcm90b3R5cGU7XG5cbiAgX3Byb3RvLnByaW50ID0gZnVuY3Rpb24gcHJpbnQoY29udGV4dCwgYnVmKSB7XG4gICAgYnVmLmFwcGVuZCh0aGlzLl9saXRlcmFsKTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfTtcblxuICBfcHJvdG8ucGFyc2UgPSBmdW5jdGlvbiBwYXJzZShjb250ZXh0LCB0ZXh0LCBwb3NpdGlvbikge1xuICAgIHZhciBsZW5ndGggPSB0ZXh0Lmxlbmd0aDtcblxuICAgIGlmIChwb3NpdGlvbiA9PT0gbGVuZ3RoKSB7XG4gICAgICByZXR1cm4gfnBvc2l0aW9uO1xuICAgIH1cblxuICAgIHZhciBjaCA9IHRleHQuY2hhckF0KHBvc2l0aW9uKTtcblxuICAgIGlmIChjb250ZXh0LmNoYXJFcXVhbHModGhpcy5fbGl0ZXJhbCwgY2gpID09PSBmYWxzZSkge1xuICAgICAgcmV0dXJuIH5wb3NpdGlvbjtcbiAgICB9XG5cbiAgICByZXR1cm4gcG9zaXRpb24gKyB0aGlzLl9saXRlcmFsLmxlbmd0aDtcbiAgfTtcblxuICBfcHJvdG8udG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZygpIHtcbiAgICBpZiAodGhpcy5fbGl0ZXJhbCA9PT0gJ1xcJycpIHtcbiAgICAgIHJldHVybiBcIicnXCI7XG4gICAgfVxuXG4gICAgcmV0dXJuIFwiJ1wiICsgdGhpcy5fbGl0ZXJhbCArIFwiJ1wiO1xuICB9O1xuXG4gIHJldHVybiBDaGFyTGl0ZXJhbFByaW50ZXJQYXJzZXI7XG59KCk7XG5cbi8qKlxuICogQGNvcHlyaWdodCAoYykgMjAxNiwgUGhpbGlwcCBUaMO8cnfDpGNodGVyICYgUGF0dHJpY2sgSMO8cGVyXG4gKiBAY29weXJpZ2h0IChjKSAyMDA3LXByZXNlbnQsIFN0ZXBoZW4gQ29sZWJvdXJuZSAmIE1pY2hhZWwgTmFzY2ltZW50byBTYW50b3NcbiAqIEBsaWNlbnNlIEJTRC0zLUNsYXVzZSAoc2VlIExJQ0VOU0UgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUpXG4gKi9cbnZhciBDb21wb3NpdGVQcmludGVyUGFyc2VyID0gZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBDb21wb3NpdGVQcmludGVyUGFyc2VyKHByaW50ZXJQYXJzZXJzLCBvcHRpb25hbCkge1xuICAgIHRoaXMuX3ByaW50ZXJQYXJzZXJzID0gcHJpbnRlclBhcnNlcnM7XG4gICAgdGhpcy5fb3B0aW9uYWwgPSBvcHRpb25hbDtcbiAgfVxuXG4gIHZhciBfcHJvdG8gPSBDb21wb3NpdGVQcmludGVyUGFyc2VyLnByb3RvdHlwZTtcblxuICBfcHJvdG8ud2l0aE9wdGlvbmFsID0gZnVuY3Rpb24gd2l0aE9wdGlvbmFsKG9wdGlvbmFsKSB7XG4gICAgaWYgKG9wdGlvbmFsID09PSB0aGlzLl9vcHRpb25hbCkge1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgcmV0dXJuIG5ldyBDb21wb3NpdGVQcmludGVyUGFyc2VyKHRoaXMuX3ByaW50ZXJQYXJzZXJzLCBvcHRpb25hbCk7XG4gIH07XG5cbiAgX3Byb3RvLnByaW50ID0gZnVuY3Rpb24gcHJpbnQoY29udGV4dCwgYnVmKSB7XG4gICAgdmFyIGxlbmd0aCA9IGJ1Zi5sZW5ndGgoKTtcblxuICAgIGlmICh0aGlzLl9vcHRpb25hbCkge1xuICAgICAgY29udGV4dC5zdGFydE9wdGlvbmFsKCk7XG4gICAgfVxuXG4gICAgdHJ5IHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5fcHJpbnRlclBhcnNlcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIHBwID0gdGhpcy5fcHJpbnRlclBhcnNlcnNbaV07XG5cbiAgICAgICAgaWYgKHBwLnByaW50KGNvbnRleHQsIGJ1ZikgPT09IGZhbHNlKSB7XG4gICAgICAgICAgYnVmLnNldExlbmd0aChsZW5ndGgpO1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIGlmICh0aGlzLl9vcHRpb25hbCkge1xuICAgICAgICBjb250ZXh0LmVuZE9wdGlvbmFsKCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRydWU7XG4gIH07XG5cbiAgX3Byb3RvLnBhcnNlID0gZnVuY3Rpb24gcGFyc2UoY29udGV4dCwgdGV4dCwgcG9zaXRpb24pIHtcbiAgICBpZiAodGhpcy5fb3B0aW9uYWwpIHtcbiAgICAgIGNvbnRleHQuc3RhcnRPcHRpb25hbCgpO1xuICAgICAgdmFyIHBvcyA9IHBvc2l0aW9uO1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuX3ByaW50ZXJQYXJzZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBwcCA9IHRoaXMuX3ByaW50ZXJQYXJzZXJzW2ldO1xuICAgICAgICBwb3MgPSBwcC5wYXJzZShjb250ZXh0LCB0ZXh0LCBwb3MpO1xuXG4gICAgICAgIGlmIChwb3MgPCAwKSB7XG4gICAgICAgICAgY29udGV4dC5lbmRPcHRpb25hbChmYWxzZSk7XG4gICAgICAgICAgcmV0dXJuIHBvc2l0aW9uO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGNvbnRleHQuZW5kT3B0aW9uYWwodHJ1ZSk7XG4gICAgICByZXR1cm4gcG9zO1xuICAgIH0gZWxzZSB7XG4gICAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgdGhpcy5fcHJpbnRlclBhcnNlcnMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgIHZhciBfcHAgPSB0aGlzLl9wcmludGVyUGFyc2Vyc1tfaV07XG4gICAgICAgIHBvc2l0aW9uID0gX3BwLnBhcnNlKGNvbnRleHQsIHRleHQsIHBvc2l0aW9uKTtcblxuICAgICAgICBpZiAocG9zaXRpb24gPCAwKSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHBvc2l0aW9uO1xuICAgIH1cbiAgfTtcblxuICBfcHJvdG8udG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZygpIHtcbiAgICB2YXIgYnVmID0gJyc7XG5cbiAgICBpZiAodGhpcy5fcHJpbnRlclBhcnNlcnMgIT0gbnVsbCkge1xuICAgICAgYnVmICs9IHRoaXMuX29wdGlvbmFsID8gJ1snIDogJygnO1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuX3ByaW50ZXJQYXJzZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBwcCA9IHRoaXMuX3ByaW50ZXJQYXJzZXJzW2ldO1xuICAgICAgICBidWYgKz0gcHAudG9TdHJpbmcoKTtcbiAgICAgIH1cblxuICAgICAgYnVmICs9IHRoaXMuX29wdGlvbmFsID8gJ10nIDogJyknO1xuICAgIH1cblxuICAgIHJldHVybiBidWY7XG4gIH07XG5cbiAgcmV0dXJuIENvbXBvc2l0ZVByaW50ZXJQYXJzZXI7XG59KCk7XG5cbi8qKlxuICogQGNvcHlyaWdodCAoYykgMjAxNiwgUGhpbGlwcCBUaMO8cnfDpGNodGVyICYgUGF0dHJpY2sgSMO8cGVyXG4gKiBAY29weXJpZ2h0IChjKSAyMDA3LXByZXNlbnQsIFN0ZXBoZW4gQ29sZWJvdXJuZSAmIE1pY2hhZWwgTmFzY2ltZW50byBTYW50b3NcbiAqIEBsaWNlbnNlIEJTRC0zLUNsYXVzZSAoc2VlIExJQ0VOU0UgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUpXG4gKi9cbnZhciBGcmFjdGlvblByaW50ZXJQYXJzZXIgPSBmdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIEZyYWN0aW9uUHJpbnRlclBhcnNlcihmaWVsZCwgbWluV2lkdGgsIG1heFdpZHRoLCBkZWNpbWFsUG9pbnQpIHtcbiAgICByZXF1aXJlTm9uTnVsbChmaWVsZCwgJ2ZpZWxkJyk7XG5cbiAgICBpZiAoZmllbGQucmFuZ2UoKS5pc0ZpeGVkKCkgPT09IGZhbHNlKSB7XG4gICAgICB0aHJvdyBuZXcgSWxsZWdhbEFyZ3VtZW50RXhjZXB0aW9uKCdGaWVsZCBtdXN0IGhhdmUgYSBmaXhlZCBzZXQgb2YgdmFsdWVzOiAnICsgZmllbGQpO1xuICAgIH1cblxuICAgIGlmIChtaW5XaWR0aCA8IDAgfHwgbWluV2lkdGggPiA5KSB7XG4gICAgICB0aHJvdyBuZXcgSWxsZWdhbEFyZ3VtZW50RXhjZXB0aW9uKCdNaW5pbXVtIHdpZHRoIG11c3QgYmUgZnJvbSAwIHRvIDkgaW5jbHVzaXZlIGJ1dCB3YXMgJyArIG1pbldpZHRoKTtcbiAgICB9XG5cbiAgICBpZiAobWF4V2lkdGggPCAxIHx8IG1heFdpZHRoID4gOSkge1xuICAgICAgdGhyb3cgbmV3IElsbGVnYWxBcmd1bWVudEV4Y2VwdGlvbignTWF4aW11bSB3aWR0aCBtdXN0IGJlIGZyb20gMSB0byA5IGluY2x1c2l2ZSBidXQgd2FzICcgKyBtYXhXaWR0aCk7XG4gICAgfVxuXG4gICAgaWYgKG1heFdpZHRoIDwgbWluV2lkdGgpIHtcbiAgICAgIHRocm93IG5ldyBJbGxlZ2FsQXJndW1lbnRFeGNlcHRpb24oJ01heGltdW0gd2lkdGggbXVzdCBleGNlZWQgb3IgZXF1YWwgdGhlIG1pbmltdW0gd2lkdGggYnV0ICcgKyBtYXhXaWR0aCArICcgPCAnICsgbWluV2lkdGgpO1xuICAgIH1cblxuICAgIHRoaXMuZmllbGQgPSBmaWVsZDtcbiAgICB0aGlzLm1pbldpZHRoID0gbWluV2lkdGg7XG4gICAgdGhpcy5tYXhXaWR0aCA9IG1heFdpZHRoO1xuICAgIHRoaXMuZGVjaW1hbFBvaW50ID0gZGVjaW1hbFBvaW50O1xuICB9XG5cbiAgdmFyIF9wcm90byA9IEZyYWN0aW9uUHJpbnRlclBhcnNlci5wcm90b3R5cGU7XG5cbiAgX3Byb3RvLnByaW50ID0gZnVuY3Rpb24gcHJpbnQoY29udGV4dCwgYnVmKSB7XG4gICAgdmFyIHZhbHVlID0gY29udGV4dC5nZXRWYWx1ZSh0aGlzLmZpZWxkKTtcblxuICAgIGlmICh2YWx1ZSA9PT0gbnVsbCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHZhciBzeW1ib2xzID0gY29udGV4dC5zeW1ib2xzKCk7XG5cbiAgICBpZiAodmFsdWUgPT09IDApIHtcbiAgICAgIGlmICh0aGlzLm1pbldpZHRoID4gMCkge1xuICAgICAgICBpZiAodGhpcy5kZWNpbWFsUG9pbnQpIHtcbiAgICAgICAgICBidWYuYXBwZW5kKHN5bWJvbHMuZGVjaW1hbFNlcGFyYXRvcigpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5taW5XaWR0aDsgaSsrKSB7XG4gICAgICAgICAgYnVmLmFwcGVuZChzeW1ib2xzLnplcm9EaWdpdCgpKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgZnJhY3Rpb24gPSB0aGlzLmNvbnZlcnRUb0ZyYWN0aW9uKHZhbHVlLCBzeW1ib2xzLnplcm9EaWdpdCgpKTtcbiAgICAgIHZhciBvdXRwdXRTY2FsZSA9IE1hdGgubWluKE1hdGgubWF4KGZyYWN0aW9uLmxlbmd0aCwgdGhpcy5taW5XaWR0aCksIHRoaXMubWF4V2lkdGgpO1xuICAgICAgZnJhY3Rpb24gPSBmcmFjdGlvbi5zdWJzdHIoMCwgb3V0cHV0U2NhbGUpO1xuXG4gICAgICBpZiAoZnJhY3Rpb24gKiAxID4gMCkge1xuICAgICAgICB3aGlsZSAoZnJhY3Rpb24ubGVuZ3RoID4gdGhpcy5taW5XaWR0aCAmJiBmcmFjdGlvbltmcmFjdGlvbi5sZW5ndGggLSAxXSA9PT0gJzAnKSB7XG4gICAgICAgICAgZnJhY3Rpb24gPSBmcmFjdGlvbi5zdWJzdHIoMCwgZnJhY3Rpb24ubGVuZ3RoIC0gMSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdmFyIHN0ciA9IGZyYWN0aW9uO1xuICAgICAgc3RyID0gc3ltYm9scy5jb252ZXJ0TnVtYmVyVG9JMThOKHN0cik7XG5cbiAgICAgIGlmICh0aGlzLmRlY2ltYWxQb2ludCkge1xuICAgICAgICBidWYuYXBwZW5kKHN5bWJvbHMuZGVjaW1hbFNlcGFyYXRvcigpKTtcbiAgICAgIH1cblxuICAgICAgYnVmLmFwcGVuZChzdHIpO1xuICAgIH1cblxuICAgIHJldHVybiB0cnVlO1xuICB9O1xuXG4gIF9wcm90by5wYXJzZSA9IGZ1bmN0aW9uIHBhcnNlKGNvbnRleHQsIHRleHQsIHBvc2l0aW9uKSB7XG4gICAgdmFyIGVmZmVjdGl2ZU1pbiA9IGNvbnRleHQuaXNTdHJpY3QoKSA/IHRoaXMubWluV2lkdGggOiAwO1xuICAgIHZhciBlZmZlY3RpdmVNYXggPSBjb250ZXh0LmlzU3RyaWN0KCkgPyB0aGlzLm1heFdpZHRoIDogOTtcbiAgICB2YXIgbGVuZ3RoID0gdGV4dC5sZW5ndGg7XG5cbiAgICBpZiAocG9zaXRpb24gPT09IGxlbmd0aCkge1xuICAgICAgcmV0dXJuIGVmZmVjdGl2ZU1pbiA+IDAgPyB+cG9zaXRpb24gOiBwb3NpdGlvbjtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5kZWNpbWFsUG9pbnQpIHtcbiAgICAgIGlmICh0ZXh0W3Bvc2l0aW9uXSAhPT0gY29udGV4dC5zeW1ib2xzKCkuZGVjaW1hbFNlcGFyYXRvcigpKSB7XG4gICAgICAgIHJldHVybiBlZmZlY3RpdmVNaW4gPiAwID8gfnBvc2l0aW9uIDogcG9zaXRpb247XG4gICAgICB9XG5cbiAgICAgIHBvc2l0aW9uKys7XG4gICAgfVxuXG4gICAgdmFyIG1pbkVuZFBvcyA9IHBvc2l0aW9uICsgZWZmZWN0aXZlTWluO1xuXG4gICAgaWYgKG1pbkVuZFBvcyA+IGxlbmd0aCkge1xuICAgICAgcmV0dXJuIH5wb3NpdGlvbjtcbiAgICB9XG5cbiAgICB2YXIgbWF4RW5kUG9zID0gTWF0aC5taW4ocG9zaXRpb24gKyBlZmZlY3RpdmVNYXgsIGxlbmd0aCk7XG4gICAgdmFyIHRvdGFsID0gMDtcbiAgICB2YXIgcG9zID0gcG9zaXRpb247XG5cbiAgICB3aGlsZSAocG9zIDwgbWF4RW5kUG9zKSB7XG4gICAgICB2YXIgY2ggPSB0ZXh0LmNoYXJBdChwb3MrKyk7XG4gICAgICB2YXIgZGlnaXQgPSBjb250ZXh0LnN5bWJvbHMoKS5jb252ZXJ0VG9EaWdpdChjaCk7XG5cbiAgICAgIGlmIChkaWdpdCA8IDApIHtcbiAgICAgICAgaWYgKHBvcyA8IG1pbkVuZFBvcykge1xuICAgICAgICAgIHJldHVybiB+cG9zaXRpb247XG4gICAgICAgIH1cblxuICAgICAgICBwb3MtLTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICAgIHRvdGFsID0gdG90YWwgKiAxMCArIGRpZ2l0O1xuICAgIH1cblxuICAgIHZhciBtb3ZlTGVmdCA9IHBvcyAtIHBvc2l0aW9uO1xuICAgIHZhciBzY2FsZSA9IE1hdGgucG93KDEwLCBtb3ZlTGVmdCk7XG4gICAgdmFyIHZhbHVlID0gdGhpcy5jb252ZXJ0RnJvbUZyYWN0aW9uKHRvdGFsLCBzY2FsZSk7XG4gICAgcmV0dXJuIGNvbnRleHQuc2V0UGFyc2VkRmllbGQodGhpcy5maWVsZCwgdmFsdWUsIHBvc2l0aW9uLCBwb3MpO1xuICB9O1xuXG4gIF9wcm90by5jb252ZXJ0VG9GcmFjdGlvbiA9IGZ1bmN0aW9uIGNvbnZlcnRUb0ZyYWN0aW9uKHZhbHVlLCB6ZXJvRGlnaXQpIHtcbiAgICB2YXIgcmFuZ2UgPSB0aGlzLmZpZWxkLnJhbmdlKCk7XG4gICAgcmFuZ2UuY2hlY2tWYWxpZFZhbHVlKHZhbHVlLCB0aGlzLmZpZWxkKTtcblxuICAgIHZhciBfbWluID0gcmFuZ2UubWluaW11bSgpO1xuXG4gICAgdmFyIF9yYW5nZSA9IHJhbmdlLm1heGltdW0oKSAtIF9taW4gKyAxO1xuXG4gICAgdmFyIF92YWx1ZSA9IHZhbHVlIC0gX21pbjtcblxuICAgIHZhciBfc2NhbGVkID0gTWF0aFV0aWwuaW50RGl2KF92YWx1ZSAqIDEwMDAwMDAwMDAsIF9yYW5nZSk7XG5cbiAgICB2YXIgZnJhY3Rpb24gPSAnJyArIF9zY2FsZWQ7XG5cbiAgICB3aGlsZSAoZnJhY3Rpb24ubGVuZ3RoIDwgOSkge1xuICAgICAgZnJhY3Rpb24gPSB6ZXJvRGlnaXQgKyBmcmFjdGlvbjtcbiAgICB9XG5cbiAgICByZXR1cm4gZnJhY3Rpb247XG4gIH07XG5cbiAgX3Byb3RvLmNvbnZlcnRGcm9tRnJhY3Rpb24gPSBmdW5jdGlvbiBjb252ZXJ0RnJvbUZyYWN0aW9uKHRvdGFsLCBzY2FsZSkge1xuICAgIHZhciByYW5nZSA9IHRoaXMuZmllbGQucmFuZ2UoKTtcblxuICAgIHZhciBfbWluID0gcmFuZ2UubWluaW11bSgpO1xuXG4gICAgdmFyIF9yYW5nZSA9IHJhbmdlLm1heGltdW0oKSAtIF9taW4gKyAxO1xuXG4gICAgdmFyIF92YWx1ZSA9IE1hdGhVdGlsLmludERpdih0b3RhbCAqIF9yYW5nZSwgc2NhbGUpO1xuXG4gICAgcmV0dXJuIF92YWx1ZTtcbiAgfTtcblxuICBfcHJvdG8udG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZygpIHtcbiAgICB2YXIgZGVjaW1hbCA9IHRoaXMuZGVjaW1hbFBvaW50ID8gJyxEZWNpbWFsUG9pbnQnIDogJyc7XG4gICAgcmV0dXJuICdGcmFjdGlvbignICsgdGhpcy5maWVsZCArICcsJyArIHRoaXMubWluV2lkdGggKyAnLCcgKyB0aGlzLm1heFdpZHRoICsgZGVjaW1hbCArICcpJztcbiAgfTtcblxuICByZXR1cm4gRnJhY3Rpb25QcmludGVyUGFyc2VyO1xufSgpO1xuXG52YXIgTUFYX1dJRFRIID0gMTU7XG52YXIgRVhDRUVEX1BPSU5UUyA9IFswLCAxMCwgMTAwLCAxMDAwLCAxMDAwMCwgMTAwMDAwLCAxMDAwMDAwLCAxMDAwMDAwMCwgMTAwMDAwMDAwLCAxMDAwMDAwMDAwXTtcbnZhciBOdW1iZXJQcmludGVyUGFyc2VyID0gZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBOdW1iZXJQcmludGVyUGFyc2VyKGZpZWxkLCBtaW5XaWR0aCwgbWF4V2lkdGgsIHNpZ25TdHlsZSwgc3Vic2VxdWVudFdpZHRoKSB7XG4gICAgaWYgKHN1YnNlcXVlbnRXaWR0aCA9PT0gdm9pZCAwKSB7XG4gICAgICBzdWJzZXF1ZW50V2lkdGggPSAwO1xuICAgIH1cblxuICAgIHRoaXMuX2ZpZWxkID0gZmllbGQ7XG4gICAgdGhpcy5fbWluV2lkdGggPSBtaW5XaWR0aDtcbiAgICB0aGlzLl9tYXhXaWR0aCA9IG1heFdpZHRoO1xuICAgIHRoaXMuX3NpZ25TdHlsZSA9IHNpZ25TdHlsZTtcbiAgICB0aGlzLl9zdWJzZXF1ZW50V2lkdGggPSBzdWJzZXF1ZW50V2lkdGg7XG4gIH1cblxuICB2YXIgX3Byb3RvID0gTnVtYmVyUHJpbnRlclBhcnNlci5wcm90b3R5cGU7XG5cbiAgX3Byb3RvLmZpZWxkID0gZnVuY3Rpb24gZmllbGQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2ZpZWxkO1xuICB9O1xuXG4gIF9wcm90by5taW5XaWR0aCA9IGZ1bmN0aW9uIG1pbldpZHRoKCkge1xuICAgIHJldHVybiB0aGlzLl9taW5XaWR0aDtcbiAgfTtcblxuICBfcHJvdG8ubWF4V2lkdGggPSBmdW5jdGlvbiBtYXhXaWR0aCgpIHtcbiAgICByZXR1cm4gdGhpcy5fbWF4V2lkdGg7XG4gIH07XG5cbiAgX3Byb3RvLnNpZ25TdHlsZSA9IGZ1bmN0aW9uIHNpZ25TdHlsZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fc2lnblN0eWxlO1xuICB9O1xuXG4gIF9wcm90by53aXRoRml4ZWRXaWR0aCA9IGZ1bmN0aW9uIHdpdGhGaXhlZFdpZHRoKCkge1xuICAgIGlmICh0aGlzLl9zdWJzZXF1ZW50V2lkdGggPT09IC0xKSB7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICByZXR1cm4gbmV3IE51bWJlclByaW50ZXJQYXJzZXIodGhpcy5fZmllbGQsIHRoaXMuX21pbldpZHRoLCB0aGlzLl9tYXhXaWR0aCwgdGhpcy5fc2lnblN0eWxlLCAtMSk7XG4gIH07XG5cbiAgX3Byb3RvLndpdGhTdWJzZXF1ZW50V2lkdGggPSBmdW5jdGlvbiB3aXRoU3Vic2VxdWVudFdpZHRoKHN1YnNlcXVlbnRXaWR0aCkge1xuICAgIHJldHVybiBuZXcgTnVtYmVyUHJpbnRlclBhcnNlcih0aGlzLl9maWVsZCwgdGhpcy5fbWluV2lkdGgsIHRoaXMuX21heFdpZHRoLCB0aGlzLl9zaWduU3R5bGUsIHRoaXMuX3N1YnNlcXVlbnRXaWR0aCArIHN1YnNlcXVlbnRXaWR0aCk7XG4gIH07XG5cbiAgX3Byb3RvLl9pc0ZpeGVkV2lkdGggPSBmdW5jdGlvbiBfaXNGaXhlZFdpZHRoKCkge1xuICAgIHJldHVybiB0aGlzLl9zdWJzZXF1ZW50V2lkdGggPT09IC0xIHx8IHRoaXMuX3N1YnNlcXVlbnRXaWR0aCA+IDAgJiYgdGhpcy5fbWluV2lkdGggPT09IHRoaXMuX21heFdpZHRoICYmIHRoaXMuX3NpZ25TdHlsZSA9PT0gU2lnblN0eWxlLk5PVF9ORUdBVElWRTtcbiAgfTtcblxuICBfcHJvdG8ucHJpbnQgPSBmdW5jdGlvbiBwcmludChjb250ZXh0LCBidWYpIHtcbiAgICB2YXIgY29udGV4dFZhbHVlID0gY29udGV4dC5nZXRWYWx1ZSh0aGlzLl9maWVsZCk7XG5cbiAgICBpZiAoY29udGV4dFZhbHVlID09IG51bGwpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICB2YXIgdmFsdWUgPSB0aGlzLl9nZXRWYWx1ZShjb250ZXh0LCBjb250ZXh0VmFsdWUpO1xuXG4gICAgdmFyIHN5bWJvbHMgPSBjb250ZXh0LnN5bWJvbHMoKTtcbiAgICB2YXIgc3RyID0gJycgKyBNYXRoLmFicyh2YWx1ZSk7XG5cbiAgICBpZiAoc3RyLmxlbmd0aCA+IHRoaXMuX21heFdpZHRoKSB7XG4gICAgICB0aHJvdyBuZXcgRGF0ZVRpbWVFeGNlcHRpb24oJ0ZpZWxkICcgKyB0aGlzLl9maWVsZCArICcgY2Fubm90IGJlIHByaW50ZWQgYXMgdGhlIHZhbHVlICcgKyB2YWx1ZSArICcgZXhjZWVkcyB0aGUgbWF4aW11bSBwcmludCB3aWR0aCBvZiAnICsgdGhpcy5fbWF4V2lkdGgpO1xuICAgIH1cblxuICAgIHN0ciA9IHN5bWJvbHMuY29udmVydE51bWJlclRvSTE4TihzdHIpO1xuXG4gICAgaWYgKHZhbHVlID49IDApIHtcbiAgICAgIHN3aXRjaCAodGhpcy5fc2lnblN0eWxlKSB7XG4gICAgICAgIGNhc2UgU2lnblN0eWxlLkVYQ0VFRFNfUEFEOlxuICAgICAgICAgIGlmICh0aGlzLl9taW5XaWR0aCA8IE1BWF9XSURUSCAmJiB2YWx1ZSA+PSBFWENFRURfUE9JTlRTW3RoaXMuX21pbldpZHRoXSkge1xuICAgICAgICAgICAgYnVmLmFwcGVuZChzeW1ib2xzLnBvc2l0aXZlU2lnbigpKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlIFNpZ25TdHlsZS5BTFdBWVM6XG4gICAgICAgICAgYnVmLmFwcGVuZChzeW1ib2xzLnBvc2l0aXZlU2lnbigpKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgc3dpdGNoICh0aGlzLl9zaWduU3R5bGUpIHtcbiAgICAgICAgY2FzZSBTaWduU3R5bGUuTk9STUFMOlxuICAgICAgICBjYXNlIFNpZ25TdHlsZS5FWENFRURTX1BBRDpcbiAgICAgICAgY2FzZSBTaWduU3R5bGUuQUxXQVlTOlxuICAgICAgICAgIGJ1Zi5hcHBlbmQoc3ltYm9scy5uZWdhdGl2ZVNpZ24oKSk7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSBTaWduU3R5bGUuTk9UX05FR0FUSVZFOlxuICAgICAgICAgIHRocm93IG5ldyBEYXRlVGltZUV4Y2VwdGlvbignRmllbGQgJyArIHRoaXMuX2ZpZWxkICsgJyBjYW5ub3QgYmUgcHJpbnRlZCBhcyB0aGUgdmFsdWUgJyArIHZhbHVlICsgJyBjYW5ub3QgYmUgbmVnYXRpdmUgYWNjb3JkaW5nIHRvIHRoZSBTaWduU3R5bGUnKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuX21pbldpZHRoIC0gc3RyLmxlbmd0aDsgaSsrKSB7XG4gICAgICBidWYuYXBwZW5kKHN5bWJvbHMuemVyb0RpZ2l0KCkpO1xuICAgIH1cblxuICAgIGJ1Zi5hcHBlbmQoc3RyKTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfTtcblxuICBfcHJvdG8ucGFyc2UgPSBmdW5jdGlvbiBwYXJzZShjb250ZXh0LCB0ZXh0LCBwb3NpdGlvbikge1xuICAgIHZhciBsZW5ndGggPSB0ZXh0Lmxlbmd0aDtcblxuICAgIGlmIChwb3NpdGlvbiA9PT0gbGVuZ3RoKSB7XG4gICAgICByZXR1cm4gfnBvc2l0aW9uO1xuICAgIH1cblxuICAgIGFzc2VydChwb3NpdGlvbiA+PSAwICYmIHBvc2l0aW9uIDwgbGVuZ3RoKTtcbiAgICB2YXIgc2lnbiA9IHRleHQuY2hhckF0KHBvc2l0aW9uKTtcbiAgICB2YXIgbmVnYXRpdmUgPSBmYWxzZTtcbiAgICB2YXIgcG9zaXRpdmUgPSBmYWxzZTtcblxuICAgIGlmIChzaWduID09PSBjb250ZXh0LnN5bWJvbHMoKS5wb3NpdGl2ZVNpZ24oKSkge1xuICAgICAgaWYgKHRoaXMuX3NpZ25TdHlsZS5wYXJzZSh0cnVlLCBjb250ZXh0LmlzU3RyaWN0KCksIHRoaXMuX21pbldpZHRoID09PSB0aGlzLl9tYXhXaWR0aCkgPT09IGZhbHNlKSB7XG4gICAgICAgIHJldHVybiB+cG9zaXRpb247XG4gICAgICB9XG5cbiAgICAgIHBvc2l0aXZlID0gdHJ1ZTtcbiAgICAgIHBvc2l0aW9uKys7XG4gICAgfSBlbHNlIGlmIChzaWduID09PSBjb250ZXh0LnN5bWJvbHMoKS5uZWdhdGl2ZVNpZ24oKSkge1xuICAgICAgaWYgKHRoaXMuX3NpZ25TdHlsZS5wYXJzZShmYWxzZSwgY29udGV4dC5pc1N0cmljdCgpLCB0aGlzLl9taW5XaWR0aCA9PT0gdGhpcy5fbWF4V2lkdGgpID09PSBmYWxzZSkge1xuICAgICAgICByZXR1cm4gfnBvc2l0aW9uO1xuICAgICAgfVxuXG4gICAgICBuZWdhdGl2ZSA9IHRydWU7XG4gICAgICBwb3NpdGlvbisrO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAodGhpcy5fc2lnblN0eWxlID09PSBTaWduU3R5bGUuQUxXQVlTICYmIGNvbnRleHQuaXNTdHJpY3QoKSkge1xuICAgICAgICByZXR1cm4gfnBvc2l0aW9uO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBlZmZNaW5XaWR0aCA9IGNvbnRleHQuaXNTdHJpY3QoKSB8fCB0aGlzLl9pc0ZpeGVkV2lkdGgoKSA/IHRoaXMuX21pbldpZHRoIDogMTtcbiAgICB2YXIgbWluRW5kUG9zID0gcG9zaXRpb24gKyBlZmZNaW5XaWR0aDtcblxuICAgIGlmIChtaW5FbmRQb3MgPiBsZW5ndGgpIHtcbiAgICAgIHJldHVybiB+cG9zaXRpb247XG4gICAgfVxuXG4gICAgdmFyIGVmZk1heFdpZHRoID0gKGNvbnRleHQuaXNTdHJpY3QoKSB8fCB0aGlzLl9pc0ZpeGVkV2lkdGgoKSA/IHRoaXMuX21heFdpZHRoIDogOSkgKyBNYXRoLm1heCh0aGlzLl9zdWJzZXF1ZW50V2lkdGgsIDApO1xuICAgIHZhciB0b3RhbCA9IDA7XG4gICAgdmFyIHBvcyA9IHBvc2l0aW9uO1xuXG4gICAgZm9yICh2YXIgcGFzcyA9IDA7IHBhc3MgPCAyOyBwYXNzKyspIHtcbiAgICAgIHZhciBtYXhFbmRQb3MgPSBNYXRoLm1pbihwb3MgKyBlZmZNYXhXaWR0aCwgbGVuZ3RoKTtcblxuICAgICAgd2hpbGUgKHBvcyA8IG1heEVuZFBvcykge1xuICAgICAgICB2YXIgY2ggPSB0ZXh0LmNoYXJBdChwb3MrKyk7XG4gICAgICAgIHZhciBkaWdpdCA9IGNvbnRleHQuc3ltYm9scygpLmNvbnZlcnRUb0RpZ2l0KGNoKTtcblxuICAgICAgICBpZiAoZGlnaXQgPCAwKSB7XG4gICAgICAgICAgcG9zLS07XG5cbiAgICAgICAgICBpZiAocG9zIDwgbWluRW5kUG9zKSB7XG4gICAgICAgICAgICByZXR1cm4gfnBvc2l0aW9uO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHBvcyAtIHBvc2l0aW9uID4gTUFYX1dJRFRIKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEFyaXRobWV0aWNFeGNlcHRpb24oJ251bWJlciB0ZXh0IGV4Y2VlZHMgbGVuZ3RoJyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdG90YWwgPSB0b3RhbCAqIDEwICsgZGlnaXQ7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMuX3N1YnNlcXVlbnRXaWR0aCA+IDAgJiYgcGFzcyA9PT0gMCkge1xuICAgICAgICB2YXIgcGFyc2VMZW4gPSBwb3MgLSBwb3NpdGlvbjtcbiAgICAgICAgZWZmTWF4V2lkdGggPSBNYXRoLm1heChlZmZNaW5XaWR0aCwgcGFyc2VMZW4gLSB0aGlzLl9zdWJzZXF1ZW50V2lkdGgpO1xuICAgICAgICBwb3MgPSBwb3NpdGlvbjtcbiAgICAgICAgdG90YWwgPSAwO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKG5lZ2F0aXZlKSB7XG4gICAgICBpZiAodG90YWwgPT09IDAgJiYgY29udGV4dC5pc1N0cmljdCgpKSB7XG4gICAgICAgIHJldHVybiB+KHBvc2l0aW9uIC0gMSk7XG4gICAgICB9XG5cbiAgICAgIGlmICh0b3RhbCAhPT0gMCkge1xuICAgICAgICB0b3RhbCA9IC10b3RhbDtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHRoaXMuX3NpZ25TdHlsZSA9PT0gU2lnblN0eWxlLkVYQ0VFRFNfUEFEICYmIGNvbnRleHQuaXNTdHJpY3QoKSkge1xuICAgICAgdmFyIF9wYXJzZUxlbiA9IHBvcyAtIHBvc2l0aW9uO1xuXG4gICAgICBpZiAocG9zaXRpdmUpIHtcbiAgICAgICAgaWYgKF9wYXJzZUxlbiA8PSB0aGlzLl9taW5XaWR0aCkge1xuICAgICAgICAgIHJldHVybiB+KHBvc2l0aW9uIC0gMSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChfcGFyc2VMZW4gPiB0aGlzLl9taW5XaWR0aCkge1xuICAgICAgICAgIHJldHVybiB+cG9zaXRpb247XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5fc2V0VmFsdWUoY29udGV4dCwgdG90YWwsIHBvc2l0aW9uLCBwb3MpO1xuICB9O1xuXG4gIF9wcm90by5fZ2V0VmFsdWUgPSBmdW5jdGlvbiBfZ2V0VmFsdWUoY29udGV4dCwgdmFsdWUpIHtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH07XG5cbiAgX3Byb3RvLl9zZXRWYWx1ZSA9IGZ1bmN0aW9uIF9zZXRWYWx1ZShjb250ZXh0LCB2YWx1ZSwgZXJyb3JQb3MsIHN1Y2Nlc3NQb3MpIHtcbiAgICByZXR1cm4gY29udGV4dC5zZXRQYXJzZWRGaWVsZCh0aGlzLl9maWVsZCwgdmFsdWUsIGVycm9yUG9zLCBzdWNjZXNzUG9zKTtcbiAgfTtcblxuICBfcHJvdG8udG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZygpIHtcbiAgICBpZiAodGhpcy5fbWluV2lkdGggPT09IDEgJiYgdGhpcy5fbWF4V2lkdGggPT09IE1BWF9XSURUSCAmJiB0aGlzLl9zaWduU3R5bGUgPT09IFNpZ25TdHlsZS5OT1JNQUwpIHtcbiAgICAgIHJldHVybiAnVmFsdWUoJyArIHRoaXMuX2ZpZWxkICsgJyknO1xuICAgIH1cblxuICAgIGlmICh0aGlzLl9taW5XaWR0aCA9PT0gdGhpcy5fbWF4V2lkdGggJiYgdGhpcy5fc2lnblN0eWxlID09PSBTaWduU3R5bGUuTk9UX05FR0FUSVZFKSB7XG4gICAgICByZXR1cm4gJ1ZhbHVlKCcgKyB0aGlzLl9maWVsZCArICcsJyArIHRoaXMuX21pbldpZHRoICsgJyknO1xuICAgIH1cblxuICAgIHJldHVybiAnVmFsdWUoJyArIHRoaXMuX2ZpZWxkICsgJywnICsgdGhpcy5fbWluV2lkdGggKyAnLCcgKyB0aGlzLl9tYXhXaWR0aCArICcsJyArIHRoaXMuX3NpZ25TdHlsZSArICcpJztcbiAgfTtcblxuICByZXR1cm4gTnVtYmVyUHJpbnRlclBhcnNlcjtcbn0oKTtcbnZhciBSZWR1Y2VkUHJpbnRlclBhcnNlciA9IGZ1bmN0aW9uIChfTnVtYmVyUHJpbnRlclBhcnNlcikge1xuICBfaW5oZXJpdHNMb29zZShSZWR1Y2VkUHJpbnRlclBhcnNlciwgX051bWJlclByaW50ZXJQYXJzZXIpO1xuXG4gIGZ1bmN0aW9uIFJlZHVjZWRQcmludGVyUGFyc2VyKGZpZWxkLCB3aWR0aCwgbWF4V2lkdGgsIGJhc2VWYWx1ZSwgYmFzZURhdGUpIHtcbiAgICB2YXIgX3RoaXM7XG5cbiAgICBfdGhpcyA9IF9OdW1iZXJQcmludGVyUGFyc2VyLmNhbGwodGhpcywgZmllbGQsIHdpZHRoLCBtYXhXaWR0aCwgU2lnblN0eWxlLk5PVF9ORUdBVElWRSkgfHwgdGhpcztcblxuICAgIGlmICh3aWR0aCA8IDEgfHwgd2lkdGggPiAxMCkge1xuICAgICAgdGhyb3cgbmV3IElsbGVnYWxBcmd1bWVudEV4Y2VwdGlvbignVGhlIHdpZHRoIG11c3QgYmUgZnJvbSAxIHRvIDEwIGluY2x1c2l2ZSBidXQgd2FzICcgKyB3aWR0aCk7XG4gICAgfVxuXG4gICAgaWYgKG1heFdpZHRoIDwgMSB8fCBtYXhXaWR0aCA+IDEwKSB7XG4gICAgICB0aHJvdyBuZXcgSWxsZWdhbEFyZ3VtZW50RXhjZXB0aW9uKCdUaGUgbWF4V2lkdGggbXVzdCBiZSBmcm9tIDEgdG8gMTAgaW5jbHVzaXZlIGJ1dCB3YXMgJyArIG1heFdpZHRoKTtcbiAgICB9XG5cbiAgICBpZiAobWF4V2lkdGggPCB3aWR0aCkge1xuICAgICAgdGhyb3cgbmV3IElsbGVnYWxBcmd1bWVudEV4Y2VwdGlvbignVGhlIG1heFdpZHRoIG11c3QgYmUgZ3JlYXRlciB0aGFuIHRoZSB3aWR0aCcpO1xuICAgIH1cblxuICAgIGlmIChiYXNlRGF0ZSA9PT0gbnVsbCkge1xuICAgICAgaWYgKGZpZWxkLnJhbmdlKCkuaXNWYWxpZFZhbHVlKGJhc2VWYWx1ZSkgPT09IGZhbHNlKSB7XG4gICAgICAgIHRocm93IG5ldyBJbGxlZ2FsQXJndW1lbnRFeGNlcHRpb24oJ1RoZSBiYXNlIHZhbHVlIG11c3QgYmUgd2l0aGluIHRoZSByYW5nZSBvZiB0aGUgZmllbGQnKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGJhc2VWYWx1ZSArIEVYQ0VFRF9QT0lOVFNbd2lkdGhdID4gTWF0aFV0aWwuTUFYX1NBRkVfSU5URUdFUikge1xuICAgICAgICB0aHJvdyBuZXcgRGF0ZVRpbWVFeGNlcHRpb24oJ1VuYWJsZSB0byBhZGQgcHJpbnRlci1wYXJzZXIgYXMgdGhlIHJhbmdlIGV4Y2VlZHMgdGhlIGNhcGFjaXR5IG9mIGFuIGludCcpO1xuICAgICAgfVxuICAgIH1cblxuICAgIF90aGlzLl9iYXNlVmFsdWUgPSBiYXNlVmFsdWU7XG4gICAgX3RoaXMuX2Jhc2VEYXRlID0gYmFzZURhdGU7XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG5cbiAgdmFyIF9wcm90bzIgPSBSZWR1Y2VkUHJpbnRlclBhcnNlci5wcm90b3R5cGU7XG5cbiAgX3Byb3RvMi5fZ2V0VmFsdWUgPSBmdW5jdGlvbiBfZ2V0VmFsdWUoY29udGV4dCwgdmFsdWUpIHtcbiAgICB2YXIgYWJzVmFsdWUgPSBNYXRoLmFicyh2YWx1ZSk7XG4gICAgdmFyIGJhc2VWYWx1ZSA9IHRoaXMuX2Jhc2VWYWx1ZTtcblxuICAgIGlmICh0aGlzLl9iYXNlRGF0ZSAhPT0gbnVsbCkge1xuICAgICAgY29udGV4dC50ZW1wb3JhbCgpO1xuICAgICAgdmFyIGNocm9ubyA9IElzb0Nocm9ub2xvZ3kuSU5TVEFOQ0U7XG4gICAgICBiYXNlVmFsdWUgPSBjaHJvbm8uZGF0ZSh0aGlzLl9iYXNlRGF0ZSkuZ2V0KHRoaXMuX2ZpZWxkKTtcbiAgICB9XG5cbiAgICBpZiAodmFsdWUgPj0gYmFzZVZhbHVlICYmIHZhbHVlIDwgYmFzZVZhbHVlICsgRVhDRUVEX1BPSU5UU1t0aGlzLl9taW5XaWR0aF0pIHtcbiAgICAgIHJldHVybiBhYnNWYWx1ZSAlIEVYQ0VFRF9QT0lOVFNbdGhpcy5fbWluV2lkdGhdO1xuICAgIH1cblxuICAgIHJldHVybiBhYnNWYWx1ZSAlIEVYQ0VFRF9QT0lOVFNbdGhpcy5fbWF4V2lkdGhdO1xuICB9O1xuXG4gIF9wcm90bzIuX3NldFZhbHVlID0gZnVuY3Rpb24gX3NldFZhbHVlKGNvbnRleHQsIHZhbHVlLCBlcnJvclBvcywgc3VjY2Vzc1Bvcykge1xuICAgIHZhciBiYXNlVmFsdWUgPSB0aGlzLl9iYXNlVmFsdWU7XG5cbiAgICBpZiAodGhpcy5fYmFzZURhdGUgIT0gbnVsbCkge1xuICAgICAgdmFyIGNocm9ubyA9IGNvbnRleHQuZ2V0RWZmZWN0aXZlQ2hyb25vbG9neSgpO1xuICAgICAgYmFzZVZhbHVlID0gY2hyb25vLmRhdGUodGhpcy5fYmFzZURhdGUpLmdldCh0aGlzLl9maWVsZCk7XG4gICAgfVxuXG4gICAgdmFyIHBhcnNlTGVuID0gc3VjY2Vzc1BvcyAtIGVycm9yUG9zO1xuXG4gICAgaWYgKHBhcnNlTGVuID09PSB0aGlzLl9taW5XaWR0aCAmJiB2YWx1ZSA+PSAwKSB7XG4gICAgICB2YXIgcmFuZ2UgPSBFWENFRURfUE9JTlRTW3RoaXMuX21pbldpZHRoXTtcbiAgICAgIHZhciBsYXN0UGFydCA9IGJhc2VWYWx1ZSAlIHJhbmdlO1xuICAgICAgdmFyIGJhc2VQYXJ0ID0gYmFzZVZhbHVlIC0gbGFzdFBhcnQ7XG5cbiAgICAgIGlmIChiYXNlVmFsdWUgPiAwKSB7XG4gICAgICAgIHZhbHVlID0gYmFzZVBhcnQgKyB2YWx1ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhbHVlID0gYmFzZVBhcnQgLSB2YWx1ZTtcbiAgICAgIH1cblxuICAgICAgaWYgKHZhbHVlIDwgYmFzZVZhbHVlKSB7XG4gICAgICAgIHZhbHVlICs9IHJhbmdlO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBjb250ZXh0LnNldFBhcnNlZEZpZWxkKHRoaXMuX2ZpZWxkLCB2YWx1ZSwgZXJyb3JQb3MsIHN1Y2Nlc3NQb3MpO1xuICB9O1xuXG4gIF9wcm90bzIud2l0aEZpeGVkV2lkdGggPSBmdW5jdGlvbiB3aXRoRml4ZWRXaWR0aCgpIHtcbiAgICBpZiAodGhpcy5fc3Vic2VxdWVudFdpZHRoID09PSAtMSkge1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgcmV0dXJuIG5ldyBSZWR1Y2VkUHJpbnRlclBhcnNlcih0aGlzLl9maWVsZCwgdGhpcy5fbWluV2lkdGgsIHRoaXMuX21heFdpZHRoLCB0aGlzLl9iYXNlVmFsdWUsIHRoaXMuX2Jhc2VEYXRlLCAtMSk7XG4gIH07XG5cbiAgX3Byb3RvMi53aXRoU3Vic2VxdWVudFdpZHRoID0gZnVuY3Rpb24gd2l0aFN1YnNlcXVlbnRXaWR0aChzdWJzZXF1ZW50V2lkdGgpIHtcbiAgICByZXR1cm4gbmV3IFJlZHVjZWRQcmludGVyUGFyc2VyKHRoaXMuX2ZpZWxkLCB0aGlzLl9taW5XaWR0aCwgdGhpcy5fbWF4V2lkdGgsIHRoaXMuX2Jhc2VWYWx1ZSwgdGhpcy5fYmFzZURhdGUsIHRoaXMuX3N1YnNlcXVlbnRXaWR0aCArIHN1YnNlcXVlbnRXaWR0aCk7XG4gIH07XG5cbiAgX3Byb3RvMi5pc0ZpeGVkV2lkdGggPSBmdW5jdGlvbiBpc0ZpeGVkV2lkdGgoY29udGV4dCkge1xuICAgIGlmIChjb250ZXh0LmlzU3RyaWN0KCkgPT09IGZhbHNlKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgcmV0dXJuIF9OdW1iZXJQcmludGVyUGFyc2VyLnByb3RvdHlwZS5pc0ZpeGVkV2lkdGguY2FsbCh0aGlzLCBjb250ZXh0KTtcbiAgfTtcblxuICBfcHJvdG8yLnRvU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG4gICAgcmV0dXJuICdSZWR1Y2VkVmFsdWUoJyArIHRoaXMuX2ZpZWxkICsgJywnICsgdGhpcy5fbWluV2lkdGggKyAnLCcgKyB0aGlzLl9tYXhXaWR0aCArICcsJyArICh0aGlzLl9iYXNlRGF0ZSAhPSBudWxsID8gdGhpcy5fYmFzZURhdGUgOiB0aGlzLl9iYXNlVmFsdWUpICsgJyknO1xuICB9O1xuXG4gIHJldHVybiBSZWR1Y2VkUHJpbnRlclBhcnNlcjtcbn0oTnVtYmVyUHJpbnRlclBhcnNlcik7XG5cbi8qKlxuICogQGNvcHlyaWdodCAoYykgMjAxNiwgUGhpbGlwcCBUaMO8cnfDpGNodGVyICYgUGF0dHJpY2sgSMO8cGVyXG4gKiBAY29weXJpZ2h0IChjKSAyMDA3LXByZXNlbnQsIFN0ZXBoZW4gQ29sZWJvdXJuZSAmIE1pY2hhZWwgTmFzY2ltZW50byBTYW50b3NcbiAqIEBsaWNlbnNlIEJTRC0zLUNsYXVzZSAoc2VlIExJQ0VOU0UgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUpXG4gKi9cbnZhciBQQVRURVJOUyA9IFsnK0hIJywgJytISG1tJywgJytISDptbScsICcrSEhNTScsICcrSEg6TU0nLCAnK0hITU1zcycsICcrSEg6TU06c3MnLCAnK0hITU1TUycsICcrSEg6TU06U1MnXTtcbnZhciBPZmZzZXRJZFByaW50ZXJQYXJzZXIgPSBmdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIE9mZnNldElkUHJpbnRlclBhcnNlcihub09mZnNldFRleHQsIHBhdHRlcm4pIHtcbiAgICByZXF1aXJlTm9uTnVsbChub09mZnNldFRleHQsICdub09mZnNldFRleHQnKTtcbiAgICByZXF1aXJlTm9uTnVsbChwYXR0ZXJuLCAncGF0dGVybicpO1xuICAgIHRoaXMubm9PZmZzZXRUZXh0ID0gbm9PZmZzZXRUZXh0O1xuICAgIHRoaXMudHlwZSA9IHRoaXMuX2NoZWNrUGF0dGVybihwYXR0ZXJuKTtcbiAgfVxuXG4gIHZhciBfcHJvdG8gPSBPZmZzZXRJZFByaW50ZXJQYXJzZXIucHJvdG90eXBlO1xuXG4gIF9wcm90by5fY2hlY2tQYXR0ZXJuID0gZnVuY3Rpb24gX2NoZWNrUGF0dGVybihwYXR0ZXJuKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBQQVRURVJOUy5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKFBBVFRFUk5TW2ldID09PSBwYXR0ZXJuKSB7XG4gICAgICAgIHJldHVybiBpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHRocm93IG5ldyBJbGxlZ2FsQXJndW1lbnRFeGNlcHRpb24oJ0ludmFsaWQgem9uZSBvZmZzZXQgcGF0dGVybjogJyArIHBhdHRlcm4pO1xuICB9O1xuXG4gIF9wcm90by5wcmludCA9IGZ1bmN0aW9uIHByaW50KGNvbnRleHQsIGJ1Zikge1xuICAgIHZhciBvZmZzZXRTZWNzID0gY29udGV4dC5nZXRWYWx1ZShDaHJvbm9GaWVsZC5PRkZTRVRfU0VDT05EUyk7XG5cbiAgICBpZiAob2Zmc2V0U2VjcyA9PSBudWxsKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgdmFyIHRvdGFsU2VjcyA9IE1hdGhVdGlsLnNhZmVUb0ludChvZmZzZXRTZWNzKTtcblxuICAgIGlmICh0b3RhbFNlY3MgPT09IDApIHtcbiAgICAgIGJ1Zi5hcHBlbmQodGhpcy5ub09mZnNldFRleHQpO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgYWJzSG91cnMgPSBNYXRoLmFicyhNYXRoVXRpbC5pbnRNb2QoTWF0aFV0aWwuaW50RGl2KHRvdGFsU2VjcywgMzYwMCksIDEwMCkpO1xuICAgICAgdmFyIGFic01pbnV0ZXMgPSBNYXRoLmFicyhNYXRoVXRpbC5pbnRNb2QoTWF0aFV0aWwuaW50RGl2KHRvdGFsU2VjcywgNjApLCA2MCkpO1xuICAgICAgdmFyIGFic1NlY29uZHMgPSBNYXRoLmFicyhNYXRoVXRpbC5pbnRNb2QodG90YWxTZWNzLCA2MCkpO1xuICAgICAgdmFyIGJ1ZlBvcyA9IGJ1Zi5sZW5ndGgoKTtcbiAgICAgIHZhciBvdXRwdXQgPSBhYnNIb3VycztcbiAgICAgIGJ1Zi5hcHBlbmQodG90YWxTZWNzIDwgMCA/ICctJyA6ICcrJykuYXBwZW5kQ2hhcihNYXRoVXRpbC5pbnREaXYoYWJzSG91cnMsIDEwKSArICcwJykuYXBwZW5kQ2hhcihNYXRoVXRpbC5pbnRNb2QoYWJzSG91cnMsIDEwKSArICcwJyk7XG5cbiAgICAgIGlmICh0aGlzLnR5cGUgPj0gMyB8fCB0aGlzLnR5cGUgPj0gMSAmJiBhYnNNaW51dGVzID4gMCkge1xuICAgICAgICBidWYuYXBwZW5kKHRoaXMudHlwZSAlIDIgPT09IDAgPyAnOicgOiAnJykuYXBwZW5kQ2hhcihNYXRoVXRpbC5pbnREaXYoYWJzTWludXRlcywgMTApICsgJzAnKS5hcHBlbmRDaGFyKGFic01pbnV0ZXMgJSAxMCArICcwJyk7XG4gICAgICAgIG91dHB1dCArPSBhYnNNaW51dGVzO1xuXG4gICAgICAgIGlmICh0aGlzLnR5cGUgPj0gNyB8fCB0aGlzLnR5cGUgPj0gNSAmJiBhYnNTZWNvbmRzID4gMCkge1xuICAgICAgICAgIGJ1Zi5hcHBlbmQodGhpcy50eXBlICUgMiA9PT0gMCA/ICc6JyA6ICcnKS5hcHBlbmRDaGFyKE1hdGhVdGlsLmludERpdihhYnNTZWNvbmRzLCAxMCkgKyAnMCcpLmFwcGVuZENoYXIoYWJzU2Vjb25kcyAlIDEwICsgJzAnKTtcbiAgICAgICAgICBvdXRwdXQgKz0gYWJzU2Vjb25kcztcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAob3V0cHV0ID09PSAwKSB7XG4gICAgICAgIGJ1Zi5zZXRMZW5ndGgoYnVmUG9zKTtcbiAgICAgICAgYnVmLmFwcGVuZCh0aGlzLm5vT2Zmc2V0VGV4dCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRydWU7XG4gIH07XG5cbiAgX3Byb3RvLnBhcnNlID0gZnVuY3Rpb24gcGFyc2UoY29udGV4dCwgdGV4dCwgcG9zaXRpb24pIHtcbiAgICB2YXIgbGVuZ3RoID0gdGV4dC5sZW5ndGg7XG4gICAgdmFyIG5vT2Zmc2V0TGVuID0gdGhpcy5ub09mZnNldFRleHQubGVuZ3RoO1xuXG4gICAgaWYgKG5vT2Zmc2V0TGVuID09PSAwKSB7XG4gICAgICBpZiAocG9zaXRpb24gPT09IGxlbmd0aCkge1xuICAgICAgICByZXR1cm4gY29udGV4dC5zZXRQYXJzZWRGaWVsZChDaHJvbm9GaWVsZC5PRkZTRVRfU0VDT05EUywgMCwgcG9zaXRpb24sIHBvc2l0aW9uKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHBvc2l0aW9uID09PSBsZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIH5wb3NpdGlvbjtcbiAgICAgIH1cblxuICAgICAgaWYgKGNvbnRleHQuc3ViU2VxdWVuY2VFcXVhbHModGV4dCwgcG9zaXRpb24sIHRoaXMubm9PZmZzZXRUZXh0LCAwLCBub09mZnNldExlbikpIHtcbiAgICAgICAgcmV0dXJuIGNvbnRleHQuc2V0UGFyc2VkRmllbGQoQ2hyb25vRmllbGQuT0ZGU0VUX1NFQ09ORFMsIDAsIHBvc2l0aW9uLCBwb3NpdGlvbiArIG5vT2Zmc2V0TGVuKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgc2lnbiA9IHRleHRbcG9zaXRpb25dO1xuXG4gICAgaWYgKHNpZ24gPT09ICcrJyB8fCBzaWduID09PSAnLScpIHtcbiAgICAgIHZhciBuZWdhdGl2ZSA9IHNpZ24gPT09ICctJyA/IC0xIDogMTtcbiAgICAgIHZhciBhcnJheSA9IFswLCAwLCAwLCAwXTtcbiAgICAgIGFycmF5WzBdID0gcG9zaXRpb24gKyAxO1xuXG4gICAgICBpZiAoKHRoaXMuX3BhcnNlTnVtYmVyKGFycmF5LCAxLCB0ZXh0LCB0cnVlKSB8fCB0aGlzLl9wYXJzZU51bWJlcihhcnJheSwgMiwgdGV4dCwgdGhpcy50eXBlID49IDMpIHx8IHRoaXMuX3BhcnNlTnVtYmVyKGFycmF5LCAzLCB0ZXh0LCBmYWxzZSkpID09PSBmYWxzZSkge1xuICAgICAgICB2YXIgb2Zmc2V0U2VjcyA9IE1hdGhVdGlsLnNhZmVaZXJvKG5lZ2F0aXZlICogKGFycmF5WzFdICogMzYwMCArIGFycmF5WzJdICogNjAgKyBhcnJheVszXSkpO1xuICAgICAgICByZXR1cm4gY29udGV4dC5zZXRQYXJzZWRGaWVsZChDaHJvbm9GaWVsZC5PRkZTRVRfU0VDT05EUywgb2Zmc2V0U2VjcywgcG9zaXRpb24sIGFycmF5WzBdKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAobm9PZmZzZXRMZW4gPT09IDApIHtcbiAgICAgIHJldHVybiBjb250ZXh0LnNldFBhcnNlZEZpZWxkKENocm9ub0ZpZWxkLk9GRlNFVF9TRUNPTkRTLCAwLCBwb3NpdGlvbiwgcG9zaXRpb24gKyBub09mZnNldExlbik7XG4gICAgfVxuXG4gICAgcmV0dXJuIH5wb3NpdGlvbjtcbiAgfTtcblxuICBfcHJvdG8uX3BhcnNlTnVtYmVyID0gZnVuY3Rpb24gX3BhcnNlTnVtYmVyKGFycmF5LCBhcnJheUluZGV4LCBwYXJzZVRleHQsIHJlcXVpcmVkKSB7XG4gICAgaWYgKCh0aGlzLnR5cGUgKyAzKSAvIDIgPCBhcnJheUluZGV4KSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgdmFyIHBvcyA9IGFycmF5WzBdO1xuXG4gICAgaWYgKHRoaXMudHlwZSAlIDIgPT09IDAgJiYgYXJyYXlJbmRleCA+IDEpIHtcbiAgICAgIGlmIChwb3MgKyAxID4gcGFyc2VUZXh0Lmxlbmd0aCB8fCBwYXJzZVRleHRbcG9zXSAhPT0gJzonKSB7XG4gICAgICAgIHJldHVybiByZXF1aXJlZDtcbiAgICAgIH1cblxuICAgICAgcG9zKys7XG4gICAgfVxuXG4gICAgaWYgKHBvcyArIDIgPiBwYXJzZVRleHQubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gcmVxdWlyZWQ7XG4gICAgfVxuXG4gICAgdmFyIGNoMSA9IHBhcnNlVGV4dFtwb3MrK107XG4gICAgdmFyIGNoMiA9IHBhcnNlVGV4dFtwb3MrK107XG5cbiAgICBpZiAoY2gxIDwgJzAnIHx8IGNoMSA+ICc5JyB8fCBjaDIgPCAnMCcgfHwgY2gyID4gJzknKSB7XG4gICAgICByZXR1cm4gcmVxdWlyZWQ7XG4gICAgfVxuXG4gICAgdmFyIHZhbHVlID0gKGNoMS5jaGFyQ29kZUF0KDApIC0gNDgpICogMTAgKyAoY2gyLmNoYXJDb2RlQXQoMCkgLSA0OCk7XG5cbiAgICBpZiAodmFsdWUgPCAwIHx8IHZhbHVlID4gNTkpIHtcbiAgICAgIHJldHVybiByZXF1aXJlZDtcbiAgICB9XG5cbiAgICBhcnJheVthcnJheUluZGV4XSA9IHZhbHVlO1xuICAgIGFycmF5WzBdID0gcG9zO1xuICAgIHJldHVybiBmYWxzZTtcbiAgfTtcblxuICBfcHJvdG8udG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZygpIHtcbiAgICB2YXIgY29udmVydGVkID0gdGhpcy5ub09mZnNldFRleHQucmVwbGFjZSgnXFwnJywgJ1xcJ1xcJycpO1xuICAgIHJldHVybiAnT2Zmc2V0KCcgKyBQQVRURVJOU1t0aGlzLnR5cGVdICsgJyxcXCcnICsgY29udmVydGVkICsgJ1xcJyknO1xuICB9O1xuXG4gIHJldHVybiBPZmZzZXRJZFByaW50ZXJQYXJzZXI7XG59KCk7XG5PZmZzZXRJZFByaW50ZXJQYXJzZXIuSU5TVEFOQ0VfSUQgPSBuZXcgT2Zmc2V0SWRQcmludGVyUGFyc2VyKCdaJywgJytISDpNTTpzcycpO1xuT2Zmc2V0SWRQcmludGVyUGFyc2VyLlBBVFRFUk5TID0gUEFUVEVSTlM7XG5cbi8qKlxuICogQGNvcHlyaWdodCAoYykgMjAxNiwgUGhpbGlwcCBUaMO8cnfDpGNodGVyICYgUGF0dHJpY2sgSMO8cGVyXG4gKiBAY29weXJpZ2h0IChjKSAyMDA3LXByZXNlbnQsIFN0ZXBoZW4gQ29sZWJvdXJuZSAmIE1pY2hhZWwgTmFzY2ltZW50byBTYW50b3NcbiAqIEBsaWNlbnNlIEJTRC0zLUNsYXVzZSAoc2VlIExJQ0VOU0UgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUpXG4gKi9cbnZhciBQYWRQcmludGVyUGFyc2VyRGVjb3JhdG9yID0gZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBQYWRQcmludGVyUGFyc2VyRGVjb3JhdG9yKHByaW50ZXJQYXJzZXIsIHBhZFdpZHRoLCBwYWRDaGFyKSB7XG4gICAgdGhpcy5fcHJpbnRlclBhcnNlciA9IHByaW50ZXJQYXJzZXI7XG4gICAgdGhpcy5fcGFkV2lkdGggPSBwYWRXaWR0aDtcbiAgICB0aGlzLl9wYWRDaGFyID0gcGFkQ2hhcjtcbiAgfVxuXG4gIHZhciBfcHJvdG8gPSBQYWRQcmludGVyUGFyc2VyRGVjb3JhdG9yLnByb3RvdHlwZTtcblxuICBfcHJvdG8ucHJpbnQgPSBmdW5jdGlvbiBwcmludChjb250ZXh0LCBidWYpIHtcbiAgICB2YXIgcHJlTGVuID0gYnVmLmxlbmd0aCgpO1xuXG4gICAgaWYgKHRoaXMuX3ByaW50ZXJQYXJzZXIucHJpbnQoY29udGV4dCwgYnVmKSA9PT0gZmFsc2UpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICB2YXIgbGVuID0gYnVmLmxlbmd0aCgpIC0gcHJlTGVuO1xuXG4gICAgaWYgKGxlbiA+IHRoaXMuX3BhZFdpZHRoKSB7XG4gICAgICB0aHJvdyBuZXcgRGF0ZVRpbWVFeGNlcHRpb24oXCJDYW5ub3QgcHJpbnQgYXMgb3V0cHV0IG9mIFwiICsgbGVuICsgXCIgY2hhcmFjdGVycyBleGNlZWRzIHBhZCB3aWR0aCBvZiBcIiArIHRoaXMuX3BhZFdpZHRoKTtcbiAgICB9XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuX3BhZFdpZHRoIC0gbGVuOyBpKyspIHtcbiAgICAgIGJ1Zi5pbnNlcnQocHJlTGVuLCB0aGlzLl9wYWRDaGFyKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfTtcblxuICBfcHJvdG8ucGFyc2UgPSBmdW5jdGlvbiBwYXJzZShjb250ZXh0LCB0ZXh0LCBwb3NpdGlvbikge1xuICAgIHZhciBzdHJpY3QgPSBjb250ZXh0LmlzU3RyaWN0KCk7XG4gICAgdmFyIGNhc2VTZW5zaXRpdmUgPSBjb250ZXh0LmlzQ2FzZVNlbnNpdGl2ZSgpO1xuICAgIGFzc2VydCghKHBvc2l0aW9uID4gdGV4dC5sZW5ndGgpKTtcbiAgICBhc3NlcnQocG9zaXRpb24gPj0gMCk7XG5cbiAgICBpZiAocG9zaXRpb24gPT09IHRleHQubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gfnBvc2l0aW9uO1xuICAgIH1cblxuICAgIHZhciBlbmRQb3MgPSBwb3NpdGlvbiArIHRoaXMuX3BhZFdpZHRoO1xuXG4gICAgaWYgKGVuZFBvcyA+IHRleHQubGVuZ3RoKSB7XG4gICAgICBpZiAoc3RyaWN0KSB7XG4gICAgICAgIHJldHVybiB+cG9zaXRpb247XG4gICAgICB9XG5cbiAgICAgIGVuZFBvcyA9IHRleHQubGVuZ3RoO1xuICAgIH1cblxuICAgIHZhciBwb3MgPSBwb3NpdGlvbjtcblxuICAgIHdoaWxlIChwb3MgPCBlbmRQb3MgJiYgKGNhc2VTZW5zaXRpdmUgPyB0ZXh0W3Bvc10gPT09IHRoaXMuX3BhZENoYXIgOiBjb250ZXh0LmNoYXJFcXVhbHModGV4dFtwb3NdLCB0aGlzLl9wYWRDaGFyKSkpIHtcbiAgICAgIHBvcysrO1xuICAgIH1cblxuICAgIHRleHQgPSB0ZXh0LnN1YnN0cmluZygwLCBlbmRQb3MpO1xuXG4gICAgdmFyIHJlc3VsdFBvcyA9IHRoaXMuX3ByaW50ZXJQYXJzZXIucGFyc2UoY29udGV4dCwgdGV4dCwgcG9zKTtcblxuICAgIGlmIChyZXN1bHRQb3MgIT09IGVuZFBvcyAmJiBzdHJpY3QpIHtcbiAgICAgIHJldHVybiB+KHBvc2l0aW9uICsgcG9zKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcmVzdWx0UG9zO1xuICB9O1xuXG4gIF9wcm90by50b1N0cmluZyA9IGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuICAgIHJldHVybiBcIlBhZChcIiArIHRoaXMuX3ByaW50ZXJQYXJzZXIgKyBcIixcIiArIHRoaXMuX3BhZFdpZHRoICsgKHRoaXMuX3BhZENoYXIgPT09ICcgJyA/ICcpJyA6ICcsXFwnJyArIHRoaXMuX3BhZENoYXIgKyAnXFwnKScpO1xuICB9O1xuXG4gIHJldHVybiBQYWRQcmludGVyUGFyc2VyRGVjb3JhdG9yO1xufSgpO1xuXG52YXIgU2V0dGluZ3NQYXJzZXIgPSBmdW5jdGlvbiAoX0VudW0pIHtcbiAgX2luaGVyaXRzTG9vc2UoU2V0dGluZ3NQYXJzZXIsIF9FbnVtKTtcblxuICBmdW5jdGlvbiBTZXR0aW5nc1BhcnNlcigpIHtcbiAgICByZXR1cm4gX0VudW0uYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICB9XG5cbiAgdmFyIF9wcm90byA9IFNldHRpbmdzUGFyc2VyLnByb3RvdHlwZTtcblxuICBfcHJvdG8ucHJpbnQgPSBmdW5jdGlvbiBwcmludCgpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfTtcblxuICBfcHJvdG8ucGFyc2UgPSBmdW5jdGlvbiBwYXJzZShjb250ZXh0LCB0ZXh0LCBwb3NpdGlvbikge1xuICAgIHN3aXRjaCAodGhpcykge1xuICAgICAgY2FzZSBTZXR0aW5nc1BhcnNlci5TRU5TSVRJVkU6XG4gICAgICAgIGNvbnRleHQuc2V0Q2FzZVNlbnNpdGl2ZSh0cnVlKTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgU2V0dGluZ3NQYXJzZXIuSU5TRU5TSVRJVkU6XG4gICAgICAgIGNvbnRleHQuc2V0Q2FzZVNlbnNpdGl2ZShmYWxzZSk7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlIFNldHRpbmdzUGFyc2VyLlNUUklDVDpcbiAgICAgICAgY29udGV4dC5zZXRTdHJpY3QodHJ1ZSk7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlIFNldHRpbmdzUGFyc2VyLkxFTklFTlQ6XG4gICAgICAgIGNvbnRleHQuc2V0U3RyaWN0KGZhbHNlKTtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgcmV0dXJuIHBvc2l0aW9uO1xuICB9O1xuXG4gIF9wcm90by50b1N0cmluZyA9IGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuICAgIHN3aXRjaCAodGhpcykge1xuICAgICAgY2FzZSBTZXR0aW5nc1BhcnNlci5TRU5TSVRJVkU6XG4gICAgICAgIHJldHVybiAnUGFyc2VDYXNlU2Vuc2l0aXZlKHRydWUpJztcblxuICAgICAgY2FzZSBTZXR0aW5nc1BhcnNlci5JTlNFTlNJVElWRTpcbiAgICAgICAgcmV0dXJuICdQYXJzZUNhc2VTZW5zaXRpdmUoZmFsc2UpJztcblxuICAgICAgY2FzZSBTZXR0aW5nc1BhcnNlci5TVFJJQ1Q6XG4gICAgICAgIHJldHVybiAnUGFyc2VTdHJpY3QodHJ1ZSknO1xuXG4gICAgICBjYXNlIFNldHRpbmdzUGFyc2VyLkxFTklFTlQ6XG4gICAgICAgIHJldHVybiAnUGFyc2VTdHJpY3QoZmFsc2UpJztcbiAgICB9XG4gIH07XG5cbiAgcmV0dXJuIFNldHRpbmdzUGFyc2VyO1xufShFbnVtKTtcblNldHRpbmdzUGFyc2VyLlNFTlNJVElWRSA9IG5ldyBTZXR0aW5nc1BhcnNlcignU0VOU0lUSVZFJyk7XG5TZXR0aW5nc1BhcnNlci5JTlNFTlNJVElWRSA9IG5ldyBTZXR0aW5nc1BhcnNlcignSU5TRU5TSVRJVkUnKTtcblNldHRpbmdzUGFyc2VyLlNUUklDVCA9IG5ldyBTZXR0aW5nc1BhcnNlcignU1RSSUNUJyk7XG5TZXR0aW5nc1BhcnNlci5MRU5JRU5UID0gbmV3IFNldHRpbmdzUGFyc2VyKCdMRU5JRU5UJyk7XG5cbi8qKlxuICogQGNvcHlyaWdodCAoYykgMjAxNiwgUGhpbGlwcCBUaMO8cnfDpGNodGVyICYgUGF0dHJpY2sgSMO8cGVyXG4gKiBAY29weXJpZ2h0IChjKSAyMDA3LXByZXNlbnQsIFN0ZXBoZW4gQ29sZWJvdXJuZSAmIE1pY2hhZWwgTmFzY2ltZW50byBTYW50b3NcbiAqIEBsaWNlbnNlIEJTRC0zLUNsYXVzZSAoc2VlIExJQ0VOU0UgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUpXG4gKi9cbnZhciBTdHJpbmdMaXRlcmFsUHJpbnRlclBhcnNlciA9IGZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gU3RyaW5nTGl0ZXJhbFByaW50ZXJQYXJzZXIobGl0ZXJhbCkge1xuICAgIHRoaXMuX2xpdGVyYWwgPSBsaXRlcmFsO1xuICB9XG5cbiAgdmFyIF9wcm90byA9IFN0cmluZ0xpdGVyYWxQcmludGVyUGFyc2VyLnByb3RvdHlwZTtcblxuICBfcHJvdG8ucHJpbnQgPSBmdW5jdGlvbiBwcmludChjb250ZXh0LCBidWYpIHtcbiAgICBidWYuYXBwZW5kKHRoaXMuX2xpdGVyYWwpO1xuICAgIHJldHVybiB0cnVlO1xuICB9O1xuXG4gIF9wcm90by5wYXJzZSA9IGZ1bmN0aW9uIHBhcnNlKGNvbnRleHQsIHRleHQsIHBvc2l0aW9uKSB7XG4gICAgdmFyIGxlbmd0aCA9IHRleHQubGVuZ3RoO1xuICAgIGFzc2VydCghKHBvc2l0aW9uID4gbGVuZ3RoIHx8IHBvc2l0aW9uIDwgMCkpO1xuXG4gICAgaWYgKGNvbnRleHQuc3ViU2VxdWVuY2VFcXVhbHModGV4dCwgcG9zaXRpb24sIHRoaXMuX2xpdGVyYWwsIDAsIHRoaXMuX2xpdGVyYWwubGVuZ3RoKSA9PT0gZmFsc2UpIHtcbiAgICAgIHJldHVybiB+cG9zaXRpb247XG4gICAgfVxuXG4gICAgcmV0dXJuIHBvc2l0aW9uICsgdGhpcy5fbGl0ZXJhbC5sZW5ndGg7XG4gIH07XG5cbiAgX3Byb3RvLnRvU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG4gICAgdmFyIGNvbnZlcnRlZCA9IHRoaXMuX2xpdGVyYWwucmVwbGFjZShcIidcIiwgXCInJ1wiKTtcblxuICAgIHJldHVybiAnXFwnJyArIGNvbnZlcnRlZCArICdcXCcnO1xuICB9O1xuXG4gIHJldHVybiBTdHJpbmdMaXRlcmFsUHJpbnRlclBhcnNlcjtcbn0oKTtcblxuLypcbiAqIEBjb3B5cmlnaHQgKGMpIDIwMTYsIFBoaWxpcHAgVGjDvHJ3w6RjaHRlciwgUGF0dHJpY2sgSMO8cGVyXG4gKiBAY29weXJpZ2h0IChjKSAyMDA3LXByZXNlbnQsIFN0ZXBoZW4gQ29sZWJvdXJuZSAmIE1pY2hhZWwgTmFzY2ltZW50byBTYW50b3NcbiAqIEBsaWNlbnNlIEJTRC0zLUNsYXVzZSAoc2VlIExJQ0VOU0UgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUpXG4gKi9cbnZhciBab25lUnVsZXNQcm92aWRlciA9IGZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gWm9uZVJ1bGVzUHJvdmlkZXIoKSB7fVxuXG4gIFpvbmVSdWxlc1Byb3ZpZGVyLmdldFJ1bGVzID0gZnVuY3Rpb24gZ2V0UnVsZXMoem9uZUlkKSB7XG4gICAgdGhyb3cgbmV3IERhdGVUaW1lRXhjZXB0aW9uKCd1bnN1cHBvcnRlZCBab25lSWQ6JyArIHpvbmVJZCk7XG4gIH07XG5cbiAgWm9uZVJ1bGVzUHJvdmlkZXIuZ2V0QXZhaWxhYmxlWm9uZUlkcyA9IGZ1bmN0aW9uIGdldEF2YWlsYWJsZVpvbmVJZHMoKSB7XG4gICAgcmV0dXJuIFtdO1xuICB9O1xuXG4gIHJldHVybiBab25lUnVsZXNQcm92aWRlcjtcbn0oKTtcblxudmFyIFpvbmVSZWdpb24gPSBmdW5jdGlvbiAoX1pvbmVJZCkge1xuICBfaW5oZXJpdHNMb29zZShab25lUmVnaW9uLCBfWm9uZUlkKTtcblxuICBab25lUmVnaW9uLm9mSWQgPSBmdW5jdGlvbiBvZklkKHpvbmVJZCkge1xuICAgIHZhciBydWxlcyA9IFpvbmVSdWxlc1Byb3ZpZGVyLmdldFJ1bGVzKHpvbmVJZCk7XG4gICAgcmV0dXJuIG5ldyBab25lUmVnaW9uKHpvbmVJZCwgcnVsZXMpO1xuICB9O1xuXG4gIGZ1bmN0aW9uIFpvbmVSZWdpb24oaWQsIHJ1bGVzKSB7XG4gICAgdmFyIF90aGlzO1xuXG4gICAgX3RoaXMgPSBfWm9uZUlkLmNhbGwodGhpcykgfHwgdGhpcztcbiAgICBfdGhpcy5faWQgPSBpZDtcbiAgICBfdGhpcy5fcnVsZXMgPSBydWxlcztcbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cblxuICB2YXIgX3Byb3RvID0gWm9uZVJlZ2lvbi5wcm90b3R5cGU7XG5cbiAgX3Byb3RvLmlkID0gZnVuY3Rpb24gaWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2lkO1xuICB9O1xuXG4gIF9wcm90by5ydWxlcyA9IGZ1bmN0aW9uIHJ1bGVzKCkge1xuICAgIHJldHVybiB0aGlzLl9ydWxlcztcbiAgfTtcblxuICByZXR1cm4gWm9uZVJlZ2lvbjtcbn0oWm9uZUlkKTtcblxuLyoqXG4gKiBAY29weXJpZ2h0IChjKSAyMDE2LCBQaGlsaXBwIFRow7xyd8OkY2h0ZXIgJiBQYXR0cmljayBIw7xwZXJcbiAqIEBjb3B5cmlnaHQgKGMpIDIwMDctcHJlc2VudCwgU3RlcGhlbiBDb2xlYm91cm5lICYgTWljaGFlbCBOYXNjaW1lbnRvIFNhbnRvc1xuICogQGxpY2Vuc2UgQlNELTMtQ2xhdXNlIChzZWUgTElDRU5TRSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZSlcbiAqL1xudmFyIFpvbmVJZFByaW50ZXJQYXJzZXIgPSBmdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIFpvbmVJZFByaW50ZXJQYXJzZXIocXVlcnksIGRlc2NyaXB0aW9uKSB7XG4gICAgdGhpcy5xdWVyeSA9IHF1ZXJ5O1xuICAgIHRoaXMuZGVzY3JpcHRpb24gPSBkZXNjcmlwdGlvbjtcbiAgfVxuXG4gIHZhciBfcHJvdG8gPSBab25lSWRQcmludGVyUGFyc2VyLnByb3RvdHlwZTtcblxuICBfcHJvdG8ucHJpbnQgPSBmdW5jdGlvbiBwcmludChjb250ZXh0LCBidWYpIHtcbiAgICB2YXIgem9uZSA9IGNvbnRleHQuZ2V0VmFsdWVRdWVyeSh0aGlzLnF1ZXJ5KTtcblxuICAgIGlmICh6b25lID09IG51bGwpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBidWYuYXBwZW5kKHpvbmUuaWQoKSk7XG4gICAgcmV0dXJuIHRydWU7XG4gIH07XG5cbiAgX3Byb3RvLnBhcnNlID0gZnVuY3Rpb24gcGFyc2UoY29udGV4dCwgdGV4dCwgcG9zaXRpb24pIHtcbiAgICB2YXIgbGVuZ3RoID0gdGV4dC5sZW5ndGg7XG5cbiAgICBpZiAocG9zaXRpb24gPiBsZW5ndGgpIHtcbiAgICAgIHJldHVybiB+cG9zaXRpb247XG4gICAgfVxuXG4gICAgaWYgKHBvc2l0aW9uID09PSBsZW5ndGgpIHtcbiAgICAgIHJldHVybiB+cG9zaXRpb247XG4gICAgfVxuXG4gICAgdmFyIG5leHRDaGFyID0gdGV4dC5jaGFyQXQocG9zaXRpb24pO1xuXG4gICAgaWYgKG5leHRDaGFyID09PSAnKycgfHwgbmV4dENoYXIgPT09ICctJykge1xuICAgICAgdmFyIG5ld0NvbnRleHQgPSBjb250ZXh0LmNvcHkoKTtcbiAgICAgIHZhciBlbmRQb3MgPSBPZmZzZXRJZFByaW50ZXJQYXJzZXIuSU5TVEFOQ0VfSUQucGFyc2UobmV3Q29udGV4dCwgdGV4dCwgcG9zaXRpb24pO1xuXG4gICAgICBpZiAoZW5kUG9zIDwgMCkge1xuICAgICAgICByZXR1cm4gZW5kUG9zO1xuICAgICAgfVxuXG4gICAgICB2YXIgb2Zmc2V0ID0gbmV3Q29udGV4dC5nZXRQYXJzZWQoQ2hyb25vRmllbGQuT0ZGU0VUX1NFQ09ORFMpO1xuICAgICAgdmFyIHpvbmUgPSBab25lT2Zmc2V0Lm9mVG90YWxTZWNvbmRzKG9mZnNldCk7XG4gICAgICBjb250ZXh0LnNldFBhcnNlZFpvbmUoem9uZSk7XG4gICAgICByZXR1cm4gZW5kUG9zO1xuICAgIH0gZWxzZSBpZiAobGVuZ3RoID49IHBvc2l0aW9uICsgMikge1xuICAgICAgdmFyIG5leHROZXh0Q2hhciA9IHRleHQuY2hhckF0KHBvc2l0aW9uICsgMSk7XG5cbiAgICAgIGlmIChjb250ZXh0LmNoYXJFcXVhbHMobmV4dENoYXIsICdVJykgJiYgY29udGV4dC5jaGFyRXF1YWxzKG5leHROZXh0Q2hhciwgJ1QnKSkge1xuICAgICAgICBpZiAobGVuZ3RoID49IHBvc2l0aW9uICsgMyAmJiBjb250ZXh0LmNoYXJFcXVhbHModGV4dC5jaGFyQXQocG9zaXRpb24gKyAyKSwgJ0MnKSkge1xuICAgICAgICAgIHJldHVybiB0aGlzLl9wYXJzZVByZWZpeGVkT2Zmc2V0KGNvbnRleHQsIHRleHQsIHBvc2l0aW9uLCBwb3NpdGlvbiArIDMpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuX3BhcnNlUHJlZml4ZWRPZmZzZXQoY29udGV4dCwgdGV4dCwgcG9zaXRpb24sIHBvc2l0aW9uICsgMik7XG4gICAgICB9IGVsc2UgaWYgKGNvbnRleHQuY2hhckVxdWFscyhuZXh0Q2hhciwgJ0cnKSAmJiBsZW5ndGggPj0gcG9zaXRpb24gKyAzICYmIGNvbnRleHQuY2hhckVxdWFscyhuZXh0TmV4dENoYXIsICdNJykgJiYgY29udGV4dC5jaGFyRXF1YWxzKHRleHQuY2hhckF0KHBvc2l0aW9uICsgMiksICdUJykpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3BhcnNlUHJlZml4ZWRPZmZzZXQoY29udGV4dCwgdGV4dCwgcG9zaXRpb24sIHBvc2l0aW9uICsgMyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHRleHQuc3Vic3RyKHBvc2l0aW9uLCA2KSA9PT0gJ1NZU1RFTScpIHtcbiAgICAgIGNvbnRleHQuc2V0UGFyc2VkWm9uZShab25lSWQuc3lzdGVtRGVmYXVsdCgpKTtcbiAgICAgIHJldHVybiBwb3NpdGlvbiArIDY7XG4gICAgfVxuXG4gICAgaWYgKGNvbnRleHQuY2hhckVxdWFscyhuZXh0Q2hhciwgJ1onKSkge1xuICAgICAgY29udGV4dC5zZXRQYXJzZWRab25lKFpvbmVPZmZzZXQuVVRDKTtcbiAgICAgIHJldHVybiBwb3NpdGlvbiArIDE7XG4gICAgfVxuXG4gICAgdmFyIGF2YWlsYWJsZVpvbmVJZHMgPSBab25lUnVsZXNQcm92aWRlci5nZXRBdmFpbGFibGVab25lSWRzKCk7XG5cbiAgICBpZiAoem9uZUlkVHJlZS5zaXplICE9PSBhdmFpbGFibGVab25lSWRzLmxlbmd0aCkge1xuICAgICAgem9uZUlkVHJlZSA9IFpvbmVJZFRyZWUuY3JlYXRlVHJlZU1hcChhdmFpbGFibGVab25lSWRzKTtcbiAgICB9XG5cbiAgICB2YXIgbWF4UGFyc2VMZW5ndGggPSBsZW5ndGggLSBwb3NpdGlvbjtcbiAgICB2YXIgdHJlZU1hcCA9IHpvbmVJZFRyZWUudHJlZU1hcDtcbiAgICB2YXIgcGFyc2VkWm9uZUlkID0gbnVsbDtcbiAgICB2YXIgcGFyc2VMZW5ndGggPSAwO1xuXG4gICAgd2hpbGUgKHRyZWVNYXAgIT0gbnVsbCkge1xuICAgICAgdmFyIHBhcnNlZFN1YlpvbmVJZCA9IHRleHQuc3Vic3RyKHBvc2l0aW9uLCBNYXRoLm1pbih0cmVlTWFwLmxlbmd0aCwgbWF4UGFyc2VMZW5ndGgpKTtcbiAgICAgIHRyZWVNYXAgPSB0cmVlTWFwLmdldChwYXJzZWRTdWJab25lSWQpO1xuXG4gICAgICBpZiAodHJlZU1hcCAhPSBudWxsICYmIHRyZWVNYXAuaXNMZWFmKSB7XG4gICAgICAgIHBhcnNlZFpvbmVJZCA9IHBhcnNlZFN1YlpvbmVJZDtcbiAgICAgICAgcGFyc2VMZW5ndGggPSB0cmVlTWFwLmxlbmd0aDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAocGFyc2VkWm9uZUlkICE9IG51bGwpIHtcbiAgICAgIGNvbnRleHQuc2V0UGFyc2VkWm9uZShab25lUmVnaW9uLm9mSWQocGFyc2VkWm9uZUlkKSk7XG4gICAgICByZXR1cm4gcG9zaXRpb24gKyBwYXJzZUxlbmd0aDtcbiAgICB9XG5cbiAgICByZXR1cm4gfnBvc2l0aW9uO1xuICB9O1xuXG4gIF9wcm90by5fcGFyc2VQcmVmaXhlZE9mZnNldCA9IGZ1bmN0aW9uIF9wYXJzZVByZWZpeGVkT2Zmc2V0KGNvbnRleHQsIHRleHQsIHByZWZpeFBvcywgcG9zaXRpb24pIHtcbiAgICB2YXIgcHJlZml4ID0gdGV4dC5zdWJzdHJpbmcocHJlZml4UG9zLCBwb3NpdGlvbikudG9VcHBlckNhc2UoKTtcbiAgICB2YXIgbmV3Q29udGV4dCA9IGNvbnRleHQuY29weSgpO1xuXG4gICAgaWYgKHBvc2l0aW9uIDwgdGV4dC5sZW5ndGggJiYgY29udGV4dC5jaGFyRXF1YWxzKHRleHQuY2hhckF0KHBvc2l0aW9uKSwgJ1onKSkge1xuICAgICAgY29udGV4dC5zZXRQYXJzZWRab25lKFpvbmVJZC5vZk9mZnNldChwcmVmaXgsIFpvbmVPZmZzZXQuVVRDKSk7XG4gICAgICByZXR1cm4gcG9zaXRpb247XG4gICAgfVxuXG4gICAgdmFyIGVuZFBvcyA9IE9mZnNldElkUHJpbnRlclBhcnNlci5JTlNUQU5DRV9JRC5wYXJzZShuZXdDb250ZXh0LCB0ZXh0LCBwb3NpdGlvbik7XG5cbiAgICBpZiAoZW5kUG9zIDwgMCkge1xuICAgICAgY29udGV4dC5zZXRQYXJzZWRab25lKFpvbmVJZC5vZk9mZnNldChwcmVmaXgsIFpvbmVPZmZzZXQuVVRDKSk7XG4gICAgICByZXR1cm4gcG9zaXRpb247XG4gICAgfVxuXG4gICAgdmFyIG9mZnNldFNlY3MgPSBuZXdDb250ZXh0LmdldFBhcnNlZChDaHJvbm9GaWVsZC5PRkZTRVRfU0VDT05EUyk7XG4gICAgdmFyIG9mZnNldCA9IFpvbmVPZmZzZXQub2ZUb3RhbFNlY29uZHMob2Zmc2V0U2Vjcyk7XG4gICAgY29udGV4dC5zZXRQYXJzZWRab25lKFpvbmVJZC5vZk9mZnNldChwcmVmaXgsIG9mZnNldCkpO1xuICAgIHJldHVybiBlbmRQb3M7XG4gIH07XG5cbiAgX3Byb3RvLnRvU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG4gICAgcmV0dXJuIHRoaXMuZGVzY3JpcHRpb247XG4gIH07XG5cbiAgcmV0dXJuIFpvbmVJZFByaW50ZXJQYXJzZXI7XG59KCk7XG5cbnZhciBab25lSWRUcmVlID0gZnVuY3Rpb24gKCkge1xuICBab25lSWRUcmVlLmNyZWF0ZVRyZWVNYXAgPSBmdW5jdGlvbiBjcmVhdGVUcmVlTWFwKGF2YWlsYWJsZVpvbmVJZHMpIHtcbiAgICB2YXIgc29ydGVkWm9uZUlkcyA9IGF2YWlsYWJsZVpvbmVJZHMuc29ydChmdW5jdGlvbiAoYSwgYikge1xuICAgICAgcmV0dXJuIGEubGVuZ3RoIC0gYi5sZW5ndGg7XG4gICAgfSk7XG4gICAgdmFyIHRyZWVNYXAgPSBuZXcgWm9uZUlkVHJlZU1hcChzb3J0ZWRab25lSWRzWzBdLmxlbmd0aCwgZmFsc2UpO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzb3J0ZWRab25lSWRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB0cmVlTWFwLmFkZChzb3J0ZWRab25lSWRzW2ldKTtcbiAgICB9XG5cbiAgICByZXR1cm4gbmV3IFpvbmVJZFRyZWUoc29ydGVkWm9uZUlkcy5sZW5ndGgsIHRyZWVNYXApO1xuICB9O1xuXG4gIGZ1bmN0aW9uIFpvbmVJZFRyZWUoc2l6ZSwgdHJlZU1hcCkge1xuICAgIHRoaXMuc2l6ZSA9IHNpemU7XG4gICAgdGhpcy50cmVlTWFwID0gdHJlZU1hcDtcbiAgfVxuXG4gIHJldHVybiBab25lSWRUcmVlO1xufSgpO1xuXG52YXIgWm9uZUlkVHJlZU1hcCA9IGZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gWm9uZUlkVHJlZU1hcChsZW5ndGgsIGlzTGVhZikge1xuICAgIGlmIChsZW5ndGggPT09IHZvaWQgMCkge1xuICAgICAgbGVuZ3RoID0gMDtcbiAgICB9XG5cbiAgICBpZiAoaXNMZWFmID09PSB2b2lkIDApIHtcbiAgICAgIGlzTGVhZiA9IGZhbHNlO1xuICAgIH1cblxuICAgIHRoaXMubGVuZ3RoID0gbGVuZ3RoO1xuICAgIHRoaXMuaXNMZWFmID0gaXNMZWFmO1xuICAgIHRoaXMuX3RyZWVNYXAgPSB7fTtcbiAgfVxuXG4gIHZhciBfcHJvdG8yID0gWm9uZUlkVHJlZU1hcC5wcm90b3R5cGU7XG5cbiAgX3Byb3RvMi5hZGQgPSBmdW5jdGlvbiBhZGQoem9uZUlkKSB7XG4gICAgdmFyIGlkTGVuZ3RoID0gem9uZUlkLmxlbmd0aDtcblxuICAgIGlmIChpZExlbmd0aCA9PT0gdGhpcy5sZW5ndGgpIHtcbiAgICAgIHRoaXMuX3RyZWVNYXBbem9uZUlkXSA9IG5ldyBab25lSWRUcmVlTWFwKGlkTGVuZ3RoLCB0cnVlKTtcbiAgICB9IGVsc2UgaWYgKGlkTGVuZ3RoID4gdGhpcy5sZW5ndGgpIHtcbiAgICAgIHZhciBzdWJab25lSWQgPSB6b25lSWQuc3Vic3RyKDAsIHRoaXMubGVuZ3RoKTtcbiAgICAgIHZhciBzdWJUcmVlTWFwID0gdGhpcy5fdHJlZU1hcFtzdWJab25lSWRdO1xuXG4gICAgICBpZiAoc3ViVHJlZU1hcCA9PSBudWxsKSB7XG4gICAgICAgIHN1YlRyZWVNYXAgPSBuZXcgWm9uZUlkVHJlZU1hcChpZExlbmd0aCwgZmFsc2UpO1xuICAgICAgICB0aGlzLl90cmVlTWFwW3N1YlpvbmVJZF0gPSBzdWJUcmVlTWFwO1xuICAgICAgfVxuXG4gICAgICBzdWJUcmVlTWFwLmFkZCh6b25lSWQpO1xuICAgIH1cbiAgfTtcblxuICBfcHJvdG8yLmdldCA9IGZ1bmN0aW9uIGdldCh6b25lSWQpIHtcbiAgICByZXR1cm4gdGhpcy5fdHJlZU1hcFt6b25lSWRdO1xuICB9O1xuXG4gIHJldHVybiBab25lSWRUcmVlTWFwO1xufSgpO1xuXG52YXIgem9uZUlkVHJlZSA9IG5ldyBab25lSWRUcmVlKFtdKTtcblxuLyoqXG4gKiBAY29weXJpZ2h0IChjKSAyMDE2LCBQaGlsaXBwIFRow7xyd8OkY2h0ZXIgJiBQYXR0cmljayBIw7xwZXJcbiAqIEBjb3B5cmlnaHQgKGMpIDIwMDctcHJlc2VudCwgU3RlcGhlbiBDb2xlYm91cm5lICYgTWljaGFlbCBOYXNjaW1lbnRvIFNhbnRvc1xuICogQGxpY2Vuc2UgQlNELTMtQ2xhdXNlIChzZWUgTElDRU5TRSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZSlcbiAqL1xudmFyIE1BWF9XSURUSCQxID0gMTU7XG52YXIgRGF0ZVRpbWVGb3JtYXR0ZXJCdWlsZGVyID0gZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBEYXRlVGltZUZvcm1hdHRlckJ1aWxkZXIoKSB7XG4gICAgdGhpcy5fYWN0aXZlID0gdGhpcztcbiAgICB0aGlzLl9wYXJlbnQgPSBudWxsO1xuICAgIHRoaXMuX3ByaW50ZXJQYXJzZXJzID0gW107XG4gICAgdGhpcy5fb3B0aW9uYWwgPSBmYWxzZTtcbiAgICB0aGlzLl9wYWROZXh0V2lkdGggPSAwO1xuICAgIHRoaXMuX3BhZE5leHRDaGFyID0gbnVsbDtcbiAgICB0aGlzLl92YWx1ZVBhcnNlckluZGV4ID0gLTE7XG4gIH1cblxuICBEYXRlVGltZUZvcm1hdHRlckJ1aWxkZXIuX29mID0gZnVuY3Rpb24gX29mKHBhcmVudCwgb3B0aW9uYWwpIHtcbiAgICByZXF1aXJlTm9uTnVsbChwYXJlbnQsICdwYXJlbnQnKTtcbiAgICByZXF1aXJlTm9uTnVsbChvcHRpb25hbCwgJ29wdGlvbmFsJyk7XG4gICAgdmFyIGR0Rm9ybWF0dGVyQnVpbGRlciA9IG5ldyBEYXRlVGltZUZvcm1hdHRlckJ1aWxkZXIoKTtcbiAgICBkdEZvcm1hdHRlckJ1aWxkZXIuX3BhcmVudCA9IHBhcmVudDtcbiAgICBkdEZvcm1hdHRlckJ1aWxkZXIuX29wdGlvbmFsID0gb3B0aW9uYWw7XG4gICAgcmV0dXJuIGR0Rm9ybWF0dGVyQnVpbGRlcjtcbiAgfTtcblxuICB2YXIgX3Byb3RvID0gRGF0ZVRpbWVGb3JtYXR0ZXJCdWlsZGVyLnByb3RvdHlwZTtcblxuICBfcHJvdG8ucGFyc2VDYXNlU2Vuc2l0aXZlID0gZnVuY3Rpb24gcGFyc2VDYXNlU2Vuc2l0aXZlKCkge1xuICAgIHRoaXMuX2FwcGVuZEludGVybmFsUHJpbnRlclBhcnNlcihTZXR0aW5nc1BhcnNlci5TRU5TSVRJVkUpO1xuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgX3Byb3RvLnBhcnNlQ2FzZUluc2Vuc2l0aXZlID0gZnVuY3Rpb24gcGFyc2VDYXNlSW5zZW5zaXRpdmUoKSB7XG4gICAgdGhpcy5fYXBwZW5kSW50ZXJuYWxQcmludGVyUGFyc2VyKFNldHRpbmdzUGFyc2VyLklOU0VOU0lUSVZFKTtcblxuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIF9wcm90by5wYXJzZVN0cmljdCA9IGZ1bmN0aW9uIHBhcnNlU3RyaWN0KCkge1xuICAgIHRoaXMuX2FwcGVuZEludGVybmFsUHJpbnRlclBhcnNlcihTZXR0aW5nc1BhcnNlci5TVFJJQ1QpO1xuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgX3Byb3RvLnBhcnNlTGVuaWVudCA9IGZ1bmN0aW9uIHBhcnNlTGVuaWVudCgpIHtcbiAgICB0aGlzLl9hcHBlbmRJbnRlcm5hbFByaW50ZXJQYXJzZXIoU2V0dGluZ3NQYXJzZXIuTEVOSUVOVCk7XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICBfcHJvdG8uYXBwZW5kVmFsdWUgPSBmdW5jdGlvbiBhcHBlbmRWYWx1ZSgpIHtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgcmV0dXJuIHRoaXMuX2FwcGVuZFZhbHVlMS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH0gZWxzZSBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMikge1xuICAgICAgcmV0dXJuIHRoaXMuX2FwcGVuZFZhbHVlMi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gdGhpcy5fYXBwZW5kVmFsdWU0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuICB9O1xuXG4gIF9wcm90by5fYXBwZW5kVmFsdWUxID0gZnVuY3Rpb24gX2FwcGVuZFZhbHVlMShmaWVsZCkge1xuICAgIHJlcXVpcmVOb25OdWxsKGZpZWxkKTtcblxuICAgIHRoaXMuX2FwcGVuZFZhbHVlUHJpbnRlclBhcnNlcihuZXcgTnVtYmVyUHJpbnRlclBhcnNlcihmaWVsZCwgMSwgTUFYX1dJRFRIJDEsIFNpZ25TdHlsZS5OT1JNQUwpKTtcblxuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIF9wcm90by5fYXBwZW5kVmFsdWUyID0gZnVuY3Rpb24gX2FwcGVuZFZhbHVlMihmaWVsZCwgd2lkdGgpIHtcbiAgICByZXF1aXJlTm9uTnVsbChmaWVsZCk7XG5cbiAgICBpZiAod2lkdGggPCAxIHx8IHdpZHRoID4gTUFYX1dJRFRIJDEpIHtcbiAgICAgIHRocm93IG5ldyBJbGxlZ2FsQXJndW1lbnRFeGNlcHRpb24oXCJUaGUgd2lkdGggbXVzdCBiZSBmcm9tIDEgdG8gXCIgKyBNQVhfV0lEVEgkMSArIFwiIGluY2x1c2l2ZSBidXQgd2FzIFwiICsgd2lkdGgpO1xuICAgIH1cblxuICAgIHZhciBwcCA9IG5ldyBOdW1iZXJQcmludGVyUGFyc2VyKGZpZWxkLCB3aWR0aCwgd2lkdGgsIFNpZ25TdHlsZS5OT1RfTkVHQVRJVkUpO1xuXG4gICAgdGhpcy5fYXBwZW5kVmFsdWVQcmludGVyUGFyc2VyKHBwKTtcblxuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIF9wcm90by5fYXBwZW5kVmFsdWU0ID0gZnVuY3Rpb24gX2FwcGVuZFZhbHVlNChmaWVsZCwgbWluV2lkdGgsIG1heFdpZHRoLCBzaWduU3R5bGUpIHtcbiAgICByZXF1aXJlTm9uTnVsbChmaWVsZCk7XG4gICAgcmVxdWlyZU5vbk51bGwoc2lnblN0eWxlKTtcblxuICAgIGlmIChtaW5XaWR0aCA9PT0gbWF4V2lkdGggJiYgc2lnblN0eWxlID09PSBTaWduU3R5bGUuTk9UX05FR0FUSVZFKSB7XG4gICAgICByZXR1cm4gdGhpcy5fYXBwZW5kVmFsdWUyKGZpZWxkLCBtYXhXaWR0aCk7XG4gICAgfVxuXG4gICAgaWYgKG1pbldpZHRoIDwgMSB8fCBtaW5XaWR0aCA+IE1BWF9XSURUSCQxKSB7XG4gICAgICB0aHJvdyBuZXcgSWxsZWdhbEFyZ3VtZW50RXhjZXB0aW9uKFwiVGhlIG1pbmltdW0gd2lkdGggbXVzdCBiZSBmcm9tIDEgdG8gXCIgKyBNQVhfV0lEVEgkMSArIFwiIGluY2x1c2l2ZSBidXQgd2FzIFwiICsgbWluV2lkdGgpO1xuICAgIH1cblxuICAgIGlmIChtYXhXaWR0aCA8IDEgfHwgbWF4V2lkdGggPiBNQVhfV0lEVEgkMSkge1xuICAgICAgdGhyb3cgbmV3IElsbGVnYWxBcmd1bWVudEV4Y2VwdGlvbihcIlRoZSBtaW5pbXVtIHdpZHRoIG11c3QgYmUgZnJvbSAxIHRvIFwiICsgTUFYX1dJRFRIJDEgKyBcIiBpbmNsdXNpdmUgYnV0IHdhcyBcIiArIG1heFdpZHRoKTtcbiAgICB9XG5cbiAgICBpZiAobWF4V2lkdGggPCBtaW5XaWR0aCkge1xuICAgICAgdGhyb3cgbmV3IElsbGVnYWxBcmd1bWVudEV4Y2VwdGlvbihcIlRoZSBtYXhpbXVtIHdpZHRoIG11c3QgZXhjZWVkIG9yIGVxdWFsIHRoZSBtaW5pbXVtIHdpZHRoIGJ1dCBcIiArIG1heFdpZHRoICsgXCIgPCBcIiArIG1pbldpZHRoKTtcbiAgICB9XG5cbiAgICB2YXIgcHAgPSBuZXcgTnVtYmVyUHJpbnRlclBhcnNlcihmaWVsZCwgbWluV2lkdGgsIG1heFdpZHRoLCBzaWduU3R5bGUpO1xuXG4gICAgdGhpcy5fYXBwZW5kVmFsdWVQcmludGVyUGFyc2VyKHBwKTtcblxuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIF9wcm90by5hcHBlbmRWYWx1ZVJlZHVjZWQgPSBmdW5jdGlvbiBhcHBlbmRWYWx1ZVJlZHVjZWQoKSB7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDQgJiYgYXJndW1lbnRzWzNdIGluc3RhbmNlb2YgQ2hyb25vTG9jYWxEYXRlKSB7XG4gICAgICByZXR1cm4gdGhpcy5fYXBwZW5kVmFsdWVSZWR1Y2VkRmllbGRXaWR0aE1heFdpZHRoQmFzZURhdGUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHRoaXMuX2FwcGVuZFZhbHVlUmVkdWNlZEZpZWxkV2lkdGhNYXhXaWR0aEJhc2VWYWx1ZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgfTtcblxuICBfcHJvdG8uX2FwcGVuZFZhbHVlUmVkdWNlZEZpZWxkV2lkdGhNYXhXaWR0aEJhc2VWYWx1ZSA9IGZ1bmN0aW9uIF9hcHBlbmRWYWx1ZVJlZHVjZWRGaWVsZFdpZHRoTWF4V2lkdGhCYXNlVmFsdWUoZmllbGQsIHdpZHRoLCBtYXhXaWR0aCwgYmFzZVZhbHVlKSB7XG4gICAgcmVxdWlyZU5vbk51bGwoZmllbGQsICdmaWVsZCcpO1xuICAgIHZhciBwcCA9IG5ldyBSZWR1Y2VkUHJpbnRlclBhcnNlcihmaWVsZCwgd2lkdGgsIG1heFdpZHRoLCBiYXNlVmFsdWUsIG51bGwpO1xuXG4gICAgdGhpcy5fYXBwZW5kVmFsdWVQcmludGVyUGFyc2VyKHBwKTtcblxuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIF9wcm90by5fYXBwZW5kVmFsdWVSZWR1Y2VkRmllbGRXaWR0aE1heFdpZHRoQmFzZURhdGUgPSBmdW5jdGlvbiBfYXBwZW5kVmFsdWVSZWR1Y2VkRmllbGRXaWR0aE1heFdpZHRoQmFzZURhdGUoZmllbGQsIHdpZHRoLCBtYXhXaWR0aCwgYmFzZURhdGUpIHtcbiAgICByZXF1aXJlTm9uTnVsbChmaWVsZCwgJ2ZpZWxkJyk7XG4gICAgcmVxdWlyZU5vbk51bGwoYmFzZURhdGUsICdiYXNlRGF0ZScpO1xuICAgIHJlcXVpcmVJbnN0YW5jZShiYXNlRGF0ZSwgQ2hyb25vTG9jYWxEYXRlLCAnYmFzZURhdGUnKTtcbiAgICB2YXIgcHAgPSBuZXcgUmVkdWNlZFByaW50ZXJQYXJzZXIoZmllbGQsIHdpZHRoLCBtYXhXaWR0aCwgMCwgYmFzZURhdGUpO1xuXG4gICAgdGhpcy5fYXBwZW5kVmFsdWVQcmludGVyUGFyc2VyKHBwKTtcblxuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIF9wcm90by5fYXBwZW5kVmFsdWVQcmludGVyUGFyc2VyID0gZnVuY3Rpb24gX2FwcGVuZFZhbHVlUHJpbnRlclBhcnNlcihwcCkge1xuICAgIGFzc2VydChwcCAhPSBudWxsKTtcblxuICAgIGlmICh0aGlzLl9hY3RpdmUuX3ZhbHVlUGFyc2VySW5kZXggPj0gMCAmJiB0aGlzLl9hY3RpdmUuX3ByaW50ZXJQYXJzZXJzW3RoaXMuX2FjdGl2ZS5fdmFsdWVQYXJzZXJJbmRleF0gaW5zdGFuY2VvZiBOdW1iZXJQcmludGVyUGFyc2VyKSB7XG4gICAgICB2YXIgYWN0aXZlVmFsdWVQYXJzZXIgPSB0aGlzLl9hY3RpdmUuX3ZhbHVlUGFyc2VySW5kZXg7XG4gICAgICB2YXIgYmFzZVBQID0gdGhpcy5fYWN0aXZlLl9wcmludGVyUGFyc2Vyc1thY3RpdmVWYWx1ZVBhcnNlcl07XG5cbiAgICAgIGlmIChwcC5taW5XaWR0aCgpID09PSBwcC5tYXhXaWR0aCgpICYmIHBwLnNpZ25TdHlsZSgpID09PSBTaWduU3R5bGUuTk9UX05FR0FUSVZFKSB7XG4gICAgICAgIGJhc2VQUCA9IGJhc2VQUC53aXRoU3Vic2VxdWVudFdpZHRoKHBwLm1heFdpZHRoKCkpO1xuXG4gICAgICAgIHRoaXMuX2FwcGVuZEludGVybmFsKHBwLndpdGhGaXhlZFdpZHRoKCkpO1xuXG4gICAgICAgIHRoaXMuX2FjdGl2ZS5fdmFsdWVQYXJzZXJJbmRleCA9IGFjdGl2ZVZhbHVlUGFyc2VyO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYmFzZVBQID0gYmFzZVBQLndpdGhGaXhlZFdpZHRoKCk7XG4gICAgICAgIHRoaXMuX2FjdGl2ZS5fdmFsdWVQYXJzZXJJbmRleCA9IHRoaXMuX2FwcGVuZEludGVybmFsKHBwKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5fYWN0aXZlLl9wcmludGVyUGFyc2Vyc1thY3RpdmVWYWx1ZVBhcnNlcl0gPSBiYXNlUFA7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX2FjdGl2ZS5fdmFsdWVQYXJzZXJJbmRleCA9IHRoaXMuX2FwcGVuZEludGVybmFsKHBwKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICBfcHJvdG8uYXBwZW5kRnJhY3Rpb24gPSBmdW5jdGlvbiBhcHBlbmRGcmFjdGlvbihmaWVsZCwgbWluV2lkdGgsIG1heFdpZHRoLCBkZWNpbWFsUG9pbnQpIHtcbiAgICB0aGlzLl9hcHBlbmRJbnRlcm5hbChuZXcgRnJhY3Rpb25QcmludGVyUGFyc2VyKGZpZWxkLCBtaW5XaWR0aCwgbWF4V2lkdGgsIGRlY2ltYWxQb2ludCkpO1xuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgX3Byb3RvLmFwcGVuZEluc3RhbnQgPSBmdW5jdGlvbiBhcHBlbmRJbnN0YW50KGZyYWN0aW9uYWxEaWdpdHMpIHtcbiAgICBpZiAoZnJhY3Rpb25hbERpZ2l0cyA9PT0gdm9pZCAwKSB7XG4gICAgICBmcmFjdGlvbmFsRGlnaXRzID0gLTI7XG4gICAgfVxuXG4gICAgaWYgKGZyYWN0aW9uYWxEaWdpdHMgPCAtMiB8fCBmcmFjdGlvbmFsRGlnaXRzID4gOSkge1xuICAgICAgdGhyb3cgbmV3IElsbGVnYWxBcmd1bWVudEV4Y2VwdGlvbignSW52YWxpZCBmcmFjdGlvbmFsIGRpZ2l0czogJyArIGZyYWN0aW9uYWxEaWdpdHMpO1xuICAgIH1cblxuICAgIHRoaXMuX2FwcGVuZEludGVybmFsKG5ldyBJbnN0YW50UHJpbnRlclBhcnNlcihmcmFjdGlvbmFsRGlnaXRzKSk7XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICBfcHJvdG8uYXBwZW5kT2Zmc2V0SWQgPSBmdW5jdGlvbiBhcHBlbmRPZmZzZXRJZCgpIHtcbiAgICB0aGlzLl9hcHBlbmRJbnRlcm5hbChPZmZzZXRJZFByaW50ZXJQYXJzZXIuSU5TVEFOQ0VfSUQpO1xuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgX3Byb3RvLmFwcGVuZE9mZnNldCA9IGZ1bmN0aW9uIGFwcGVuZE9mZnNldChwYXR0ZXJuLCBub09mZnNldFRleHQpIHtcbiAgICB0aGlzLl9hcHBlbmRJbnRlcm5hbFByaW50ZXJQYXJzZXIobmV3IE9mZnNldElkUHJpbnRlclBhcnNlcihub09mZnNldFRleHQsIHBhdHRlcm4pKTtcblxuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIF9wcm90by5hcHBlbmRab25lSWQgPSBmdW5jdGlvbiBhcHBlbmRab25lSWQoKSB7XG4gICAgdGhpcy5fYXBwZW5kSW50ZXJuYWwobmV3IFpvbmVJZFByaW50ZXJQYXJzZXIoVGVtcG9yYWxRdWVyaWVzLnpvbmVJZCgpLCAnWm9uZUlkKCknKSk7XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICBfcHJvdG8uYXBwZW5kUGF0dGVybiA9IGZ1bmN0aW9uIGFwcGVuZFBhdHRlcm4ocGF0dGVybikge1xuICAgIHJlcXVpcmVOb25OdWxsKHBhdHRlcm4sICdwYXR0ZXJuJyk7XG5cbiAgICB0aGlzLl9wYXJzZVBhdHRlcm4ocGF0dGVybik7XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICBfcHJvdG8uYXBwZW5kWm9uZVRleHQgPSBmdW5jdGlvbiBhcHBlbmRab25lVGV4dCgpIHtcbiAgICB0aHJvdyBuZXcgSWxsZWdhbEFyZ3VtZW50RXhjZXB0aW9uKCdQYXR0ZXJuIHVzaW5nIChsb2NhbGl6ZWQpIHRleHQgbm90IGltcGxlbWVudGVkLCB1c2UganMtam9kYS1sb2NhbGUgcGx1Z2luIScpO1xuICB9O1xuXG4gIF9wcm90by5hcHBlbmRUZXh0ID0gZnVuY3Rpb24gYXBwZW5kVGV4dCgpIHtcbiAgICB0aHJvdyBuZXcgSWxsZWdhbEFyZ3VtZW50RXhjZXB0aW9uKCdQYXR0ZXJuIHVzaW5nIChsb2NhbGl6ZWQpIHRleHQgbm90IGltcGxlbWVudGVkLCB1c2UganMtam9kYS1sb2NhbGUgcGx1Z2luIScpO1xuICB9O1xuXG4gIF9wcm90by5hcHBlbmRMb2NhbGl6ZWRPZmZzZXQgPSBmdW5jdGlvbiBhcHBlbmRMb2NhbGl6ZWRPZmZzZXQoKSB7XG4gICAgdGhyb3cgbmV3IElsbGVnYWxBcmd1bWVudEV4Y2VwdGlvbignUGF0dGVybiB1c2luZyAobG9jYWxpemVkKSB0ZXh0IG5vdCBpbXBsZW1lbnRlZCwgdXNlIGpzLWpvZGEtbG9jYWxlIHBsdWdpbiEnKTtcbiAgfTtcblxuICBfcHJvdG8uYXBwZW5kV2Vla0ZpZWxkID0gZnVuY3Rpb24gYXBwZW5kV2Vla0ZpZWxkKCkge1xuICAgIHRocm93IG5ldyBJbGxlZ2FsQXJndW1lbnRFeGNlcHRpb24oJ1BhdHRlcm4gdXNpbmcgKGxvY2FsaXplZCkgdGV4dCBub3QgaW1wbGVtZW50ZWQsIHVzZSBqcy1qb2RhLWxvY2FsZSBwbHVnaW4hJyk7XG4gIH07XG5cbiAgX3Byb3RvLl9wYXJzZVBhdHRlcm4gPSBmdW5jdGlvbiBfcGFyc2VQYXR0ZXJuKHBhdHRlcm4pIHtcbiAgICB2YXIgRklFTERfTUFQID0ge1xuICAgICAgJ0cnOiBDaHJvbm9GaWVsZC5FUkEsXG4gICAgICAneSc6IENocm9ub0ZpZWxkLllFQVJfT0ZfRVJBLFxuICAgICAgJ3UnOiBDaHJvbm9GaWVsZC5ZRUFSLFxuICAgICAgJ1EnOiBJc29GaWVsZHMuUVVBUlRFUl9PRl9ZRUFSLFxuICAgICAgJ3EnOiBJc29GaWVsZHMuUVVBUlRFUl9PRl9ZRUFSLFxuICAgICAgJ00nOiBDaHJvbm9GaWVsZC5NT05USF9PRl9ZRUFSLFxuICAgICAgJ0wnOiBDaHJvbm9GaWVsZC5NT05USF9PRl9ZRUFSLFxuICAgICAgJ0QnOiBDaHJvbm9GaWVsZC5EQVlfT0ZfWUVBUixcbiAgICAgICdkJzogQ2hyb25vRmllbGQuREFZX09GX01PTlRILFxuICAgICAgJ0YnOiBDaHJvbm9GaWVsZC5BTElHTkVEX0RBWV9PRl9XRUVLX0lOX01PTlRILFxuICAgICAgJ0UnOiBDaHJvbm9GaWVsZC5EQVlfT0ZfV0VFSyxcbiAgICAgICdjJzogQ2hyb25vRmllbGQuREFZX09GX1dFRUssXG4gICAgICAnZSc6IENocm9ub0ZpZWxkLkRBWV9PRl9XRUVLLFxuICAgICAgJ2EnOiBDaHJvbm9GaWVsZC5BTVBNX09GX0RBWSxcbiAgICAgICdIJzogQ2hyb25vRmllbGQuSE9VUl9PRl9EQVksXG4gICAgICAnayc6IENocm9ub0ZpZWxkLkNMT0NLX0hPVVJfT0ZfREFZLFxuICAgICAgJ0snOiBDaHJvbm9GaWVsZC5IT1VSX09GX0FNUE0sXG4gICAgICAnaCc6IENocm9ub0ZpZWxkLkNMT0NLX0hPVVJfT0ZfQU1QTSxcbiAgICAgICdtJzogQ2hyb25vRmllbGQuTUlOVVRFX09GX0hPVVIsXG4gICAgICAncyc6IENocm9ub0ZpZWxkLlNFQ09ORF9PRl9NSU5VVEUsXG4gICAgICAnUyc6IENocm9ub0ZpZWxkLk5BTk9fT0ZfU0VDT05ELFxuICAgICAgJ0EnOiBDaHJvbm9GaWVsZC5NSUxMSV9PRl9EQVksXG4gICAgICAnbic6IENocm9ub0ZpZWxkLk5BTk9fT0ZfU0VDT05ELFxuICAgICAgJ04nOiBDaHJvbm9GaWVsZC5OQU5PX09GX0RBWVxuICAgIH07XG5cbiAgICBmb3IgKHZhciBwb3MgPSAwOyBwb3MgPCBwYXR0ZXJuLmxlbmd0aDsgcG9zKyspIHtcbiAgICAgIHZhciBjdXIgPSBwYXR0ZXJuLmNoYXJBdChwb3MpO1xuXG4gICAgICBpZiAoY3VyID49ICdBJyAmJiBjdXIgPD0gJ1onIHx8IGN1ciA+PSAnYScgJiYgY3VyIDw9ICd6Jykge1xuICAgICAgICB2YXIgc3RhcnQgPSBwb3MrKztcblxuICAgICAgICBmb3IgKDsgcG9zIDwgcGF0dGVybi5sZW5ndGggJiYgcGF0dGVybi5jaGFyQXQocG9zKSA9PT0gY3VyOyBwb3MrKykge1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGNvdW50ID0gcG9zIC0gc3RhcnQ7XG5cbiAgICAgICAgaWYgKGN1ciA9PT0gJ3AnKSB7XG4gICAgICAgICAgdmFyIHBhZCA9IDA7XG5cbiAgICAgICAgICBpZiAocG9zIDwgcGF0dGVybi5sZW5ndGgpIHtcbiAgICAgICAgICAgIGN1ciA9IHBhdHRlcm4uY2hhckF0KHBvcyk7XG5cbiAgICAgICAgICAgIGlmIChjdXIgPj0gJ0EnICYmIGN1ciA8PSAnWicgfHwgY3VyID49ICdhJyAmJiBjdXIgPD0gJ3onKSB7XG4gICAgICAgICAgICAgIHBhZCA9IGNvdW50O1xuICAgICAgICAgICAgICBzdGFydCA9IHBvcysrO1xuXG4gICAgICAgICAgICAgIGZvciAoOyBwb3MgPCBwYXR0ZXJuLmxlbmd0aCAmJiBwYXR0ZXJuLmNoYXJBdChwb3MpID09PSBjdXI7IHBvcysrKSB7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBjb3VudCA9IHBvcyAtIHN0YXJ0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChwYWQgPT09IDApIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBJbGxlZ2FsQXJndW1lbnRFeGNlcHRpb24oJ1BhZCBsZXR0ZXIgXFwncFxcJyBtdXN0IGJlIGZvbGxvd2VkIGJ5IHZhbGlkIHBhZCBwYXR0ZXJuOiAnICsgcGF0dGVybik7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdGhpcy5wYWROZXh0KHBhZCk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgZmllbGQgPSBGSUVMRF9NQVBbY3VyXTtcblxuICAgICAgICBpZiAoZmllbGQgIT0gbnVsbCkge1xuICAgICAgICAgIHRoaXMuX3BhcnNlRmllbGQoY3VyLCBjb3VudCwgZmllbGQpO1xuICAgICAgICB9IGVsc2UgaWYgKGN1ciA9PT0gJ3onKSB7XG4gICAgICAgICAgaWYgKGNvdW50ID4gNCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IElsbGVnYWxBcmd1bWVudEV4Y2VwdGlvbignVG9vIG1hbnkgcGF0dGVybiBsZXR0ZXJzOiAnICsgY3VyKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKGNvdW50ID09PSA0KSB7XG4gICAgICAgICAgICB0aGlzLmFwcGVuZFpvbmVUZXh0KFRleHRTdHlsZS5GVUxMKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5hcHBlbmRab25lVGV4dChUZXh0U3R5bGUuU0hPUlQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChjdXIgPT09ICdWJykge1xuICAgICAgICAgIGlmIChjb3VudCAhPT0gMikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IElsbGVnYWxBcmd1bWVudEV4Y2VwdGlvbignUGF0dGVybiBsZXR0ZXIgY291bnQgbXVzdCBiZSAyOiAnICsgY3VyKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB0aGlzLmFwcGVuZFpvbmVJZCgpO1xuICAgICAgICB9IGVsc2UgaWYgKGN1ciA9PT0gJ1onKSB7XG4gICAgICAgICAgaWYgKGNvdW50IDwgNCkge1xuICAgICAgICAgICAgdGhpcy5hcHBlbmRPZmZzZXQoJytISE1NJywgJyswMDAwJyk7XG4gICAgICAgICAgfSBlbHNlIGlmIChjb3VudCA9PT0gNCkge1xuICAgICAgICAgICAgdGhpcy5hcHBlbmRMb2NhbGl6ZWRPZmZzZXQoVGV4dFN0eWxlLkZVTEwpO1xuICAgICAgICAgIH0gZWxzZSBpZiAoY291bnQgPT09IDUpIHtcbiAgICAgICAgICAgIHRoaXMuYXBwZW5kT2Zmc2V0KCcrSEg6TU06c3MnLCAnWicpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgSWxsZWdhbEFyZ3VtZW50RXhjZXB0aW9uKCdUb28gbWFueSBwYXR0ZXJuIGxldHRlcnM6ICcgKyBjdXIpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChjdXIgPT09ICdPJykge1xuICAgICAgICAgIGlmIChjb3VudCA9PT0gMSkge1xuICAgICAgICAgICAgdGhpcy5hcHBlbmRMb2NhbGl6ZWRPZmZzZXQoVGV4dFN0eWxlLlNIT1JUKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKGNvdW50ID09PSA0KSB7XG4gICAgICAgICAgICB0aGlzLmFwcGVuZExvY2FsaXplZE9mZnNldChUZXh0U3R5bGUuRlVMTCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBJbGxlZ2FsQXJndW1lbnRFeGNlcHRpb24oJ1BhdHRlcm4gbGV0dGVyIGNvdW50IG11c3QgYmUgMSBvciA0OiAnICsgY3VyKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoY3VyID09PSAnWCcpIHtcbiAgICAgICAgICBpZiAoY291bnQgPiA1KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgSWxsZWdhbEFyZ3VtZW50RXhjZXB0aW9uKCdUb28gbWFueSBwYXR0ZXJuIGxldHRlcnM6ICcgKyBjdXIpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHRoaXMuYXBwZW5kT2Zmc2V0KE9mZnNldElkUHJpbnRlclBhcnNlci5QQVRURVJOU1tjb3VudCArIChjb3VudCA9PT0gMSA/IDAgOiAxKV0sICdaJyk7XG4gICAgICAgIH0gZWxzZSBpZiAoY3VyID09PSAneCcpIHtcbiAgICAgICAgICBpZiAoY291bnQgPiA1KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgSWxsZWdhbEFyZ3VtZW50RXhjZXB0aW9uKCdUb28gbWFueSBwYXR0ZXJuIGxldHRlcnM6ICcgKyBjdXIpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhciB6ZXJvID0gY291bnQgPT09IDEgPyAnKzAwJyA6IGNvdW50ICUgMiA9PT0gMCA/ICcrMDAwMCcgOiAnKzAwOjAwJztcbiAgICAgICAgICB0aGlzLmFwcGVuZE9mZnNldChPZmZzZXRJZFByaW50ZXJQYXJzZXIuUEFUVEVSTlNbY291bnQgKyAoY291bnQgPT09IDEgPyAwIDogMSldLCB6ZXJvKTtcbiAgICAgICAgfSBlbHNlIGlmIChjdXIgPT09ICdXJykge1xuICAgICAgICAgIGlmIChjb3VudCA+IDEpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBJbGxlZ2FsQXJndW1lbnRFeGNlcHRpb24oJ1RvbyBtYW55IHBhdHRlcm4gbGV0dGVyczogJyArIGN1cik7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdGhpcy5hcHBlbmRXZWVrRmllbGQoJ1cnLCBjb3VudCk7XG4gICAgICAgIH0gZWxzZSBpZiAoY3VyID09PSAndycpIHtcbiAgICAgICAgICBpZiAoY291bnQgPiAyKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgSWxsZWdhbEFyZ3VtZW50RXhjZXB0aW9uKCdUb28gbWFueSBwYXR0ZXJuIGxldHRlcnM6ICcgKyBjdXIpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHRoaXMuYXBwZW5kV2Vla0ZpZWxkKCd3JywgY291bnQpO1xuICAgICAgICB9IGVsc2UgaWYgKGN1ciA9PT0gJ1knKSB7XG4gICAgICAgICAgdGhpcy5hcHBlbmRXZWVrRmllbGQoJ1knLCBjb3VudCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhyb3cgbmV3IElsbGVnYWxBcmd1bWVudEV4Y2VwdGlvbignVW5rbm93biBwYXR0ZXJuIGxldHRlcjogJyArIGN1cik7XG4gICAgICAgIH1cblxuICAgICAgICBwb3MtLTtcbiAgICAgIH0gZWxzZSBpZiAoY3VyID09PSAnXFwnJykge1xuICAgICAgICB2YXIgX3N0YXJ0ID0gcG9zKys7XG5cbiAgICAgICAgZm9yICg7IHBvcyA8IHBhdHRlcm4ubGVuZ3RoOyBwb3MrKykge1xuICAgICAgICAgIGlmIChwYXR0ZXJuLmNoYXJBdChwb3MpID09PSAnXFwnJykge1xuICAgICAgICAgICAgaWYgKHBvcyArIDEgPCBwYXR0ZXJuLmxlbmd0aCAmJiBwYXR0ZXJuLmNoYXJBdChwb3MgKyAxKSA9PT0gJ1xcJycpIHtcbiAgICAgICAgICAgICAgcG9zKys7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocG9zID49IHBhdHRlcm4ubGVuZ3RoKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IElsbGVnYWxBcmd1bWVudEV4Y2VwdGlvbignUGF0dGVybiBlbmRzIHdpdGggYW4gaW5jb21wbGV0ZSBzdHJpbmcgbGl0ZXJhbDogJyArIHBhdHRlcm4pO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHN0ciA9IHBhdHRlcm4uc3Vic3RyaW5nKF9zdGFydCArIDEsIHBvcyk7XG5cbiAgICAgICAgaWYgKHN0ci5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICB0aGlzLmFwcGVuZExpdGVyYWwoJ1xcJycpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMuYXBwZW5kTGl0ZXJhbChzdHIucmVwbGFjZSgnXFwnXFwnJywgJ1xcJycpKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChjdXIgPT09ICdbJykge1xuICAgICAgICB0aGlzLm9wdGlvbmFsU3RhcnQoKTtcbiAgICAgIH0gZWxzZSBpZiAoY3VyID09PSAnXScpIHtcbiAgICAgICAgaWYgKHRoaXMuX2FjdGl2ZS5fcGFyZW50ID09PSBudWxsKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IElsbGVnYWxBcmd1bWVudEV4Y2VwdGlvbignUGF0dGVybiBpbnZhbGlkIGFzIGl0IGNvbnRhaW5zIF0gd2l0aG91dCBwcmV2aW91cyBbJyk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLm9wdGlvbmFsRW5kKCk7XG4gICAgICB9IGVsc2UgaWYgKGN1ciA9PT0gJ3snIHx8IGN1ciA9PT0gJ30nIHx8IGN1ciA9PT0gJyMnKSB7XG4gICAgICAgIHRocm93IG5ldyBJbGxlZ2FsQXJndW1lbnRFeGNlcHRpb24oJ1BhdHRlcm4gaW5jbHVkZXMgcmVzZXJ2ZWQgY2hhcmFjdGVyOiBcXCcnICsgY3VyICsgJ1xcJycpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5hcHBlbmRMaXRlcmFsKGN1cik7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIF9wcm90by5fcGFyc2VGaWVsZCA9IGZ1bmN0aW9uIF9wYXJzZUZpZWxkKGN1ciwgY291bnQsIGZpZWxkKSB7XG4gICAgc3dpdGNoIChjdXIpIHtcbiAgICAgIGNhc2UgJ3UnOlxuICAgICAgY2FzZSAneSc6XG4gICAgICAgIGlmIChjb3VudCA9PT0gMikge1xuICAgICAgICAgIHRoaXMuYXBwZW5kVmFsdWVSZWR1Y2VkKGZpZWxkLCAyLCAyLCBSZWR1Y2VkUHJpbnRlclBhcnNlci5CQVNFX0RBVEUpO1xuICAgICAgICB9IGVsc2UgaWYgKGNvdW50IDwgNCkge1xuICAgICAgICAgIHRoaXMuYXBwZW5kVmFsdWUoZmllbGQsIGNvdW50LCBNQVhfV0lEVEgkMSwgU2lnblN0eWxlLk5PUk1BTCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5hcHBlbmRWYWx1ZShmaWVsZCwgY291bnQsIE1BWF9XSURUSCQxLCBTaWduU3R5bGUuRVhDRUVEU19QQUQpO1xuICAgICAgICB9XG5cbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgJ00nOlxuICAgICAgY2FzZSAnUSc6XG4gICAgICAgIHN3aXRjaCAoY291bnQpIHtcbiAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICB0aGlzLmFwcGVuZFZhbHVlKGZpZWxkKTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgdGhpcy5hcHBlbmRWYWx1ZShmaWVsZCwgMik7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgIHRoaXMuYXBwZW5kVGV4dChmaWVsZCwgVGV4dFN0eWxlLlNIT1JUKTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSA0OlxuICAgICAgICAgICAgdGhpcy5hcHBlbmRUZXh0KGZpZWxkLCBUZXh0U3R5bGUuRlVMTCk7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgNTpcbiAgICAgICAgICAgIHRoaXMuYXBwZW5kVGV4dChmaWVsZCwgVGV4dFN0eWxlLk5BUlJPVyk7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICB0aHJvdyBuZXcgSWxsZWdhbEFyZ3VtZW50RXhjZXB0aW9uKCdUb28gbWFueSBwYXR0ZXJuIGxldHRlcnM6ICcgKyBjdXIpO1xuICAgICAgICB9XG5cbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgJ0wnOlxuICAgICAgY2FzZSAncSc6XG4gICAgICAgIHN3aXRjaCAoY291bnQpIHtcbiAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICB0aGlzLmFwcGVuZFZhbHVlKGZpZWxkKTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgdGhpcy5hcHBlbmRWYWx1ZShmaWVsZCwgMik7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgIHRoaXMuYXBwZW5kVGV4dChmaWVsZCwgVGV4dFN0eWxlLlNIT1JUX1NUQU5EQUxPTkUpO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgICB0aGlzLmFwcGVuZFRleHQoZmllbGQsIFRleHRTdHlsZS5GVUxMX1NUQU5EQUxPTkUpO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlIDU6XG4gICAgICAgICAgICB0aGlzLmFwcGVuZFRleHQoZmllbGQsIFRleHRTdHlsZS5OQVJST1dfU1RBTkRBTE9ORSk7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICB0aHJvdyBuZXcgSWxsZWdhbEFyZ3VtZW50RXhjZXB0aW9uKCdUb28gbWFueSBwYXR0ZXJuIGxldHRlcnM6ICcgKyBjdXIpO1xuICAgICAgICB9XG5cbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgJ2UnOlxuICAgICAgICBzd2l0Y2ggKGNvdW50KSB7XG4gICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgIHRoaXMuYXBwZW5kV2Vla0ZpZWxkKCdlJywgY291bnQpO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICB0aGlzLmFwcGVuZFRleHQoZmllbGQsIFRleHRTdHlsZS5TSE9SVCk7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgIHRoaXMuYXBwZW5kVGV4dChmaWVsZCwgVGV4dFN0eWxlLkZVTEwpO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlIDU6XG4gICAgICAgICAgICB0aGlzLmFwcGVuZFRleHQoZmllbGQsIFRleHRTdHlsZS5OQVJST1cpO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgdGhyb3cgbmV3IElsbGVnYWxBcmd1bWVudEV4Y2VwdGlvbignVG9vIG1hbnkgcGF0dGVybiBsZXR0ZXJzOiAnICsgY3VyKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlICdjJzpcbiAgICAgICAgc3dpdGNoIChjb3VudCkge1xuICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgIHRoaXMuYXBwZW5kV2Vla0ZpZWxkKCdjJywgY291bnQpO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICB0aHJvdyBuZXcgSWxsZWdhbEFyZ3VtZW50RXhjZXB0aW9uKCdJbnZhbGlkIG51bWJlciBvZiBwYXR0ZXJuIGxldHRlcnM6ICcgKyBjdXIpO1xuXG4gICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgdGhpcy5hcHBlbmRUZXh0KGZpZWxkLCBUZXh0U3R5bGUuU0hPUlRfU1RBTkRBTE9ORSk7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgIHRoaXMuYXBwZW5kVGV4dChmaWVsZCwgVGV4dFN0eWxlLkZVTExfU1RBTkRBTE9ORSk7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgNTpcbiAgICAgICAgICAgIHRoaXMuYXBwZW5kVGV4dChmaWVsZCwgVGV4dFN0eWxlLk5BUlJPV19TVEFOREFMT05FKTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHRocm93IG5ldyBJbGxlZ2FsQXJndW1lbnRFeGNlcHRpb24oJ1RvbyBtYW55IHBhdHRlcm4gbGV0dGVyczogJyArIGN1cik7XG4gICAgICAgIH1cblxuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSAnYSc6XG4gICAgICAgIGlmIChjb3VudCA9PT0gMSkge1xuICAgICAgICAgIHRoaXMuYXBwZW5kVGV4dChmaWVsZCwgVGV4dFN0eWxlLlNIT1JUKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aHJvdyBuZXcgSWxsZWdhbEFyZ3VtZW50RXhjZXB0aW9uKCdUb28gbWFueSBwYXR0ZXJuIGxldHRlcnM6ICcgKyBjdXIpO1xuICAgICAgICB9XG5cbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgJ0UnOlxuICAgICAgY2FzZSAnRyc6XG4gICAgICAgIHN3aXRjaCAoY291bnQpIHtcbiAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgIHRoaXMuYXBwZW5kVGV4dChmaWVsZCwgVGV4dFN0eWxlLlNIT1JUKTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSA0OlxuICAgICAgICAgICAgdGhpcy5hcHBlbmRUZXh0KGZpZWxkLCBUZXh0U3R5bGUuRlVMTCk7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgNTpcbiAgICAgICAgICAgIHRoaXMuYXBwZW5kVGV4dChmaWVsZCwgVGV4dFN0eWxlLk5BUlJPVyk7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICB0aHJvdyBuZXcgSWxsZWdhbEFyZ3VtZW50RXhjZXB0aW9uKCdUb28gbWFueSBwYXR0ZXJuIGxldHRlcnM6ICcgKyBjdXIpO1xuICAgICAgICB9XG5cbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgJ1MnOlxuICAgICAgICB0aGlzLmFwcGVuZEZyYWN0aW9uKENocm9ub0ZpZWxkLk5BTk9fT0ZfU0VDT05ELCBjb3VudCwgY291bnQsIGZhbHNlKTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgJ0YnOlxuICAgICAgICBpZiAoY291bnQgPT09IDEpIHtcbiAgICAgICAgICB0aGlzLmFwcGVuZFZhbHVlKGZpZWxkKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aHJvdyBuZXcgSWxsZWdhbEFyZ3VtZW50RXhjZXB0aW9uKCdUb28gbWFueSBwYXR0ZXJuIGxldHRlcnM6ICcgKyBjdXIpO1xuICAgICAgICB9XG5cbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgJ2QnOlxuICAgICAgY2FzZSAnaCc6XG4gICAgICBjYXNlICdIJzpcbiAgICAgIGNhc2UgJ2snOlxuICAgICAgY2FzZSAnSyc6XG4gICAgICBjYXNlICdtJzpcbiAgICAgIGNhc2UgJ3MnOlxuICAgICAgICBpZiAoY291bnQgPT09IDEpIHtcbiAgICAgICAgICB0aGlzLmFwcGVuZFZhbHVlKGZpZWxkKTtcbiAgICAgICAgfSBlbHNlIGlmIChjb3VudCA9PT0gMikge1xuICAgICAgICAgIHRoaXMuYXBwZW5kVmFsdWUoZmllbGQsIGNvdW50KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aHJvdyBuZXcgSWxsZWdhbEFyZ3VtZW50RXhjZXB0aW9uKCdUb28gbWFueSBwYXR0ZXJuIGxldHRlcnM6ICcgKyBjdXIpO1xuICAgICAgICB9XG5cbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgJ0QnOlxuICAgICAgICBpZiAoY291bnQgPT09IDEpIHtcbiAgICAgICAgICB0aGlzLmFwcGVuZFZhbHVlKGZpZWxkKTtcbiAgICAgICAgfSBlbHNlIGlmIChjb3VudCA8PSAzKSB7XG4gICAgICAgICAgdGhpcy5hcHBlbmRWYWx1ZShmaWVsZCwgY291bnQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRocm93IG5ldyBJbGxlZ2FsQXJndW1lbnRFeGNlcHRpb24oJ1RvbyBtYW55IHBhdHRlcm4gbGV0dGVyczogJyArIGN1cik7XG4gICAgICAgIH1cblxuICAgICAgICBicmVhaztcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgaWYgKGNvdW50ID09PSAxKSB7XG4gICAgICAgICAgdGhpcy5hcHBlbmRWYWx1ZShmaWVsZCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5hcHBlbmRWYWx1ZShmaWVsZCwgY291bnQpO1xuICAgICAgICB9XG5cbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICB9O1xuXG4gIF9wcm90by5wYWROZXh0ID0gZnVuY3Rpb24gcGFkTmV4dCgpIHtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgcmV0dXJuIHRoaXMuX3BhZE5leHQxLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB0aGlzLl9wYWROZXh0Mi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgfTtcblxuICBfcHJvdG8uX3BhZE5leHQxID0gZnVuY3Rpb24gX3BhZE5leHQxKHBhZFdpZHRoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3BhZE5leHQyKHBhZFdpZHRoLCAnICcpO1xuICB9O1xuXG4gIF9wcm90by5fcGFkTmV4dDIgPSBmdW5jdGlvbiBfcGFkTmV4dDIocGFkV2lkdGgsIHBhZENoYXIpIHtcbiAgICBpZiAocGFkV2lkdGggPCAxKSB7XG4gICAgICB0aHJvdyBuZXcgSWxsZWdhbEFyZ3VtZW50RXhjZXB0aW9uKCdUaGUgcGFkIHdpZHRoIG11c3QgYmUgYXQgbGVhc3Qgb25lIGJ1dCB3YXMgJyArIHBhZFdpZHRoKTtcbiAgICB9XG5cbiAgICB0aGlzLl9hY3RpdmUuX3BhZE5leHRXaWR0aCA9IHBhZFdpZHRoO1xuICAgIHRoaXMuX2FjdGl2ZS5fcGFkTmV4dENoYXIgPSBwYWRDaGFyO1xuICAgIHRoaXMuX2FjdGl2ZS5fdmFsdWVQYXJzZXJJbmRleCA9IC0xO1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIF9wcm90by5vcHRpb25hbFN0YXJ0ID0gZnVuY3Rpb24gb3B0aW9uYWxTdGFydCgpIHtcbiAgICB0aGlzLl9hY3RpdmUuX3ZhbHVlUGFyc2VySW5kZXggPSAtMTtcbiAgICB0aGlzLl9hY3RpdmUgPSBEYXRlVGltZUZvcm1hdHRlckJ1aWxkZXIuX29mKHRoaXMuX2FjdGl2ZSwgdHJ1ZSk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgX3Byb3RvLm9wdGlvbmFsRW5kID0gZnVuY3Rpb24gb3B0aW9uYWxFbmQoKSB7XG4gICAgaWYgKHRoaXMuX2FjdGl2ZS5fcGFyZW50ID09IG51bGwpIHtcbiAgICAgIHRocm93IG5ldyBJbGxlZ2FsU3RhdGVFeGNlcHRpb24oJ0Nhbm5vdCBjYWxsIG9wdGlvbmFsRW5kKCkgYXMgdGhlcmUgd2FzIG5vIHByZXZpb3VzIGNhbGwgdG8gb3B0aW9uYWxTdGFydCgpJyk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuX2FjdGl2ZS5fcHJpbnRlclBhcnNlcnMubGVuZ3RoID4gMCkge1xuICAgICAgdmFyIGNwcCA9IG5ldyBDb21wb3NpdGVQcmludGVyUGFyc2VyKHRoaXMuX2FjdGl2ZS5fcHJpbnRlclBhcnNlcnMsIHRoaXMuX2FjdGl2ZS5fb3B0aW9uYWwpO1xuICAgICAgdGhpcy5fYWN0aXZlID0gdGhpcy5fYWN0aXZlLl9wYXJlbnQ7XG5cbiAgICAgIHRoaXMuX2FwcGVuZEludGVybmFsKGNwcCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX2FjdGl2ZSA9IHRoaXMuX2FjdGl2ZS5fcGFyZW50O1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIF9wcm90by5fYXBwZW5kSW50ZXJuYWwgPSBmdW5jdGlvbiBfYXBwZW5kSW50ZXJuYWwocHApIHtcbiAgICBhc3NlcnQocHAgIT0gbnVsbCk7XG5cbiAgICBpZiAodGhpcy5fYWN0aXZlLl9wYWROZXh0V2lkdGggPiAwKSB7XG4gICAgICBpZiAocHAgIT0gbnVsbCkge1xuICAgICAgICBwcCA9IG5ldyBQYWRQcmludGVyUGFyc2VyRGVjb3JhdG9yKHBwLCB0aGlzLl9hY3RpdmUuX3BhZE5leHRXaWR0aCwgdGhpcy5fYWN0aXZlLl9wYWROZXh0Q2hhcik7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuX2FjdGl2ZS5fcGFkTmV4dFdpZHRoID0gMDtcbiAgICAgIHRoaXMuX2FjdGl2ZS5fcGFkTmV4dENoYXIgPSAwO1xuICAgIH1cblxuICAgIHRoaXMuX2FjdGl2ZS5fcHJpbnRlclBhcnNlcnMucHVzaChwcCk7XG5cbiAgICB0aGlzLl9hY3RpdmUuX3ZhbHVlUGFyc2VySW5kZXggPSAtMTtcbiAgICByZXR1cm4gdGhpcy5fYWN0aXZlLl9wcmludGVyUGFyc2Vycy5sZW5ndGggLSAxO1xuICB9O1xuXG4gIF9wcm90by5hcHBlbmRMaXRlcmFsID0gZnVuY3Rpb24gYXBwZW5kTGl0ZXJhbChsaXRlcmFsKSB7XG4gICAgYXNzZXJ0KGxpdGVyYWwgIT0gbnVsbCk7XG5cbiAgICBpZiAobGl0ZXJhbC5sZW5ndGggPiAwKSB7XG4gICAgICBpZiAobGl0ZXJhbC5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgdGhpcy5fYXBwZW5kSW50ZXJuYWxQcmludGVyUGFyc2VyKG5ldyBDaGFyTGl0ZXJhbFByaW50ZXJQYXJzZXIobGl0ZXJhbC5jaGFyQXQoMCkpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuX2FwcGVuZEludGVybmFsUHJpbnRlclBhcnNlcihuZXcgU3RyaW5nTGl0ZXJhbFByaW50ZXJQYXJzZXIobGl0ZXJhbCkpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIF9wcm90by5fYXBwZW5kSW50ZXJuYWxQcmludGVyUGFyc2VyID0gZnVuY3Rpb24gX2FwcGVuZEludGVybmFsUHJpbnRlclBhcnNlcihwcCkge1xuICAgIGFzc2VydChwcCAhPSBudWxsKTtcblxuICAgIGlmICh0aGlzLl9hY3RpdmUuX3BhZE5leHRXaWR0aCA+IDApIHtcbiAgICAgIGlmIChwcCAhPSBudWxsKSB7XG4gICAgICAgIHBwID0gbmV3IFBhZFByaW50ZXJQYXJzZXJEZWNvcmF0b3IocHAsIHRoaXMuX2FjdGl2ZS5fcGFkTmV4dFdpZHRoLCB0aGlzLl9hY3RpdmUuX3BhZE5leHRDaGFyKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5fYWN0aXZlLl9wYWROZXh0V2lkdGggPSAwO1xuICAgICAgdGhpcy5fYWN0aXZlLl9wYWROZXh0Q2hhciA9IDA7XG4gICAgfVxuXG4gICAgdGhpcy5fYWN0aXZlLl9wcmludGVyUGFyc2Vycy5wdXNoKHBwKTtcblxuICAgIHRoaXMuX2FjdGl2ZS5fdmFsdWVQYXJzZXJJbmRleCA9IC0xO1xuICAgIHJldHVybiB0aGlzLl9hY3RpdmUuX3ByaW50ZXJQYXJzZXJzLmxlbmd0aCAtIDE7XG4gIH07XG5cbiAgX3Byb3RvLmFwcGVuZCA9IGZ1bmN0aW9uIGFwcGVuZChmb3JtYXR0ZXIpIHtcbiAgICByZXF1aXJlTm9uTnVsbChmb3JtYXR0ZXIsICdmb3JtYXR0ZXInKTtcblxuICAgIHRoaXMuX2FwcGVuZEludGVybmFsKGZvcm1hdHRlci5fdG9QcmludGVyUGFyc2VyKGZhbHNlKSk7XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICBfcHJvdG8udG9Gb3JtYXR0ZXIgPSBmdW5jdGlvbiB0b0Zvcm1hdHRlcihyZXNvbHZlclN0eWxlKSB7XG4gICAgaWYgKHJlc29sdmVyU3R5bGUgPT09IHZvaWQgMCkge1xuICAgICAgcmVzb2x2ZXJTdHlsZSA9IFJlc29sdmVyU3R5bGUuU01BUlQ7XG4gICAgfVxuXG4gICAgd2hpbGUgKHRoaXMuX2FjdGl2ZS5fcGFyZW50ICE9IG51bGwpIHtcbiAgICAgIHRoaXMub3B0aW9uYWxFbmQoKTtcbiAgICB9XG5cbiAgICB2YXIgcHAgPSBuZXcgQ29tcG9zaXRlUHJpbnRlclBhcnNlcih0aGlzLl9wcmludGVyUGFyc2VycywgZmFsc2UpO1xuICAgIHJldHVybiBuZXcgRGF0ZVRpbWVGb3JtYXR0ZXIocHAsIG51bGwsIERlY2ltYWxTdHlsZS5TVEFOREFSRCwgcmVzb2x2ZXJTdHlsZSwgbnVsbCwgbnVsbCwgbnVsbCk7XG4gIH07XG5cbiAgcmV0dXJuIERhdGVUaW1lRm9ybWF0dGVyQnVpbGRlcjtcbn0oKTtcbnZhciBTRUNPTkRTX1BFUl8xMDAwMF9ZRUFSUyA9IDE0NjA5NyAqIDI1ICogODY0MDA7XG52YXIgU0VDT05EU18wMDAwX1RPXzE5NzAgPSAoMTQ2MDk3ICogNSAtICgzMCAqIDM2NSArIDcpKSAqIDg2NDAwO1xuXG52YXIgSW5zdGFudFByaW50ZXJQYXJzZXIgPSBmdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIEluc3RhbnRQcmludGVyUGFyc2VyKGZyYWN0aW9uYWxEaWdpdHMpIHtcbiAgICB0aGlzLmZyYWN0aW9uYWxEaWdpdHMgPSBmcmFjdGlvbmFsRGlnaXRzO1xuICB9XG5cbiAgdmFyIF9wcm90bzIgPSBJbnN0YW50UHJpbnRlclBhcnNlci5wcm90b3R5cGU7XG5cbiAgX3Byb3RvMi5wcmludCA9IGZ1bmN0aW9uIHByaW50KGNvbnRleHQsIGJ1Zikge1xuICAgIHZhciBpblNlY3MgPSBjb250ZXh0LmdldFZhbHVlKENocm9ub0ZpZWxkLklOU1RBTlRfU0VDT05EUyk7XG4gICAgdmFyIGluTmFub3MgPSAwO1xuXG4gICAgaWYgKGNvbnRleHQudGVtcG9yYWwoKS5pc1N1cHBvcnRlZChDaHJvbm9GaWVsZC5OQU5PX09GX1NFQ09ORCkpIHtcbiAgICAgIGluTmFub3MgPSBjb250ZXh0LnRlbXBvcmFsKCkuZ2V0TG9uZyhDaHJvbm9GaWVsZC5OQU5PX09GX1NFQ09ORCk7XG4gICAgfVxuXG4gICAgaWYgKGluU2VjcyA9PSBudWxsKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgdmFyIGluU2VjID0gaW5TZWNzO1xuICAgIHZhciBpbk5hbm8gPSBDaHJvbm9GaWVsZC5OQU5PX09GX1NFQ09ORC5jaGVja1ZhbGlkSW50VmFsdWUoaW5OYW5vcyk7XG5cbiAgICBpZiAoaW5TZWMgPj0gLVNFQ09ORFNfMDAwMF9UT18xOTcwKSB7XG4gICAgICB2YXIgemVyb1NlY3MgPSBpblNlYyAtIFNFQ09ORFNfUEVSXzEwMDAwX1lFQVJTICsgU0VDT05EU18wMDAwX1RPXzE5NzA7XG4gICAgICB2YXIgaGkgPSBNYXRoVXRpbC5mbG9vckRpdih6ZXJvU2VjcywgU0VDT05EU19QRVJfMTAwMDBfWUVBUlMpICsgMTtcbiAgICAgIHZhciBsbyA9IE1hdGhVdGlsLmZsb29yTW9kKHplcm9TZWNzLCBTRUNPTkRTX1BFUl8xMDAwMF9ZRUFSUyk7XG4gICAgICB2YXIgbGR0ID0gTG9jYWxEYXRlVGltZS5vZkVwb2NoU2Vjb25kKGxvIC0gU0VDT05EU18wMDAwX1RPXzE5NzAsIDAsIFpvbmVPZmZzZXQuVVRDKTtcblxuICAgICAgaWYgKGhpID4gMCkge1xuICAgICAgICBidWYuYXBwZW5kKCcrJykuYXBwZW5kKGhpKTtcbiAgICAgIH1cblxuICAgICAgYnVmLmFwcGVuZChsZHQpO1xuXG4gICAgICBpZiAobGR0LnNlY29uZCgpID09PSAwKSB7XG4gICAgICAgIGJ1Zi5hcHBlbmQoJzowMCcpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgX3plcm9TZWNzID0gaW5TZWMgKyBTRUNPTkRTXzAwMDBfVE9fMTk3MDtcblxuICAgICAgdmFyIF9oaSA9IE1hdGhVdGlsLmludERpdihfemVyb1NlY3MsIFNFQ09ORFNfUEVSXzEwMDAwX1lFQVJTKTtcblxuICAgICAgdmFyIF9sbyA9IE1hdGhVdGlsLmludE1vZChfemVyb1NlY3MsIFNFQ09ORFNfUEVSXzEwMDAwX1lFQVJTKTtcblxuICAgICAgdmFyIF9sZHQgPSBMb2NhbERhdGVUaW1lLm9mRXBvY2hTZWNvbmQoX2xvIC0gU0VDT05EU18wMDAwX1RPXzE5NzAsIDAsIFpvbmVPZmZzZXQuVVRDKTtcblxuICAgICAgdmFyIHBvcyA9IGJ1Zi5sZW5ndGgoKTtcbiAgICAgIGJ1Zi5hcHBlbmQoX2xkdCk7XG5cbiAgICAgIGlmIChfbGR0LnNlY29uZCgpID09PSAwKSB7XG4gICAgICAgIGJ1Zi5hcHBlbmQoJzowMCcpO1xuICAgICAgfVxuXG4gICAgICBpZiAoX2hpIDwgMCkge1xuICAgICAgICBpZiAoX2xkdC55ZWFyKCkgPT09IC0xMDAwMCkge1xuICAgICAgICAgIGJ1Zi5yZXBsYWNlKHBvcywgcG9zICsgMiwgJycgKyAoX2hpIC0gMSkpO1xuICAgICAgICB9IGVsc2UgaWYgKF9sbyA9PT0gMCkge1xuICAgICAgICAgIGJ1Zi5pbnNlcnQocG9zLCBfaGkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGJ1Zi5pbnNlcnQocG9zICsgMSwgTWF0aC5hYnMoX2hpKSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAodGhpcy5mcmFjdGlvbmFsRGlnaXRzID09PSAtMikge1xuICAgICAgaWYgKGluTmFubyAhPT0gMCkge1xuICAgICAgICBidWYuYXBwZW5kKCcuJyk7XG5cbiAgICAgICAgaWYgKE1hdGhVdGlsLmludE1vZChpbk5hbm8sIDEwMDAwMDApID09PSAwKSB7XG4gICAgICAgICAgYnVmLmFwcGVuZCgoJycgKyAoTWF0aFV0aWwuaW50RGl2KGluTmFubywgMTAwMDAwMCkgKyAxMDAwKSkuc3Vic3RyaW5nKDEpKTtcbiAgICAgICAgfSBlbHNlIGlmIChNYXRoVXRpbC5pbnRNb2QoaW5OYW5vLCAxMDAwKSA9PT0gMCkge1xuICAgICAgICAgIGJ1Zi5hcHBlbmQoKCcnICsgKE1hdGhVdGlsLmludERpdihpbk5hbm8sIDEwMDApICsgMTAwMDAwMCkpLnN1YnN0cmluZygxKSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgYnVmLmFwcGVuZCgoJycgKyAoaW5OYW5vICsgMTAwMDAwMDAwMCkpLnN1YnN0cmluZygxKSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHRoaXMuZnJhY3Rpb25hbERpZ2l0cyA+IDAgfHwgdGhpcy5mcmFjdGlvbmFsRGlnaXRzID09PSAtMSAmJiBpbk5hbm8gPiAwKSB7XG4gICAgICBidWYuYXBwZW5kKCcuJyk7XG4gICAgICB2YXIgZGl2ID0gMTAwMDAwMDAwO1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgdGhpcy5mcmFjdGlvbmFsRGlnaXRzID09PSAtMSAmJiBpbk5hbm8gPiAwIHx8IGkgPCB0aGlzLmZyYWN0aW9uYWxEaWdpdHM7IGkrKykge1xuICAgICAgICB2YXIgZGlnaXQgPSBNYXRoVXRpbC5pbnREaXYoaW5OYW5vLCBkaXYpO1xuICAgICAgICBidWYuYXBwZW5kKGRpZ2l0KTtcbiAgICAgICAgaW5OYW5vID0gaW5OYW5vIC0gZGlnaXQgKiBkaXY7XG4gICAgICAgIGRpdiA9IE1hdGhVdGlsLmludERpdihkaXYsIDEwKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBidWYuYXBwZW5kKCdaJyk7XG4gICAgcmV0dXJuIHRydWU7XG4gIH07XG5cbiAgX3Byb3RvMi5wYXJzZSA9IGZ1bmN0aW9uIHBhcnNlKGNvbnRleHQsIHRleHQsIHBvc2l0aW9uKSB7XG4gICAgdmFyIG5ld0NvbnRleHQgPSBjb250ZXh0LmNvcHkoKTtcbiAgICB2YXIgbWluRGlnaXRzID0gdGhpcy5mcmFjdGlvbmFsRGlnaXRzIDwgMCA/IDAgOiB0aGlzLmZyYWN0aW9uYWxEaWdpdHM7XG4gICAgdmFyIG1heERpZ2l0cyA9IHRoaXMuZnJhY3Rpb25hbERpZ2l0cyA8IDAgPyA5IDogdGhpcy5mcmFjdGlvbmFsRGlnaXRzO1xuXG4gICAgdmFyIHBhcnNlciA9IG5ldyBEYXRlVGltZUZvcm1hdHRlckJ1aWxkZXIoKS5hcHBlbmQoRGF0ZVRpbWVGb3JtYXR0ZXIuSVNPX0xPQ0FMX0RBVEUpLmFwcGVuZExpdGVyYWwoJ1QnKS5hcHBlbmRWYWx1ZShDaHJvbm9GaWVsZC5IT1VSX09GX0RBWSwgMikuYXBwZW5kTGl0ZXJhbCgnOicpLmFwcGVuZFZhbHVlKENocm9ub0ZpZWxkLk1JTlVURV9PRl9IT1VSLCAyKS5hcHBlbmRMaXRlcmFsKCc6JykuYXBwZW5kVmFsdWUoQ2hyb25vRmllbGQuU0VDT05EX09GX01JTlVURSwgMikuYXBwZW5kRnJhY3Rpb24oQ2hyb25vRmllbGQuTkFOT19PRl9TRUNPTkQsIG1pbkRpZ2l0cywgbWF4RGlnaXRzLCB0cnVlKS5hcHBlbmRMaXRlcmFsKCdaJykudG9Gb3JtYXR0ZXIoKS5fdG9QcmludGVyUGFyc2VyKGZhbHNlKTtcblxuICAgIHZhciBwb3MgPSBwYXJzZXIucGFyc2UobmV3Q29udGV4dCwgdGV4dCwgcG9zaXRpb24pO1xuXG4gICAgaWYgKHBvcyA8IDApIHtcbiAgICAgIHJldHVybiBwb3M7XG4gICAgfVxuXG4gICAgdmFyIHllYXJQYXJzZWQgPSBuZXdDb250ZXh0LmdldFBhcnNlZChDaHJvbm9GaWVsZC5ZRUFSKTtcbiAgICB2YXIgbW9udGggPSBuZXdDb250ZXh0LmdldFBhcnNlZChDaHJvbm9GaWVsZC5NT05USF9PRl9ZRUFSKTtcbiAgICB2YXIgZGF5ID0gbmV3Q29udGV4dC5nZXRQYXJzZWQoQ2hyb25vRmllbGQuREFZX09GX01PTlRIKTtcbiAgICB2YXIgaG91ciA9IG5ld0NvbnRleHQuZ2V0UGFyc2VkKENocm9ub0ZpZWxkLkhPVVJfT0ZfREFZKTtcbiAgICB2YXIgbWluID0gbmV3Q29udGV4dC5nZXRQYXJzZWQoQ2hyb25vRmllbGQuTUlOVVRFX09GX0hPVVIpO1xuICAgIHZhciBzZWNWYWwgPSBuZXdDb250ZXh0LmdldFBhcnNlZChDaHJvbm9GaWVsZC5TRUNPTkRfT0ZfTUlOVVRFKTtcbiAgICB2YXIgbmFub1ZhbCA9IG5ld0NvbnRleHQuZ2V0UGFyc2VkKENocm9ub0ZpZWxkLk5BTk9fT0ZfU0VDT05EKTtcbiAgICB2YXIgc2VjID0gc2VjVmFsICE9IG51bGwgPyBzZWNWYWwgOiAwO1xuICAgIHZhciBuYW5vID0gbmFub1ZhbCAhPSBudWxsID8gbmFub1ZhbCA6IDA7XG4gICAgdmFyIHllYXIgPSBNYXRoVXRpbC5pbnRNb2QoeWVhclBhcnNlZCwgMTAwMDApO1xuICAgIHZhciBkYXlzID0gMDtcblxuICAgIGlmIChob3VyID09PSAyNCAmJiBtaW4gPT09IDAgJiYgc2VjID09PSAwICYmIG5hbm8gPT09IDApIHtcbiAgICAgIGhvdXIgPSAwO1xuICAgICAgZGF5cyA9IDE7XG4gICAgfSBlbHNlIGlmIChob3VyID09PSAyMyAmJiBtaW4gPT09IDU5ICYmIHNlYyA9PT0gNjApIHtcbiAgICAgIGNvbnRleHQuc2V0UGFyc2VkTGVhcFNlY29uZCgpO1xuICAgICAgc2VjID0gNTk7XG4gICAgfVxuXG4gICAgdmFyIGluc3RhbnRTZWNzO1xuXG4gICAgdHJ5IHtcbiAgICAgIHZhciBsZHQgPSBMb2NhbERhdGVUaW1lLm9mKHllYXIsIG1vbnRoLCBkYXksIGhvdXIsIG1pbiwgc2VjLCAwKS5wbHVzRGF5cyhkYXlzKTtcbiAgICAgIGluc3RhbnRTZWNzID0gbGR0LnRvRXBvY2hTZWNvbmQoWm9uZU9mZnNldC5VVEMpO1xuICAgICAgaW5zdGFudFNlY3MgKz0gTWF0aFV0aWwuc2FmZU11bHRpcGx5KE1hdGhVdGlsLmludERpdih5ZWFyUGFyc2VkLCAxMDAwMCksIFNFQ09ORFNfUEVSXzEwMDAwX1lFQVJTKTtcbiAgICB9IGNhdGNoIChleCkge1xuICAgICAgcmV0dXJuIH5wb3NpdGlvbjtcbiAgICB9XG5cbiAgICB2YXIgc3VjY2Vzc1BvcyA9IHBvcztcbiAgICBzdWNjZXNzUG9zID0gY29udGV4dC5zZXRQYXJzZWRGaWVsZChDaHJvbm9GaWVsZC5JTlNUQU5UX1NFQ09ORFMsIGluc3RhbnRTZWNzLCBwb3NpdGlvbiwgc3VjY2Vzc1Bvcyk7XG4gICAgcmV0dXJuIGNvbnRleHQuc2V0UGFyc2VkRmllbGQoQ2hyb25vRmllbGQuTkFOT19PRl9TRUNPTkQsIG5hbm8sIHBvc2l0aW9uLCBzdWNjZXNzUG9zKTtcbiAgfTtcblxuICBfcHJvdG8yLnRvU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG4gICAgcmV0dXJuICdJbnN0YW50KCknO1xuICB9O1xuXG4gIHJldHVybiBJbnN0YW50UHJpbnRlclBhcnNlcjtcbn0oKTtcblxuZnVuY3Rpb24gX2luaXQkOSgpIHtcbiAgUmVkdWNlZFByaW50ZXJQYXJzZXIuQkFTRV9EQVRFID0gTG9jYWxEYXRlLm9mKDIwMDAsIDEsIDEpO1xuICBEYXRlVGltZUZvcm1hdHRlckJ1aWxkZXIuQ29tcG9zaXRlUHJpbnRlclBhcnNlciA9IENvbXBvc2l0ZVByaW50ZXJQYXJzZXI7XG4gIERhdGVUaW1lRm9ybWF0dGVyQnVpbGRlci5QYWRQcmludGVyUGFyc2VyRGVjb3JhdG9yID0gUGFkUHJpbnRlclBhcnNlckRlY29yYXRvcjtcbiAgRGF0ZVRpbWVGb3JtYXR0ZXJCdWlsZGVyLlNldHRpbmdzUGFyc2VyID0gU2V0dGluZ3NQYXJzZXI7XG4gIERhdGVUaW1lRm9ybWF0dGVyQnVpbGRlci5DaGFyTGl0ZXJhbFByaW50ZXJQYXJzZXIgPSBTdHJpbmdMaXRlcmFsUHJpbnRlclBhcnNlcjtcbiAgRGF0ZVRpbWVGb3JtYXR0ZXJCdWlsZGVyLlN0cmluZ0xpdGVyYWxQcmludGVyUGFyc2VyID0gU3RyaW5nTGl0ZXJhbFByaW50ZXJQYXJzZXI7XG4gIERhdGVUaW1lRm9ybWF0dGVyQnVpbGRlci5DaGFyTGl0ZXJhbFByaW50ZXJQYXJzZXIgPSBDaGFyTGl0ZXJhbFByaW50ZXJQYXJzZXI7XG4gIERhdGVUaW1lRm9ybWF0dGVyQnVpbGRlci5OdW1iZXJQcmludGVyUGFyc2VyID0gTnVtYmVyUHJpbnRlclBhcnNlcjtcbiAgRGF0ZVRpbWVGb3JtYXR0ZXJCdWlsZGVyLlJlZHVjZWRQcmludGVyUGFyc2VyID0gUmVkdWNlZFByaW50ZXJQYXJzZXI7XG4gIERhdGVUaW1lRm9ybWF0dGVyQnVpbGRlci5GcmFjdGlvblByaW50ZXJQYXJzZXIgPSBGcmFjdGlvblByaW50ZXJQYXJzZXI7XG4gIERhdGVUaW1lRm9ybWF0dGVyQnVpbGRlci5PZmZzZXRJZFByaW50ZXJQYXJzZXIgPSBPZmZzZXRJZFByaW50ZXJQYXJzZXI7XG4gIERhdGVUaW1lRm9ybWF0dGVyQnVpbGRlci5ab25lSWRQcmludGVyUGFyc2VyID0gWm9uZUlkUHJpbnRlclBhcnNlcjtcbn1cblxuLypcbiAqIEBjb3B5cmlnaHQgKGMpIDIwMTYsIFBoaWxpcHAgVGjDvHJ3w6RjaHRlciAmIFBhdHRyaWNrIEjDvHBlclxuICogQGxpY2Vuc2UgQlNELTMtQ2xhdXNlIChzZWUgTElDRU5TRSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZSlcbiAqL1xudmFyIFN0cmluZ0J1aWxkZXIgPSBmdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIFN0cmluZ0J1aWxkZXIoKSB7XG4gICAgdGhpcy5fc3RyID0gJyc7XG4gIH1cblxuICB2YXIgX3Byb3RvID0gU3RyaW5nQnVpbGRlci5wcm90b3R5cGU7XG5cbiAgX3Byb3RvLmFwcGVuZCA9IGZ1bmN0aW9uIGFwcGVuZChzdHIpIHtcbiAgICB0aGlzLl9zdHIgKz0gc3RyO1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIF9wcm90by5hcHBlbmRDaGFyID0gZnVuY3Rpb24gYXBwZW5kQ2hhcihzdHIpIHtcbiAgICB0aGlzLl9zdHIgKz0gc3RyWzBdO1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIF9wcm90by5pbnNlcnQgPSBmdW5jdGlvbiBpbnNlcnQob2Zmc2V0LCBzdHIpIHtcbiAgICB0aGlzLl9zdHIgPSB0aGlzLl9zdHIuc2xpY2UoMCwgb2Zmc2V0KSArIHN0ciArIHRoaXMuX3N0ci5zbGljZShvZmZzZXQpO1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIF9wcm90by5yZXBsYWNlID0gZnVuY3Rpb24gcmVwbGFjZShzdGFydCwgZW5kLCBzdHIpIHtcbiAgICB0aGlzLl9zdHIgPSB0aGlzLl9zdHIuc2xpY2UoMCwgc3RhcnQpICsgc3RyICsgdGhpcy5fc3RyLnNsaWNlKGVuZCk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgX3Byb3RvLmxlbmd0aCA9IGZ1bmN0aW9uIGxlbmd0aCgpIHtcbiAgICByZXR1cm4gdGhpcy5fc3RyLmxlbmd0aDtcbiAgfTtcblxuICBfcHJvdG8uc2V0TGVuZ3RoID0gZnVuY3Rpb24gc2V0TGVuZ3RoKGxlbmd0aCkge1xuICAgIHRoaXMuX3N0ciA9IHRoaXMuX3N0ci5zbGljZSgwLCBsZW5ndGgpO1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIF9wcm90by50b1N0cmluZyA9IGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuICAgIHJldHVybiB0aGlzLl9zdHI7XG4gIH07XG5cbiAgcmV0dXJuIFN0cmluZ0J1aWxkZXI7XG59KCk7XG5cbi8qKlxuICogQGNvcHlyaWdodCAoYykgMjAxNiwgUGhpbGlwcCBUaMO8cnfDpGNodGVyICYgUGF0dHJpY2sgSMO8cGVyXG4gKiBAY29weXJpZ2h0IChjKSAyMDA3LXByZXNlbnQsIFN0ZXBoZW4gQ29sZWJvdXJuZSAmIE1pY2hhZWwgTmFzY2ltZW50byBTYW50b3NcbiAqIEBsaWNlbnNlIEJTRC0zLUNsYXVzZSAoc2VlIExJQ0VOU0UgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUpXG4gKi9cbnZhciBEYXRlVGltZUZvcm1hdHRlciA9IGZ1bmN0aW9uICgpIHtcbiAgRGF0ZVRpbWVGb3JtYXR0ZXIucGFyc2VkRXhjZXNzRGF5cyA9IGZ1bmN0aW9uIHBhcnNlZEV4Y2Vzc0RheXMoKSB7XG4gICAgcmV0dXJuIERhdGVUaW1lRm9ybWF0dGVyLlBBUlNFRF9FWENFU1NfREFZUztcbiAgfTtcblxuICBEYXRlVGltZUZvcm1hdHRlci5wYXJzZWRMZWFwU2Vjb25kID0gZnVuY3Rpb24gcGFyc2VkTGVhcFNlY29uZCgpIHtcbiAgICByZXR1cm4gRGF0ZVRpbWVGb3JtYXR0ZXIuUEFSU0VEX0xFQVBfU0VDT05EO1xuICB9O1xuXG4gIERhdGVUaW1lRm9ybWF0dGVyLm9mUGF0dGVybiA9IGZ1bmN0aW9uIG9mUGF0dGVybihwYXR0ZXJuKSB7XG4gICAgcmV0dXJuIG5ldyBEYXRlVGltZUZvcm1hdHRlckJ1aWxkZXIoKS5hcHBlbmRQYXR0ZXJuKHBhdHRlcm4pLnRvRm9ybWF0dGVyKCk7XG4gIH07XG5cbiAgZnVuY3Rpb24gRGF0ZVRpbWVGb3JtYXR0ZXIocHJpbnRlclBhcnNlciwgbG9jYWxlLCBkZWNpbWFsU3R5bGUsIHJlc29sdmVyU3R5bGUsIHJlc29sdmVyRmllbGRzLCBjaHJvbm8sIHpvbmUpIHtcbiAgICBpZiAoY2hyb25vID09PSB2b2lkIDApIHtcbiAgICAgIGNocm9ubyA9IElzb0Nocm9ub2xvZ3kuSU5TVEFOQ0U7XG4gICAgfVxuXG4gICAgYXNzZXJ0KHByaW50ZXJQYXJzZXIgIT0gbnVsbCk7XG4gICAgYXNzZXJ0KGRlY2ltYWxTdHlsZSAhPSBudWxsKTtcbiAgICBhc3NlcnQocmVzb2x2ZXJTdHlsZSAhPSBudWxsKTtcbiAgICB0aGlzLl9wcmludGVyUGFyc2VyID0gcHJpbnRlclBhcnNlcjtcbiAgICB0aGlzLl9sb2NhbGUgPSBsb2NhbGU7XG4gICAgdGhpcy5fZGVjaW1hbFN0eWxlID0gZGVjaW1hbFN0eWxlO1xuICAgIHRoaXMuX3Jlc29sdmVyU3R5bGUgPSByZXNvbHZlclN0eWxlO1xuICAgIHRoaXMuX3Jlc29sdmVyRmllbGRzID0gcmVzb2x2ZXJGaWVsZHM7XG4gICAgdGhpcy5fY2hyb25vID0gY2hyb25vO1xuICAgIHRoaXMuX3pvbmUgPSB6b25lO1xuICB9XG5cbiAgdmFyIF9wcm90byA9IERhdGVUaW1lRm9ybWF0dGVyLnByb3RvdHlwZTtcblxuICBfcHJvdG8ubG9jYWxlID0gZnVuY3Rpb24gbG9jYWxlKCkge1xuICAgIHJldHVybiB0aGlzLl9sb2NhbGU7XG4gIH07XG5cbiAgX3Byb3RvLmRlY2ltYWxTdHlsZSA9IGZ1bmN0aW9uIGRlY2ltYWxTdHlsZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fZGVjaW1hbFN0eWxlO1xuICB9O1xuXG4gIF9wcm90by5jaHJvbm9sb2d5ID0gZnVuY3Rpb24gY2hyb25vbG9neSgpIHtcbiAgICByZXR1cm4gdGhpcy5fY2hyb25vO1xuICB9O1xuXG4gIF9wcm90by53aXRoQ2hyb25vbG9neSA9IGZ1bmN0aW9uIHdpdGhDaHJvbm9sb2d5KGNocm9ubykge1xuICAgIGlmICh0aGlzLl9jaHJvbm8gIT0gbnVsbCAmJiB0aGlzLl9jaHJvbm8uZXF1YWxzKGNocm9ubykpIHtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIHJldHVybiBuZXcgRGF0ZVRpbWVGb3JtYXR0ZXIodGhpcy5fcHJpbnRlclBhcnNlciwgdGhpcy5fbG9jYWxlLCB0aGlzLl9kZWNpbWFsU3R5bGUsIHRoaXMuX3Jlc29sdmVyU3R5bGUsIHRoaXMuX3Jlc29sdmVyRmllbGRzLCBjaHJvbm8sIHRoaXMuX3pvbmUpO1xuICB9O1xuXG4gIF9wcm90by53aXRoTG9jYWxlID0gZnVuY3Rpb24gd2l0aExvY2FsZSgpIHtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICBfcHJvdG8ud2l0aFJlc29sdmVyU3R5bGUgPSBmdW5jdGlvbiB3aXRoUmVzb2x2ZXJTdHlsZShyZXNvbHZlclN0eWxlKSB7XG4gICAgcmVxdWlyZU5vbk51bGwocmVzb2x2ZXJTdHlsZSwgJ3Jlc29sdmVyU3R5bGUnKTtcblxuICAgIGlmIChyZXNvbHZlclN0eWxlLmVxdWFscyh0aGlzLl9yZXNvbHZlclN0eWxlKSkge1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgcmV0dXJuIG5ldyBEYXRlVGltZUZvcm1hdHRlcih0aGlzLl9wcmludGVyUGFyc2VyLCB0aGlzLl9sb2NhbGUsIHRoaXMuX2RlY2ltYWxTdHlsZSwgcmVzb2x2ZXJTdHlsZSwgdGhpcy5fcmVzb2x2ZXJGaWVsZHMsIHRoaXMuX2Nocm9ubywgdGhpcy5fem9uZSk7XG4gIH07XG5cbiAgX3Byb3RvLmZvcm1hdCA9IGZ1bmN0aW9uIGZvcm1hdCh0ZW1wb3JhbCkge1xuICAgIHZhciBidWYgPSBuZXcgU3RyaW5nQnVpbGRlcigzMik7XG5cbiAgICB0aGlzLl9mb3JtYXRUbyh0ZW1wb3JhbCwgYnVmKTtcblxuICAgIHJldHVybiBidWYudG9TdHJpbmcoKTtcbiAgfTtcblxuICBfcHJvdG8uX2Zvcm1hdFRvID0gZnVuY3Rpb24gX2Zvcm1hdFRvKHRlbXBvcmFsLCBhcHBlbmRhYmxlKSB7XG4gICAgcmVxdWlyZU5vbk51bGwodGVtcG9yYWwsICd0ZW1wb3JhbCcpO1xuICAgIHJlcXVpcmVOb25OdWxsKGFwcGVuZGFibGUsICdhcHBlbmRhYmxlJyk7XG4gICAgdmFyIGNvbnRleHQgPSBuZXcgRGF0ZVRpbWVQcmludENvbnRleHQodGVtcG9yYWwsIHRoaXMpO1xuXG4gICAgdGhpcy5fcHJpbnRlclBhcnNlci5wcmludChjb250ZXh0LCBhcHBlbmRhYmxlKTtcbiAgfTtcblxuICBfcHJvdG8ucGFyc2UgPSBmdW5jdGlvbiBwYXJzZSh0ZXh0LCB0eXBlKSB7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEpIHtcbiAgICAgIHJldHVybiB0aGlzLnBhcnNlMSh0ZXh0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHRoaXMucGFyc2UyKHRleHQsIHR5cGUpO1xuICAgIH1cbiAgfTtcblxuICBfcHJvdG8ucGFyc2UxID0gZnVuY3Rpb24gcGFyc2UxKHRleHQpIHtcbiAgICByZXF1aXJlTm9uTnVsbCh0ZXh0LCAndGV4dCcpO1xuXG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiB0aGlzLl9wYXJzZVRvQnVpbGRlcih0ZXh0LCBudWxsKS5yZXNvbHZlKHRoaXMuX3Jlc29sdmVyU3R5bGUsIHRoaXMuX3Jlc29sdmVyRmllbGRzKTtcbiAgICB9IGNhdGNoIChleCkge1xuICAgICAgaWYgKGV4IGluc3RhbmNlb2YgRGF0ZVRpbWVQYXJzZUV4Y2VwdGlvbikge1xuICAgICAgICB0aHJvdyBleDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IHRoaXMuX2NyZWF0ZUVycm9yKHRleHQsIGV4KTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgX3Byb3RvLnBhcnNlMiA9IGZ1bmN0aW9uIHBhcnNlMih0ZXh0LCB0eXBlKSB7XG4gICAgcmVxdWlyZU5vbk51bGwodGV4dCwgJ3RleHQnKTtcbiAgICByZXF1aXJlTm9uTnVsbCh0eXBlLCAndHlwZScpO1xuXG4gICAgdHJ5IHtcbiAgICAgIHZhciBidWlsZGVyID0gdGhpcy5fcGFyc2VUb0J1aWxkZXIodGV4dCwgbnVsbCkucmVzb2x2ZSh0aGlzLl9yZXNvbHZlclN0eWxlLCB0aGlzLl9yZXNvbHZlckZpZWxkcyk7XG5cbiAgICAgIHJldHVybiBidWlsZGVyLmJ1aWxkKHR5cGUpO1xuICAgIH0gY2F0Y2ggKGV4KSB7XG4gICAgICBpZiAoZXggaW5zdGFuY2VvZiBEYXRlVGltZVBhcnNlRXhjZXB0aW9uKSB7XG4gICAgICAgIHRocm93IGV4O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgdGhpcy5fY3JlYXRlRXJyb3IodGV4dCwgZXgpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICBfcHJvdG8uX2NyZWF0ZUVycm9yID0gZnVuY3Rpb24gX2NyZWF0ZUVycm9yKHRleHQsIGV4KSB7XG4gICAgdmFyIGFiYnIgPSAnJztcblxuICAgIGlmICh0ZXh0Lmxlbmd0aCA+IDY0KSB7XG4gICAgICBhYmJyID0gdGV4dC5zdWJzdHJpbmcoMCwgNjQpICsgJy4uLic7XG4gICAgfSBlbHNlIHtcbiAgICAgIGFiYnIgPSB0ZXh0O1xuICAgIH1cblxuICAgIHJldHVybiBuZXcgRGF0ZVRpbWVQYXJzZUV4Y2VwdGlvbignVGV4dCBcXCcnICsgYWJiciArICdcXCcgY291bGQgbm90IGJlIHBhcnNlZDogJyArIGV4Lm1lc3NhZ2UsIHRleHQsIDAsIGV4KTtcbiAgfTtcblxuICBfcHJvdG8uX3BhcnNlVG9CdWlsZGVyID0gZnVuY3Rpb24gX3BhcnNlVG9CdWlsZGVyKHRleHQsIHBvc2l0aW9uKSB7XG4gICAgdmFyIHBvcyA9IHBvc2l0aW9uICE9IG51bGwgPyBwb3NpdGlvbiA6IG5ldyBQYXJzZVBvc2l0aW9uKDApO1xuXG4gICAgdmFyIHJlc3VsdCA9IHRoaXMuX3BhcnNlVW5yZXNvbHZlZDAodGV4dCwgcG9zKTtcblxuICAgIGlmIChyZXN1bHQgPT0gbnVsbCB8fCBwb3MuZ2V0RXJyb3JJbmRleCgpID49IDAgfHwgcG9zaXRpb24gPT0gbnVsbCAmJiBwb3MuZ2V0SW5kZXgoKSA8IHRleHQubGVuZ3RoKSB7XG4gICAgICB2YXIgYWJiciA9ICcnO1xuXG4gICAgICBpZiAodGV4dC5sZW5ndGggPiA2NCkge1xuICAgICAgICBhYmJyID0gdGV4dC5zdWJzdHIoMCwgNjQpLnRvU3RyaW5nKCkgKyAnLi4uJztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGFiYnIgPSB0ZXh0O1xuICAgICAgfVxuXG4gICAgICBpZiAocG9zLmdldEVycm9ySW5kZXgoKSA+PSAwKSB7XG4gICAgICAgIHRocm93IG5ldyBEYXRlVGltZVBhcnNlRXhjZXB0aW9uKCdUZXh0IFxcJycgKyBhYmJyICsgJ1xcJyBjb3VsZCBub3QgYmUgcGFyc2VkIGF0IGluZGV4ICcgKyBwb3MuZ2V0RXJyb3JJbmRleCgpLCB0ZXh0LCBwb3MuZ2V0RXJyb3JJbmRleCgpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBEYXRlVGltZVBhcnNlRXhjZXB0aW9uKCdUZXh0IFxcJycgKyBhYmJyICsgJ1xcJyBjb3VsZCBub3QgYmUgcGFyc2VkLCB1bnBhcnNlZCB0ZXh0IGZvdW5kIGF0IGluZGV4ICcgKyBwb3MuZ2V0SW5kZXgoKSwgdGV4dCwgcG9zLmdldEluZGV4KCkpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiByZXN1bHQudG9CdWlsZGVyKCk7XG4gIH07XG5cbiAgX3Byb3RvLnBhcnNlVW5yZXNvbHZlZCA9IGZ1bmN0aW9uIHBhcnNlVW5yZXNvbHZlZCh0ZXh0LCBwb3NpdGlvbikge1xuICAgIHJldHVybiB0aGlzLl9wYXJzZVVucmVzb2x2ZWQwKHRleHQsIHBvc2l0aW9uKTtcbiAgfTtcblxuICBfcHJvdG8uX3BhcnNlVW5yZXNvbHZlZDAgPSBmdW5jdGlvbiBfcGFyc2VVbnJlc29sdmVkMCh0ZXh0LCBwb3NpdGlvbikge1xuICAgIGFzc2VydCh0ZXh0ICE9IG51bGwsICd0ZXh0JywgTnVsbFBvaW50ZXJFeGNlcHRpb24pO1xuICAgIGFzc2VydChwb3NpdGlvbiAhPSBudWxsLCAncG9zaXRpb24nLCBOdWxsUG9pbnRlckV4Y2VwdGlvbik7XG4gICAgdmFyIGNvbnRleHQgPSBuZXcgRGF0ZVRpbWVQYXJzZUNvbnRleHQodGhpcyk7XG4gICAgdmFyIHBvcyA9IHBvc2l0aW9uLmdldEluZGV4KCk7XG4gICAgcG9zID0gdGhpcy5fcHJpbnRlclBhcnNlci5wYXJzZShjb250ZXh0LCB0ZXh0LCBwb3MpO1xuXG4gICAgaWYgKHBvcyA8IDApIHtcbiAgICAgIHBvc2l0aW9uLnNldEVycm9ySW5kZXgofnBvcyk7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICBwb3NpdGlvbi5zZXRJbmRleChwb3MpO1xuICAgIHJldHVybiBjb250ZXh0LnRvUGFyc2VkKCk7XG4gIH07XG5cbiAgX3Byb3RvLl90b1ByaW50ZXJQYXJzZXIgPSBmdW5jdGlvbiBfdG9QcmludGVyUGFyc2VyKG9wdGlvbmFsKSB7XG4gICAgcmV0dXJuIHRoaXMuX3ByaW50ZXJQYXJzZXIud2l0aE9wdGlvbmFsKG9wdGlvbmFsKTtcbiAgfTtcblxuICBfcHJvdG8udG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZygpIHtcbiAgICB2YXIgcGF0dGVybiA9IHRoaXMuX3ByaW50ZXJQYXJzZXIudG9TdHJpbmcoKTtcblxuICAgIHJldHVybiBwYXR0ZXJuLmluZGV4T2YoJ1snKSA9PT0gMCA/IHBhdHRlcm4gOiBwYXR0ZXJuLnN1YnN0cmluZygxLCBwYXR0ZXJuLmxlbmd0aCAtIDEpO1xuICB9O1xuXG4gIHJldHVybiBEYXRlVGltZUZvcm1hdHRlcjtcbn0oKTtcbmZ1bmN0aW9uIF9pbml0JGEoKSB7XG4gIERhdGVUaW1lRm9ybWF0dGVyLklTT19MT0NBTF9EQVRFID0gbmV3IERhdGVUaW1lRm9ybWF0dGVyQnVpbGRlcigpLmFwcGVuZFZhbHVlKENocm9ub0ZpZWxkLllFQVIsIDQsIDEwLCBTaWduU3R5bGUuRVhDRUVEU19QQUQpLmFwcGVuZExpdGVyYWwoJy0nKS5hcHBlbmRWYWx1ZShDaHJvbm9GaWVsZC5NT05USF9PRl9ZRUFSLCAyKS5hcHBlbmRMaXRlcmFsKCctJykuYXBwZW5kVmFsdWUoQ2hyb25vRmllbGQuREFZX09GX01PTlRILCAyKS50b0Zvcm1hdHRlcihSZXNvbHZlclN0eWxlLlNUUklDVCkud2l0aENocm9ub2xvZ3koSXNvQ2hyb25vbG9neS5JTlNUQU5DRSk7XG4gIERhdGVUaW1lRm9ybWF0dGVyLklTT19MT0NBTF9USU1FID0gbmV3IERhdGVUaW1lRm9ybWF0dGVyQnVpbGRlcigpLmFwcGVuZFZhbHVlKENocm9ub0ZpZWxkLkhPVVJfT0ZfREFZLCAyKS5hcHBlbmRMaXRlcmFsKCc6JykuYXBwZW5kVmFsdWUoQ2hyb25vRmllbGQuTUlOVVRFX09GX0hPVVIsIDIpLm9wdGlvbmFsU3RhcnQoKS5hcHBlbmRMaXRlcmFsKCc6JykuYXBwZW5kVmFsdWUoQ2hyb25vRmllbGQuU0VDT05EX09GX01JTlVURSwgMikub3B0aW9uYWxTdGFydCgpLmFwcGVuZEZyYWN0aW9uKENocm9ub0ZpZWxkLk5BTk9fT0ZfU0VDT05ELCAwLCA5LCB0cnVlKS50b0Zvcm1hdHRlcihSZXNvbHZlclN0eWxlLlNUUklDVCk7XG4gIERhdGVUaW1lRm9ybWF0dGVyLklTT19MT0NBTF9EQVRFX1RJTUUgPSBuZXcgRGF0ZVRpbWVGb3JtYXR0ZXJCdWlsZGVyKCkucGFyc2VDYXNlSW5zZW5zaXRpdmUoKS5hcHBlbmQoRGF0ZVRpbWVGb3JtYXR0ZXIuSVNPX0xPQ0FMX0RBVEUpLmFwcGVuZExpdGVyYWwoJ1QnKS5hcHBlbmQoRGF0ZVRpbWVGb3JtYXR0ZXIuSVNPX0xPQ0FMX1RJTUUpLnRvRm9ybWF0dGVyKFJlc29sdmVyU3R5bGUuU1RSSUNUKS53aXRoQ2hyb25vbG9neShJc29DaHJvbm9sb2d5LklOU1RBTkNFKTtcbiAgRGF0ZVRpbWVGb3JtYXR0ZXIuSVNPX0lOU1RBTlQgPSBuZXcgRGF0ZVRpbWVGb3JtYXR0ZXJCdWlsZGVyKCkucGFyc2VDYXNlSW5zZW5zaXRpdmUoKS5hcHBlbmRJbnN0YW50KCkudG9Gb3JtYXR0ZXIoUmVzb2x2ZXJTdHlsZS5TVFJJQ1QpO1xuICBEYXRlVGltZUZvcm1hdHRlci5JU09fT0ZGU0VUX0RBVEVfVElNRSA9IG5ldyBEYXRlVGltZUZvcm1hdHRlckJ1aWxkZXIoKS5wYXJzZUNhc2VJbnNlbnNpdGl2ZSgpLmFwcGVuZChEYXRlVGltZUZvcm1hdHRlci5JU09fTE9DQUxfREFURV9USU1FKS5hcHBlbmRPZmZzZXRJZCgpLnRvRm9ybWF0dGVyKFJlc29sdmVyU3R5bGUuU1RSSUNUKS53aXRoQ2hyb25vbG9neShJc29DaHJvbm9sb2d5LklOU1RBTkNFKTtcbiAgRGF0ZVRpbWVGb3JtYXR0ZXIuSVNPX1pPTkVEX0RBVEVfVElNRSA9IG5ldyBEYXRlVGltZUZvcm1hdHRlckJ1aWxkZXIoKS5hcHBlbmQoRGF0ZVRpbWVGb3JtYXR0ZXIuSVNPX09GRlNFVF9EQVRFX1RJTUUpLm9wdGlvbmFsU3RhcnQoKS5hcHBlbmRMaXRlcmFsKCdbJykucGFyc2VDYXNlU2Vuc2l0aXZlKCkuYXBwZW5kWm9uZUlkKCkuYXBwZW5kTGl0ZXJhbCgnXScpLnRvRm9ybWF0dGVyKFJlc29sdmVyU3R5bGUuU1RSSUNUKS53aXRoQ2hyb25vbG9neShJc29DaHJvbm9sb2d5LklOU1RBTkNFKTtcbiAgRGF0ZVRpbWVGb3JtYXR0ZXIuQkFTSUNfSVNPX0RBVEUgPSBuZXcgRGF0ZVRpbWVGb3JtYXR0ZXJCdWlsZGVyKCkuYXBwZW5kVmFsdWUoQ2hyb25vRmllbGQuWUVBUiwgNCwgMTAsIFNpZ25TdHlsZS5FWENFRURTX1BBRCkuYXBwZW5kVmFsdWUoQ2hyb25vRmllbGQuTU9OVEhfT0ZfWUVBUiwgMikuYXBwZW5kVmFsdWUoQ2hyb25vRmllbGQuREFZX09GX01PTlRILCAyKS50b0Zvcm1hdHRlcihSZXNvbHZlclN0eWxlLlNUUklDVCkud2l0aENocm9ub2xvZ3koSXNvQ2hyb25vbG9neS5JTlNUQU5DRSk7XG4gIERhdGVUaW1lRm9ybWF0dGVyLklTT19PRkZTRVRfREFURSA9IG5ldyBEYXRlVGltZUZvcm1hdHRlckJ1aWxkZXIoKS5wYXJzZUNhc2VJbnNlbnNpdGl2ZSgpLmFwcGVuZChEYXRlVGltZUZvcm1hdHRlci5JU09fTE9DQUxfREFURSkuYXBwZW5kT2Zmc2V0SWQoKS50b0Zvcm1hdHRlcihSZXNvbHZlclN0eWxlLlNUUklDVCkud2l0aENocm9ub2xvZ3koSXNvQ2hyb25vbG9neS5JTlNUQU5DRSk7XG4gIERhdGVUaW1lRm9ybWF0dGVyLklTT19PRkZTRVRfVElNRSA9IG5ldyBEYXRlVGltZUZvcm1hdHRlckJ1aWxkZXIoKS5wYXJzZUNhc2VJbnNlbnNpdGl2ZSgpLmFwcGVuZChEYXRlVGltZUZvcm1hdHRlci5JU09fTE9DQUxfVElNRSkuYXBwZW5kT2Zmc2V0SWQoKS50b0Zvcm1hdHRlcihSZXNvbHZlclN0eWxlLlNUUklDVCkud2l0aENocm9ub2xvZ3koSXNvQ2hyb25vbG9neS5JTlNUQU5DRSk7XG4gIERhdGVUaW1lRm9ybWF0dGVyLklTT19PUkRJTkFMX0RBVEUgPSBuZXcgRGF0ZVRpbWVGb3JtYXR0ZXJCdWlsZGVyKCkuYXBwZW5kVmFsdWUoQ2hyb25vRmllbGQuWUVBUiwgNCwgMTAsIFNpZ25TdHlsZS5FWENFRURTX1BBRCkuYXBwZW5kTGl0ZXJhbCgnLScpLmFwcGVuZFZhbHVlKENocm9ub0ZpZWxkLkRBWV9PRl9ZRUFSKS50b0Zvcm1hdHRlcihSZXNvbHZlclN0eWxlLlNUUklDVCk7XG4gIERhdGVUaW1lRm9ybWF0dGVyLklTT19XRUVLX0RBVEUgPSBuZXcgRGF0ZVRpbWVGb3JtYXR0ZXJCdWlsZGVyKCkuYXBwZW5kVmFsdWUoQ2hyb25vRmllbGQuWUVBUiwgNCwgMTAsIFNpZ25TdHlsZS5FWENFRURTX1BBRCkuYXBwZW5kTGl0ZXJhbCgnLVcnKS5hcHBlbmRWYWx1ZShDaHJvbm9GaWVsZC5BTElHTkVEX1dFRUtfT0ZfWUVBUikuYXBwZW5kTGl0ZXJhbCgnLScpLmFwcGVuZFZhbHVlKENocm9ub0ZpZWxkLkRBWV9PRl9XRUVLKS50b0Zvcm1hdHRlcihSZXNvbHZlclN0eWxlLlNUUklDVCk7XG4gIERhdGVUaW1lRm9ybWF0dGVyLlBBUlNFRF9FWENFU1NfREFZUyA9IGNyZWF0ZVRlbXBvcmFsUXVlcnkoJ1BBUlNFRF9FWENFU1NfREFZUycsIGZ1bmN0aW9uICh0ZW1wb3JhbCkge1xuICAgIGlmICh0ZW1wb3JhbCBpbnN0YW5jZW9mIERhdGVUaW1lQnVpbGRlcikge1xuICAgICAgcmV0dXJuIHRlbXBvcmFsLmV4Y2Vzc0RheXM7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBQZXJpb2QuWkVSTztcbiAgICB9XG4gIH0pO1xuICBEYXRlVGltZUZvcm1hdHRlci5QQVJTRURfTEVBUF9TRUNPTkQgPSBjcmVhdGVUZW1wb3JhbFF1ZXJ5KCdQQVJTRURfTEVBUF9TRUNPTkQnLCBmdW5jdGlvbiAodGVtcG9yYWwpIHtcbiAgICBpZiAodGVtcG9yYWwgaW5zdGFuY2VvZiBEYXRlVGltZUJ1aWxkZXIpIHtcbiAgICAgIHJldHVybiB0ZW1wb3JhbC5sZWFwU2Vjb25kO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9KTtcbn1cblxudmFyIE1vbnRoRGF5ID0gZnVuY3Rpb24gKF9UZW1wb3JhbEFjY2Vzc29yKSB7XG4gIF9pbmhlcml0c0xvb3NlKE1vbnRoRGF5LCBfVGVtcG9yYWxBY2Nlc3Nvcik7XG5cbiAgTW9udGhEYXkubm93ID0gZnVuY3Rpb24gbm93KHpvbmVJZE9yQ2xvY2spIHtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuIE1vbnRoRGF5Lm5vdzAoKTtcbiAgICB9IGVsc2UgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEgJiYgem9uZUlkT3JDbG9jayBpbnN0YW5jZW9mIFpvbmVJZCkge1xuICAgICAgcmV0dXJuIE1vbnRoRGF5Lm5vd1pvbmVJZCh6b25lSWRPckNsb2NrKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIE1vbnRoRGF5Lm5vd0Nsb2NrKHpvbmVJZE9yQ2xvY2spO1xuICAgIH1cbiAgfTtcblxuICBNb250aERheS5ub3cwID0gZnVuY3Rpb24gbm93MCgpIHtcbiAgICByZXR1cm4gdGhpcy5ub3dDbG9jayhDbG9jay5zeXN0ZW1EZWZhdWx0Wm9uZSgpKTtcbiAgfTtcblxuICBNb250aERheS5ub3dab25lSWQgPSBmdW5jdGlvbiBub3dab25lSWQoem9uZSkge1xuICAgIHJlcXVpcmVOb25OdWxsKHpvbmUsICd6b25lJyk7XG4gICAgcmV0dXJuIHRoaXMubm93Q2xvY2soQ2xvY2suc3lzdGVtKHpvbmUpKTtcbiAgfTtcblxuICBNb250aERheS5ub3dDbG9jayA9IGZ1bmN0aW9uIG5vd0Nsb2NrKGNsb2NrKSB7XG4gICAgcmVxdWlyZU5vbk51bGwoY2xvY2ssICdjbG9jaycpO1xuICAgIHZhciBub3cgPSBMb2NhbERhdGUubm93KGNsb2NrKTtcbiAgICByZXR1cm4gTW9udGhEYXkub2Yobm93Lm1vbnRoKCksIG5vdy5kYXlPZk1vbnRoKCkpO1xuICB9O1xuXG4gIE1vbnRoRGF5Lm9mID0gZnVuY3Rpb24gb2YobW9udGhPck51bWJlciwgbnVtYmVyKSB7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDIgJiYgbW9udGhPck51bWJlciBpbnN0YW5jZW9mIE1vbnRoKSB7XG4gICAgICByZXR1cm4gTW9udGhEYXkub2ZNb250aE51bWJlcihtb250aE9yTnVtYmVyLCBudW1iZXIpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gTW9udGhEYXkub2ZOdW1iZXJOdW1iZXIobW9udGhPck51bWJlciwgbnVtYmVyKTtcbiAgICB9XG4gIH07XG5cbiAgTW9udGhEYXkub2ZNb250aE51bWJlciA9IGZ1bmN0aW9uIG9mTW9udGhOdW1iZXIobW9udGgsIGRheU9mTW9udGgpIHtcbiAgICByZXF1aXJlTm9uTnVsbChtb250aCwgJ21vbnRoJyk7XG4gICAgQ2hyb25vRmllbGQuREFZX09GX01PTlRILmNoZWNrVmFsaWRWYWx1ZShkYXlPZk1vbnRoKTtcblxuICAgIGlmIChkYXlPZk1vbnRoID4gbW9udGgubWF4TGVuZ3RoKCkpIHtcbiAgICAgIHRocm93IG5ldyBEYXRlVGltZUV4Y2VwdGlvbignSWxsZWdhbCB2YWx1ZSBmb3IgRGF5T2ZNb250aCBmaWVsZCwgdmFsdWUgJyArIGRheU9mTW9udGggKyAnIGlzIG5vdCB2YWxpZCBmb3IgbW9udGggJyArIG1vbnRoLnRvU3RyaW5nKCkpO1xuICAgIH1cblxuICAgIHJldHVybiBuZXcgTW9udGhEYXkobW9udGgudmFsdWUoKSwgZGF5T2ZNb250aCk7XG4gIH07XG5cbiAgTW9udGhEYXkub2ZOdW1iZXJOdW1iZXIgPSBmdW5jdGlvbiBvZk51bWJlck51bWJlcihtb250aCwgZGF5T2ZNb250aCkge1xuICAgIHJlcXVpcmVOb25OdWxsKG1vbnRoLCAnbW9udGgnKTtcbiAgICByZXF1aXJlTm9uTnVsbChkYXlPZk1vbnRoLCAnZGF5T2ZNb250aCcpO1xuICAgIHJldHVybiBNb250aERheS5vZihNb250aC5vZihtb250aCksIGRheU9mTW9udGgpO1xuICB9O1xuXG4gIE1vbnRoRGF5LmZyb20gPSBmdW5jdGlvbiBmcm9tKHRlbXBvcmFsKSB7XG4gICAgcmVxdWlyZU5vbk51bGwodGVtcG9yYWwsICd0ZW1wb3JhbCcpO1xuICAgIHJlcXVpcmVJbnN0YW5jZSh0ZW1wb3JhbCwgVGVtcG9yYWxBY2Nlc3NvciwgJ3RlbXBvcmFsJyk7XG5cbiAgICBpZiAodGVtcG9yYWwgaW5zdGFuY2VvZiBNb250aERheSkge1xuICAgICAgcmV0dXJuIHRlbXBvcmFsO1xuICAgIH1cblxuICAgIHRyeSB7XG4gICAgICByZXR1cm4gTW9udGhEYXkub2YodGVtcG9yYWwuZ2V0KENocm9ub0ZpZWxkLk1PTlRIX09GX1lFQVIpLCB0ZW1wb3JhbC5nZXQoQ2hyb25vRmllbGQuREFZX09GX01PTlRIKSk7XG4gICAgfSBjYXRjaCAoZXgpIHtcbiAgICAgIHRocm93IG5ldyBEYXRlVGltZUV4Y2VwdGlvbignVW5hYmxlIHRvIG9idGFpbiBNb250aERheSBmcm9tIFRlbXBvcmFsQWNjZXNzb3I6ICcgKyB0ZW1wb3JhbCArICcsIHR5cGUgJyArICh0ZW1wb3JhbCAmJiB0ZW1wb3JhbC5jb25zdHJ1Y3RvciAhPSBudWxsID8gdGVtcG9yYWwuY29uc3RydWN0b3IubmFtZSA6ICcnKSk7XG4gICAgfVxuICB9O1xuXG4gIE1vbnRoRGF5LnBhcnNlID0gZnVuY3Rpb24gcGFyc2UodGV4dCwgZm9ybWF0dGVyKSB7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEpIHtcbiAgICAgIHJldHVybiBNb250aERheS5wYXJzZVN0cmluZyh0ZXh0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIE1vbnRoRGF5LnBhcnNlU3RyaW5nRm9ybWF0dGVyKHRleHQsIGZvcm1hdHRlcik7XG4gICAgfVxuICB9O1xuXG4gIE1vbnRoRGF5LnBhcnNlU3RyaW5nID0gZnVuY3Rpb24gcGFyc2VTdHJpbmcodGV4dCkge1xuICAgIHJldHVybiBNb250aERheS5wYXJzZVN0cmluZ0Zvcm1hdHRlcih0ZXh0LCBQQVJTRVIpO1xuICB9O1xuXG4gIE1vbnRoRGF5LnBhcnNlU3RyaW5nRm9ybWF0dGVyID0gZnVuY3Rpb24gcGFyc2VTdHJpbmdGb3JtYXR0ZXIodGV4dCwgZm9ybWF0dGVyKSB7XG4gICAgcmVxdWlyZU5vbk51bGwodGV4dCwgJ3RleHQnKTtcbiAgICByZXF1aXJlTm9uTnVsbChmb3JtYXR0ZXIsICdmb3JtYXR0ZXInKTtcbiAgICByZXF1aXJlSW5zdGFuY2UoZm9ybWF0dGVyLCBEYXRlVGltZUZvcm1hdHRlciwgJ2Zvcm1hdHRlcicpO1xuICAgIHJldHVybiBmb3JtYXR0ZXIucGFyc2UodGV4dCwgTW9udGhEYXkuRlJPTSk7XG4gIH07XG5cbiAgZnVuY3Rpb24gTW9udGhEYXkobW9udGgsIGRheU9mTW9udGgpIHtcbiAgICB2YXIgX3RoaXM7XG5cbiAgICBfdGhpcyA9IF9UZW1wb3JhbEFjY2Vzc29yLmNhbGwodGhpcykgfHwgdGhpcztcbiAgICBfdGhpcy5fbW9udGggPSBNYXRoVXRpbC5zYWZlVG9JbnQobW9udGgpO1xuICAgIF90aGlzLl9kYXkgPSBNYXRoVXRpbC5zYWZlVG9JbnQoZGF5T2ZNb250aCk7XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG5cbiAgdmFyIF9wcm90byA9IE1vbnRoRGF5LnByb3RvdHlwZTtcblxuICBfcHJvdG8ubW9udGhWYWx1ZSA9IGZ1bmN0aW9uIG1vbnRoVmFsdWUoKSB7XG4gICAgcmV0dXJuIHRoaXMuX21vbnRoO1xuICB9O1xuXG4gIF9wcm90by5tb250aCA9IGZ1bmN0aW9uIG1vbnRoKCkge1xuICAgIHJldHVybiBNb250aC5vZih0aGlzLl9tb250aCk7XG4gIH07XG5cbiAgX3Byb3RvLmRheU9mTW9udGggPSBmdW5jdGlvbiBkYXlPZk1vbnRoKCkge1xuICAgIHJldHVybiB0aGlzLl9kYXk7XG4gIH07XG5cbiAgX3Byb3RvLmlzU3VwcG9ydGVkID0gZnVuY3Rpb24gaXNTdXBwb3J0ZWQoZmllbGQpIHtcbiAgICBpZiAoZmllbGQgaW5zdGFuY2VvZiBDaHJvbm9GaWVsZCkge1xuICAgICAgcmV0dXJuIGZpZWxkID09PSBDaHJvbm9GaWVsZC5NT05USF9PRl9ZRUFSIHx8IGZpZWxkID09PSBDaHJvbm9GaWVsZC5EQVlfT0ZfTU9OVEg7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZpZWxkICE9IG51bGwgJiYgZmllbGQuaXNTdXBwb3J0ZWRCeSh0aGlzKTtcbiAgfTtcblxuICBfcHJvdG8ucmFuZ2UgPSBmdW5jdGlvbiByYW5nZShmaWVsZCkge1xuICAgIGlmIChmaWVsZCA9PT0gQ2hyb25vRmllbGQuTU9OVEhfT0ZfWUVBUikge1xuICAgICAgcmV0dXJuIGZpZWxkLnJhbmdlKCk7XG4gICAgfSBlbHNlIGlmIChmaWVsZCA9PT0gQ2hyb25vRmllbGQuREFZX09GX01PTlRIKSB7XG4gICAgICByZXR1cm4gVmFsdWVSYW5nZS5vZigxLCB0aGlzLm1vbnRoKCkubWluTGVuZ3RoKCksIHRoaXMubW9udGgoKS5tYXhMZW5ndGgoKSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIF9UZW1wb3JhbEFjY2Vzc29yLnByb3RvdHlwZS5yYW5nZS5jYWxsKHRoaXMsIGZpZWxkKTtcbiAgfTtcblxuICBfcHJvdG8uZ2V0ID0gZnVuY3Rpb24gZ2V0KGZpZWxkKSB7XG4gICAgcmV0dXJuIHRoaXMucmFuZ2UoZmllbGQpLmNoZWNrVmFsaWRJbnRWYWx1ZSh0aGlzLmdldExvbmcoZmllbGQpLCBmaWVsZCk7XG4gIH07XG5cbiAgX3Byb3RvLmdldExvbmcgPSBmdW5jdGlvbiBnZXRMb25nKGZpZWxkKSB7XG4gICAgcmVxdWlyZU5vbk51bGwoZmllbGQsICdmaWVsZCcpO1xuXG4gICAgaWYgKGZpZWxkIGluc3RhbmNlb2YgQ2hyb25vRmllbGQpIHtcbiAgICAgIHN3aXRjaCAoZmllbGQpIHtcbiAgICAgICAgY2FzZSBDaHJvbm9GaWVsZC5EQVlfT0ZfTU9OVEg6XG4gICAgICAgICAgcmV0dXJuIHRoaXMuX2RheTtcblxuICAgICAgICBjYXNlIENocm9ub0ZpZWxkLk1PTlRIX09GX1lFQVI6XG4gICAgICAgICAgcmV0dXJuIHRoaXMuX21vbnRoO1xuICAgICAgfVxuXG4gICAgICB0aHJvdyBuZXcgVW5zdXBwb3J0ZWRUZW1wb3JhbFR5cGVFeGNlcHRpb24oJ1Vuc3VwcG9ydGVkIGZpZWxkOiAnICsgZmllbGQpO1xuICAgIH1cblxuICAgIHJldHVybiBmaWVsZC5nZXRGcm9tKHRoaXMpO1xuICB9O1xuXG4gIF9wcm90by5pc1ZhbGlkWWVhciA9IGZ1bmN0aW9uIGlzVmFsaWRZZWFyKHllYXIpIHtcbiAgICByZXR1cm4gKHRoaXMuX2RheSA9PT0gMjkgJiYgdGhpcy5fbW9udGggPT09IDIgJiYgWWVhci5pc0xlYXAoeWVhcikgPT09IGZhbHNlKSA9PT0gZmFsc2U7XG4gIH07XG5cbiAgX3Byb3RvLndpdGhNb250aCA9IGZ1bmN0aW9uIHdpdGhNb250aChtb250aCkge1xuICAgIHJldHVybiB0aGlzLndpdGgoTW9udGgub2YobW9udGgpKTtcbiAgfTtcblxuICBfcHJvdG8ud2l0aCA9IGZ1bmN0aW9uIF93aXRoKG1vbnRoKSB7XG4gICAgcmVxdWlyZU5vbk51bGwobW9udGgsICdtb250aCcpO1xuXG4gICAgaWYgKG1vbnRoLnZhbHVlKCkgPT09IHRoaXMuX21vbnRoKSB7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICB2YXIgZGF5ID0gTWF0aC5taW4odGhpcy5fZGF5LCBtb250aC5tYXhMZW5ndGgoKSk7XG4gICAgcmV0dXJuIG5ldyBNb250aERheShtb250aC52YWx1ZSgpLCBkYXkpO1xuICB9O1xuXG4gIF9wcm90by53aXRoRGF5T2ZNb250aCA9IGZ1bmN0aW9uIHdpdGhEYXlPZk1vbnRoKGRheU9mTW9udGgpIHtcbiAgICBpZiAoZGF5T2ZNb250aCA9PT0gdGhpcy5fZGF5KSB7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICByZXR1cm4gTW9udGhEYXkub2YodGhpcy5fbW9udGgsIGRheU9mTW9udGgpO1xuICB9O1xuXG4gIF9wcm90by5xdWVyeSA9IGZ1bmN0aW9uIHF1ZXJ5KF9xdWVyeSkge1xuICAgIHJlcXVpcmVOb25OdWxsKF9xdWVyeSwgJ3F1ZXJ5Jyk7XG4gICAgcmVxdWlyZUluc3RhbmNlKF9xdWVyeSwgVGVtcG9yYWxRdWVyeSwgJ3F1ZXJ5Jyk7XG5cbiAgICBpZiAoX3F1ZXJ5ID09PSBUZW1wb3JhbFF1ZXJpZXMuY2hyb25vbG9neSgpKSB7XG4gICAgICByZXR1cm4gSXNvQ2hyb25vbG9neS5JTlNUQU5DRTtcbiAgICB9XG5cbiAgICByZXR1cm4gX1RlbXBvcmFsQWNjZXNzb3IucHJvdG90eXBlLnF1ZXJ5LmNhbGwodGhpcywgX3F1ZXJ5KTtcbiAgfTtcblxuICBfcHJvdG8uYWRqdXN0SW50byA9IGZ1bmN0aW9uIGFkanVzdEludG8odGVtcG9yYWwpIHtcbiAgICByZXF1aXJlTm9uTnVsbCh0ZW1wb3JhbCwgJ3RlbXBvcmFsJyk7XG4gICAgdGVtcG9yYWwgPSB0ZW1wb3JhbC53aXRoKENocm9ub0ZpZWxkLk1PTlRIX09GX1lFQVIsIHRoaXMuX21vbnRoKTtcbiAgICByZXR1cm4gdGVtcG9yYWwud2l0aChDaHJvbm9GaWVsZC5EQVlfT0ZfTU9OVEgsIE1hdGgubWluKHRlbXBvcmFsLnJhbmdlKENocm9ub0ZpZWxkLkRBWV9PRl9NT05USCkubWF4aW11bSgpLCB0aGlzLl9kYXkpKTtcbiAgfTtcblxuICBfcHJvdG8uYXRZZWFyID0gZnVuY3Rpb24gYXRZZWFyKHllYXIpIHtcbiAgICByZXR1cm4gTG9jYWxEYXRlLm9mKHllYXIsIHRoaXMuX21vbnRoLCB0aGlzLmlzVmFsaWRZZWFyKHllYXIpID8gdGhpcy5fZGF5IDogMjgpO1xuICB9O1xuXG4gIF9wcm90by5jb21wYXJlVG8gPSBmdW5jdGlvbiBjb21wYXJlVG8ob3RoZXIpIHtcbiAgICByZXF1aXJlTm9uTnVsbChvdGhlciwgJ290aGVyJyk7XG4gICAgcmVxdWlyZUluc3RhbmNlKG90aGVyLCBNb250aERheSwgJ290aGVyJyk7XG4gICAgdmFyIGNtcCA9IHRoaXMuX21vbnRoIC0gb3RoZXIubW9udGhWYWx1ZSgpO1xuXG4gICAgaWYgKGNtcCA9PT0gMCkge1xuICAgICAgY21wID0gdGhpcy5fZGF5IC0gb3RoZXIuZGF5T2ZNb250aCgpO1xuICAgIH1cblxuICAgIHJldHVybiBjbXA7XG4gIH07XG5cbiAgX3Byb3RvLmlzQWZ0ZXIgPSBmdW5jdGlvbiBpc0FmdGVyKG90aGVyKSB7XG4gICAgcmVxdWlyZU5vbk51bGwob3RoZXIsICdvdGhlcicpO1xuICAgIHJlcXVpcmVJbnN0YW5jZShvdGhlciwgTW9udGhEYXksICdvdGhlcicpO1xuICAgIHJldHVybiB0aGlzLmNvbXBhcmVUbyhvdGhlcikgPiAwO1xuICB9O1xuXG4gIF9wcm90by5pc0JlZm9yZSA9IGZ1bmN0aW9uIGlzQmVmb3JlKG90aGVyKSB7XG4gICAgcmVxdWlyZU5vbk51bGwob3RoZXIsICdvdGhlcicpO1xuICAgIHJlcXVpcmVJbnN0YW5jZShvdGhlciwgTW9udGhEYXksICdvdGhlcicpO1xuICAgIHJldHVybiB0aGlzLmNvbXBhcmVUbyhvdGhlcikgPCAwO1xuICB9O1xuXG4gIF9wcm90by5lcXVhbHMgPSBmdW5jdGlvbiBlcXVhbHMob2JqKSB7XG4gICAgaWYgKHRoaXMgPT09IG9iaikge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgaWYgKG9iaiBpbnN0YW5jZW9mIE1vbnRoRGF5KSB7XG4gICAgICB2YXIgb3RoZXIgPSBvYmo7XG4gICAgICByZXR1cm4gdGhpcy5tb250aFZhbHVlKCkgPT09IG90aGVyLm1vbnRoVmFsdWUoKSAmJiB0aGlzLmRheU9mTW9udGgoKSA9PT0gb3RoZXIuZGF5T2ZNb250aCgpO1xuICAgIH1cblxuICAgIHJldHVybiBmYWxzZTtcbiAgfTtcblxuICBfcHJvdG8udG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZygpIHtcbiAgICByZXR1cm4gJy0tJyArICh0aGlzLl9tb250aCA8IDEwID8gJzAnIDogJycpICsgdGhpcy5fbW9udGggKyAodGhpcy5fZGF5IDwgMTAgPyAnLTAnIDogJy0nKSArIHRoaXMuX2RheTtcbiAgfTtcblxuICBfcHJvdG8udG9KU09OID0gZnVuY3Rpb24gdG9KU09OKCkge1xuICAgIHJldHVybiB0aGlzLnRvU3RyaW5nKCk7XG4gIH07XG5cbiAgX3Byb3RvLmZvcm1hdCA9IGZ1bmN0aW9uIGZvcm1hdChmb3JtYXR0ZXIpIHtcbiAgICByZXF1aXJlTm9uTnVsbChmb3JtYXR0ZXIsICdmb3JtYXR0ZXInKTtcbiAgICByZXF1aXJlSW5zdGFuY2UoZm9ybWF0dGVyLCBEYXRlVGltZUZvcm1hdHRlciwgJ2Zvcm1hdHRlcicpO1xuICAgIHJldHVybiBmb3JtYXR0ZXIuZm9ybWF0KHRoaXMpO1xuICB9O1xuXG4gIHJldHVybiBNb250aERheTtcbn0oVGVtcG9yYWxBY2Nlc3Nvcik7XG52YXIgUEFSU0VSO1xuZnVuY3Rpb24gX2luaXQkYigpIHtcbiAgUEFSU0VSID0gbmV3IERhdGVUaW1lRm9ybWF0dGVyQnVpbGRlcigpLmFwcGVuZExpdGVyYWwoJy0tJykuYXBwZW5kVmFsdWUoQ2hyb25vRmllbGQuTU9OVEhfT0ZfWUVBUiwgMikuYXBwZW5kTGl0ZXJhbCgnLScpLmFwcGVuZFZhbHVlKENocm9ub0ZpZWxkLkRBWV9PRl9NT05USCwgMikudG9Gb3JtYXR0ZXIoKTtcbiAgTW9udGhEYXkuRlJPTSA9IGNyZWF0ZVRlbXBvcmFsUXVlcnkoJ01vbnRoRGF5LkZST00nLCBmdW5jdGlvbiAodGVtcG9yYWwpIHtcbiAgICByZXR1cm4gTW9udGhEYXkuZnJvbSh0ZW1wb3JhbCk7XG4gIH0pO1xufVxuXG52YXIgWWVhck1vbnRoID0gZnVuY3Rpb24gKF9UZW1wb3JhbCkge1xuICBfaW5oZXJpdHNMb29zZShZZWFyTW9udGgsIF9UZW1wb3JhbCk7XG5cbiAgWWVhck1vbnRoLm5vdyA9IGZ1bmN0aW9uIG5vdyh6b25lSWRPckNsb2NrKSB7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybiBZZWFyTW9udGgubm93MCgpO1xuICAgIH0gZWxzZSBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSAmJiB6b25lSWRPckNsb2NrIGluc3RhbmNlb2YgWm9uZUlkKSB7XG4gICAgICByZXR1cm4gWWVhck1vbnRoLm5vd1pvbmVJZCh6b25lSWRPckNsb2NrKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIFllYXJNb250aC5ub3dDbG9jayh6b25lSWRPckNsb2NrKTtcbiAgICB9XG4gIH07XG5cbiAgWWVhck1vbnRoLm5vdzAgPSBmdW5jdGlvbiBub3cwKCkge1xuICAgIHJldHVybiBZZWFyTW9udGgubm93Q2xvY2soQ2xvY2suc3lzdGVtRGVmYXVsdFpvbmUoKSk7XG4gIH07XG5cbiAgWWVhck1vbnRoLm5vd1pvbmVJZCA9IGZ1bmN0aW9uIG5vd1pvbmVJZCh6b25lKSB7XG4gICAgcmV0dXJuIFllYXJNb250aC5ub3dDbG9jayhDbG9jay5zeXN0ZW0oem9uZSkpO1xuICB9O1xuXG4gIFllYXJNb250aC5ub3dDbG9jayA9IGZ1bmN0aW9uIG5vd0Nsb2NrKGNsb2NrKSB7XG4gICAgdmFyIG5vdyA9IExvY2FsRGF0ZS5ub3coY2xvY2spO1xuICAgIHJldHVybiBZZWFyTW9udGgub2Yobm93LnllYXIoKSwgbm93Lm1vbnRoKCkpO1xuICB9O1xuXG4gIFllYXJNb250aC5vZiA9IGZ1bmN0aW9uIG9mKHllYXIsIG1vbnRoT3JOdW1iZXIpIHtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMiAmJiBtb250aE9yTnVtYmVyIGluc3RhbmNlb2YgTW9udGgpIHtcbiAgICAgIHJldHVybiBZZWFyTW9udGgub2ZOdW1iZXJNb250aCh5ZWFyLCBtb250aE9yTnVtYmVyKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIFllYXJNb250aC5vZk51bWJlck51bWJlcih5ZWFyLCBtb250aE9yTnVtYmVyKTtcbiAgICB9XG4gIH07XG5cbiAgWWVhck1vbnRoLm9mTnVtYmVyTW9udGggPSBmdW5jdGlvbiBvZk51bWJlck1vbnRoKHllYXIsIG1vbnRoKSB7XG4gICAgcmVxdWlyZU5vbk51bGwobW9udGgsICdtb250aCcpO1xuICAgIHJlcXVpcmVJbnN0YW5jZShtb250aCwgTW9udGgsICdtb250aCcpO1xuICAgIHJldHVybiBZZWFyTW9udGgub2ZOdW1iZXJOdW1iZXIoeWVhciwgbW9udGgudmFsdWUoKSk7XG4gIH07XG5cbiAgWWVhck1vbnRoLm9mTnVtYmVyTnVtYmVyID0gZnVuY3Rpb24gb2ZOdW1iZXJOdW1iZXIoeWVhciwgbW9udGgpIHtcbiAgICByZXF1aXJlTm9uTnVsbCh5ZWFyLCAneWVhcicpO1xuICAgIHJlcXVpcmVOb25OdWxsKG1vbnRoLCAnbW9udGgnKTtcbiAgICBDaHJvbm9GaWVsZC5ZRUFSLmNoZWNrVmFsaWRWYWx1ZSh5ZWFyKTtcbiAgICBDaHJvbm9GaWVsZC5NT05USF9PRl9ZRUFSLmNoZWNrVmFsaWRWYWx1ZShtb250aCk7XG4gICAgcmV0dXJuIG5ldyBZZWFyTW9udGgoeWVhciwgbW9udGgpO1xuICB9O1xuXG4gIFllYXJNb250aC5mcm9tID0gZnVuY3Rpb24gZnJvbSh0ZW1wb3JhbCkge1xuICAgIHJlcXVpcmVOb25OdWxsKHRlbXBvcmFsLCAndGVtcG9yYWwnKTtcblxuICAgIGlmICh0ZW1wb3JhbCBpbnN0YW5jZW9mIFllYXJNb250aCkge1xuICAgICAgcmV0dXJuIHRlbXBvcmFsO1xuICAgIH1cblxuICAgIHRyeSB7XG4gICAgICByZXR1cm4gWWVhck1vbnRoLm9mKHRlbXBvcmFsLmdldChDaHJvbm9GaWVsZC5ZRUFSKSwgdGVtcG9yYWwuZ2V0KENocm9ub0ZpZWxkLk1PTlRIX09GX1lFQVIpKTtcbiAgICB9IGNhdGNoIChleCkge1xuICAgICAgdGhyb3cgbmV3IERhdGVUaW1lRXhjZXB0aW9uKCdVbmFibGUgdG8gb2J0YWluIFllYXJNb250aCBmcm9tIFRlbXBvcmFsQWNjZXNzb3I6ICcgKyB0ZW1wb3JhbCArICcsIHR5cGUgJyArICh0ZW1wb3JhbCAmJiB0ZW1wb3JhbC5jb25zdHJ1Y3RvciAhPSBudWxsID8gdGVtcG9yYWwuY29uc3RydWN0b3IubmFtZSA6ICcnKSk7XG4gICAgfVxuICB9O1xuXG4gIFllYXJNb250aC5wYXJzZSA9IGZ1bmN0aW9uIHBhcnNlKHRleHQsIGZvcm1hdHRlcikge1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAxKSB7XG4gICAgICByZXR1cm4gWWVhck1vbnRoLnBhcnNlU3RyaW5nKHRleHQpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gWWVhck1vbnRoLnBhcnNlU3RyaW5nRm9ybWF0dGVyKHRleHQsIGZvcm1hdHRlcik7XG4gICAgfVxuICB9O1xuXG4gIFllYXJNb250aC5wYXJzZVN0cmluZyA9IGZ1bmN0aW9uIHBhcnNlU3RyaW5nKHRleHQpIHtcbiAgICByZXR1cm4gWWVhck1vbnRoLnBhcnNlU3RyaW5nRm9ybWF0dGVyKHRleHQsIFBBUlNFUiQxKTtcbiAgfTtcblxuICBZZWFyTW9udGgucGFyc2VTdHJpbmdGb3JtYXR0ZXIgPSBmdW5jdGlvbiBwYXJzZVN0cmluZ0Zvcm1hdHRlcih0ZXh0LCBmb3JtYXR0ZXIpIHtcbiAgICByZXF1aXJlTm9uTnVsbChmb3JtYXR0ZXIsICdmb3JtYXR0ZXInKTtcbiAgICByZXR1cm4gZm9ybWF0dGVyLnBhcnNlKHRleHQsIFllYXJNb250aC5GUk9NKTtcbiAgfTtcblxuICBmdW5jdGlvbiBZZWFyTW9udGgoeWVhciwgbW9udGgpIHtcbiAgICB2YXIgX3RoaXM7XG5cbiAgICBfdGhpcyA9IF9UZW1wb3JhbC5jYWxsKHRoaXMpIHx8IHRoaXM7XG4gICAgX3RoaXMuX3llYXIgPSBNYXRoVXRpbC5zYWZlVG9JbnQoeWVhcik7XG4gICAgX3RoaXMuX21vbnRoID0gTWF0aFV0aWwuc2FmZVRvSW50KG1vbnRoKTtcbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cblxuICB2YXIgX3Byb3RvID0gWWVhck1vbnRoLnByb3RvdHlwZTtcblxuICBfcHJvdG8uaXNTdXBwb3J0ZWQgPSBmdW5jdGlvbiBpc1N1cHBvcnRlZChmaWVsZE9yVW5pdCkge1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAxICYmIGZpZWxkT3JVbml0IGluc3RhbmNlb2YgVGVtcG9yYWxGaWVsZCkge1xuICAgICAgcmV0dXJuIHRoaXMuaXNTdXBwb3J0ZWRGaWVsZChmaWVsZE9yVW5pdCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB0aGlzLmlzU3VwcG9ydGVkVW5pdChmaWVsZE9yVW5pdCk7XG4gICAgfVxuICB9O1xuXG4gIF9wcm90by5pc1N1cHBvcnRlZEZpZWxkID0gZnVuY3Rpb24gaXNTdXBwb3J0ZWRGaWVsZChmaWVsZCkge1xuICAgIGlmIChmaWVsZCBpbnN0YW5jZW9mIENocm9ub0ZpZWxkKSB7XG4gICAgICByZXR1cm4gZmllbGQgPT09IENocm9ub0ZpZWxkLllFQVIgfHwgZmllbGQgPT09IENocm9ub0ZpZWxkLk1PTlRIX09GX1lFQVIgfHwgZmllbGQgPT09IENocm9ub0ZpZWxkLlBST0xFUFRJQ19NT05USCB8fCBmaWVsZCA9PT0gQ2hyb25vRmllbGQuWUVBUl9PRl9FUkEgfHwgZmllbGQgPT09IENocm9ub0ZpZWxkLkVSQTtcbiAgICB9XG5cbiAgICByZXR1cm4gZmllbGQgIT0gbnVsbCAmJiBmaWVsZC5pc1N1cHBvcnRlZEJ5KHRoaXMpO1xuICB9O1xuXG4gIF9wcm90by5pc1N1cHBvcnRlZFVuaXQgPSBmdW5jdGlvbiBpc1N1cHBvcnRlZFVuaXQodW5pdCkge1xuICAgIGlmICh1bml0IGluc3RhbmNlb2YgQ2hyb25vVW5pdCkge1xuICAgICAgcmV0dXJuIHVuaXQgPT09IENocm9ub1VuaXQuTU9OVEhTIHx8IHVuaXQgPT09IENocm9ub1VuaXQuWUVBUlMgfHwgdW5pdCA9PT0gQ2hyb25vVW5pdC5ERUNBREVTIHx8IHVuaXQgPT09IENocm9ub1VuaXQuQ0VOVFVSSUVTIHx8IHVuaXQgPT09IENocm9ub1VuaXQuTUlMTEVOTklBIHx8IHVuaXQgPT09IENocm9ub1VuaXQuRVJBUztcbiAgICB9XG5cbiAgICByZXR1cm4gdW5pdCAhPSBudWxsICYmIHVuaXQuaXNTdXBwb3J0ZWRCeSh0aGlzKTtcbiAgfTtcblxuICBfcHJvdG8ucmFuZ2UgPSBmdW5jdGlvbiByYW5nZShmaWVsZCkge1xuICAgIGlmIChmaWVsZCA9PT0gQ2hyb25vRmllbGQuWUVBUl9PRl9FUkEpIHtcbiAgICAgIHJldHVybiB0aGlzLnllYXIoKSA8PSAwID8gVmFsdWVSYW5nZS5vZigxLCBZZWFyLk1BWF9WQUxVRSArIDEpIDogVmFsdWVSYW5nZS5vZigxLCBZZWFyLk1BWF9WQUxVRSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIF9UZW1wb3JhbC5wcm90b3R5cGUucmFuZ2UuY2FsbCh0aGlzLCBmaWVsZCk7XG4gIH07XG5cbiAgX3Byb3RvLmdldCA9IGZ1bmN0aW9uIGdldChmaWVsZCkge1xuICAgIHJlcXVpcmVOb25OdWxsKGZpZWxkLCAnZmllbGQnKTtcbiAgICByZXF1aXJlSW5zdGFuY2UoZmllbGQsIFRlbXBvcmFsRmllbGQsICdmaWVsZCcpO1xuICAgIHJldHVybiB0aGlzLnJhbmdlKGZpZWxkKS5jaGVja1ZhbGlkSW50VmFsdWUodGhpcy5nZXRMb25nKGZpZWxkKSwgZmllbGQpO1xuICB9O1xuXG4gIF9wcm90by5nZXRMb25nID0gZnVuY3Rpb24gZ2V0TG9uZyhmaWVsZCkge1xuICAgIHJlcXVpcmVOb25OdWxsKGZpZWxkLCAnZmllbGQnKTtcbiAgICByZXF1aXJlSW5zdGFuY2UoZmllbGQsIFRlbXBvcmFsRmllbGQsICdmaWVsZCcpO1xuXG4gICAgaWYgKGZpZWxkIGluc3RhbmNlb2YgQ2hyb25vRmllbGQpIHtcbiAgICAgIHN3aXRjaCAoZmllbGQpIHtcbiAgICAgICAgY2FzZSBDaHJvbm9GaWVsZC5NT05USF9PRl9ZRUFSOlxuICAgICAgICAgIHJldHVybiB0aGlzLl9tb250aDtcblxuICAgICAgICBjYXNlIENocm9ub0ZpZWxkLlBST0xFUFRJQ19NT05USDpcbiAgICAgICAgICByZXR1cm4gdGhpcy5fZ2V0UHJvbGVwdGljTW9udGgoKTtcblxuICAgICAgICBjYXNlIENocm9ub0ZpZWxkLllFQVJfT0ZfRVJBOlxuICAgICAgICAgIHJldHVybiB0aGlzLl95ZWFyIDwgMSA/IDEgLSB0aGlzLl95ZWFyIDogdGhpcy5feWVhcjtcblxuICAgICAgICBjYXNlIENocm9ub0ZpZWxkLllFQVI6XG4gICAgICAgICAgcmV0dXJuIHRoaXMuX3llYXI7XG5cbiAgICAgICAgY2FzZSBDaHJvbm9GaWVsZC5FUkE6XG4gICAgICAgICAgcmV0dXJuIHRoaXMuX3llYXIgPCAxID8gMCA6IDE7XG4gICAgICB9XG5cbiAgICAgIHRocm93IG5ldyBVbnN1cHBvcnRlZFRlbXBvcmFsVHlwZUV4Y2VwdGlvbignVW5zdXBwb3J0ZWQgZmllbGQ6ICcgKyBmaWVsZCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZpZWxkLmdldEZyb20odGhpcyk7XG4gIH07XG5cbiAgX3Byb3RvLl9nZXRQcm9sZXB0aWNNb250aCA9IGZ1bmN0aW9uIF9nZXRQcm9sZXB0aWNNb250aCgpIHtcbiAgICByZXR1cm4gTWF0aFV0aWwuc2FmZUFkZChNYXRoVXRpbC5zYWZlTXVsdGlwbHkodGhpcy5feWVhciwgMTIpLCB0aGlzLl9tb250aCAtIDEpO1xuICB9O1xuXG4gIF9wcm90by55ZWFyID0gZnVuY3Rpb24geWVhcigpIHtcbiAgICByZXR1cm4gdGhpcy5feWVhcjtcbiAgfTtcblxuICBfcHJvdG8ubW9udGhWYWx1ZSA9IGZ1bmN0aW9uIG1vbnRoVmFsdWUoKSB7XG4gICAgcmV0dXJuIHRoaXMuX21vbnRoO1xuICB9O1xuXG4gIF9wcm90by5tb250aCA9IGZ1bmN0aW9uIG1vbnRoKCkge1xuICAgIHJldHVybiBNb250aC5vZih0aGlzLl9tb250aCk7XG4gIH07XG5cbiAgX3Byb3RvLmlzTGVhcFllYXIgPSBmdW5jdGlvbiBpc0xlYXBZZWFyKCkge1xuICAgIHJldHVybiBJc29DaHJvbm9sb2d5LmlzTGVhcFllYXIodGhpcy5feWVhcik7XG4gIH07XG5cbiAgX3Byb3RvLmlzVmFsaWREYXkgPSBmdW5jdGlvbiBpc1ZhbGlkRGF5KGRheU9mTW9udGgpIHtcbiAgICByZXR1cm4gZGF5T2ZNb250aCA+PSAxICYmIGRheU9mTW9udGggPD0gdGhpcy5sZW5ndGhPZk1vbnRoKCk7XG4gIH07XG5cbiAgX3Byb3RvLmxlbmd0aE9mTW9udGggPSBmdW5jdGlvbiBsZW5ndGhPZk1vbnRoKCkge1xuICAgIHJldHVybiB0aGlzLm1vbnRoKCkubGVuZ3RoKHRoaXMuaXNMZWFwWWVhcigpKTtcbiAgfTtcblxuICBfcHJvdG8ubGVuZ3RoT2ZZZWFyID0gZnVuY3Rpb24gbGVuZ3RoT2ZZZWFyKCkge1xuICAgIHJldHVybiB0aGlzLmlzTGVhcFllYXIoKSA/IDM2NiA6IDM2NTtcbiAgfTtcblxuICBfcHJvdG8ud2l0aCA9IGZ1bmN0aW9uIF93aXRoKGFkanVzdGVyT3JGaWVsZCwgdmFsdWUpIHtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgcmV0dXJuIHRoaXMud2l0aEFkanVzdGVyKGFkanVzdGVyT3JGaWVsZCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB0aGlzLndpdGhGaWVsZFZhbHVlKGFkanVzdGVyT3JGaWVsZCwgdmFsdWUpO1xuICAgIH1cbiAgfTtcblxuICBfcHJvdG8ud2l0aEFkanVzdGVyID0gZnVuY3Rpb24gd2l0aEFkanVzdGVyKGFkanVzdGVyKSB7XG4gICAgcmVxdWlyZU5vbk51bGwoYWRqdXN0ZXIsICdhZGp1c3RlcicpO1xuICAgIHJldHVybiBhZGp1c3Rlci5hZGp1c3RJbnRvKHRoaXMpO1xuICB9O1xuXG4gIF9wcm90by53aXRoRmllbGRWYWx1ZSA9IGZ1bmN0aW9uIHdpdGhGaWVsZFZhbHVlKGZpZWxkLCBuZXdWYWx1ZSkge1xuICAgIHJlcXVpcmVOb25OdWxsKGZpZWxkLCAnZmllbGQnKTtcbiAgICByZXF1aXJlSW5zdGFuY2UoZmllbGQsIFRlbXBvcmFsRmllbGQsICdmaWVsZCcpO1xuXG4gICAgaWYgKGZpZWxkIGluc3RhbmNlb2YgQ2hyb25vRmllbGQpIHtcbiAgICAgIHZhciBmID0gZmllbGQ7XG4gICAgICBmLmNoZWNrVmFsaWRWYWx1ZShuZXdWYWx1ZSk7XG5cbiAgICAgIHN3aXRjaCAoZikge1xuICAgICAgICBjYXNlIENocm9ub0ZpZWxkLk1PTlRIX09GX1lFQVI6XG4gICAgICAgICAgcmV0dXJuIHRoaXMud2l0aE1vbnRoKG5ld1ZhbHVlKTtcblxuICAgICAgICBjYXNlIENocm9ub0ZpZWxkLlBST0xFUFRJQ19NT05USDpcbiAgICAgICAgICByZXR1cm4gdGhpcy5wbHVzTW9udGhzKG5ld1ZhbHVlIC0gdGhpcy5nZXRMb25nKENocm9ub0ZpZWxkLlBST0xFUFRJQ19NT05USCkpO1xuXG4gICAgICAgIGNhc2UgQ2hyb25vRmllbGQuWUVBUl9PRl9FUkE6XG4gICAgICAgICAgcmV0dXJuIHRoaXMud2l0aFllYXIodGhpcy5feWVhciA8IDEgPyAxIC0gbmV3VmFsdWUgOiBuZXdWYWx1ZSk7XG5cbiAgICAgICAgY2FzZSBDaHJvbm9GaWVsZC5ZRUFSOlxuICAgICAgICAgIHJldHVybiB0aGlzLndpdGhZZWFyKG5ld1ZhbHVlKTtcblxuICAgICAgICBjYXNlIENocm9ub0ZpZWxkLkVSQTpcbiAgICAgICAgICByZXR1cm4gdGhpcy5nZXRMb25nKENocm9ub0ZpZWxkLkVSQSkgPT09IG5ld1ZhbHVlID8gdGhpcyA6IHRoaXMud2l0aFllYXIoMSAtIHRoaXMuX3llYXIpO1xuICAgICAgfVxuXG4gICAgICB0aHJvdyBuZXcgVW5zdXBwb3J0ZWRUZW1wb3JhbFR5cGVFeGNlcHRpb24oJ1Vuc3VwcG9ydGVkIGZpZWxkOiAnICsgZmllbGQpO1xuICAgIH1cblxuICAgIHJldHVybiBmaWVsZC5hZGp1c3RJbnRvKHRoaXMsIG5ld1ZhbHVlKTtcbiAgfTtcblxuICBfcHJvdG8ud2l0aFllYXIgPSBmdW5jdGlvbiB3aXRoWWVhcih5ZWFyKSB7XG4gICAgQ2hyb25vRmllbGQuWUVBUi5jaGVja1ZhbGlkVmFsdWUoeWVhcik7XG4gICAgcmV0dXJuIG5ldyBZZWFyTW9udGgoeWVhciwgdGhpcy5fbW9udGgpO1xuICB9O1xuXG4gIF9wcm90by53aXRoTW9udGggPSBmdW5jdGlvbiB3aXRoTW9udGgobW9udGgpIHtcbiAgICBDaHJvbm9GaWVsZC5NT05USF9PRl9ZRUFSLmNoZWNrVmFsaWRWYWx1ZShtb250aCk7XG4gICAgcmV0dXJuIG5ldyBZZWFyTW9udGgodGhpcy5feWVhciwgbW9udGgpO1xuICB9O1xuXG4gIF9wcm90by5wbHVzQW1vdW50ID0gZnVuY3Rpb24gcGx1c0Ftb3VudChhbW91bnQpIHtcbiAgICByZXF1aXJlTm9uTnVsbChhbW91bnQsICdhbW91bnQnKTtcbiAgICByZXF1aXJlSW5zdGFuY2UoYW1vdW50LCBUZW1wb3JhbEFtb3VudCwgJ2Ftb3VudCcpO1xuICAgIHJldHVybiBhbW91bnQuYWRkVG8odGhpcyk7XG4gIH07XG5cbiAgX3Byb3RvLnBsdXNBbW91bnRVbml0ID0gZnVuY3Rpb24gcGx1c0Ftb3VudFVuaXQoYW1vdW50VG9BZGQsIHVuaXQpIHtcbiAgICByZXF1aXJlTm9uTnVsbCh1bml0LCAndW5pdCcpO1xuICAgIHJlcXVpcmVJbnN0YW5jZSh1bml0LCBUZW1wb3JhbFVuaXQsICd1bml0Jyk7XG5cbiAgICBpZiAodW5pdCBpbnN0YW5jZW9mIENocm9ub1VuaXQpIHtcbiAgICAgIHN3aXRjaCAodW5pdCkge1xuICAgICAgICBjYXNlIENocm9ub1VuaXQuTU9OVEhTOlxuICAgICAgICAgIHJldHVybiB0aGlzLnBsdXNNb250aHMoYW1vdW50VG9BZGQpO1xuXG4gICAgICAgIGNhc2UgQ2hyb25vVW5pdC5ZRUFSUzpcbiAgICAgICAgICByZXR1cm4gdGhpcy5wbHVzWWVhcnMoYW1vdW50VG9BZGQpO1xuXG4gICAgICAgIGNhc2UgQ2hyb25vVW5pdC5ERUNBREVTOlxuICAgICAgICAgIHJldHVybiB0aGlzLnBsdXNZZWFycyhNYXRoVXRpbC5zYWZlTXVsdGlwbHkoYW1vdW50VG9BZGQsIDEwKSk7XG5cbiAgICAgICAgY2FzZSBDaHJvbm9Vbml0LkNFTlRVUklFUzpcbiAgICAgICAgICByZXR1cm4gdGhpcy5wbHVzWWVhcnMoTWF0aFV0aWwuc2FmZU11bHRpcGx5KGFtb3VudFRvQWRkLCAxMDApKTtcblxuICAgICAgICBjYXNlIENocm9ub1VuaXQuTUlMTEVOTklBOlxuICAgICAgICAgIHJldHVybiB0aGlzLnBsdXNZZWFycyhNYXRoVXRpbC5zYWZlTXVsdGlwbHkoYW1vdW50VG9BZGQsIDEwMDApKTtcblxuICAgICAgICBjYXNlIENocm9ub1VuaXQuRVJBUzpcbiAgICAgICAgICByZXR1cm4gdGhpcy53aXRoKENocm9ub0ZpZWxkLkVSQSwgTWF0aFV0aWwuc2FmZUFkZCh0aGlzLmdldExvbmcoQ2hyb25vRmllbGQuRVJBKSwgYW1vdW50VG9BZGQpKTtcbiAgICAgIH1cblxuICAgICAgdGhyb3cgbmV3IFVuc3VwcG9ydGVkVGVtcG9yYWxUeXBlRXhjZXB0aW9uKCdVbnN1cHBvcnRlZCB1bml0OiAnICsgdW5pdCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHVuaXQuYWRkVG8odGhpcywgYW1vdW50VG9BZGQpO1xuICB9O1xuXG4gIF9wcm90by5wbHVzWWVhcnMgPSBmdW5jdGlvbiBwbHVzWWVhcnMoeWVhcnNUb0FkZCkge1xuICAgIGlmICh5ZWFyc1RvQWRkID09PSAwKSB7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICB2YXIgbmV3WWVhciA9IENocm9ub0ZpZWxkLllFQVIuY2hlY2tWYWxpZEludFZhbHVlKHRoaXMuX3llYXIgKyB5ZWFyc1RvQWRkKTtcbiAgICByZXR1cm4gdGhpcy53aXRoWWVhcihuZXdZZWFyKTtcbiAgfTtcblxuICBfcHJvdG8ucGx1c01vbnRocyA9IGZ1bmN0aW9uIHBsdXNNb250aHMobW9udGhzVG9BZGQpIHtcbiAgICBpZiAobW9udGhzVG9BZGQgPT09IDApIHtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIHZhciBtb250aENvdW50ID0gdGhpcy5feWVhciAqIDEyICsgKHRoaXMuX21vbnRoIC0gMSk7XG4gICAgdmFyIGNhbGNNb250aHMgPSBtb250aENvdW50ICsgbW9udGhzVG9BZGQ7XG4gICAgdmFyIG5ld1llYXIgPSBDaHJvbm9GaWVsZC5ZRUFSLmNoZWNrVmFsaWRJbnRWYWx1ZShNYXRoVXRpbC5mbG9vckRpdihjYWxjTW9udGhzLCAxMikpO1xuICAgIHZhciBuZXdNb250aCA9IE1hdGhVdGlsLmZsb29yTW9kKGNhbGNNb250aHMsIDEyKSArIDE7XG4gICAgcmV0dXJuIG5ldyBZZWFyTW9udGgobmV3WWVhciwgbmV3TW9udGgpO1xuICB9O1xuXG4gIF9wcm90by5taW51c0Ftb3VudCA9IGZ1bmN0aW9uIG1pbnVzQW1vdW50KGFtb3VudCkge1xuICAgIHJlcXVpcmVOb25OdWxsKGFtb3VudCwgJ2Ftb3VudCcpO1xuICAgIHJldHVybiBhbW91bnQuc3VidHJhY3RGcm9tKHRoaXMpO1xuICB9O1xuXG4gIF9wcm90by5taW51c0Ftb3VudFVuaXQgPSBmdW5jdGlvbiBtaW51c0Ftb3VudFVuaXQoYW1vdW50VG9TdWJ0cmFjdCwgdW5pdCkge1xuICAgIHJldHVybiBhbW91bnRUb1N1YnRyYWN0ID09PSBNYXRoVXRpbC5NSU5fU0FGRV9JTlRFR0VSID8gdGhpcy5wbHVzQW1vdW50VW5pdChNYXRoVXRpbC5NQVhfU0FGRV9JTlRFR0VSLCB1bml0KS5wbHVzQW1vdW50VW5pdCgxLCB1bml0KSA6IHRoaXMucGx1c0Ftb3VudFVuaXQoLWFtb3VudFRvU3VidHJhY3QsIHVuaXQpO1xuICB9O1xuXG4gIF9wcm90by5taW51c1llYXJzID0gZnVuY3Rpb24gbWludXNZZWFycyh5ZWFyc1RvU3VidHJhY3QpIHtcbiAgICByZXR1cm4geWVhcnNUb1N1YnRyYWN0ID09PSBNYXRoVXRpbC5NSU5fU0FGRV9JTlRFR0VSID8gdGhpcy5wbHVzWWVhcnMoTWF0aFV0aWwuTUlOX1NBRkVfSU5URUdFUikucGx1c1llYXJzKDEpIDogdGhpcy5wbHVzWWVhcnMoLXllYXJzVG9TdWJ0cmFjdCk7XG4gIH07XG5cbiAgX3Byb3RvLm1pbnVzTW9udGhzID0gZnVuY3Rpb24gbWludXNNb250aHMobW9udGhzVG9TdWJ0cmFjdCkge1xuICAgIHJldHVybiBtb250aHNUb1N1YnRyYWN0ID09PSBNYXRoVXRpbC5NSU5fU0FGRV9JTlRFR0VSID8gdGhpcy5wbHVzTW9udGhzKE1hdGguTUFYX1NBRkVfSU5URUdFUikucGx1c01vbnRocygxKSA6IHRoaXMucGx1c01vbnRocygtbW9udGhzVG9TdWJ0cmFjdCk7XG4gIH07XG5cbiAgX3Byb3RvLnF1ZXJ5ID0gZnVuY3Rpb24gcXVlcnkoX3F1ZXJ5KSB7XG4gICAgcmVxdWlyZU5vbk51bGwoX3F1ZXJ5LCAncXVlcnknKTtcbiAgICByZXF1aXJlSW5zdGFuY2UoX3F1ZXJ5LCBUZW1wb3JhbFF1ZXJ5LCAncXVlcnknKTtcblxuICAgIGlmIChfcXVlcnkgPT09IFRlbXBvcmFsUXVlcmllcy5jaHJvbm9sb2d5KCkpIHtcbiAgICAgIHJldHVybiBJc29DaHJvbm9sb2d5LklOU1RBTkNFO1xuICAgIH0gZWxzZSBpZiAoX3F1ZXJ5ID09PSBUZW1wb3JhbFF1ZXJpZXMucHJlY2lzaW9uKCkpIHtcbiAgICAgIHJldHVybiBDaHJvbm9Vbml0Lk1PTlRIUztcbiAgICB9IGVsc2UgaWYgKF9xdWVyeSA9PT0gVGVtcG9yYWxRdWVyaWVzLmxvY2FsRGF0ZSgpIHx8IF9xdWVyeSA9PT0gVGVtcG9yYWxRdWVyaWVzLmxvY2FsVGltZSgpIHx8IF9xdWVyeSA9PT0gVGVtcG9yYWxRdWVyaWVzLnpvbmUoKSB8fCBfcXVlcnkgPT09IFRlbXBvcmFsUXVlcmllcy56b25lSWQoKSB8fCBfcXVlcnkgPT09IFRlbXBvcmFsUXVlcmllcy5vZmZzZXQoKSkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgcmV0dXJuIF9UZW1wb3JhbC5wcm90b3R5cGUucXVlcnkuY2FsbCh0aGlzLCBfcXVlcnkpO1xuICB9O1xuXG4gIF9wcm90by5hZGp1c3RJbnRvID0gZnVuY3Rpb24gYWRqdXN0SW50byh0ZW1wb3JhbCkge1xuICAgIHJlcXVpcmVOb25OdWxsKHRlbXBvcmFsLCAndGVtcG9yYWwnKTtcbiAgICByZXF1aXJlSW5zdGFuY2UodGVtcG9yYWwsIFRlbXBvcmFsLCAndGVtcG9yYWwnKTtcbiAgICByZXR1cm4gdGVtcG9yYWwud2l0aChDaHJvbm9GaWVsZC5QUk9MRVBUSUNfTU9OVEgsIHRoaXMuX2dldFByb2xlcHRpY01vbnRoKCkpO1xuICB9O1xuXG4gIF9wcm90by51bnRpbCA9IGZ1bmN0aW9uIHVudGlsKGVuZEV4Y2x1c2l2ZSwgdW5pdCkge1xuICAgIHJlcXVpcmVOb25OdWxsKGVuZEV4Y2x1c2l2ZSwgJ2VuZEV4Y2x1c2l2ZScpO1xuICAgIHJlcXVpcmVOb25OdWxsKHVuaXQsICd1bml0Jyk7XG4gICAgcmVxdWlyZUluc3RhbmNlKGVuZEV4Y2x1c2l2ZSwgVGVtcG9yYWwsICdlbmRFeGNsdXNpdmUnKTtcbiAgICByZXF1aXJlSW5zdGFuY2UodW5pdCwgVGVtcG9yYWxVbml0LCAndW5pdCcpO1xuICAgIHZhciBlbmQgPSBZZWFyTW9udGguZnJvbShlbmRFeGNsdXNpdmUpO1xuXG4gICAgaWYgKHVuaXQgaW5zdGFuY2VvZiBDaHJvbm9Vbml0KSB7XG4gICAgICB2YXIgbW9udGhzVW50aWwgPSBlbmQuX2dldFByb2xlcHRpY01vbnRoKCkgLSB0aGlzLl9nZXRQcm9sZXB0aWNNb250aCgpO1xuXG4gICAgICBzd2l0Y2ggKHVuaXQpIHtcbiAgICAgICAgY2FzZSBDaHJvbm9Vbml0Lk1PTlRIUzpcbiAgICAgICAgICByZXR1cm4gbW9udGhzVW50aWw7XG5cbiAgICAgICAgY2FzZSBDaHJvbm9Vbml0LllFQVJTOlxuICAgICAgICAgIHJldHVybiBtb250aHNVbnRpbCAvIDEyO1xuXG4gICAgICAgIGNhc2UgQ2hyb25vVW5pdC5ERUNBREVTOlxuICAgICAgICAgIHJldHVybiBtb250aHNVbnRpbCAvIDEyMDtcblxuICAgICAgICBjYXNlIENocm9ub1VuaXQuQ0VOVFVSSUVTOlxuICAgICAgICAgIHJldHVybiBtb250aHNVbnRpbCAvIDEyMDA7XG5cbiAgICAgICAgY2FzZSBDaHJvbm9Vbml0Lk1JTExFTk5JQTpcbiAgICAgICAgICByZXR1cm4gbW9udGhzVW50aWwgLyAxMjAwMDtcblxuICAgICAgICBjYXNlIENocm9ub1VuaXQuRVJBUzpcbiAgICAgICAgICByZXR1cm4gZW5kLmdldExvbmcoQ2hyb25vRmllbGQuRVJBKSAtIHRoaXMuZ2V0TG9uZyhDaHJvbm9GaWVsZC5FUkEpO1xuICAgICAgfVxuXG4gICAgICB0aHJvdyBuZXcgVW5zdXBwb3J0ZWRUZW1wb3JhbFR5cGVFeGNlcHRpb24oJ1Vuc3VwcG9ydGVkIHVuaXQ6ICcgKyB1bml0KTtcbiAgICB9XG5cbiAgICByZXR1cm4gdW5pdC5iZXR3ZWVuKHRoaXMsIGVuZCk7XG4gIH07XG5cbiAgX3Byb3RvLmF0RGF5ID0gZnVuY3Rpb24gYXREYXkoZGF5T2ZNb250aCkge1xuICAgIHJldHVybiBMb2NhbERhdGUub2YodGhpcy5feWVhciwgdGhpcy5fbW9udGgsIGRheU9mTW9udGgpO1xuICB9O1xuXG4gIF9wcm90by5hdEVuZE9mTW9udGggPSBmdW5jdGlvbiBhdEVuZE9mTW9udGgoKSB7XG4gICAgcmV0dXJuIExvY2FsRGF0ZS5vZih0aGlzLl95ZWFyLCB0aGlzLl9tb250aCwgdGhpcy5sZW5ndGhPZk1vbnRoKCkpO1xuICB9O1xuXG4gIF9wcm90by5jb21wYXJlVG8gPSBmdW5jdGlvbiBjb21wYXJlVG8ob3RoZXIpIHtcbiAgICByZXF1aXJlTm9uTnVsbChvdGhlciwgJ290aGVyJyk7XG4gICAgcmVxdWlyZUluc3RhbmNlKG90aGVyLCBZZWFyTW9udGgsICdvdGhlcicpO1xuICAgIHZhciBjbXAgPSB0aGlzLl95ZWFyIC0gb3RoZXIueWVhcigpO1xuXG4gICAgaWYgKGNtcCA9PT0gMCkge1xuICAgICAgY21wID0gdGhpcy5fbW9udGggLSBvdGhlci5tb250aFZhbHVlKCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGNtcDtcbiAgfTtcblxuICBfcHJvdG8uaXNBZnRlciA9IGZ1bmN0aW9uIGlzQWZ0ZXIob3RoZXIpIHtcbiAgICByZXR1cm4gdGhpcy5jb21wYXJlVG8ob3RoZXIpID4gMDtcbiAgfTtcblxuICBfcHJvdG8uaXNCZWZvcmUgPSBmdW5jdGlvbiBpc0JlZm9yZShvdGhlcikge1xuICAgIHJldHVybiB0aGlzLmNvbXBhcmVUbyhvdGhlcikgPCAwO1xuICB9O1xuXG4gIF9wcm90by5lcXVhbHMgPSBmdW5jdGlvbiBlcXVhbHMob2JqKSB7XG4gICAgaWYgKHRoaXMgPT09IG9iaikge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgaWYgKG9iaiBpbnN0YW5jZW9mIFllYXJNb250aCkge1xuICAgICAgdmFyIG90aGVyID0gb2JqO1xuICAgICAgcmV0dXJuIHRoaXMueWVhcigpID09PSBvdGhlci55ZWFyKCkgJiYgdGhpcy5tb250aFZhbHVlKCkgPT09IG90aGVyLm1vbnRoVmFsdWUoKTtcbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2U7XG4gIH07XG5cbiAgX3Byb3RvLnRvU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG4gICAgcmV0dXJuIFBBUlNFUiQxLmZvcm1hdCh0aGlzKTtcbiAgfTtcblxuICBfcHJvdG8udG9KU09OID0gZnVuY3Rpb24gdG9KU09OKCkge1xuICAgIHJldHVybiB0aGlzLnRvU3RyaW5nKCk7XG4gIH07XG5cbiAgX3Byb3RvLmZvcm1hdCA9IGZ1bmN0aW9uIGZvcm1hdChmb3JtYXR0ZXIpIHtcbiAgICByZXF1aXJlTm9uTnVsbChmb3JtYXR0ZXIsICdmb3JtYXR0ZXInKTtcbiAgICByZXR1cm4gZm9ybWF0dGVyLmZvcm1hdCh0aGlzKTtcbiAgfTtcblxuICByZXR1cm4gWWVhck1vbnRoO1xufShUZW1wb3JhbCk7XG52YXIgUEFSU0VSJDE7XG5mdW5jdGlvbiBfaW5pdCRjKCkge1xuICBQQVJTRVIkMSA9IG5ldyBEYXRlVGltZUZvcm1hdHRlckJ1aWxkZXIoKS5hcHBlbmRWYWx1ZShDaHJvbm9GaWVsZC5ZRUFSLCA0LCAxMCwgU2lnblN0eWxlLkVYQ0VFRFNfUEFEKS5hcHBlbmRMaXRlcmFsKCctJykuYXBwZW5kVmFsdWUoQ2hyb25vRmllbGQuTU9OVEhfT0ZfWUVBUiwgMikudG9Gb3JtYXR0ZXIoKTtcbiAgWWVhck1vbnRoLkZST00gPSBjcmVhdGVUZW1wb3JhbFF1ZXJ5KCdZZWFyTW9udGguRlJPTScsIGZ1bmN0aW9uICh0ZW1wb3JhbCkge1xuICAgIHJldHVybiBZZWFyTW9udGguZnJvbSh0ZW1wb3JhbCk7XG4gIH0pO1xufVxuXG52YXIgWWVhciA9IGZ1bmN0aW9uIChfVGVtcG9yYWwpIHtcbiAgX2luaGVyaXRzTG9vc2UoWWVhciwgX1RlbXBvcmFsKTtcblxuICBmdW5jdGlvbiBZZWFyKHZhbHVlKSB7XG4gICAgdmFyIF90aGlzO1xuXG4gICAgX3RoaXMgPSBfVGVtcG9yYWwuY2FsbCh0aGlzKSB8fCB0aGlzO1xuICAgIF90aGlzLl95ZWFyID0gTWF0aFV0aWwuc2FmZVRvSW50KHZhbHVlKTtcbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cblxuICB2YXIgX3Byb3RvID0gWWVhci5wcm90b3R5cGU7XG5cbiAgX3Byb3RvLnZhbHVlID0gZnVuY3Rpb24gdmFsdWUoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3llYXI7XG4gIH07XG5cbiAgWWVhci5ub3cgPSBmdW5jdGlvbiBub3coem9uZUlkT3JDbG9jaykge1xuICAgIGlmICh6b25lSWRPckNsb2NrID09PSB2b2lkIDApIHtcbiAgICAgIHpvbmVJZE9yQ2xvY2sgPSB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgaWYgKHpvbmVJZE9yQ2xvY2sgPT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIFllYXIubm93MCgpO1xuICAgIH0gZWxzZSBpZiAoem9uZUlkT3JDbG9jayBpbnN0YW5jZW9mIFpvbmVJZCkge1xuICAgICAgcmV0dXJuIFllYXIubm93Wm9uZUlkKHpvbmVJZE9yQ2xvY2spO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gWWVhci5ub3dDbG9jayh6b25lSWRPckNsb2NrKTtcbiAgICB9XG4gIH07XG5cbiAgWWVhci5ub3cwID0gZnVuY3Rpb24gbm93MCgpIHtcbiAgICByZXR1cm4gWWVhci5ub3dDbG9jayhDbG9jay5zeXN0ZW1EZWZhdWx0Wm9uZSgpKTtcbiAgfTtcblxuICBZZWFyLm5vd1pvbmVJZCA9IGZ1bmN0aW9uIG5vd1pvbmVJZCh6b25lKSB7XG4gICAgcmVxdWlyZU5vbk51bGwoem9uZSwgJ3pvbmUnKTtcbiAgICByZXF1aXJlSW5zdGFuY2Uoem9uZSwgWm9uZUlkLCAnem9uZScpO1xuICAgIHJldHVybiBZZWFyLm5vd0Nsb2NrKENsb2NrLnN5c3RlbSh6b25lKSk7XG4gIH07XG5cbiAgWWVhci5ub3dDbG9jayA9IGZ1bmN0aW9uIG5vd0Nsb2NrKGNsb2NrKSB7XG4gICAgcmVxdWlyZU5vbk51bGwoY2xvY2ssICdjbG9jaycpO1xuICAgIHJlcXVpcmVJbnN0YW5jZShjbG9jaywgQ2xvY2ssICdjbG9jaycpO1xuICAgIHZhciBub3cgPSBMb2NhbERhdGUubm93KGNsb2NrKTtcbiAgICByZXR1cm4gWWVhci5vZihub3cueWVhcigpKTtcbiAgfTtcblxuICBZZWFyLm9mID0gZnVuY3Rpb24gb2YoaXNvWWVhcikge1xuICAgIHJlcXVpcmVOb25OdWxsKGlzb1llYXIsICdpc29ZZWFyJyk7XG4gICAgQ2hyb25vRmllbGQuWUVBUi5jaGVja1ZhbGlkVmFsdWUoaXNvWWVhcik7XG4gICAgcmV0dXJuIG5ldyBZZWFyKGlzb1llYXIpO1xuICB9O1xuXG4gIFllYXIuZnJvbSA9IGZ1bmN0aW9uIGZyb20odGVtcG9yYWwpIHtcbiAgICByZXF1aXJlTm9uTnVsbCh0ZW1wb3JhbCwgJ3RlbXBvcmFsJyk7XG4gICAgcmVxdWlyZUluc3RhbmNlKHRlbXBvcmFsLCBUZW1wb3JhbEFjY2Vzc29yLCAndGVtcG9yYWwnKTtcblxuICAgIGlmICh0ZW1wb3JhbCBpbnN0YW5jZW9mIFllYXIpIHtcbiAgICAgIHJldHVybiB0ZW1wb3JhbDtcbiAgICB9XG5cbiAgICB0cnkge1xuICAgICAgcmV0dXJuIFllYXIub2YodGVtcG9yYWwuZ2V0KENocm9ub0ZpZWxkLllFQVIpKTtcbiAgICB9IGNhdGNoIChleCkge1xuICAgICAgdGhyb3cgbmV3IERhdGVUaW1lRXhjZXB0aW9uKCdVbmFibGUgdG8gb2J0YWluIFllYXIgZnJvbSBUZW1wb3JhbEFjY2Vzc29yOiAnICsgdGVtcG9yYWwgKyAnLCB0eXBlICcgKyAodGVtcG9yYWwgJiYgdGVtcG9yYWwuY29uc3RydWN0b3IgIT0gbnVsbCA/IHRlbXBvcmFsLmNvbnN0cnVjdG9yLm5hbWUgOiAnJykpO1xuICAgIH1cbiAgfTtcblxuICBZZWFyLnBhcnNlID0gZnVuY3Rpb24gcGFyc2UodGV4dCwgZm9ybWF0dGVyKSB7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPD0gMSkge1xuICAgICAgcmV0dXJuIFllYXIucGFyc2VUZXh0KHRleHQpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gWWVhci5wYXJzZVRleHRGb3JtYXR0ZXIodGV4dCwgZm9ybWF0dGVyKTtcbiAgICB9XG4gIH07XG5cbiAgWWVhci5wYXJzZVRleHQgPSBmdW5jdGlvbiBwYXJzZVRleHQodGV4dCkge1xuICAgIHJlcXVpcmVOb25OdWxsKHRleHQsICd0ZXh0Jyk7XG4gICAgcmV0dXJuIFllYXIucGFyc2UodGV4dCwgUEFSU0VSJDIpO1xuICB9O1xuXG4gIFllYXIucGFyc2VUZXh0Rm9ybWF0dGVyID0gZnVuY3Rpb24gcGFyc2VUZXh0Rm9ybWF0dGVyKHRleHQsIGZvcm1hdHRlcikge1xuICAgIGlmIChmb3JtYXR0ZXIgPT09IHZvaWQgMCkge1xuICAgICAgZm9ybWF0dGVyID0gUEFSU0VSJDI7XG4gICAgfVxuXG4gICAgcmVxdWlyZU5vbk51bGwodGV4dCwgJ3RleHQnKTtcbiAgICByZXF1aXJlTm9uTnVsbChmb3JtYXR0ZXIsICdmb3JtYXR0ZXInKTtcbiAgICByZXF1aXJlSW5zdGFuY2UoZm9ybWF0dGVyLCBEYXRlVGltZUZvcm1hdHRlciwgJ2Zvcm1hdHRlcicpO1xuICAgIHJldHVybiBmb3JtYXR0ZXIucGFyc2UodGV4dCwgWWVhci5GUk9NKTtcbiAgfTtcblxuICBZZWFyLmlzTGVhcCA9IGZ1bmN0aW9uIGlzTGVhcCh5ZWFyKSB7XG4gICAgcmV0dXJuIE1hdGhVdGlsLmludE1vZCh5ZWFyLCA0KSA9PT0gMCAmJiAoTWF0aFV0aWwuaW50TW9kKHllYXIsIDEwMCkgIT09IDAgfHwgTWF0aFV0aWwuaW50TW9kKHllYXIsIDQwMCkgPT09IDApO1xuICB9O1xuXG4gIF9wcm90by5pc1N1cHBvcnRlZCA9IGZ1bmN0aW9uIGlzU3VwcG9ydGVkKGZpZWxkT3JVbml0KSB7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEgJiYgZmllbGRPclVuaXQgaW5zdGFuY2VvZiBUZW1wb3JhbEZpZWxkKSB7XG4gICAgICByZXR1cm4gdGhpcy5pc1N1cHBvcnRlZEZpZWxkKGZpZWxkT3JVbml0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHRoaXMuaXNTdXBwb3J0ZWRVbml0KGZpZWxkT3JVbml0KTtcbiAgICB9XG4gIH07XG5cbiAgX3Byb3RvLmlzU3VwcG9ydGVkRmllbGQgPSBmdW5jdGlvbiBpc1N1cHBvcnRlZEZpZWxkKGZpZWxkKSB7XG4gICAgaWYgKGZpZWxkIGluc3RhbmNlb2YgQ2hyb25vRmllbGQpIHtcbiAgICAgIHJldHVybiBmaWVsZCA9PT0gQ2hyb25vRmllbGQuWUVBUiB8fCBmaWVsZCA9PT0gQ2hyb25vRmllbGQuWUVBUl9PRl9FUkEgfHwgZmllbGQgPT09IENocm9ub0ZpZWxkLkVSQTtcbiAgICB9XG5cbiAgICByZXR1cm4gZmllbGQgIT0gbnVsbCAmJiBmaWVsZC5pc1N1cHBvcnRlZEJ5KHRoaXMpO1xuICB9O1xuXG4gIF9wcm90by5pc1N1cHBvcnRlZFVuaXQgPSBmdW5jdGlvbiBpc1N1cHBvcnRlZFVuaXQodW5pdCkge1xuICAgIGlmICh1bml0IGluc3RhbmNlb2YgQ2hyb25vVW5pdCkge1xuICAgICAgcmV0dXJuIHVuaXQgPT09IENocm9ub1VuaXQuWUVBUlMgfHwgdW5pdCA9PT0gQ2hyb25vVW5pdC5ERUNBREVTIHx8IHVuaXQgPT09IENocm9ub1VuaXQuQ0VOVFVSSUVTIHx8IHVuaXQgPT09IENocm9ub1VuaXQuTUlMTEVOTklBIHx8IHVuaXQgPT09IENocm9ub1VuaXQuRVJBUztcbiAgICB9XG5cbiAgICByZXR1cm4gdW5pdCAhPSBudWxsICYmIHVuaXQuaXNTdXBwb3J0ZWRCeSh0aGlzKTtcbiAgfTtcblxuICBfcHJvdG8ucmFuZ2UgPSBmdW5jdGlvbiByYW5nZShmaWVsZCkge1xuICAgIGlmICh0aGlzLmlzU3VwcG9ydGVkKGZpZWxkKSkge1xuICAgICAgcmV0dXJuIGZpZWxkLnJhbmdlKCk7XG4gICAgfSBlbHNlIGlmIChmaWVsZCBpbnN0YW5jZW9mIENocm9ub0ZpZWxkKSB7XG4gICAgICB0aHJvdyBuZXcgVW5zdXBwb3J0ZWRUZW1wb3JhbFR5cGVFeGNlcHRpb24oJ1Vuc3VwcG9ydGVkIGZpZWxkOiAnICsgZmllbGQpO1xuICAgIH1cblxuICAgIHJldHVybiBfVGVtcG9yYWwucHJvdG90eXBlLnJhbmdlLmNhbGwodGhpcywgZmllbGQpO1xuICB9O1xuXG4gIF9wcm90by5nZXQgPSBmdW5jdGlvbiBnZXQoZmllbGQpIHtcbiAgICByZXR1cm4gdGhpcy5yYW5nZShmaWVsZCkuY2hlY2tWYWxpZEludFZhbHVlKHRoaXMuZ2V0TG9uZyhmaWVsZCksIGZpZWxkKTtcbiAgfTtcblxuICBfcHJvdG8uZ2V0TG9uZyA9IGZ1bmN0aW9uIGdldExvbmcoZmllbGQpIHtcbiAgICByZXF1aXJlTm9uTnVsbChmaWVsZCwgJ2ZpZWxkJyk7XG5cbiAgICBpZiAoZmllbGQgaW5zdGFuY2VvZiBDaHJvbm9GaWVsZCkge1xuICAgICAgc3dpdGNoIChmaWVsZCkge1xuICAgICAgICBjYXNlIENocm9ub0ZpZWxkLllFQVJfT0ZfRVJBOlxuICAgICAgICAgIHJldHVybiB0aGlzLl95ZWFyIDwgMSA/IDEgLSB0aGlzLl95ZWFyIDogdGhpcy5feWVhcjtcblxuICAgICAgICBjYXNlIENocm9ub0ZpZWxkLllFQVI6XG4gICAgICAgICAgcmV0dXJuIHRoaXMuX3llYXI7XG5cbiAgICAgICAgY2FzZSBDaHJvbm9GaWVsZC5FUkE6XG4gICAgICAgICAgcmV0dXJuIHRoaXMuX3llYXIgPCAxID8gMCA6IDE7XG4gICAgICB9XG5cbiAgICAgIHRocm93IG5ldyBVbnN1cHBvcnRlZFRlbXBvcmFsVHlwZUV4Y2VwdGlvbignVW5zdXBwb3J0ZWQgZmllbGQ6ICcgKyBmaWVsZCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZpZWxkLmdldEZyb20odGhpcyk7XG4gIH07XG5cbiAgX3Byb3RvLmlzTGVhcCA9IGZ1bmN0aW9uIGlzTGVhcCgpIHtcbiAgICByZXR1cm4gWWVhci5pc0xlYXAodGhpcy5feWVhcik7XG4gIH07XG5cbiAgX3Byb3RvLndpdGhBZGp1c3RlciA9IGZ1bmN0aW9uIHdpdGhBZGp1c3RlcihhZGp1c3Rlcikge1xuICAgIHJlcXVpcmVOb25OdWxsKGFkanVzdGVyLCAnYWRqdXN0ZXInKTtcbiAgICByZXR1cm4gYWRqdXN0ZXIuYWRqdXN0SW50byh0aGlzKTtcbiAgfTtcblxuICBfcHJvdG8ud2l0aEZpZWxkVmFsdWUgPSBmdW5jdGlvbiB3aXRoRmllbGRWYWx1ZShmaWVsZCwgbmV3VmFsdWUpIHtcbiAgICByZXF1aXJlTm9uTnVsbChmaWVsZCwgJ2ZpZWxkJyk7XG4gICAgcmVxdWlyZUluc3RhbmNlKGZpZWxkLCBUZW1wb3JhbEZpZWxkLCAnZmllbGQnKTtcblxuICAgIGlmIChmaWVsZCBpbnN0YW5jZW9mIENocm9ub0ZpZWxkKSB7XG4gICAgICBmaWVsZC5jaGVja1ZhbGlkVmFsdWUobmV3VmFsdWUpO1xuXG4gICAgICBzd2l0Y2ggKGZpZWxkKSB7XG4gICAgICAgIGNhc2UgQ2hyb25vRmllbGQuWUVBUl9PRl9FUkE6XG4gICAgICAgICAgcmV0dXJuIFllYXIub2YodGhpcy5feWVhciA8IDEgPyAxIC0gbmV3VmFsdWUgOiBuZXdWYWx1ZSk7XG5cbiAgICAgICAgY2FzZSBDaHJvbm9GaWVsZC5ZRUFSOlxuICAgICAgICAgIHJldHVybiBZZWFyLm9mKG5ld1ZhbHVlKTtcblxuICAgICAgICBjYXNlIENocm9ub0ZpZWxkLkVSQTpcbiAgICAgICAgICByZXR1cm4gdGhpcy5nZXRMb25nKENocm9ub0ZpZWxkLkVSQSkgPT09IG5ld1ZhbHVlID8gdGhpcyA6IFllYXIub2YoMSAtIHRoaXMuX3llYXIpO1xuICAgICAgfVxuXG4gICAgICB0aHJvdyBuZXcgVW5zdXBwb3J0ZWRUZW1wb3JhbFR5cGVFeGNlcHRpb24oJ1Vuc3VwcG9ydGVkIGZpZWxkOiAnICsgZmllbGQpO1xuICAgIH1cblxuICAgIHJldHVybiBmaWVsZC5hZGp1c3RJbnRvKHRoaXMsIG5ld1ZhbHVlKTtcbiAgfTtcblxuICBfcHJvdG8ucGx1c0Ftb3VudCA9IGZ1bmN0aW9uIHBsdXNBbW91bnQoYW1vdW50KSB7XG4gICAgcmVxdWlyZU5vbk51bGwoYW1vdW50LCAnYW1vdW50Jyk7XG4gICAgcmVxdWlyZUluc3RhbmNlKGFtb3VudCwgVGVtcG9yYWxBbW91bnQsICdhbW91bnQnKTtcbiAgICByZXR1cm4gYW1vdW50LmFkZFRvKHRoaXMpO1xuICB9O1xuXG4gIF9wcm90by5wbHVzQW1vdW50VW5pdCA9IGZ1bmN0aW9uIHBsdXNBbW91bnRVbml0KGFtb3VudFRvQWRkLCB1bml0KSB7XG4gICAgcmVxdWlyZU5vbk51bGwoYW1vdW50VG9BZGQsICdhbW91bnRUb0FkZCcpO1xuICAgIHJlcXVpcmVOb25OdWxsKHVuaXQsICd1bml0Jyk7XG4gICAgcmVxdWlyZUluc3RhbmNlKHVuaXQsIFRlbXBvcmFsVW5pdCwgJ3VuaXQnKTtcblxuICAgIGlmICh1bml0IGluc3RhbmNlb2YgQ2hyb25vVW5pdCkge1xuICAgICAgc3dpdGNoICh1bml0KSB7XG4gICAgICAgIGNhc2UgQ2hyb25vVW5pdC5ZRUFSUzpcbiAgICAgICAgICByZXR1cm4gdGhpcy5wbHVzWWVhcnMoYW1vdW50VG9BZGQpO1xuXG4gICAgICAgIGNhc2UgQ2hyb25vVW5pdC5ERUNBREVTOlxuICAgICAgICAgIHJldHVybiB0aGlzLnBsdXNZZWFycyhNYXRoVXRpbC5zYWZlTXVsdGlwbHkoYW1vdW50VG9BZGQsIDEwKSk7XG5cbiAgICAgICAgY2FzZSBDaHJvbm9Vbml0LkNFTlRVUklFUzpcbiAgICAgICAgICByZXR1cm4gdGhpcy5wbHVzWWVhcnMoTWF0aFV0aWwuc2FmZU11bHRpcGx5KGFtb3VudFRvQWRkLCAxMDApKTtcblxuICAgICAgICBjYXNlIENocm9ub1VuaXQuTUlMTEVOTklBOlxuICAgICAgICAgIHJldHVybiB0aGlzLnBsdXNZZWFycyhNYXRoVXRpbC5zYWZlTXVsdGlwbHkoYW1vdW50VG9BZGQsIDEwMDApKTtcblxuICAgICAgICBjYXNlIENocm9ub1VuaXQuRVJBUzpcbiAgICAgICAgICByZXR1cm4gdGhpcy53aXRoKENocm9ub0ZpZWxkLkVSQSwgTWF0aFV0aWwuc2FmZUFkZCh0aGlzLmdldExvbmcoQ2hyb25vRmllbGQuRVJBKSwgYW1vdW50VG9BZGQpKTtcbiAgICAgIH1cblxuICAgICAgdGhyb3cgbmV3IFVuc3VwcG9ydGVkVGVtcG9yYWxUeXBlRXhjZXB0aW9uKCdVbnN1cHBvcnRlZCB1bml0OiAnICsgdW5pdCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHVuaXQuYWRkVG8odGhpcywgYW1vdW50VG9BZGQpO1xuICB9O1xuXG4gIF9wcm90by5wbHVzWWVhcnMgPSBmdW5jdGlvbiBwbHVzWWVhcnMoeWVhcnNUb0FkZCkge1xuICAgIGlmICh5ZWFyc1RvQWRkID09PSAwKSB7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICByZXR1cm4gWWVhci5vZihDaHJvbm9GaWVsZC5ZRUFSLmNoZWNrVmFsaWRJbnRWYWx1ZShNYXRoVXRpbC5zYWZlQWRkKHRoaXMuX3llYXIsIHllYXJzVG9BZGQpKSk7XG4gIH07XG5cbiAgX3Byb3RvLm1pbnVzQW1vdW50ID0gZnVuY3Rpb24gbWludXNBbW91bnQoYW1vdW50KSB7XG4gICAgcmVxdWlyZU5vbk51bGwoYW1vdW50LCAnYW1vdW50Jyk7XG4gICAgcmVxdWlyZUluc3RhbmNlKGFtb3VudCwgVGVtcG9yYWxBbW91bnQsICdhbW91bnQnKTtcbiAgICByZXR1cm4gYW1vdW50LnN1YnRyYWN0RnJvbSh0aGlzKTtcbiAgfTtcblxuICBfcHJvdG8ubWludXNBbW91bnRVbml0ID0gZnVuY3Rpb24gbWludXNBbW91bnRVbml0KGFtb3VudFRvU3VidHJhY3QsIHVuaXQpIHtcbiAgICByZXF1aXJlTm9uTnVsbChhbW91bnRUb1N1YnRyYWN0LCAnYW1vdW50VG9TdWJ0cmFjdCcpO1xuICAgIHJlcXVpcmVOb25OdWxsKHVuaXQsICd1bml0Jyk7XG4gICAgcmVxdWlyZUluc3RhbmNlKHVuaXQsIFRlbXBvcmFsVW5pdCwgJ3VuaXQnKTtcbiAgICByZXR1cm4gYW1vdW50VG9TdWJ0cmFjdCA9PT0gTWF0aFV0aWwuTUlOX1NBRkVfSU5URUdFUiA/IHRoaXMucGx1cyhNYXRoVXRpbC5NQVhfU0FGRV9JTlRFR0VSLCB1bml0KS5wbHVzKDEsIHVuaXQpIDogdGhpcy5wbHVzKC1hbW91bnRUb1N1YnRyYWN0LCB1bml0KTtcbiAgfTtcblxuICBfcHJvdG8ubWludXNZZWFycyA9IGZ1bmN0aW9uIG1pbnVzWWVhcnMoeWVhcnNUb1N1YnRyYWN0KSB7XG4gICAgcmV0dXJuIHllYXJzVG9TdWJ0cmFjdCA9PT0gTWF0aFV0aWwuTUlOX1NBRkVfSU5URUdFUiA/IHRoaXMucGx1c1llYXJzKE1hdGhVdGlsLk1BWF9TQUZFX0lOVEVHRVIpLnBsdXNZZWFycygxKSA6IHRoaXMucGx1c1llYXJzKC15ZWFyc1RvU3VidHJhY3QpO1xuICB9O1xuXG4gIF9wcm90by5hZGp1c3RJbnRvID0gZnVuY3Rpb24gYWRqdXN0SW50byh0ZW1wb3JhbCkge1xuICAgIHJlcXVpcmVOb25OdWxsKHRlbXBvcmFsLCAndGVtcG9yYWwnKTtcbiAgICByZXR1cm4gdGVtcG9yYWwud2l0aChDaHJvbm9GaWVsZC5ZRUFSLCB0aGlzLl95ZWFyKTtcbiAgfTtcblxuICBfcHJvdG8uaXNWYWxpZE1vbnRoRGF5ID0gZnVuY3Rpb24gaXNWYWxpZE1vbnRoRGF5KG1vbnRoRGF5KSB7XG4gICAgcmV0dXJuIG1vbnRoRGF5ICE9IG51bGwgJiYgbW9udGhEYXkuaXNWYWxpZFllYXIodGhpcy5feWVhcik7XG4gIH07XG5cbiAgX3Byb3RvLmxlbmd0aCA9IGZ1bmN0aW9uIGxlbmd0aCgpIHtcbiAgICByZXR1cm4gdGhpcy5pc0xlYXAoKSA/IDM2NiA6IDM2NTtcbiAgfTtcblxuICBfcHJvdG8uYXREYXkgPSBmdW5jdGlvbiBhdERheShkYXlPZlllYXIpIHtcbiAgICByZXR1cm4gTG9jYWxEYXRlLm9mWWVhckRheSh0aGlzLl95ZWFyLCBkYXlPZlllYXIpO1xuICB9O1xuXG4gIF9wcm90by5hdE1vbnRoID0gZnVuY3Rpb24gYXRNb250aChtb250aE9yTnVtYmVyKSB7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEgJiYgbW9udGhPck51bWJlciBpbnN0YW5jZW9mIE1vbnRoKSB7XG4gICAgICByZXR1cm4gdGhpcy5hdE1vbnRoTW9udGgobW9udGhPck51bWJlcik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB0aGlzLmF0TW9udGhOdW1iZXIobW9udGhPck51bWJlcik7XG4gICAgfVxuICB9O1xuXG4gIF9wcm90by5hdE1vbnRoTW9udGggPSBmdW5jdGlvbiBhdE1vbnRoTW9udGgobW9udGgpIHtcbiAgICByZXF1aXJlTm9uTnVsbChtb250aCwgJ21vbnRoJyk7XG4gICAgcmVxdWlyZUluc3RhbmNlKG1vbnRoLCBNb250aCwgJ21vbnRoJyk7XG4gICAgcmV0dXJuIFllYXJNb250aC5vZih0aGlzLl95ZWFyLCBtb250aCk7XG4gIH07XG5cbiAgX3Byb3RvLmF0TW9udGhOdW1iZXIgPSBmdW5jdGlvbiBhdE1vbnRoTnVtYmVyKG1vbnRoKSB7XG4gICAgcmVxdWlyZU5vbk51bGwobW9udGgsICdtb250aCcpO1xuICAgIHJldHVybiBZZWFyTW9udGgub2YodGhpcy5feWVhciwgbW9udGgpO1xuICB9O1xuXG4gIF9wcm90by5hdE1vbnRoRGF5ID0gZnVuY3Rpb24gYXRNb250aERheShtb250aERheSkge1xuICAgIHJlcXVpcmVOb25OdWxsKG1vbnRoRGF5LCAnbW9udGhEYXknKTtcbiAgICByZXF1aXJlSW5zdGFuY2UobW9udGhEYXksIE1vbnRoRGF5LCAnbW9udGhEYXknKTtcbiAgICByZXR1cm4gbW9udGhEYXkuYXRZZWFyKHRoaXMuX3llYXIpO1xuICB9O1xuXG4gIF9wcm90by5xdWVyeSA9IGZ1bmN0aW9uIHF1ZXJ5KF9xdWVyeSkge1xuICAgIHJlcXVpcmVOb25OdWxsKF9xdWVyeSwgJ3F1ZXJ5KCknKTtcbiAgICByZXF1aXJlSW5zdGFuY2UoX3F1ZXJ5LCBUZW1wb3JhbFF1ZXJ5LCAncXVlcnkoKScpO1xuXG4gICAgaWYgKF9xdWVyeSA9PT0gVGVtcG9yYWxRdWVyaWVzLmNocm9ub2xvZ3koKSkge1xuICAgICAgcmV0dXJuIElzb0Nocm9ub2xvZ3kuSU5TVEFOQ0U7XG4gICAgfSBlbHNlIGlmIChfcXVlcnkgPT09IFRlbXBvcmFsUXVlcmllcy5wcmVjaXNpb24oKSkge1xuICAgICAgcmV0dXJuIENocm9ub1VuaXQuWUVBUlM7XG4gICAgfSBlbHNlIGlmIChfcXVlcnkgPT09IFRlbXBvcmFsUXVlcmllcy5sb2NhbERhdGUoKSB8fCBfcXVlcnkgPT09IFRlbXBvcmFsUXVlcmllcy5sb2NhbFRpbWUoKSB8fCBfcXVlcnkgPT09IFRlbXBvcmFsUXVlcmllcy56b25lKCkgfHwgX3F1ZXJ5ID09PSBUZW1wb3JhbFF1ZXJpZXMuem9uZUlkKCkgfHwgX3F1ZXJ5ID09PSBUZW1wb3JhbFF1ZXJpZXMub2Zmc2V0KCkpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIHJldHVybiBfVGVtcG9yYWwucHJvdG90eXBlLnF1ZXJ5LmNhbGwodGhpcywgX3F1ZXJ5KTtcbiAgfTtcblxuICBfcHJvdG8uY29tcGFyZVRvID0gZnVuY3Rpb24gY29tcGFyZVRvKG90aGVyKSB7XG4gICAgcmVxdWlyZU5vbk51bGwob3RoZXIsICdvdGhlcicpO1xuICAgIHJlcXVpcmVJbnN0YW5jZShvdGhlciwgWWVhciwgJ290aGVyJyk7XG4gICAgcmV0dXJuIHRoaXMuX3llYXIgLSBvdGhlci5feWVhcjtcbiAgfTtcblxuICBfcHJvdG8uaXNBZnRlciA9IGZ1bmN0aW9uIGlzQWZ0ZXIob3RoZXIpIHtcbiAgICByZXF1aXJlTm9uTnVsbChvdGhlciwgJ290aGVyJyk7XG4gICAgcmVxdWlyZUluc3RhbmNlKG90aGVyLCBZZWFyLCAnb3RoZXInKTtcbiAgICByZXR1cm4gdGhpcy5feWVhciA+IG90aGVyLl95ZWFyO1xuICB9O1xuXG4gIF9wcm90by5pc0JlZm9yZSA9IGZ1bmN0aW9uIGlzQmVmb3JlKG90aGVyKSB7XG4gICAgcmVxdWlyZU5vbk51bGwob3RoZXIsICdvdGhlcicpO1xuICAgIHJlcXVpcmVJbnN0YW5jZShvdGhlciwgWWVhciwgJ290aGVyJyk7XG4gICAgcmV0dXJuIHRoaXMuX3llYXIgPCBvdGhlci5feWVhcjtcbiAgfTtcblxuICBfcHJvdG8uZm9ybWF0ID0gZnVuY3Rpb24gZm9ybWF0KGZvcm1hdHRlcikge1xuICAgIHJlcXVpcmVOb25OdWxsKGZvcm1hdHRlciwgJ2Zvcm1hdHRlcicpO1xuICAgIHJlcXVpcmVJbnN0YW5jZShmb3JtYXR0ZXIsIERhdGVUaW1lRm9ybWF0dGVyLCAnZm9ybWF0dGVyJyk7XG4gICAgcmV0dXJuIGZvcm1hdHRlci5mb3JtYXQodGhpcyk7XG4gIH07XG5cbiAgX3Byb3RvLmVxdWFscyA9IGZ1bmN0aW9uIGVxdWFscyhvdGhlcikge1xuICAgIGlmICh0aGlzID09PSBvdGhlcikge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgaWYgKG90aGVyIGluc3RhbmNlb2YgWWVhcikge1xuICAgICAgcmV0dXJuIHRoaXMudmFsdWUoKSA9PT0gb3RoZXIudmFsdWUoKTtcbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2U7XG4gIH07XG5cbiAgX3Byb3RvLnRvU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG4gICAgcmV0dXJuICcnICsgdGhpcy5feWVhcjtcbiAgfTtcblxuICBfcHJvdG8udG9KU09OID0gZnVuY3Rpb24gdG9KU09OKCkge1xuICAgIHJldHVybiB0aGlzLnRvU3RyaW5nKCk7XG4gIH07XG5cbiAgX3Byb3RvLnVudGlsID0gZnVuY3Rpb24gdW50aWwoZW5kRXhjbHVzaXZlLCB1bml0KSB7XG4gICAgdmFyIGVuZCA9IFllYXIuZnJvbShlbmRFeGNsdXNpdmUpO1xuXG4gICAgaWYgKHVuaXQgaW5zdGFuY2VvZiBDaHJvbm9Vbml0KSB7XG4gICAgICB2YXIgeWVhcnNVbnRpbCA9IGVuZC52YWx1ZSgpIC0gdGhpcy52YWx1ZSgpO1xuXG4gICAgICBzd2l0Y2ggKHVuaXQpIHtcbiAgICAgICAgY2FzZSBDaHJvbm9Vbml0LllFQVJTOlxuICAgICAgICAgIHJldHVybiB5ZWFyc1VudGlsO1xuXG4gICAgICAgIGNhc2UgQ2hyb25vVW5pdC5ERUNBREVTOlxuICAgICAgICAgIHJldHVybiBNYXRoVXRpbC5pbnREaXYoeWVhcnNVbnRpbCwgMTApO1xuXG4gICAgICAgIGNhc2UgQ2hyb25vVW5pdC5DRU5UVVJJRVM6XG4gICAgICAgICAgcmV0dXJuIE1hdGhVdGlsLmludERpdih5ZWFyc1VudGlsLCAxMDApO1xuXG4gICAgICAgIGNhc2UgQ2hyb25vVW5pdC5NSUxMRU5OSUE6XG4gICAgICAgICAgcmV0dXJuIE1hdGhVdGlsLmludERpdih5ZWFyc1VudGlsLCAxMDAwKTtcblxuICAgICAgICBjYXNlIENocm9ub1VuaXQuRVJBUzpcbiAgICAgICAgICByZXR1cm4gZW5kLmdldExvbmcoQ2hyb25vRmllbGQuRVJBKSAtIHRoaXMuZ2V0TG9uZyhDaHJvbm9GaWVsZC5FUkEpO1xuICAgICAgfVxuXG4gICAgICB0aHJvdyBuZXcgVW5zdXBwb3J0ZWRUZW1wb3JhbFR5cGVFeGNlcHRpb24oJ1Vuc3VwcG9ydGVkIHVuaXQ6ICcgKyB1bml0KTtcbiAgICB9XG5cbiAgICByZXR1cm4gdW5pdC5iZXR3ZWVuKHRoaXMsIGVuZCk7XG4gIH07XG5cbiAgcmV0dXJuIFllYXI7XG59KFRlbXBvcmFsKTtcbnZhciBQQVJTRVIkMjtcbmZ1bmN0aW9uIF9pbml0JGQoKSB7XG4gIFllYXIuTUlOX1ZBTFVFID0gWWVhckNvbnN0YW50cy5NSU5fVkFMVUU7XG4gIFllYXIuTUFYX1ZBTFVFID0gWWVhckNvbnN0YW50cy5NQVhfVkFMVUU7XG4gIFBBUlNFUiQyID0gbmV3IERhdGVUaW1lRm9ybWF0dGVyQnVpbGRlcigpLmFwcGVuZFZhbHVlKENocm9ub0ZpZWxkLllFQVIsIDQsIDEwLCBTaWduU3R5bGUuRVhDRUVEU19QQUQpLnRvRm9ybWF0dGVyKCk7XG4gIFllYXIuRlJPTSA9IGNyZWF0ZVRlbXBvcmFsUXVlcnkoJ1llYXIuRlJPTScsIGZ1bmN0aW9uICh0ZW1wb3JhbCkge1xuICAgIHJldHVybiBZZWFyLmZyb20odGVtcG9yYWwpO1xuICB9KTtcbn1cblxudmFyIFRlbXBvcmFsQWRqdXN0ZXJzID0gZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBUZW1wb3JhbEFkanVzdGVycygpIHt9XG5cbiAgVGVtcG9yYWxBZGp1c3RlcnMuZmlyc3REYXlPZk1vbnRoID0gZnVuY3Rpb24gZmlyc3REYXlPZk1vbnRoKCkge1xuICAgIHJldHVybiBJbXBsLkZJUlNUX0RBWV9PRl9NT05USDtcbiAgfTtcblxuICBUZW1wb3JhbEFkanVzdGVycy5sYXN0RGF5T2ZNb250aCA9IGZ1bmN0aW9uIGxhc3REYXlPZk1vbnRoKCkge1xuICAgIHJldHVybiBJbXBsLkxBU1RfREFZX09GX01PTlRIO1xuICB9O1xuXG4gIFRlbXBvcmFsQWRqdXN0ZXJzLmZpcnN0RGF5T2ZOZXh0TW9udGggPSBmdW5jdGlvbiBmaXJzdERheU9mTmV4dE1vbnRoKCkge1xuICAgIHJldHVybiBJbXBsLkZJUlNUX0RBWV9PRl9ORVhUX01PTlRIO1xuICB9O1xuXG4gIFRlbXBvcmFsQWRqdXN0ZXJzLmZpcnN0RGF5T2ZZZWFyID0gZnVuY3Rpb24gZmlyc3REYXlPZlllYXIoKSB7XG4gICAgcmV0dXJuIEltcGwuRklSU1RfREFZX09GX1lFQVI7XG4gIH07XG5cbiAgVGVtcG9yYWxBZGp1c3RlcnMubGFzdERheU9mWWVhciA9IGZ1bmN0aW9uIGxhc3REYXlPZlllYXIoKSB7XG4gICAgcmV0dXJuIEltcGwuTEFTVF9EQVlfT0ZfWUVBUjtcbiAgfTtcblxuICBUZW1wb3JhbEFkanVzdGVycy5maXJzdERheU9mTmV4dFllYXIgPSBmdW5jdGlvbiBmaXJzdERheU9mTmV4dFllYXIoKSB7XG4gICAgcmV0dXJuIEltcGwuRklSU1RfREFZX09GX05FWFRfWUVBUjtcbiAgfTtcblxuICBUZW1wb3JhbEFkanVzdGVycy5maXJzdEluTW9udGggPSBmdW5jdGlvbiBmaXJzdEluTW9udGgoZGF5T2ZXZWVrKSB7XG4gICAgcmVxdWlyZU5vbk51bGwoZGF5T2ZXZWVrLCAnZGF5T2ZXZWVrJyk7XG4gICAgcmV0dXJuIG5ldyBEYXlPZldlZWtJbk1vbnRoKDEsIGRheU9mV2Vlayk7XG4gIH07XG5cbiAgVGVtcG9yYWxBZGp1c3RlcnMubGFzdEluTW9udGggPSBmdW5jdGlvbiBsYXN0SW5Nb250aChkYXlPZldlZWspIHtcbiAgICByZXF1aXJlTm9uTnVsbChkYXlPZldlZWssICdkYXlPZldlZWsnKTtcbiAgICByZXR1cm4gbmV3IERheU9mV2Vla0luTW9udGgoLTEsIGRheU9mV2Vlayk7XG4gIH07XG5cbiAgVGVtcG9yYWxBZGp1c3RlcnMuZGF5T2ZXZWVrSW5Nb250aCA9IGZ1bmN0aW9uIGRheU9mV2Vla0luTW9udGgob3JkaW5hbCwgZGF5T2ZXZWVrKSB7XG4gICAgcmVxdWlyZU5vbk51bGwoZGF5T2ZXZWVrLCAnZGF5T2ZXZWVrJyk7XG4gICAgcmV0dXJuIG5ldyBEYXlPZldlZWtJbk1vbnRoKG9yZGluYWwsIGRheU9mV2Vlayk7XG4gIH07XG5cbiAgVGVtcG9yYWxBZGp1c3RlcnMubmV4dCA9IGZ1bmN0aW9uIG5leHQoZGF5T2ZXZWVrKSB7XG4gICAgcmV0dXJuIG5ldyBSZWxhdGl2ZURheU9mV2VlaygyLCBkYXlPZldlZWspO1xuICB9O1xuXG4gIFRlbXBvcmFsQWRqdXN0ZXJzLm5leHRPclNhbWUgPSBmdW5jdGlvbiBuZXh0T3JTYW1lKGRheU9mV2Vlaykge1xuICAgIHJldHVybiBuZXcgUmVsYXRpdmVEYXlPZldlZWsoMCwgZGF5T2ZXZWVrKTtcbiAgfTtcblxuICBUZW1wb3JhbEFkanVzdGVycy5wcmV2aW91cyA9IGZ1bmN0aW9uIHByZXZpb3VzKGRheU9mV2Vlaykge1xuICAgIHJldHVybiBuZXcgUmVsYXRpdmVEYXlPZldlZWsoMywgZGF5T2ZXZWVrKTtcbiAgfTtcblxuICBUZW1wb3JhbEFkanVzdGVycy5wcmV2aW91c09yU2FtZSA9IGZ1bmN0aW9uIHByZXZpb3VzT3JTYW1lKGRheU9mV2Vlaykge1xuICAgIHJldHVybiBuZXcgUmVsYXRpdmVEYXlPZldlZWsoMSwgZGF5T2ZXZWVrKTtcbiAgfTtcblxuICByZXR1cm4gVGVtcG9yYWxBZGp1c3RlcnM7XG59KCk7XG5cbnZhciBJbXBsID0gZnVuY3Rpb24gKF9UZW1wb3JhbEFkanVzdGVyKSB7XG4gIF9pbmhlcml0c0xvb3NlKEltcGwsIF9UZW1wb3JhbEFkanVzdGVyKTtcblxuICBmdW5jdGlvbiBJbXBsKG9yZGluYWwpIHtcbiAgICB2YXIgX3RoaXM7XG5cbiAgICBfdGhpcyA9IF9UZW1wb3JhbEFkanVzdGVyLmNhbGwodGhpcykgfHwgdGhpcztcbiAgICBfdGhpcy5fb3JkaW5hbCA9IG9yZGluYWw7XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG5cbiAgdmFyIF9wcm90byA9IEltcGwucHJvdG90eXBlO1xuXG4gIF9wcm90by5hZGp1c3RJbnRvID0gZnVuY3Rpb24gYWRqdXN0SW50byh0ZW1wb3JhbCkge1xuICAgIHN3aXRjaCAodGhpcy5fb3JkaW5hbCkge1xuICAgICAgY2FzZSAwOlxuICAgICAgICByZXR1cm4gdGVtcG9yYWwud2l0aChDaHJvbm9GaWVsZC5EQVlfT0ZfTU9OVEgsIDEpO1xuXG4gICAgICBjYXNlIDE6XG4gICAgICAgIHJldHVybiB0ZW1wb3JhbC53aXRoKENocm9ub0ZpZWxkLkRBWV9PRl9NT05USCwgdGVtcG9yYWwucmFuZ2UoQ2hyb25vRmllbGQuREFZX09GX01PTlRIKS5tYXhpbXVtKCkpO1xuXG4gICAgICBjYXNlIDI6XG4gICAgICAgIHJldHVybiB0ZW1wb3JhbC53aXRoKENocm9ub0ZpZWxkLkRBWV9PRl9NT05USCwgMSkucGx1cygxLCBDaHJvbm9Vbml0Lk1PTlRIUyk7XG5cbiAgICAgIGNhc2UgMzpcbiAgICAgICAgcmV0dXJuIHRlbXBvcmFsLndpdGgoQ2hyb25vRmllbGQuREFZX09GX1lFQVIsIDEpO1xuXG4gICAgICBjYXNlIDQ6XG4gICAgICAgIHJldHVybiB0ZW1wb3JhbC53aXRoKENocm9ub0ZpZWxkLkRBWV9PRl9ZRUFSLCB0ZW1wb3JhbC5yYW5nZShDaHJvbm9GaWVsZC5EQVlfT0ZfWUVBUikubWF4aW11bSgpKTtcblxuICAgICAgY2FzZSA1OlxuICAgICAgICByZXR1cm4gdGVtcG9yYWwud2l0aChDaHJvbm9GaWVsZC5EQVlfT0ZfWUVBUiwgMSkucGx1cygxLCBDaHJvbm9Vbml0LllFQVJTKTtcbiAgICB9XG5cbiAgICB0aHJvdyBuZXcgSWxsZWdhbFN0YXRlRXhjZXB0aW9uKCdVbnJlYWNoYWJsZScpO1xuICB9O1xuXG4gIHJldHVybiBJbXBsO1xufShUZW1wb3JhbEFkanVzdGVyKTtcblxuSW1wbC5GSVJTVF9EQVlfT0ZfTU9OVEggPSBuZXcgSW1wbCgwKTtcbkltcGwuTEFTVF9EQVlfT0ZfTU9OVEggPSBuZXcgSW1wbCgxKTtcbkltcGwuRklSU1RfREFZX09GX05FWFRfTU9OVEggPSBuZXcgSW1wbCgyKTtcbkltcGwuRklSU1RfREFZX09GX1lFQVIgPSBuZXcgSW1wbCgzKTtcbkltcGwuTEFTVF9EQVlfT0ZfWUVBUiA9IG5ldyBJbXBsKDQpO1xuSW1wbC5GSVJTVF9EQVlfT0ZfTkVYVF9ZRUFSID0gbmV3IEltcGwoNSk7XG5cbnZhciBEYXlPZldlZWtJbk1vbnRoID0gZnVuY3Rpb24gKF9UZW1wb3JhbEFkanVzdGVyMikge1xuICBfaW5oZXJpdHNMb29zZShEYXlPZldlZWtJbk1vbnRoLCBfVGVtcG9yYWxBZGp1c3RlcjIpO1xuXG4gIGZ1bmN0aW9uIERheU9mV2Vla0luTW9udGgob3JkaW5hbCwgZG93KSB7XG4gICAgdmFyIF90aGlzMjtcblxuICAgIF90aGlzMiA9IF9UZW1wb3JhbEFkanVzdGVyMi5jYWxsKHRoaXMpIHx8IHRoaXM7XG4gICAgX3RoaXMyLl9vcmRpbmFsID0gb3JkaW5hbDtcbiAgICBfdGhpczIuX2Rvd1ZhbHVlID0gZG93LnZhbHVlKCk7XG4gICAgcmV0dXJuIF90aGlzMjtcbiAgfVxuXG4gIHZhciBfcHJvdG8yID0gRGF5T2ZXZWVrSW5Nb250aC5wcm90b3R5cGU7XG5cbiAgX3Byb3RvMi5hZGp1c3RJbnRvID0gZnVuY3Rpb24gYWRqdXN0SW50byh0ZW1wb3JhbCkge1xuICAgIGlmICh0aGlzLl9vcmRpbmFsID49IDApIHtcbiAgICAgIHZhciB0ZW1wID0gdGVtcG9yYWwud2l0aChDaHJvbm9GaWVsZC5EQVlfT0ZfTU9OVEgsIDEpO1xuICAgICAgdmFyIGN1ckRvdyA9IHRlbXAuZ2V0KENocm9ub0ZpZWxkLkRBWV9PRl9XRUVLKTtcbiAgICAgIHZhciBkb3dEaWZmID0gTWF0aFV0aWwuaW50TW9kKHRoaXMuX2Rvd1ZhbHVlIC0gY3VyRG93ICsgNywgNyk7XG4gICAgICBkb3dEaWZmICs9ICh0aGlzLl9vcmRpbmFsIC0gMSkgKiA3O1xuICAgICAgcmV0dXJuIHRlbXAucGx1cyhkb3dEaWZmLCBDaHJvbm9Vbml0LkRBWVMpO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgX3RlbXAgPSB0ZW1wb3JhbC53aXRoKENocm9ub0ZpZWxkLkRBWV9PRl9NT05USCwgdGVtcG9yYWwucmFuZ2UoQ2hyb25vRmllbGQuREFZX09GX01PTlRIKS5tYXhpbXVtKCkpO1xuXG4gICAgICB2YXIgX2N1ckRvdyA9IF90ZW1wLmdldChDaHJvbm9GaWVsZC5EQVlfT0ZfV0VFSyk7XG5cbiAgICAgIHZhciBkYXlzRGlmZiA9IHRoaXMuX2Rvd1ZhbHVlIC0gX2N1ckRvdztcbiAgICAgIGRheXNEaWZmID0gZGF5c0RpZmYgPT09IDAgPyAwIDogZGF5c0RpZmYgPiAwID8gZGF5c0RpZmYgLSA3IDogZGF5c0RpZmY7XG4gICAgICBkYXlzRGlmZiAtPSAoLXRoaXMuX29yZGluYWwgLSAxKSAqIDc7XG4gICAgICByZXR1cm4gX3RlbXAucGx1cyhkYXlzRGlmZiwgQ2hyb25vVW5pdC5EQVlTKTtcbiAgICB9XG4gIH07XG5cbiAgcmV0dXJuIERheU9mV2Vla0luTW9udGg7XG59KFRlbXBvcmFsQWRqdXN0ZXIpO1xuXG52YXIgUmVsYXRpdmVEYXlPZldlZWsgPSBmdW5jdGlvbiAoX1RlbXBvcmFsQWRqdXN0ZXIzKSB7XG4gIF9pbmhlcml0c0xvb3NlKFJlbGF0aXZlRGF5T2ZXZWVrLCBfVGVtcG9yYWxBZGp1c3RlcjMpO1xuXG4gIGZ1bmN0aW9uIFJlbGF0aXZlRGF5T2ZXZWVrKHJlbGF0aXZlLCBkYXlPZldlZWspIHtcbiAgICB2YXIgX3RoaXMzO1xuXG4gICAgX3RoaXMzID0gX1RlbXBvcmFsQWRqdXN0ZXIzLmNhbGwodGhpcykgfHwgdGhpcztcbiAgICByZXF1aXJlTm9uTnVsbChkYXlPZldlZWssICdkYXlPZldlZWsnKTtcbiAgICBfdGhpczMuX3JlbGF0aXZlID0gcmVsYXRpdmU7XG4gICAgX3RoaXMzLl9kb3dWYWx1ZSA9IGRheU9mV2Vlay52YWx1ZSgpO1xuICAgIHJldHVybiBfdGhpczM7XG4gIH1cblxuICB2YXIgX3Byb3RvMyA9IFJlbGF0aXZlRGF5T2ZXZWVrLnByb3RvdHlwZTtcblxuICBfcHJvdG8zLmFkanVzdEludG8gPSBmdW5jdGlvbiBhZGp1c3RJbnRvKHRlbXBvcmFsKSB7XG4gICAgdmFyIGNhbERvdyA9IHRlbXBvcmFsLmdldChDaHJvbm9GaWVsZC5EQVlfT0ZfV0VFSyk7XG5cbiAgICBpZiAodGhpcy5fcmVsYXRpdmUgPCAyICYmIGNhbERvdyA9PT0gdGhpcy5fZG93VmFsdWUpIHtcbiAgICAgIHJldHVybiB0ZW1wb3JhbDtcbiAgICB9XG5cbiAgICBpZiAoKHRoaXMuX3JlbGF0aXZlICYgMSkgPT09IDApIHtcbiAgICAgIHZhciBkYXlzRGlmZiA9IGNhbERvdyAtIHRoaXMuX2Rvd1ZhbHVlO1xuICAgICAgcmV0dXJuIHRlbXBvcmFsLnBsdXMoZGF5c0RpZmYgPj0gMCA/IDcgLSBkYXlzRGlmZiA6IC1kYXlzRGlmZiwgQ2hyb25vVW5pdC5EQVlTKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIF9kYXlzRGlmZiA9IHRoaXMuX2Rvd1ZhbHVlIC0gY2FsRG93O1xuXG4gICAgICByZXR1cm4gdGVtcG9yYWwubWludXMoX2RheXNEaWZmID49IDAgPyA3IC0gX2RheXNEaWZmIDogLV9kYXlzRGlmZiwgQ2hyb25vVW5pdC5EQVlTKTtcbiAgICB9XG4gIH07XG5cbiAgcmV0dXJuIFJlbGF0aXZlRGF5T2ZXZWVrO1xufShUZW1wb3JhbEFkanVzdGVyKTtcblxudmFyIElzb0Nocm9ub2xvZ3kgPSBmdW5jdGlvbiAoX0VudW0pIHtcbiAgX2luaGVyaXRzTG9vc2UoSXNvQ2hyb25vbG9neSwgX0VudW0pO1xuXG4gIGZ1bmN0aW9uIElzb0Nocm9ub2xvZ3koKSB7XG4gICAgcmV0dXJuIF9FbnVtLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgfVxuXG4gIElzb0Nocm9ub2xvZ3kuaXNMZWFwWWVhciA9IGZ1bmN0aW9uIGlzTGVhcFllYXIocHJvbGVwdGljWWVhcikge1xuICAgIHJldHVybiAocHJvbGVwdGljWWVhciAmIDMpID09PSAwICYmIChwcm9sZXB0aWNZZWFyICUgMTAwICE9PSAwIHx8IHByb2xlcHRpY1llYXIgJSA0MDAgPT09IDApO1xuICB9O1xuXG4gIHZhciBfcHJvdG8gPSBJc29DaHJvbm9sb2d5LnByb3RvdHlwZTtcblxuICBfcHJvdG8uX3VwZGF0ZVJlc29sdmVNYXAgPSBmdW5jdGlvbiBfdXBkYXRlUmVzb2x2ZU1hcChmaWVsZFZhbHVlcywgZmllbGQsIHZhbHVlKSB7XG4gICAgcmVxdWlyZU5vbk51bGwoZmllbGRWYWx1ZXMsICdmaWVsZFZhbHVlcycpO1xuICAgIHJlcXVpcmVOb25OdWxsKGZpZWxkLCAnZmllbGQnKTtcbiAgICB2YXIgY3VycmVudCA9IGZpZWxkVmFsdWVzLmdldChmaWVsZCk7XG5cbiAgICBpZiAoY3VycmVudCAhPSBudWxsICYmIGN1cnJlbnQgIT09IHZhbHVlKSB7XG4gICAgICB0aHJvdyBuZXcgRGF0ZVRpbWVFeGNlcHRpb24oJ0ludmFsaWQgc3RhdGUsIGZpZWxkOiAnICsgZmllbGQgKyAnICcgKyBjdXJyZW50ICsgJyBjb25mbGljdHMgd2l0aCAnICsgZmllbGQgKyAnICcgKyB2YWx1ZSk7XG4gICAgfVxuXG4gICAgZmllbGRWYWx1ZXMucHV0KGZpZWxkLCB2YWx1ZSk7XG4gIH07XG5cbiAgX3Byb3RvLnJlc29sdmVEYXRlID0gZnVuY3Rpb24gcmVzb2x2ZURhdGUoZmllbGRWYWx1ZXMsIHJlc29sdmVyU3R5bGUpIHtcbiAgICBpZiAoZmllbGRWYWx1ZXMuY29udGFpbnNLZXkoQ2hyb25vRmllbGQuRVBPQ0hfREFZKSkge1xuICAgICAgcmV0dXJuIExvY2FsRGF0ZS5vZkVwb2NoRGF5KGZpZWxkVmFsdWVzLnJlbW92ZShDaHJvbm9GaWVsZC5FUE9DSF9EQVkpKTtcbiAgICB9XG5cbiAgICB2YXIgcHJvbGVwdGljTW9udGggPSBmaWVsZFZhbHVlcy5yZW1vdmUoQ2hyb25vRmllbGQuUFJPTEVQVElDX01PTlRIKTtcblxuICAgIGlmIChwcm9sZXB0aWNNb250aCAhPSBudWxsKSB7XG4gICAgICBpZiAocmVzb2x2ZXJTdHlsZSAhPT0gUmVzb2x2ZXJTdHlsZS5MRU5JRU5UKSB7XG4gICAgICAgIENocm9ub0ZpZWxkLlBST0xFUFRJQ19NT05USC5jaGVja1ZhbGlkVmFsdWUocHJvbGVwdGljTW9udGgpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLl91cGRhdGVSZXNvbHZlTWFwKGZpZWxkVmFsdWVzLCBDaHJvbm9GaWVsZC5NT05USF9PRl9ZRUFSLCBNYXRoVXRpbC5mbG9vck1vZChwcm9sZXB0aWNNb250aCwgMTIpICsgMSk7XG5cbiAgICAgIHRoaXMuX3VwZGF0ZVJlc29sdmVNYXAoZmllbGRWYWx1ZXMsIENocm9ub0ZpZWxkLllFQVIsIE1hdGhVdGlsLmZsb29yRGl2KHByb2xlcHRpY01vbnRoLCAxMikpO1xuICAgIH1cblxuICAgIHZhciB5b2VMb25nID0gZmllbGRWYWx1ZXMucmVtb3ZlKENocm9ub0ZpZWxkLllFQVJfT0ZfRVJBKTtcblxuICAgIGlmICh5b2VMb25nICE9IG51bGwpIHtcbiAgICAgIGlmIChyZXNvbHZlclN0eWxlICE9PSBSZXNvbHZlclN0eWxlLkxFTklFTlQpIHtcbiAgICAgICAgQ2hyb25vRmllbGQuWUVBUl9PRl9FUkEuY2hlY2tWYWxpZFZhbHVlKHlvZUxvbmcpO1xuICAgICAgfVxuXG4gICAgICB2YXIgZXJhID0gZmllbGRWYWx1ZXMucmVtb3ZlKENocm9ub0ZpZWxkLkVSQSk7XG5cbiAgICAgIGlmIChlcmEgPT0gbnVsbCkge1xuICAgICAgICB2YXIgeWVhciA9IGZpZWxkVmFsdWVzLmdldChDaHJvbm9GaWVsZC5ZRUFSKTtcblxuICAgICAgICBpZiAocmVzb2x2ZXJTdHlsZSA9PT0gUmVzb2x2ZXJTdHlsZS5TVFJJQ1QpIHtcbiAgICAgICAgICBpZiAoeWVhciAhPSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLl91cGRhdGVSZXNvbHZlTWFwKGZpZWxkVmFsdWVzLCBDaHJvbm9GaWVsZC5ZRUFSLCB5ZWFyID4gMCA/IHlvZUxvbmcgOiBNYXRoVXRpbC5zYWZlU3VidHJhY3QoMSwgeW9lTG9uZykpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBmaWVsZFZhbHVlcy5wdXQoQ2hyb25vRmllbGQuWUVBUl9PRl9FUkEsIHlvZUxvbmcpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLl91cGRhdGVSZXNvbHZlTWFwKGZpZWxkVmFsdWVzLCBDaHJvbm9GaWVsZC5ZRUFSLCB5ZWFyID09IG51bGwgfHwgeWVhciA+IDAgPyB5b2VMb25nIDogTWF0aFV0aWwuc2FmZVN1YnRyYWN0KDEsIHlvZUxvbmcpKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChlcmEgPT09IDEpIHtcbiAgICAgICAgdGhpcy5fdXBkYXRlUmVzb2x2ZU1hcChmaWVsZFZhbHVlcywgQ2hyb25vRmllbGQuWUVBUiwgeW9lTG9uZyk7XG4gICAgICB9IGVsc2UgaWYgKGVyYSA9PT0gMCkge1xuICAgICAgICB0aGlzLl91cGRhdGVSZXNvbHZlTWFwKGZpZWxkVmFsdWVzLCBDaHJvbm9GaWVsZC5ZRUFSLCBNYXRoVXRpbC5zYWZlU3VidHJhY3QoMSwgeW9lTG9uZykpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IERhdGVUaW1lRXhjZXB0aW9uKCdJbnZhbGlkIHZhbHVlIGZvciBlcmE6ICcgKyBlcmEpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoZmllbGRWYWx1ZXMuY29udGFpbnNLZXkoQ2hyb25vRmllbGQuRVJBKSkge1xuICAgICAgQ2hyb25vRmllbGQuRVJBLmNoZWNrVmFsaWRWYWx1ZShmaWVsZFZhbHVlcy5nZXQoQ2hyb25vRmllbGQuRVJBKSk7XG4gICAgfVxuXG4gICAgaWYgKGZpZWxkVmFsdWVzLmNvbnRhaW5zS2V5KENocm9ub0ZpZWxkLllFQVIpKSB7XG4gICAgICBpZiAoZmllbGRWYWx1ZXMuY29udGFpbnNLZXkoQ2hyb25vRmllbGQuTU9OVEhfT0ZfWUVBUikpIHtcbiAgICAgICAgaWYgKGZpZWxkVmFsdWVzLmNvbnRhaW5zS2V5KENocm9ub0ZpZWxkLkRBWV9PRl9NT05USCkpIHtcbiAgICAgICAgICB2YXIgeSA9IENocm9ub0ZpZWxkLllFQVIuY2hlY2tWYWxpZEludFZhbHVlKGZpZWxkVmFsdWVzLnJlbW92ZShDaHJvbm9GaWVsZC5ZRUFSKSk7XG4gICAgICAgICAgdmFyIG1veSA9IGZpZWxkVmFsdWVzLnJlbW92ZShDaHJvbm9GaWVsZC5NT05USF9PRl9ZRUFSKTtcbiAgICAgICAgICB2YXIgZG9tID0gZmllbGRWYWx1ZXMucmVtb3ZlKENocm9ub0ZpZWxkLkRBWV9PRl9NT05USCk7XG5cbiAgICAgICAgICBpZiAocmVzb2x2ZXJTdHlsZSA9PT0gUmVzb2x2ZXJTdHlsZS5MRU5JRU5UKSB7XG4gICAgICAgICAgICB2YXIgbW9udGhzID0gbW95IC0gMTtcbiAgICAgICAgICAgIHZhciBkYXlzID0gZG9tIC0gMTtcbiAgICAgICAgICAgIHJldHVybiBMb2NhbERhdGUub2YoeSwgMSwgMSkucGx1c01vbnRocyhtb250aHMpLnBsdXNEYXlzKGRheXMpO1xuICAgICAgICAgIH0gZWxzZSBpZiAocmVzb2x2ZXJTdHlsZSA9PT0gUmVzb2x2ZXJTdHlsZS5TTUFSVCkge1xuICAgICAgICAgICAgQ2hyb25vRmllbGQuREFZX09GX01PTlRILmNoZWNrVmFsaWRWYWx1ZShkb20pO1xuXG4gICAgICAgICAgICBpZiAobW95ID09PSA0IHx8IG1veSA9PT0gNiB8fCBtb3kgPT09IDkgfHwgbW95ID09PSAxMSkge1xuICAgICAgICAgICAgICBkb20gPSBNYXRoLm1pbihkb20sIDMwKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAobW95ID09PSAyKSB7XG4gICAgICAgICAgICAgIGRvbSA9IE1hdGgubWluKGRvbSwgTW9udGguRkVCUlVBUlkubGVuZ3RoKFllYXIuaXNMZWFwKHkpKSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBMb2NhbERhdGUub2YoeSwgbW95LCBkb20pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gTG9jYWxEYXRlLm9mKHksIG1veSwgZG9tKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKGZpZWxkVmFsdWVzLmNvbnRhaW5zS2V5KENocm9ub0ZpZWxkLkRBWV9PRl9ZRUFSKSkge1xuICAgICAgICB2YXIgX3kgPSBDaHJvbm9GaWVsZC5ZRUFSLmNoZWNrVmFsaWRJbnRWYWx1ZShmaWVsZFZhbHVlcy5yZW1vdmUoQ2hyb25vRmllbGQuWUVBUikpO1xuXG4gICAgICAgIGlmIChyZXNvbHZlclN0eWxlID09PSBSZXNvbHZlclN0eWxlLkxFTklFTlQpIHtcbiAgICAgICAgICB2YXIgX2RheXMgPSBNYXRoVXRpbC5zYWZlU3VidHJhY3QoZmllbGRWYWx1ZXMucmVtb3ZlKENocm9ub0ZpZWxkLkRBWV9PRl9ZRUFSKSwgMSk7XG5cbiAgICAgICAgICByZXR1cm4gTG9jYWxEYXRlLm9mWWVhckRheShfeSwgMSkucGx1c0RheXMoX2RheXMpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGRveSA9IENocm9ub0ZpZWxkLkRBWV9PRl9ZRUFSLmNoZWNrVmFsaWRJbnRWYWx1ZShmaWVsZFZhbHVlcy5yZW1vdmUoQ2hyb25vRmllbGQuREFZX09GX1lFQVIpKTtcbiAgICAgICAgcmV0dXJuIExvY2FsRGF0ZS5vZlllYXJEYXkoX3ksIGRveSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChmaWVsZFZhbHVlcy5jb250YWluc0tleShDaHJvbm9GaWVsZC5BTElHTkVEX1dFRUtfT0ZfWUVBUikpIHtcbiAgICAgICAgaWYgKGZpZWxkVmFsdWVzLmNvbnRhaW5zS2V5KENocm9ub0ZpZWxkLkFMSUdORURfREFZX09GX1dFRUtfSU5fWUVBUikpIHtcbiAgICAgICAgICB2YXIgX3kyID0gQ2hyb25vRmllbGQuWUVBUi5jaGVja1ZhbGlkSW50VmFsdWUoZmllbGRWYWx1ZXMucmVtb3ZlKENocm9ub0ZpZWxkLllFQVIpKTtcblxuICAgICAgICAgIGlmIChyZXNvbHZlclN0eWxlID09PSBSZXNvbHZlclN0eWxlLkxFTklFTlQpIHtcbiAgICAgICAgICAgIHZhciB3ZWVrcyA9IE1hdGhVdGlsLnNhZmVTdWJ0cmFjdChmaWVsZFZhbHVlcy5yZW1vdmUoQ2hyb25vRmllbGQuQUxJR05FRF9XRUVLX09GX1lFQVIpLCAxKTtcblxuICAgICAgICAgICAgdmFyIF9kYXlzMiA9IE1hdGhVdGlsLnNhZmVTdWJ0cmFjdChmaWVsZFZhbHVlcy5yZW1vdmUoQ2hyb25vRmllbGQuQUxJR05FRF9EQVlfT0ZfV0VFS19JTl9ZRUFSKSwgMSk7XG5cbiAgICAgICAgICAgIHJldHVybiBMb2NhbERhdGUub2YoX3kyLCAxLCAxKS5wbHVzV2Vla3Mod2Vla3MpLnBsdXNEYXlzKF9kYXlzMik7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFyIGF3ID0gQ2hyb25vRmllbGQuQUxJR05FRF9XRUVLX09GX1lFQVIuY2hlY2tWYWxpZEludFZhbHVlKGZpZWxkVmFsdWVzLnJlbW92ZShDaHJvbm9GaWVsZC5BTElHTkVEX1dFRUtfT0ZfWUVBUikpO1xuICAgICAgICAgIHZhciBhZCA9IENocm9ub0ZpZWxkLkFMSUdORURfREFZX09GX1dFRUtfSU5fWUVBUi5jaGVja1ZhbGlkSW50VmFsdWUoZmllbGRWYWx1ZXMucmVtb3ZlKENocm9ub0ZpZWxkLkFMSUdORURfREFZX09GX1dFRUtfSU5fWUVBUikpO1xuICAgICAgICAgIHZhciBkYXRlID0gTG9jYWxEYXRlLm9mKF95MiwgMSwgMSkucGx1c0RheXMoKGF3IC0gMSkgKiA3ICsgKGFkIC0gMSkpO1xuXG4gICAgICAgICAgaWYgKHJlc29sdmVyU3R5bGUgPT09IFJlc29sdmVyU3R5bGUuU1RSSUNUICYmIGRhdGUuZ2V0KENocm9ub0ZpZWxkLllFQVIpICE9PSBfeTIpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBEYXRlVGltZUV4Y2VwdGlvbignU3RyaWN0IG1vZGUgcmVqZWN0ZWQgZGF0ZSBwYXJzZWQgdG8gYSBkaWZmZXJlbnQgeWVhcicpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiBkYXRlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGZpZWxkVmFsdWVzLmNvbnRhaW5zS2V5KENocm9ub0ZpZWxkLkRBWV9PRl9XRUVLKSkge1xuICAgICAgICAgIHZhciBfeTMgPSBDaHJvbm9GaWVsZC5ZRUFSLmNoZWNrVmFsaWRJbnRWYWx1ZShmaWVsZFZhbHVlcy5yZW1vdmUoQ2hyb25vRmllbGQuWUVBUikpO1xuXG4gICAgICAgICAgaWYgKHJlc29sdmVyU3R5bGUgPT09IFJlc29sdmVyU3R5bGUuTEVOSUVOVCkge1xuICAgICAgICAgICAgdmFyIF93ZWVrcyA9IE1hdGhVdGlsLnNhZmVTdWJ0cmFjdChmaWVsZFZhbHVlcy5yZW1vdmUoQ2hyb25vRmllbGQuQUxJR05FRF9XRUVLX09GX1lFQVIpLCAxKTtcblxuICAgICAgICAgICAgdmFyIF9kYXlzMyA9IE1hdGhVdGlsLnNhZmVTdWJ0cmFjdChmaWVsZFZhbHVlcy5yZW1vdmUoQ2hyb25vRmllbGQuREFZX09GX1dFRUspLCAxKTtcblxuICAgICAgICAgICAgcmV0dXJuIExvY2FsRGF0ZS5vZihfeTMsIDEsIDEpLnBsdXNXZWVrcyhfd2Vla3MpLnBsdXNEYXlzKF9kYXlzMyk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFyIF9hdyA9IENocm9ub0ZpZWxkLkFMSUdORURfV0VFS19PRl9ZRUFSLmNoZWNrVmFsaWRJbnRWYWx1ZShmaWVsZFZhbHVlcy5yZW1vdmUoQ2hyb25vRmllbGQuQUxJR05FRF9XRUVLX09GX1lFQVIpKTtcblxuICAgICAgICAgIHZhciBkb3cgPSBDaHJvbm9GaWVsZC5EQVlfT0ZfV0VFSy5jaGVja1ZhbGlkSW50VmFsdWUoZmllbGRWYWx1ZXMucmVtb3ZlKENocm9ub0ZpZWxkLkRBWV9PRl9XRUVLKSk7XG5cbiAgICAgICAgICB2YXIgX2RhdGUgPSBMb2NhbERhdGUub2YoX3kzLCAxLCAxKS5wbHVzV2Vla3MoX2F3IC0gMSkud2l0aChUZW1wb3JhbEFkanVzdGVycy5uZXh0T3JTYW1lKERheU9mV2Vlay5vZihkb3cpKSk7XG5cbiAgICAgICAgICBpZiAocmVzb2x2ZXJTdHlsZSA9PT0gUmVzb2x2ZXJTdHlsZS5TVFJJQ1QgJiYgX2RhdGUuZ2V0KENocm9ub0ZpZWxkLllFQVIpICE9PSBfeTMpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBEYXRlVGltZUV4Y2VwdGlvbignU3RyaWN0IG1vZGUgcmVqZWN0ZWQgZGF0ZSBwYXJzZWQgdG8gYSBkaWZmZXJlbnQgbW9udGgnKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gX2RhdGU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gbnVsbDtcbiAgfTtcblxuICBfcHJvdG8uZGF0ZSA9IGZ1bmN0aW9uIGRhdGUodGVtcG9yYWwpIHtcbiAgICByZXR1cm4gTG9jYWxEYXRlLmZyb20odGVtcG9yYWwpO1xuICB9O1xuXG4gIHJldHVybiBJc29DaHJvbm9sb2d5O1xufShFbnVtKTtcbmZ1bmN0aW9uIF9pbml0JGUoKSB7XG4gIElzb0Nocm9ub2xvZ3kuSU5TVEFOQ0UgPSBuZXcgSXNvQ2hyb25vbG9neSgnSXNvQ2hyb25vbG9neScpO1xufVxuXG52YXIgT2Zmc2V0VGltZSA9IGZ1bmN0aW9uIChfRGVmYXVsdEludGVyZmFjZVRlbXApIHtcbiAgX2luaGVyaXRzTG9vc2UoT2Zmc2V0VGltZSwgX0RlZmF1bHRJbnRlcmZhY2VUZW1wKTtcblxuICBPZmZzZXRUaW1lLmZyb20gPSBmdW5jdGlvbiBmcm9tKHRlbXBvcmFsKSB7XG4gICAgcmVxdWlyZU5vbk51bGwodGVtcG9yYWwsICd0ZW1wb3JhbCcpO1xuXG4gICAgaWYgKHRlbXBvcmFsIGluc3RhbmNlb2YgT2Zmc2V0VGltZSkge1xuICAgICAgcmV0dXJuIHRlbXBvcmFsO1xuICAgIH0gZWxzZSBpZiAodGVtcG9yYWwgaW5zdGFuY2VvZiBPZmZzZXREYXRlVGltZSkge1xuICAgICAgcmV0dXJuIHRlbXBvcmFsLnRvT2Zmc2V0VGltZSgpO1xuICAgIH1cblxuICAgIHRyeSB7XG4gICAgICB2YXIgdGltZSA9IExvY2FsVGltZS5mcm9tKHRlbXBvcmFsKTtcbiAgICAgIHZhciBvZmZzZXQgPSBab25lT2Zmc2V0LmZyb20odGVtcG9yYWwpO1xuICAgICAgcmV0dXJuIG5ldyBPZmZzZXRUaW1lKHRpbWUsIG9mZnNldCk7XG4gICAgfSBjYXRjaCAoZXgpIHtcbiAgICAgIHRocm93IG5ldyBEYXRlVGltZUV4Y2VwdGlvbihcIlVuYWJsZSB0byBvYnRhaW4gT2Zmc2V0VGltZSBUZW1wb3JhbEFjY2Vzc29yOiBcIiArIHRlbXBvcmFsICsgXCIsIHR5cGUgXCIgKyAodGVtcG9yYWwuY29uc3RydWN0b3IgIT0gbnVsbCA/IHRlbXBvcmFsLmNvbnN0cnVjdG9yLm5hbWUgOiAnJykpO1xuICAgIH1cbiAgfTtcblxuICBPZmZzZXRUaW1lLm5vdyA9IGZ1bmN0aW9uIG5vdyhjbG9ja09yWm9uZSkge1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm4gT2Zmc2V0VGltZS5fbm93KENsb2NrLnN5c3RlbURlZmF1bHRab25lKCkpO1xuICAgIH0gZWxzZSBpZiAoY2xvY2tPclpvbmUgaW5zdGFuY2VvZiBDbG9jaykge1xuICAgICAgcmV0dXJuIE9mZnNldFRpbWUuX25vdyhjbG9ja09yWm9uZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBPZmZzZXRUaW1lLl9ub3coQ2xvY2suc3lzdGVtKGNsb2NrT3Jab25lKSk7XG4gICAgfVxuICB9O1xuXG4gIE9mZnNldFRpbWUuX25vdyA9IGZ1bmN0aW9uIF9ub3coY2xvY2spIHtcbiAgICByZXF1aXJlTm9uTnVsbChjbG9jaywgJ2Nsb2NrJyk7XG4gICAgdmFyIG5vdyA9IGNsb2NrLmluc3RhbnQoKTtcbiAgICByZXR1cm4gT2Zmc2V0VGltZS5vZkluc3RhbnQobm93LCBjbG9jay56b25lKCkucnVsZXMoKS5vZmZzZXQobm93KSk7XG4gIH07XG5cbiAgT2Zmc2V0VGltZS5vZiA9IGZ1bmN0aW9uIG9mKCkge1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoIDw9IDIpIHtcbiAgICAgIHJldHVybiBPZmZzZXRUaW1lLm9mVGltZUFuZE9mZnNldC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gT2Zmc2V0VGltZS5vZk51bWJlcnMuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gIH07XG5cbiAgT2Zmc2V0VGltZS5vZk51bWJlcnMgPSBmdW5jdGlvbiBvZk51bWJlcnMoaG91ciwgbWludXRlLCBzZWNvbmQsIG5hbm9PZlNlY29uZCwgb2Zmc2V0KSB7XG4gICAgdmFyIHRpbWUgPSBMb2NhbFRpbWUub2YoaG91ciwgbWludXRlLCBzZWNvbmQsIG5hbm9PZlNlY29uZCk7XG4gICAgcmV0dXJuIG5ldyBPZmZzZXRUaW1lKHRpbWUsIG9mZnNldCk7XG4gIH07XG5cbiAgT2Zmc2V0VGltZS5vZlRpbWVBbmRPZmZzZXQgPSBmdW5jdGlvbiBvZlRpbWVBbmRPZmZzZXQodGltZSwgb2Zmc2V0KSB7XG4gICAgcmV0dXJuIG5ldyBPZmZzZXRUaW1lKHRpbWUsIG9mZnNldCk7XG4gIH07XG5cbiAgT2Zmc2V0VGltZS5vZkluc3RhbnQgPSBmdW5jdGlvbiBvZkluc3RhbnQoaW5zdGFudCwgem9uZSkge1xuICAgIHJlcXVpcmVOb25OdWxsKGluc3RhbnQsICdpbnN0YW50Jyk7XG4gICAgcmVxdWlyZUluc3RhbmNlKGluc3RhbnQsIEluc3RhbnQsICdpbnN0YW50Jyk7XG4gICAgcmVxdWlyZU5vbk51bGwoem9uZSwgJ3pvbmUnKTtcbiAgICByZXF1aXJlSW5zdGFuY2Uoem9uZSwgWm9uZUlkLCAnem9uZScpO1xuICAgIHZhciBydWxlcyA9IHpvbmUucnVsZXMoKTtcbiAgICB2YXIgb2Zmc2V0ID0gcnVsZXMub2Zmc2V0KGluc3RhbnQpO1xuICAgIHZhciBzZWNzT2ZEYXkgPSBpbnN0YW50LmVwb2NoU2Vjb25kKCkgJSBMb2NhbFRpbWUuU0VDT05EU19QRVJfREFZO1xuICAgIHNlY3NPZkRheSA9IChzZWNzT2ZEYXkgKyBvZmZzZXQudG90YWxTZWNvbmRzKCkpICUgTG9jYWxUaW1lLlNFQ09ORFNfUEVSX0RBWTtcblxuICAgIGlmIChzZWNzT2ZEYXkgPCAwKSB7XG4gICAgICBzZWNzT2ZEYXkgKz0gTG9jYWxUaW1lLlNFQ09ORFNfUEVSX0RBWTtcbiAgICB9XG5cbiAgICB2YXIgdGltZSA9IExvY2FsVGltZS5vZlNlY29uZE9mRGF5KHNlY3NPZkRheSwgaW5zdGFudC5uYW5vKCkpO1xuICAgIHJldHVybiBuZXcgT2Zmc2V0VGltZSh0aW1lLCBvZmZzZXQpO1xuICB9O1xuXG4gIE9mZnNldFRpbWUucGFyc2UgPSBmdW5jdGlvbiBwYXJzZSh0ZXh0LCBmb3JtYXR0ZXIpIHtcbiAgICBpZiAoZm9ybWF0dGVyID09PSB2b2lkIDApIHtcbiAgICAgIGZvcm1hdHRlciA9IERhdGVUaW1lRm9ybWF0dGVyLklTT19PRkZTRVRfVElNRTtcbiAgICB9XG5cbiAgICByZXF1aXJlTm9uTnVsbChmb3JtYXR0ZXIsICdmb3JtYXR0ZXInKTtcbiAgICByZXR1cm4gZm9ybWF0dGVyLnBhcnNlKHRleHQsIE9mZnNldFRpbWUuRlJPTSk7XG4gIH07XG5cbiAgZnVuY3Rpb24gT2Zmc2V0VGltZSh0aW1lLCBvZmZzZXQpIHtcbiAgICB2YXIgX3RoaXM7XG5cbiAgICBfdGhpcyA9IF9EZWZhdWx0SW50ZXJmYWNlVGVtcC5jYWxsKHRoaXMpIHx8IHRoaXM7XG4gICAgcmVxdWlyZU5vbk51bGwodGltZSwgJ3RpbWUnKTtcbiAgICByZXF1aXJlSW5zdGFuY2UodGltZSwgTG9jYWxUaW1lLCAndGltZScpO1xuICAgIHJlcXVpcmVOb25OdWxsKG9mZnNldCwgJ29mZnNldCcpO1xuICAgIHJlcXVpcmVJbnN0YW5jZShvZmZzZXQsIFpvbmVPZmZzZXQsICdvZmZzZXQnKTtcbiAgICBfdGhpcy5fdGltZSA9IHRpbWU7XG4gICAgX3RoaXMuX29mZnNldCA9IG9mZnNldDtcbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cblxuICB2YXIgX3Byb3RvID0gT2Zmc2V0VGltZS5wcm90b3R5cGU7XG5cbiAgX3Byb3RvLmFkanVzdEludG8gPSBmdW5jdGlvbiBhZGp1c3RJbnRvKHRlbXBvcmFsKSB7XG4gICAgcmV0dXJuIHRlbXBvcmFsLndpdGgoQ2hyb25vRmllbGQuTkFOT19PRl9EQVksIHRoaXMuX3RpbWUudG9OYW5vT2ZEYXkoKSkud2l0aChDaHJvbm9GaWVsZC5PRkZTRVRfU0VDT05EUywgdGhpcy5vZmZzZXQoKS50b3RhbFNlY29uZHMoKSk7XG4gIH07XG5cbiAgX3Byb3RvLmF0RGF0ZSA9IGZ1bmN0aW9uIGF0RGF0ZShkYXRlKSB7XG4gICAgcmV0dXJuIE9mZnNldERhdGVUaW1lLm9mKGRhdGUsIHRoaXMuX3RpbWUsIHRoaXMuX29mZnNldCk7XG4gIH07XG5cbiAgX3Byb3RvLmZvcm1hdCA9IGZ1bmN0aW9uIGZvcm1hdChmb3JtYXR0ZXIpIHtcbiAgICByZXF1aXJlTm9uTnVsbChmb3JtYXR0ZXIsICdmb3JtYXR0ZXInKTtcbiAgICByZXR1cm4gZm9ybWF0dGVyLmZvcm1hdCh0aGlzLCBPZmZzZXRUaW1lLkZST00pO1xuICB9O1xuXG4gIF9wcm90by5nZXQgPSBmdW5jdGlvbiBnZXQoZmllbGQpIHtcbiAgICByZXR1cm4gX0RlZmF1bHRJbnRlcmZhY2VUZW1wLnByb3RvdHlwZS5nZXQuY2FsbCh0aGlzLCBmaWVsZCk7XG4gIH07XG5cbiAgX3Byb3RvLmdldExvbmcgPSBmdW5jdGlvbiBnZXRMb25nKGZpZWxkKSB7XG4gICAgaWYgKGZpZWxkIGluc3RhbmNlb2YgQ2hyb25vRmllbGQpIHtcbiAgICAgIGlmIChmaWVsZCA9PT0gQ2hyb25vRmllbGQuT0ZGU0VUX1NFQ09ORFMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX29mZnNldC50b3RhbFNlY29uZHMoKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXMuX3RpbWUuZ2V0TG9uZyhmaWVsZCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZpZWxkLmdldEZyb20odGhpcyk7XG4gIH07XG5cbiAgX3Byb3RvLmhvdXIgPSBmdW5jdGlvbiBob3VyKCkge1xuICAgIHJldHVybiB0aGlzLl90aW1lLmhvdXIoKTtcbiAgfTtcblxuICBfcHJvdG8ubWludXRlID0gZnVuY3Rpb24gbWludXRlKCkge1xuICAgIHJldHVybiB0aGlzLl90aW1lLm1pbnV0ZSgpO1xuICB9O1xuXG4gIF9wcm90by5zZWNvbmQgPSBmdW5jdGlvbiBzZWNvbmQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3RpbWUuc2Vjb25kKCk7XG4gIH07XG5cbiAgX3Byb3RvLm5hbm8gPSBmdW5jdGlvbiBuYW5vKCkge1xuICAgIHJldHVybiB0aGlzLl90aW1lLm5hbm8oKTtcbiAgfTtcblxuICBfcHJvdG8ub2Zmc2V0ID0gZnVuY3Rpb24gb2Zmc2V0KCkge1xuICAgIHJldHVybiB0aGlzLl9vZmZzZXQ7XG4gIH07XG5cbiAgX3Byb3RvLmlzQWZ0ZXIgPSBmdW5jdGlvbiBpc0FmdGVyKG90aGVyKSB7XG4gICAgcmVxdWlyZU5vbk51bGwob3RoZXIsICdvdGhlcicpO1xuICAgIHJldHVybiB0aGlzLl90b0Vwb2NoTmFubygpID4gb3RoZXIuX3RvRXBvY2hOYW5vKCk7XG4gIH07XG5cbiAgX3Byb3RvLmlzQmVmb3JlID0gZnVuY3Rpb24gaXNCZWZvcmUob3RoZXIpIHtcbiAgICByZXF1aXJlTm9uTnVsbChvdGhlciwgJ290aGVyJyk7XG4gICAgcmV0dXJuIHRoaXMuX3RvRXBvY2hOYW5vKCkgPCBvdGhlci5fdG9FcG9jaE5hbm8oKTtcbiAgfTtcblxuICBfcHJvdG8uaXNFcXVhbCA9IGZ1bmN0aW9uIGlzRXF1YWwob3RoZXIpIHtcbiAgICByZXF1aXJlTm9uTnVsbChvdGhlciwgJ290aGVyJyk7XG4gICAgcmV0dXJuIHRoaXMuX3RvRXBvY2hOYW5vKCkgPT09IG90aGVyLl90b0Vwb2NoTmFubygpO1xuICB9O1xuXG4gIF9wcm90by5pc1N1cHBvcnRlZCA9IGZ1bmN0aW9uIGlzU3VwcG9ydGVkKGZpZWxkT3JVbml0KSB7XG4gICAgaWYgKGZpZWxkT3JVbml0IGluc3RhbmNlb2YgQ2hyb25vRmllbGQpIHtcbiAgICAgIHJldHVybiBmaWVsZE9yVW5pdC5pc1RpbWVCYXNlZCgpIHx8IGZpZWxkT3JVbml0ID09PSBDaHJvbm9GaWVsZC5PRkZTRVRfU0VDT05EUztcbiAgICB9IGVsc2UgaWYgKGZpZWxkT3JVbml0IGluc3RhbmNlb2YgQ2hyb25vVW5pdCkge1xuICAgICAgcmV0dXJuIGZpZWxkT3JVbml0LmlzVGltZUJhc2VkKCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZpZWxkT3JVbml0ICE9IG51bGwgJiYgZmllbGRPclVuaXQuaXNTdXBwb3J0ZWRCeSh0aGlzKTtcbiAgfTtcblxuICBfcHJvdG8ubWludXNIb3VycyA9IGZ1bmN0aW9uIG1pbnVzSG91cnMoaG91cnMpIHtcbiAgICByZXR1cm4gdGhpcy5fd2l0aExvY2FsVGltZU9mZnNldCh0aGlzLl90aW1lLm1pbnVzSG91cnMoaG91cnMpLCB0aGlzLl9vZmZzZXQpO1xuICB9O1xuXG4gIF9wcm90by5taW51c01pbnV0ZXMgPSBmdW5jdGlvbiBtaW51c01pbnV0ZXMobWludXRlcykge1xuICAgIHJldHVybiB0aGlzLl93aXRoTG9jYWxUaW1lT2Zmc2V0KHRoaXMuX3RpbWUubWludXNNaW51dGVzKG1pbnV0ZXMpLCB0aGlzLl9vZmZzZXQpO1xuICB9O1xuXG4gIF9wcm90by5taW51c1NlY29uZHMgPSBmdW5jdGlvbiBtaW51c1NlY29uZHMoc2Vjb25kcykge1xuICAgIHJldHVybiB0aGlzLl93aXRoTG9jYWxUaW1lT2Zmc2V0KHRoaXMuX3RpbWUubWludXNTZWNvbmRzKHNlY29uZHMpLCB0aGlzLl9vZmZzZXQpO1xuICB9O1xuXG4gIF9wcm90by5taW51c05hbm9zID0gZnVuY3Rpb24gbWludXNOYW5vcyhuYW5vcykge1xuICAgIHJldHVybiB0aGlzLl93aXRoTG9jYWxUaW1lT2Zmc2V0KHRoaXMuX3RpbWUubWludXNOYW5vcyhuYW5vcyksIHRoaXMuX29mZnNldCk7XG4gIH07XG5cbiAgX3Byb3RvLm1pbnVzQW1vdW50ID0gZnVuY3Rpb24gbWludXNBbW91bnQoYW1vdW50KSB7XG4gICAgcmVxdWlyZU5vbk51bGwoYW1vdW50KTtcbiAgICByZXR1cm4gYW1vdW50LnN1YnRyYWN0RnJvbSh0aGlzKTtcbiAgfTtcblxuICBfcHJvdG8ubWludXNBbW91bnRVbml0ID0gZnVuY3Rpb24gbWludXNBbW91bnRVbml0KGFtb3VudFRvU3VidHJhY3QsIHVuaXQpIHtcbiAgICByZXR1cm4gdGhpcy5wbHVzKC0xICogYW1vdW50VG9TdWJ0cmFjdCwgdW5pdCk7XG4gIH07XG5cbiAgX3Byb3RvLnBsdXNBbW91bnQgPSBmdW5jdGlvbiBwbHVzQW1vdW50KGFtb3VudCkge1xuICAgIHJlcXVpcmVOb25OdWxsKGFtb3VudCk7XG4gICAgcmV0dXJuIGFtb3VudC5hZGRUbyh0aGlzKTtcbiAgfTtcblxuICBfcHJvdG8ucGx1c0Ftb3VudFVuaXQgPSBmdW5jdGlvbiBwbHVzQW1vdW50VW5pdChhbW91bnRUb0FkZCwgdW5pdCkge1xuICAgIGlmICh1bml0IGluc3RhbmNlb2YgQ2hyb25vVW5pdCkge1xuICAgICAgcmV0dXJuIHRoaXMuX3dpdGhMb2NhbFRpbWVPZmZzZXQodGhpcy5fdGltZS5wbHVzKGFtb3VudFRvQWRkLCB1bml0KSwgdGhpcy5fb2Zmc2V0KTtcbiAgICB9XG5cbiAgICByZXR1cm4gdW5pdC5hZGRUbyh0aGlzLCBhbW91bnRUb0FkZCk7XG4gIH07XG5cbiAgX3Byb3RvLnBsdXNIb3VycyA9IGZ1bmN0aW9uIHBsdXNIb3Vycyhob3Vycykge1xuICAgIHJldHVybiB0aGlzLl93aXRoTG9jYWxUaW1lT2Zmc2V0KHRoaXMuX3RpbWUucGx1c0hvdXJzKGhvdXJzKSwgdGhpcy5fb2Zmc2V0KTtcbiAgfTtcblxuICBfcHJvdG8ucGx1c01pbnV0ZXMgPSBmdW5jdGlvbiBwbHVzTWludXRlcyhtaW51dGVzKSB7XG4gICAgcmV0dXJuIHRoaXMuX3dpdGhMb2NhbFRpbWVPZmZzZXQodGhpcy5fdGltZS5wbHVzTWludXRlcyhtaW51dGVzKSwgdGhpcy5fb2Zmc2V0KTtcbiAgfTtcblxuICBfcHJvdG8ucGx1c1NlY29uZHMgPSBmdW5jdGlvbiBwbHVzU2Vjb25kcyhzZWNvbmRzKSB7XG4gICAgcmV0dXJuIHRoaXMuX3dpdGhMb2NhbFRpbWVPZmZzZXQodGhpcy5fdGltZS5wbHVzU2Vjb25kcyhzZWNvbmRzKSwgdGhpcy5fb2Zmc2V0KTtcbiAgfTtcblxuICBfcHJvdG8ucGx1c05hbm9zID0gZnVuY3Rpb24gcGx1c05hbm9zKG5hbm9zKSB7XG4gICAgcmV0dXJuIHRoaXMuX3dpdGhMb2NhbFRpbWVPZmZzZXQodGhpcy5fdGltZS5wbHVzTmFub3MobmFub3MpLCB0aGlzLl9vZmZzZXQpO1xuICB9O1xuXG4gIF9wcm90by5xdWVyeSA9IGZ1bmN0aW9uIHF1ZXJ5KF9xdWVyeSkge1xuICAgIHJlcXVpcmVOb25OdWxsKF9xdWVyeSwgJ3F1ZXJ5Jyk7XG5cbiAgICBpZiAoX3F1ZXJ5ID09PSBUZW1wb3JhbFF1ZXJpZXMucHJlY2lzaW9uKCkpIHtcbiAgICAgIHJldHVybiBDaHJvbm9Vbml0Lk5BTk9TO1xuICAgIH0gZWxzZSBpZiAoX3F1ZXJ5ID09PSBUZW1wb3JhbFF1ZXJpZXMub2Zmc2V0KCkgfHwgX3F1ZXJ5ID09PSBUZW1wb3JhbFF1ZXJpZXMuem9uZSgpKSB7XG4gICAgICByZXR1cm4gdGhpcy5vZmZzZXQoKTtcbiAgICB9IGVsc2UgaWYgKF9xdWVyeSA9PT0gVGVtcG9yYWxRdWVyaWVzLmxvY2FsVGltZSgpKSB7XG4gICAgICByZXR1cm4gdGhpcy5fdGltZTtcbiAgICB9IGVsc2UgaWYgKF9xdWVyeSA9PT0gVGVtcG9yYWxRdWVyaWVzLmNocm9ub2xvZ3koKSB8fCBfcXVlcnkgPT09IFRlbXBvcmFsUXVlcmllcy5sb2NhbERhdGUoKSB8fCBfcXVlcnkgPT09IFRlbXBvcmFsUXVlcmllcy56b25lSWQoKSkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgcmV0dXJuIF9EZWZhdWx0SW50ZXJmYWNlVGVtcC5wcm90b3R5cGUucXVlcnkuY2FsbCh0aGlzLCBfcXVlcnkpO1xuICB9O1xuXG4gIF9wcm90by5yYW5nZSA9IGZ1bmN0aW9uIHJhbmdlKGZpZWxkKSB7XG4gICAgaWYgKGZpZWxkIGluc3RhbmNlb2YgQ2hyb25vRmllbGQpIHtcbiAgICAgIGlmIChmaWVsZCA9PT0gQ2hyb25vRmllbGQuT0ZGU0VUX1NFQ09ORFMpIHtcbiAgICAgICAgcmV0dXJuIGZpZWxkLnJhbmdlKCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzLl90aW1lLnJhbmdlKGZpZWxkKTtcbiAgICB9XG5cbiAgICByZXR1cm4gZmllbGQucmFuZ2VSZWZpbmVkQnkodGhpcyk7XG4gIH07XG5cbiAgX3Byb3RvLnRvTG9jYWxUaW1lID0gZnVuY3Rpb24gdG9Mb2NhbFRpbWUoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3RpbWU7XG4gIH07XG5cbiAgX3Byb3RvLnRydW5jYXRlZFRvID0gZnVuY3Rpb24gdHJ1bmNhdGVkVG8odW5pdCkge1xuICAgIHJldHVybiB0aGlzLl93aXRoTG9jYWxUaW1lT2Zmc2V0KHRoaXMuX3RpbWUudHJ1bmNhdGVkVG8odW5pdCksIHRoaXMuX29mZnNldCk7XG4gIH07XG5cbiAgX3Byb3RvLnVudGlsID0gZnVuY3Rpb24gdW50aWwoZW5kRXhjbHVzaXZlLCB1bml0KSB7XG4gICAgcmVxdWlyZU5vbk51bGwoZW5kRXhjbHVzaXZlLCAnZW5kRXhjbHVzaXZlJyk7XG4gICAgcmVxdWlyZU5vbk51bGwodW5pdCwgJ3VuaXQnKTtcbiAgICB2YXIgZW5kID0gT2Zmc2V0VGltZS5mcm9tKGVuZEV4Y2x1c2l2ZSk7XG5cbiAgICBpZiAodW5pdCBpbnN0YW5jZW9mIENocm9ub1VuaXQpIHtcbiAgICAgIHZhciBuYW5vc1VudGlsID0gZW5kLl90b0Vwb2NoTmFubygpIC0gdGhpcy5fdG9FcG9jaE5hbm8oKTtcblxuICAgICAgc3dpdGNoICh1bml0KSB7XG4gICAgICAgIGNhc2UgQ2hyb25vVW5pdC5OQU5PUzpcbiAgICAgICAgICByZXR1cm4gbmFub3NVbnRpbDtcblxuICAgICAgICBjYXNlIENocm9ub1VuaXQuTUlDUk9TOlxuICAgICAgICAgIHJldHVybiBNYXRoLmZsb29yKG5hbm9zVW50aWwgLyAxMDAwKTtcblxuICAgICAgICBjYXNlIENocm9ub1VuaXQuTUlMTElTOlxuICAgICAgICAgIHJldHVybiBNYXRoLmZsb29yKG5hbm9zVW50aWwgLyAxMDAwMDAwKTtcblxuICAgICAgICBjYXNlIENocm9ub1VuaXQuU0VDT05EUzpcbiAgICAgICAgICByZXR1cm4gTWF0aC5mbG9vcihuYW5vc1VudGlsIC8gTG9jYWxUaW1lLk5BTk9TX1BFUl9TRUNPTkQpO1xuXG4gICAgICAgIGNhc2UgQ2hyb25vVW5pdC5NSU5VVEVTOlxuICAgICAgICAgIHJldHVybiBNYXRoLmZsb29yKG5hbm9zVW50aWwgLyBMb2NhbFRpbWUuTkFOT1NfUEVSX01JTlVURSk7XG5cbiAgICAgICAgY2FzZSBDaHJvbm9Vbml0LkhPVVJTOlxuICAgICAgICAgIHJldHVybiBNYXRoLmZsb29yKG5hbm9zVW50aWwgLyBMb2NhbFRpbWUuTkFOT1NfUEVSX0hPVVIpO1xuXG4gICAgICAgIGNhc2UgQ2hyb25vVW5pdC5IQUxGX0RBWVM6XG4gICAgICAgICAgcmV0dXJuIE1hdGguZmxvb3IobmFub3NVbnRpbCAvICgxMiAqIExvY2FsVGltZS5OQU5PU19QRVJfSE9VUikpO1xuICAgICAgfVxuXG4gICAgICB0aHJvdyBuZXcgVW5zdXBwb3J0ZWRUZW1wb3JhbFR5cGVFeGNlcHRpb24oJ1Vuc3VwcG9ydGVkIHVuaXQ6ICcgKyB1bml0KTtcbiAgICB9XG5cbiAgICByZXR1cm4gdW5pdC5iZXR3ZWVuKHRoaXMsIGVuZCk7XG4gIH07XG5cbiAgX3Byb3RvLndpdGhIb3VyID0gZnVuY3Rpb24gd2l0aEhvdXIoaG91cikge1xuICAgIHJldHVybiB0aGlzLl93aXRoTG9jYWxUaW1lT2Zmc2V0KHRoaXMuX3RpbWUud2l0aEhvdXIoaG91ciksIHRoaXMuX29mZnNldCk7XG4gIH07XG5cbiAgX3Byb3RvLndpdGhNaW51dGUgPSBmdW5jdGlvbiB3aXRoTWludXRlKG1pbnV0ZSkge1xuICAgIHJldHVybiB0aGlzLl93aXRoTG9jYWxUaW1lT2Zmc2V0KHRoaXMuX3RpbWUud2l0aE1pbnV0ZShtaW51dGUpLCB0aGlzLl9vZmZzZXQpO1xuICB9O1xuXG4gIF9wcm90by53aXRoU2Vjb25kID0gZnVuY3Rpb24gd2l0aFNlY29uZChzZWNvbmQpIHtcbiAgICByZXR1cm4gdGhpcy5fd2l0aExvY2FsVGltZU9mZnNldCh0aGlzLl90aW1lLndpdGhTZWNvbmQoc2Vjb25kKSwgdGhpcy5fb2Zmc2V0KTtcbiAgfTtcblxuICBfcHJvdG8ud2l0aE5hbm8gPSBmdW5jdGlvbiB3aXRoTmFubyhuYW5vKSB7XG4gICAgcmV0dXJuIHRoaXMuX3dpdGhMb2NhbFRpbWVPZmZzZXQodGhpcy5fdGltZS53aXRoTmFubyhuYW5vKSwgdGhpcy5fb2Zmc2V0KTtcbiAgfTtcblxuICBfcHJvdG8ud2l0aE9mZnNldFNhbWVJbnN0YW50ID0gZnVuY3Rpb24gd2l0aE9mZnNldFNhbWVJbnN0YW50KG9mZnNldCkge1xuICAgIHJlcXVpcmVOb25OdWxsKG9mZnNldCwgJ29mZnNldCcpO1xuXG4gICAgaWYgKG9mZnNldC5lcXVhbHModGhpcy5fb2Zmc2V0KSkge1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgdmFyIGRpZmZlcmVuY2UgPSBvZmZzZXQudG90YWxTZWNvbmRzKCkgLSB0aGlzLl9vZmZzZXQudG90YWxTZWNvbmRzKCk7XG5cbiAgICB2YXIgYWRqdXN0ZWQgPSB0aGlzLl90aW1lLnBsdXNTZWNvbmRzKGRpZmZlcmVuY2UpO1xuXG4gICAgcmV0dXJuIG5ldyBPZmZzZXRUaW1lKGFkanVzdGVkLCBvZmZzZXQpO1xuICB9O1xuXG4gIF9wcm90by53aXRoT2Zmc2V0U2FtZUxvY2FsID0gZnVuY3Rpb24gd2l0aE9mZnNldFNhbWVMb2NhbChvZmZzZXQpIHtcbiAgICByZXR1cm4gb2Zmc2V0ICE9IG51bGwgJiYgb2Zmc2V0LmVxdWFscyh0aGlzLl9vZmZzZXQpID8gdGhpcyA6IG5ldyBPZmZzZXRUaW1lKHRoaXMuX3RpbWUsIG9mZnNldCk7XG4gIH07XG5cbiAgX3Byb3RvLl90b0Vwb2NoTmFubyA9IGZ1bmN0aW9uIF90b0Vwb2NoTmFubygpIHtcbiAgICB2YXIgbm9kID0gdGhpcy5fdGltZS50b05hbm9PZkRheSgpO1xuXG4gICAgdmFyIG9mZnNldE5hbm9zID0gdGhpcy5fb2Zmc2V0LnRvdGFsU2Vjb25kcygpICogTG9jYWxUaW1lLk5BTk9TX1BFUl9TRUNPTkQ7XG4gICAgcmV0dXJuIG5vZCAtIG9mZnNldE5hbm9zO1xuICB9O1xuXG4gIF9wcm90by53aXRoQWRqdXN0ZXIgPSBmdW5jdGlvbiB3aXRoQWRqdXN0ZXIoYWRqdXN0ZXIpIHtcbiAgICByZXF1aXJlTm9uTnVsbChhZGp1c3RlciwgJ2FkanVzdGVyJyk7XG5cbiAgICBpZiAoYWRqdXN0ZXIgaW5zdGFuY2VvZiBMb2NhbFRpbWUpIHtcbiAgICAgIHJldHVybiB0aGlzLl93aXRoTG9jYWxUaW1lT2Zmc2V0KGFkanVzdGVyLCB0aGlzLl9vZmZzZXQpO1xuICAgIH0gZWxzZSBpZiAoYWRqdXN0ZXIgaW5zdGFuY2VvZiBab25lT2Zmc2V0KSB7XG4gICAgICByZXR1cm4gdGhpcy5fd2l0aExvY2FsVGltZU9mZnNldCh0aGlzLl90aW1lLCBhZGp1c3Rlcik7XG4gICAgfSBlbHNlIGlmIChhZGp1c3RlciBpbnN0YW5jZW9mIE9mZnNldFRpbWUpIHtcbiAgICAgIHJldHVybiBhZGp1c3RlcjtcbiAgICB9XG5cbiAgICByZXR1cm4gYWRqdXN0ZXIuYWRqdXN0SW50byh0aGlzKTtcbiAgfTtcblxuICBfcHJvdG8ud2l0aEZpZWxkVmFsdWUgPSBmdW5jdGlvbiB3aXRoRmllbGRWYWx1ZShmaWVsZCwgbmV3VmFsdWUpIHtcbiAgICByZXF1aXJlTm9uTnVsbChmaWVsZCwgJ2ZpZWxkJyk7XG5cbiAgICBpZiAoZmllbGQgaW5zdGFuY2VvZiBDaHJvbm9GaWVsZCkge1xuICAgICAgaWYgKGZpZWxkID09PSBDaHJvbm9GaWVsZC5PRkZTRVRfU0VDT05EUykge1xuICAgICAgICByZXR1cm4gdGhpcy5fd2l0aExvY2FsVGltZU9mZnNldCh0aGlzLl90aW1lLCBab25lT2Zmc2V0Lm9mVG90YWxTZWNvbmRzKGZpZWxkLmNoZWNrVmFsaWRJbnRWYWx1ZShuZXdWYWx1ZSkpKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXMuX3dpdGhMb2NhbFRpbWVPZmZzZXQodGhpcy5fdGltZS53aXRoKGZpZWxkLCBuZXdWYWx1ZSksIHRoaXMuX29mZnNldCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZpZWxkLmFkanVzdEludG8odGhpcywgbmV3VmFsdWUpO1xuICB9O1xuXG4gIF9wcm90by5fd2l0aExvY2FsVGltZU9mZnNldCA9IGZ1bmN0aW9uIF93aXRoTG9jYWxUaW1lT2Zmc2V0KHRpbWUsIG9mZnNldCkge1xuICAgIGlmICh0aGlzLl90aW1lID09PSB0aW1lICYmIHRoaXMuX29mZnNldC5lcXVhbHMob2Zmc2V0KSkge1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgcmV0dXJuIG5ldyBPZmZzZXRUaW1lKHRpbWUsIG9mZnNldCk7XG4gIH07XG5cbiAgX3Byb3RvLmNvbXBhcmVUbyA9IGZ1bmN0aW9uIGNvbXBhcmVUbyhvdGhlcikge1xuICAgIHJlcXVpcmVOb25OdWxsKG90aGVyLCAnb3RoZXInKTtcbiAgICByZXF1aXJlSW5zdGFuY2Uob3RoZXIsIE9mZnNldFRpbWUsICdvdGhlcicpO1xuXG4gICAgaWYgKHRoaXMuX29mZnNldC5lcXVhbHMob3RoZXIuX29mZnNldCkpIHtcbiAgICAgIHJldHVybiB0aGlzLl90aW1lLmNvbXBhcmVUbyhvdGhlci5fdGltZSk7XG4gICAgfVxuXG4gICAgdmFyIGNvbXBhcmUgPSBNYXRoVXRpbC5jb21wYXJlTnVtYmVycyh0aGlzLl90b0Vwb2NoTmFubygpLCBvdGhlci5fdG9FcG9jaE5hbm8oKSk7XG5cbiAgICBpZiAoY29tcGFyZSA9PT0gMCkge1xuICAgICAgcmV0dXJuIHRoaXMuX3RpbWUuY29tcGFyZVRvKG90aGVyLl90aW1lKTtcbiAgICB9XG5cbiAgICByZXR1cm4gY29tcGFyZTtcbiAgfTtcblxuICBfcHJvdG8uZXF1YWxzID0gZnVuY3Rpb24gZXF1YWxzKG90aGVyKSB7XG4gICAgaWYgKHRoaXMgPT09IG90aGVyKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICBpZiAob3RoZXIgaW5zdGFuY2VvZiBPZmZzZXRUaW1lKSB7XG4gICAgICByZXR1cm4gdGhpcy5fdGltZS5lcXVhbHMob3RoZXIuX3RpbWUpICYmIHRoaXMuX29mZnNldC5lcXVhbHMob3RoZXIuX29mZnNldCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9O1xuXG4gIF9wcm90by5oYXNoQ29kZSA9IGZ1bmN0aW9uIGhhc2hDb2RlKCkge1xuICAgIHJldHVybiB0aGlzLl90aW1lLmhhc2hDb2RlKCkgXiB0aGlzLl9vZmZzZXQuaGFzaENvZGUoKTtcbiAgfTtcblxuICBfcHJvdG8udG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZygpIHtcbiAgICByZXR1cm4gdGhpcy5fdGltZS50b1N0cmluZygpICsgdGhpcy5fb2Zmc2V0LnRvU3RyaW5nKCk7XG4gIH07XG5cbiAgX3Byb3RvLnRvSlNPTiA9IGZ1bmN0aW9uIHRvSlNPTigpIHtcbiAgICByZXR1cm4gdGhpcy50b1N0cmluZygpO1xuICB9O1xuXG4gIHJldHVybiBPZmZzZXRUaW1lO1xufShEZWZhdWx0SW50ZXJmYWNlVGVtcG9yYWwpO1xuZnVuY3Rpb24gX2luaXQkZigpIHtcbiAgT2Zmc2V0VGltZS5NSU4gPSBPZmZzZXRUaW1lLm9mTnVtYmVycygwLCAwLCAwLCAwLCBab25lT2Zmc2V0Lk1BWCk7XG4gIE9mZnNldFRpbWUuTUFYID0gT2Zmc2V0VGltZS5vZk51bWJlcnMoMjMsIDU5LCA1OSwgOTk5OTk5OTk5LCBab25lT2Zmc2V0Lk1JTik7XG4gIE9mZnNldFRpbWUuRlJPTSA9IGNyZWF0ZVRlbXBvcmFsUXVlcnkoJ09mZnNldFRpbWUuRlJPTScsIGZ1bmN0aW9uICh0ZW1wb3JhbCkge1xuICAgIHJldHVybiBPZmZzZXRUaW1lLmZyb20odGVtcG9yYWwpO1xuICB9KTtcbn1cblxudmFyIENocm9ub1pvbmVkRGF0ZVRpbWUgPSBmdW5jdGlvbiAoX0RlZmF1bHRJbnRlcmZhY2VUZW1wKSB7XG4gIF9pbmhlcml0c0xvb3NlKENocm9ub1pvbmVkRGF0ZVRpbWUsIF9EZWZhdWx0SW50ZXJmYWNlVGVtcCk7XG5cbiAgZnVuY3Rpb24gQ2hyb25vWm9uZWREYXRlVGltZSgpIHtcbiAgICByZXR1cm4gX0RlZmF1bHRJbnRlcmZhY2VUZW1wLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgfVxuXG4gIHZhciBfcHJvdG8gPSBDaHJvbm9ab25lZERhdGVUaW1lLnByb3RvdHlwZTtcblxuICBfcHJvdG8ucXVlcnkgPSBmdW5jdGlvbiBxdWVyeShfcXVlcnkpIHtcbiAgICBpZiAoX3F1ZXJ5ID09PSBUZW1wb3JhbFF1ZXJpZXMuem9uZUlkKCkgfHwgX3F1ZXJ5ID09PSBUZW1wb3JhbFF1ZXJpZXMuem9uZSgpKSB7XG4gICAgICByZXR1cm4gdGhpcy56b25lKCk7XG4gICAgfSBlbHNlIGlmIChfcXVlcnkgPT09IFRlbXBvcmFsUXVlcmllcy5jaHJvbm9sb2d5KCkpIHtcbiAgICAgIHJldHVybiB0aGlzLnRvTG9jYWxEYXRlKCkuY2hyb25vbG9neSgpO1xuICAgIH0gZWxzZSBpZiAoX3F1ZXJ5ID09PSBUZW1wb3JhbFF1ZXJpZXMucHJlY2lzaW9uKCkpIHtcbiAgICAgIHJldHVybiBDaHJvbm9Vbml0Lk5BTk9TO1xuICAgIH0gZWxzZSBpZiAoX3F1ZXJ5ID09PSBUZW1wb3JhbFF1ZXJpZXMub2Zmc2V0KCkpIHtcbiAgICAgIHJldHVybiB0aGlzLm9mZnNldCgpO1xuICAgIH0gZWxzZSBpZiAoX3F1ZXJ5ID09PSBUZW1wb3JhbFF1ZXJpZXMubG9jYWxEYXRlKCkpIHtcbiAgICAgIHJldHVybiBMb2NhbERhdGUub2ZFcG9jaERheSh0aGlzLnRvTG9jYWxEYXRlKCkudG9FcG9jaERheSgpKTtcbiAgICB9IGVsc2UgaWYgKF9xdWVyeSA9PT0gVGVtcG9yYWxRdWVyaWVzLmxvY2FsVGltZSgpKSB7XG4gICAgICByZXR1cm4gdGhpcy50b0xvY2FsVGltZSgpO1xuICAgIH1cblxuICAgIHJldHVybiBfRGVmYXVsdEludGVyZmFjZVRlbXAucHJvdG90eXBlLnF1ZXJ5LmNhbGwodGhpcywgX3F1ZXJ5KTtcbiAgfTtcblxuICBfcHJvdG8uZm9ybWF0ID0gZnVuY3Rpb24gZm9ybWF0KGZvcm1hdHRlcikge1xuICAgIHJlcXVpcmVOb25OdWxsKGZvcm1hdHRlciwgJ2Zvcm1hdHRlcicpO1xuICAgIHJldHVybiBmb3JtYXR0ZXIuZm9ybWF0KHRoaXMpO1xuICB9O1xuXG4gIF9wcm90by50b0luc3RhbnQgPSBmdW5jdGlvbiB0b0luc3RhbnQoKSB7XG4gICAgcmV0dXJuIEluc3RhbnQub2ZFcG9jaFNlY29uZCh0aGlzLnRvRXBvY2hTZWNvbmQoKSwgdGhpcy50b0xvY2FsVGltZSgpLm5hbm8oKSk7XG4gIH07XG5cbiAgX3Byb3RvLnRvRXBvY2hTZWNvbmQgPSBmdW5jdGlvbiB0b0Vwb2NoU2Vjb25kKCkge1xuICAgIHZhciBlcG9jaERheSA9IHRoaXMudG9Mb2NhbERhdGUoKS50b0Vwb2NoRGF5KCk7XG4gICAgdmFyIHNlY3MgPSBlcG9jaERheSAqIDg2NDAwICsgdGhpcy50b0xvY2FsVGltZSgpLnRvU2Vjb25kT2ZEYXkoKTtcbiAgICBzZWNzIC09IHRoaXMub2Zmc2V0KCkudG90YWxTZWNvbmRzKCk7XG4gICAgcmV0dXJuIHNlY3M7XG4gIH07XG5cbiAgX3Byb3RvLmNvbXBhcmVUbyA9IGZ1bmN0aW9uIGNvbXBhcmVUbyhvdGhlcikge1xuICAgIHJlcXVpcmVOb25OdWxsKG90aGVyLCAnb3RoZXInKTtcbiAgICB2YXIgY21wID0gTWF0aFV0aWwuY29tcGFyZU51bWJlcnModGhpcy50b0Vwb2NoU2Vjb25kKCksIG90aGVyLnRvRXBvY2hTZWNvbmQoKSk7XG5cbiAgICBpZiAoY21wID09PSAwKSB7XG4gICAgICBjbXAgPSB0aGlzLnRvTG9jYWxUaW1lKCkubmFubygpIC0gb3RoZXIudG9Mb2NhbFRpbWUoKS5uYW5vKCk7XG5cbiAgICAgIGlmIChjbXAgPT09IDApIHtcbiAgICAgICAgY21wID0gdGhpcy50b0xvY2FsRGF0ZVRpbWUoKS5jb21wYXJlVG8ob3RoZXIudG9Mb2NhbERhdGVUaW1lKCkpO1xuXG4gICAgICAgIGlmIChjbXAgPT09IDApIHtcbiAgICAgICAgICBjbXAgPSBzdHJjbXAodGhpcy56b25lKCkuaWQoKSwgb3RoZXIuem9uZSgpLmlkKCkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGNtcDtcbiAgfTtcblxuICBfcHJvdG8uaXNBZnRlciA9IGZ1bmN0aW9uIGlzQWZ0ZXIob3RoZXIpIHtcbiAgICByZXF1aXJlTm9uTnVsbChvdGhlciwgJ290aGVyJyk7XG4gICAgdmFyIHRoaXNFcG9jaFNlYyA9IHRoaXMudG9FcG9jaFNlY29uZCgpO1xuICAgIHZhciBvdGhlckVwb2NoU2VjID0gb3RoZXIudG9FcG9jaFNlY29uZCgpO1xuICAgIHJldHVybiB0aGlzRXBvY2hTZWMgPiBvdGhlckVwb2NoU2VjIHx8IHRoaXNFcG9jaFNlYyA9PT0gb3RoZXJFcG9jaFNlYyAmJiB0aGlzLnRvTG9jYWxUaW1lKCkubmFubygpID4gb3RoZXIudG9Mb2NhbFRpbWUoKS5uYW5vKCk7XG4gIH07XG5cbiAgX3Byb3RvLmlzQmVmb3JlID0gZnVuY3Rpb24gaXNCZWZvcmUob3RoZXIpIHtcbiAgICByZXF1aXJlTm9uTnVsbChvdGhlciwgJ290aGVyJyk7XG4gICAgdmFyIHRoaXNFcG9jaFNlYyA9IHRoaXMudG9FcG9jaFNlY29uZCgpO1xuICAgIHZhciBvdGhlckVwb2NoU2VjID0gb3RoZXIudG9FcG9jaFNlY29uZCgpO1xuICAgIHJldHVybiB0aGlzRXBvY2hTZWMgPCBvdGhlckVwb2NoU2VjIHx8IHRoaXNFcG9jaFNlYyA9PT0gb3RoZXJFcG9jaFNlYyAmJiB0aGlzLnRvTG9jYWxUaW1lKCkubmFubygpIDwgb3RoZXIudG9Mb2NhbFRpbWUoKS5uYW5vKCk7XG4gIH07XG5cbiAgX3Byb3RvLmlzRXF1YWwgPSBmdW5jdGlvbiBpc0VxdWFsKG90aGVyKSB7XG4gICAgcmVxdWlyZU5vbk51bGwob3RoZXIsICdvdGhlcicpO1xuICAgIHJldHVybiB0aGlzLnRvRXBvY2hTZWNvbmQoKSA9PT0gb3RoZXIudG9FcG9jaFNlY29uZCgpICYmIHRoaXMudG9Mb2NhbFRpbWUoKS5uYW5vKCkgPT09IG90aGVyLnRvTG9jYWxUaW1lKCkubmFubygpO1xuICB9O1xuXG4gIF9wcm90by5lcXVhbHMgPSBmdW5jdGlvbiBlcXVhbHMob3RoZXIpIHtcbiAgICBpZiAodGhpcyA9PT0gb3RoZXIpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIGlmIChvdGhlciBpbnN0YW5jZW9mIENocm9ub1pvbmVkRGF0ZVRpbWUpIHtcbiAgICAgIHJldHVybiB0aGlzLmNvbXBhcmVUbyhvdGhlcikgPT09IDA7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9O1xuXG4gIHJldHVybiBDaHJvbm9ab25lZERhdGVUaW1lO1xufShEZWZhdWx0SW50ZXJmYWNlVGVtcG9yYWwpO1xuXG5mdW5jdGlvbiBzdHJjbXAoYSwgYikge1xuICBpZiAoYSA8IGIpIHtcbiAgICByZXR1cm4gLTE7XG4gIH1cblxuICBpZiAoYSA+IGIpIHtcbiAgICByZXR1cm4gMTtcbiAgfVxuXG4gIHJldHVybiAwO1xufVxuXG52YXIgWm9uZWREYXRlVGltZSA9IGZ1bmN0aW9uIChfQ2hyb25vWm9uZWREYXRlVGltZSkge1xuICBfaW5oZXJpdHNMb29zZShab25lZERhdGVUaW1lLCBfQ2hyb25vWm9uZWREYXRlVGltZSk7XG5cbiAgWm9uZWREYXRlVGltZS5ub3cgPSBmdW5jdGlvbiBub3coY2xvY2tPclpvbmUpIHtcbiAgICB2YXIgY2xvY2s7XG5cbiAgICBpZiAoY2xvY2tPclpvbmUgaW5zdGFuY2VvZiBab25lSWQpIHtcbiAgICAgIGNsb2NrID0gQ2xvY2suc3lzdGVtKGNsb2NrT3Jab25lKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY2xvY2sgPSBjbG9ja09yWm9uZSA9PSBudWxsID8gQ2xvY2suc3lzdGVtRGVmYXVsdFpvbmUoKSA6IGNsb2NrT3Jab25lO1xuICAgIH1cblxuICAgIHJldHVybiBab25lZERhdGVUaW1lLm9mSW5zdGFudChjbG9jay5pbnN0YW50KCksIGNsb2NrLnpvbmUoKSk7XG4gIH07XG5cbiAgWm9uZWREYXRlVGltZS5vZiA9IGZ1bmN0aW9uIG9mKCkge1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoIDw9IDIpIHtcbiAgICAgIHJldHVybiBab25lZERhdGVUaW1lLm9mMi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH0gZWxzZSBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMyAmJiBhcmd1bWVudHNbMF0gaW5zdGFuY2VvZiBMb2NhbERhdGUpIHtcbiAgICAgIHJldHVybiBab25lZERhdGVUaW1lLm9mMy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gWm9uZWREYXRlVGltZS5vZjguYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gIH07XG5cbiAgWm9uZWREYXRlVGltZS5vZjMgPSBmdW5jdGlvbiBvZjMoZGF0ZSwgdGltZSwgem9uZSkge1xuICAgIHJldHVybiBab25lZERhdGVUaW1lLm9mMihMb2NhbERhdGVUaW1lLm9mKGRhdGUsIHRpbWUpLCB6b25lKTtcbiAgfTtcblxuICBab25lZERhdGVUaW1lLm9mMiA9IGZ1bmN0aW9uIG9mMihsb2NhbERhdGVUaW1lLCB6b25lKSB7XG4gICAgcmV0dXJuIFpvbmVkRGF0ZVRpbWUub2ZMb2NhbChsb2NhbERhdGVUaW1lLCB6b25lLCBudWxsKTtcbiAgfTtcblxuICBab25lZERhdGVUaW1lLm9mOCA9IGZ1bmN0aW9uIG9mOCh5ZWFyLCBtb250aCwgZGF5T2ZNb250aCwgaG91ciwgbWludXRlLCBzZWNvbmQsIG5hbm9PZlNlY29uZCwgem9uZSkge1xuICAgIHZhciBkdCA9IExvY2FsRGF0ZVRpbWUub2YoeWVhciwgbW9udGgsIGRheU9mTW9udGgsIGhvdXIsIG1pbnV0ZSwgc2Vjb25kLCBuYW5vT2ZTZWNvbmQpO1xuICAgIHJldHVybiBab25lZERhdGVUaW1lLm9mTG9jYWwoZHQsIHpvbmUsIG51bGwpO1xuICB9O1xuXG4gIFpvbmVkRGF0ZVRpbWUub2ZMb2NhbCA9IGZ1bmN0aW9uIG9mTG9jYWwobG9jYWxEYXRlVGltZSwgem9uZSwgcHJlZmVycmVkT2Zmc2V0KSB7XG4gICAgcmVxdWlyZU5vbk51bGwobG9jYWxEYXRlVGltZSwgJ2xvY2FsRGF0ZVRpbWUnKTtcbiAgICByZXF1aXJlTm9uTnVsbCh6b25lLCAnem9uZScpO1xuXG4gICAgaWYgKHpvbmUgaW5zdGFuY2VvZiBab25lT2Zmc2V0KSB7XG4gICAgICByZXR1cm4gbmV3IFpvbmVkRGF0ZVRpbWUobG9jYWxEYXRlVGltZSwgem9uZSwgem9uZSk7XG4gICAgfVxuXG4gICAgdmFyIG9mZnNldCA9IG51bGw7XG4gICAgdmFyIHJ1bGVzID0gem9uZS5ydWxlcygpO1xuICAgIHZhciB2YWxpZE9mZnNldHMgPSBydWxlcy52YWxpZE9mZnNldHMobG9jYWxEYXRlVGltZSk7XG5cbiAgICBpZiAodmFsaWRPZmZzZXRzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgb2Zmc2V0ID0gdmFsaWRPZmZzZXRzWzBdO1xuICAgIH0gZWxzZSBpZiAodmFsaWRPZmZzZXRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgdmFyIHRyYW5zID0gcnVsZXMudHJhbnNpdGlvbihsb2NhbERhdGVUaW1lKTtcbiAgICAgIGxvY2FsRGF0ZVRpbWUgPSBsb2NhbERhdGVUaW1lLnBsdXNTZWNvbmRzKHRyYW5zLmR1cmF0aW9uKCkuc2Vjb25kcygpKTtcbiAgICAgIG9mZnNldCA9IHRyYW5zLm9mZnNldEFmdGVyKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChwcmVmZXJyZWRPZmZzZXQgIT0gbnVsbCAmJiB2YWxpZE9mZnNldHMuc29tZShmdW5jdGlvbiAodmFsaWRPZmZzZXQpIHtcbiAgICAgICAgcmV0dXJuIHZhbGlkT2Zmc2V0LmVxdWFscyhwcmVmZXJyZWRPZmZzZXQpO1xuICAgICAgfSkpIHtcbiAgICAgICAgb2Zmc2V0ID0gcHJlZmVycmVkT2Zmc2V0O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgb2Zmc2V0ID0gcmVxdWlyZU5vbk51bGwodmFsaWRPZmZzZXRzWzBdLCAnb2Zmc2V0Jyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIG5ldyBab25lZERhdGVUaW1lKGxvY2FsRGF0ZVRpbWUsIG9mZnNldCwgem9uZSk7XG4gIH07XG5cbiAgWm9uZWREYXRlVGltZS5vZkluc3RhbnQgPSBmdW5jdGlvbiBvZkluc3RhbnQoKSB7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDIpIHtcbiAgICAgIHJldHVybiBab25lZERhdGVUaW1lLm9mSW5zdGFudDIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIFpvbmVkRGF0ZVRpbWUub2ZJbnN0YW50My5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgfTtcblxuICBab25lZERhdGVUaW1lLm9mSW5zdGFudDIgPSBmdW5jdGlvbiBvZkluc3RhbnQyKGluc3RhbnQsIHpvbmUpIHtcbiAgICByZXF1aXJlTm9uTnVsbChpbnN0YW50LCAnaW5zdGFudCcpO1xuICAgIHJlcXVpcmVOb25OdWxsKHpvbmUsICd6b25lJyk7XG4gICAgcmV0dXJuIFpvbmVkRGF0ZVRpbWUuX2NyZWF0ZShpbnN0YW50LmVwb2NoU2Vjb25kKCksIGluc3RhbnQubmFubygpLCB6b25lKTtcbiAgfTtcblxuICBab25lZERhdGVUaW1lLm9mSW5zdGFudDMgPSBmdW5jdGlvbiBvZkluc3RhbnQzKGxvY2FsRGF0ZVRpbWUsIG9mZnNldCwgem9uZSkge1xuICAgIHJlcXVpcmVOb25OdWxsKGxvY2FsRGF0ZVRpbWUsICdsb2NhbERhdGVUaW1lJyk7XG4gICAgcmVxdWlyZU5vbk51bGwob2Zmc2V0LCAnb2Zmc2V0Jyk7XG4gICAgcmVxdWlyZU5vbk51bGwoem9uZSwgJ3pvbmUnKTtcbiAgICByZXR1cm4gWm9uZWREYXRlVGltZS5fY3JlYXRlKGxvY2FsRGF0ZVRpbWUudG9FcG9jaFNlY29uZChvZmZzZXQpLCBsb2NhbERhdGVUaW1lLm5hbm8oKSwgem9uZSk7XG4gIH07XG5cbiAgWm9uZWREYXRlVGltZS5fY3JlYXRlID0gZnVuY3Rpb24gX2NyZWF0ZShlcG9jaFNlY29uZCwgbmFub09mU2Vjb25kLCB6b25lKSB7XG4gICAgdmFyIHJ1bGVzID0gem9uZS5ydWxlcygpO1xuICAgIHZhciBpbnN0YW50ID0gSW5zdGFudC5vZkVwb2NoU2Vjb25kKGVwb2NoU2Vjb25kLCBuYW5vT2ZTZWNvbmQpO1xuICAgIHZhciBvZmZzZXQgPSBydWxlcy5vZmZzZXQoaW5zdGFudCk7XG4gICAgdmFyIGxkdCA9IExvY2FsRGF0ZVRpbWUub2ZFcG9jaFNlY29uZChlcG9jaFNlY29uZCwgbmFub09mU2Vjb25kLCBvZmZzZXQpO1xuICAgIHJldHVybiBuZXcgWm9uZWREYXRlVGltZShsZHQsIG9mZnNldCwgem9uZSk7XG4gIH07XG5cbiAgWm9uZWREYXRlVGltZS5vZlN0cmljdCA9IGZ1bmN0aW9uIG9mU3RyaWN0KGxvY2FsRGF0ZVRpbWUsIG9mZnNldCwgem9uZSkge1xuICAgIHJlcXVpcmVOb25OdWxsKGxvY2FsRGF0ZVRpbWUsICdsb2NhbERhdGVUaW1lJyk7XG4gICAgcmVxdWlyZU5vbk51bGwob2Zmc2V0LCAnb2Zmc2V0Jyk7XG4gICAgcmVxdWlyZU5vbk51bGwoem9uZSwgJ3pvbmUnKTtcbiAgICB2YXIgcnVsZXMgPSB6b25lLnJ1bGVzKCk7XG5cbiAgICBpZiAocnVsZXMuaXNWYWxpZE9mZnNldChsb2NhbERhdGVUaW1lLCBvZmZzZXQpID09PSBmYWxzZSkge1xuICAgICAgdmFyIHRyYW5zID0gcnVsZXMudHJhbnNpdGlvbihsb2NhbERhdGVUaW1lKTtcblxuICAgICAgaWYgKHRyYW5zICE9IG51bGwgJiYgdHJhbnMuaXNHYXAoKSkge1xuICAgICAgICB0aHJvdyBuZXcgRGF0ZVRpbWVFeGNlcHRpb24oJ0xvY2FsRGF0ZVRpbWUgJyArIGxvY2FsRGF0ZVRpbWUgKyAnIGRvZXMgbm90IGV4aXN0IGluIHpvbmUgJyArIHpvbmUgKyAnIGR1ZSB0byBhIGdhcCBpbiB0aGUgbG9jYWwgdGltZS1saW5lLCB0eXBpY2FsbHkgY2F1c2VkIGJ5IGRheWxpZ2h0IHNhdmluZ3MnKTtcbiAgICAgIH1cblxuICAgICAgdGhyb3cgbmV3IERhdGVUaW1lRXhjZXB0aW9uKCdab25lT2Zmc2V0IFwiJyArIG9mZnNldCArICdcIiBpcyBub3QgdmFsaWQgZm9yIExvY2FsRGF0ZVRpbWUgXCInICsgbG9jYWxEYXRlVGltZSArICdcIiBpbiB6b25lIFwiJyArIHpvbmUgKyAnXCInKTtcbiAgICB9XG5cbiAgICByZXR1cm4gbmV3IFpvbmVkRGF0ZVRpbWUobG9jYWxEYXRlVGltZSwgb2Zmc2V0LCB6b25lKTtcbiAgfTtcblxuICBab25lZERhdGVUaW1lLm9mTGVuaWVudCA9IGZ1bmN0aW9uIG9mTGVuaWVudChsb2NhbERhdGVUaW1lLCBvZmZzZXQsIHpvbmUpIHtcbiAgICByZXF1aXJlTm9uTnVsbChsb2NhbERhdGVUaW1lLCAnbG9jYWxEYXRlVGltZScpO1xuICAgIHJlcXVpcmVOb25OdWxsKG9mZnNldCwgJ29mZnNldCcpO1xuICAgIHJlcXVpcmVOb25OdWxsKHpvbmUsICd6b25lJyk7XG5cbiAgICBpZiAoem9uZSBpbnN0YW5jZW9mIFpvbmVPZmZzZXQgJiYgb2Zmc2V0LmVxdWFscyh6b25lKSA9PT0gZmFsc2UpIHtcbiAgICAgIHRocm93IG5ldyBJbGxlZ2FsQXJndW1lbnRFeGNlcHRpb24oJ1pvbmVJZCBtdXN0IG1hdGNoIFpvbmVPZmZzZXQnKTtcbiAgICB9XG5cbiAgICByZXR1cm4gbmV3IFpvbmVkRGF0ZVRpbWUobG9jYWxEYXRlVGltZSwgb2Zmc2V0LCB6b25lKTtcbiAgfTtcblxuICBab25lZERhdGVUaW1lLmZyb20gPSBmdW5jdGlvbiBmcm9tKHRlbXBvcmFsKSB7XG4gICAgcmVxdWlyZU5vbk51bGwodGVtcG9yYWwsICd0ZW1wb3JhbCcpO1xuXG4gICAgaWYgKHRlbXBvcmFsIGluc3RhbmNlb2YgWm9uZWREYXRlVGltZSkge1xuICAgICAgcmV0dXJuIHRlbXBvcmFsO1xuICAgIH1cblxuICAgIHZhciB6b25lID0gWm9uZUlkLmZyb20odGVtcG9yYWwpO1xuXG4gICAgaWYgKHRlbXBvcmFsLmlzU3VwcG9ydGVkKENocm9ub0ZpZWxkLklOU1RBTlRfU0VDT05EUykpIHtcbiAgICAgIHZhciB6ZHQgPSBab25lZERhdGVUaW1lLl9mcm9tKHRlbXBvcmFsLCB6b25lKTtcblxuICAgICAgaWYgKHpkdCAhPSBudWxsKSByZXR1cm4gemR0O1xuICAgIH1cblxuICAgIHZhciBsZHQgPSBMb2NhbERhdGVUaW1lLmZyb20odGVtcG9yYWwpO1xuICAgIHJldHVybiBab25lZERhdGVUaW1lLm9mMihsZHQsIHpvbmUpO1xuICB9O1xuXG4gIFpvbmVkRGF0ZVRpbWUuX2Zyb20gPSBmdW5jdGlvbiBfZnJvbSh0ZW1wb3JhbCwgem9uZSkge1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4gWm9uZWREYXRlVGltZS5fX2Zyb20odGVtcG9yYWwsIHpvbmUpO1xuICAgIH0gY2F0Y2ggKGV4KSB7XG4gICAgICBpZiAoIShleCBpbnN0YW5jZW9mIERhdGVUaW1lRXhjZXB0aW9uKSkgdGhyb3cgZXg7XG4gICAgfVxuICB9O1xuXG4gIFpvbmVkRGF0ZVRpbWUuX19mcm9tID0gZnVuY3Rpb24gX19mcm9tKHRlbXBvcmFsLCB6b25lKSB7XG4gICAgdmFyIGVwb2NoU2Vjb25kID0gdGVtcG9yYWwuZ2V0TG9uZyhDaHJvbm9GaWVsZC5JTlNUQU5UX1NFQ09ORFMpO1xuICAgIHZhciBuYW5vT2ZTZWNvbmQgPSB0ZW1wb3JhbC5nZXQoQ2hyb25vRmllbGQuTkFOT19PRl9TRUNPTkQpO1xuICAgIHJldHVybiBab25lZERhdGVUaW1lLl9jcmVhdGUoZXBvY2hTZWNvbmQsIG5hbm9PZlNlY29uZCwgem9uZSk7XG4gIH07XG5cbiAgWm9uZWREYXRlVGltZS5wYXJzZSA9IGZ1bmN0aW9uIHBhcnNlKHRleHQsIGZvcm1hdHRlcikge1xuICAgIGlmIChmb3JtYXR0ZXIgPT09IHZvaWQgMCkge1xuICAgICAgZm9ybWF0dGVyID0gRGF0ZVRpbWVGb3JtYXR0ZXIuSVNPX1pPTkVEX0RBVEVfVElNRTtcbiAgICB9XG5cbiAgICByZXF1aXJlTm9uTnVsbChmb3JtYXR0ZXIsICdmb3JtYXR0ZXInKTtcbiAgICByZXR1cm4gZm9ybWF0dGVyLnBhcnNlKHRleHQsIFpvbmVkRGF0ZVRpbWUuRlJPTSk7XG4gIH07XG5cbiAgZnVuY3Rpb24gWm9uZWREYXRlVGltZShkYXRlVGltZSwgb2Zmc2V0LCB6b25lKSB7XG4gICAgdmFyIF90aGlzO1xuXG4gICAgcmVxdWlyZU5vbk51bGwoZGF0ZVRpbWUsICdkYXRlVGltZScpO1xuICAgIHJlcXVpcmVOb25OdWxsKG9mZnNldCwgJ29mZnNldCcpO1xuICAgIHJlcXVpcmVOb25OdWxsKHpvbmUsICd6b25lJyk7XG4gICAgX3RoaXMgPSBfQ2hyb25vWm9uZWREYXRlVGltZS5jYWxsKHRoaXMpIHx8IHRoaXM7XG4gICAgX3RoaXMuX2RhdGVUaW1lID0gZGF0ZVRpbWU7XG4gICAgX3RoaXMuX29mZnNldCA9IG9mZnNldDtcbiAgICBfdGhpcy5fem9uZSA9IHpvbmU7XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG5cbiAgdmFyIF9wcm90byA9IFpvbmVkRGF0ZVRpbWUucHJvdG90eXBlO1xuXG4gIF9wcm90by5fcmVzb2x2ZUxvY2FsID0gZnVuY3Rpb24gX3Jlc29sdmVMb2NhbChuZXdEYXRlVGltZSkge1xuICAgIHJlcXVpcmVOb25OdWxsKG5ld0RhdGVUaW1lLCAnbmV3RGF0ZVRpbWUnKTtcbiAgICByZXR1cm4gWm9uZWREYXRlVGltZS5vZkxvY2FsKG5ld0RhdGVUaW1lLCB0aGlzLl96b25lLCB0aGlzLl9vZmZzZXQpO1xuICB9O1xuXG4gIF9wcm90by5fcmVzb2x2ZUluc3RhbnQgPSBmdW5jdGlvbiBfcmVzb2x2ZUluc3RhbnQobmV3RGF0ZVRpbWUpIHtcbiAgICByZXR1cm4gWm9uZWREYXRlVGltZS5vZkluc3RhbnQzKG5ld0RhdGVUaW1lLCB0aGlzLl9vZmZzZXQsIHRoaXMuX3pvbmUpO1xuICB9O1xuXG4gIF9wcm90by5fcmVzb2x2ZU9mZnNldCA9IGZ1bmN0aW9uIF9yZXNvbHZlT2Zmc2V0KG9mZnNldCkge1xuICAgIGlmIChvZmZzZXQuZXF1YWxzKHRoaXMuX29mZnNldCkgPT09IGZhbHNlICYmIHRoaXMuX3pvbmUucnVsZXMoKS5pc1ZhbGlkT2Zmc2V0KHRoaXMuX2RhdGVUaW1lLCBvZmZzZXQpKSB7XG4gICAgICByZXR1cm4gbmV3IFpvbmVkRGF0ZVRpbWUodGhpcy5fZGF0ZVRpbWUsIG9mZnNldCwgdGhpcy5fem9uZSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgX3Byb3RvLmlzU3VwcG9ydGVkID0gZnVuY3Rpb24gaXNTdXBwb3J0ZWQoZmllbGRPclVuaXQpIHtcbiAgICBpZiAoZmllbGRPclVuaXQgaW5zdGFuY2VvZiBDaHJvbm9GaWVsZCkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBlbHNlIGlmIChmaWVsZE9yVW5pdCBpbnN0YW5jZW9mIENocm9ub1VuaXQpIHtcbiAgICAgIHJldHVybiBmaWVsZE9yVW5pdC5pc0RhdGVCYXNlZCgpIHx8IGZpZWxkT3JVbml0LmlzVGltZUJhc2VkKCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZpZWxkT3JVbml0ICE9IG51bGwgJiYgZmllbGRPclVuaXQuaXNTdXBwb3J0ZWRCeSh0aGlzKTtcbiAgfTtcblxuICBfcHJvdG8ucmFuZ2UgPSBmdW5jdGlvbiByYW5nZShmaWVsZCkge1xuICAgIGlmIChmaWVsZCBpbnN0YW5jZW9mIENocm9ub0ZpZWxkKSB7XG4gICAgICBpZiAoZmllbGQgPT09IENocm9ub0ZpZWxkLklOU1RBTlRfU0VDT05EUyB8fCBmaWVsZCA9PT0gQ2hyb25vRmllbGQuT0ZGU0VUX1NFQ09ORFMpIHtcbiAgICAgICAgcmV0dXJuIGZpZWxkLnJhbmdlKCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzLl9kYXRlVGltZS5yYW5nZShmaWVsZCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZpZWxkLnJhbmdlUmVmaW5lZEJ5KHRoaXMpO1xuICB9O1xuXG4gIF9wcm90by5nZXQgPSBmdW5jdGlvbiBnZXQoZmllbGQpIHtcbiAgICByZXR1cm4gdGhpcy5nZXRMb25nKGZpZWxkKTtcbiAgfTtcblxuICBfcHJvdG8uZ2V0TG9uZyA9IGZ1bmN0aW9uIGdldExvbmcoZmllbGQpIHtcbiAgICBpZiAoZmllbGQgaW5zdGFuY2VvZiBDaHJvbm9GaWVsZCkge1xuICAgICAgc3dpdGNoIChmaWVsZCkge1xuICAgICAgICBjYXNlIENocm9ub0ZpZWxkLklOU1RBTlRfU0VDT05EUzpcbiAgICAgICAgICByZXR1cm4gdGhpcy50b0Vwb2NoU2Vjb25kKCk7XG5cbiAgICAgICAgY2FzZSBDaHJvbm9GaWVsZC5PRkZTRVRfU0VDT05EUzpcbiAgICAgICAgICByZXR1cm4gdGhpcy5fb2Zmc2V0LnRvdGFsU2Vjb25kcygpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcy5fZGF0ZVRpbWUuZ2V0TG9uZyhmaWVsZCk7XG4gICAgfVxuXG4gICAgcmVxdWlyZU5vbk51bGwoZmllbGQsICdmaWVsZCcpO1xuICAgIHJldHVybiBmaWVsZC5nZXRGcm9tKHRoaXMpO1xuICB9O1xuXG4gIF9wcm90by5vZmZzZXQgPSBmdW5jdGlvbiBvZmZzZXQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX29mZnNldDtcbiAgfTtcblxuICBfcHJvdG8ud2l0aEVhcmxpZXJPZmZzZXRBdE92ZXJsYXAgPSBmdW5jdGlvbiB3aXRoRWFybGllck9mZnNldEF0T3ZlcmxhcCgpIHtcbiAgICB2YXIgdHJhbnMgPSB0aGlzLl96b25lLnJ1bGVzKCkudHJhbnNpdGlvbih0aGlzLl9kYXRlVGltZSk7XG5cbiAgICBpZiAodHJhbnMgIT0gbnVsbCAmJiB0cmFucy5pc092ZXJsYXAoKSkge1xuICAgICAgdmFyIGVhcmxpZXJPZmZzZXQgPSB0cmFucy5vZmZzZXRCZWZvcmUoKTtcblxuICAgICAgaWYgKGVhcmxpZXJPZmZzZXQuZXF1YWxzKHRoaXMuX29mZnNldCkgPT09IGZhbHNlKSB7XG4gICAgICAgIHJldHVybiBuZXcgWm9uZWREYXRlVGltZSh0aGlzLl9kYXRlVGltZSwgZWFybGllck9mZnNldCwgdGhpcy5fem9uZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgX3Byb3RvLndpdGhMYXRlck9mZnNldEF0T3ZlcmxhcCA9IGZ1bmN0aW9uIHdpdGhMYXRlck9mZnNldEF0T3ZlcmxhcCgpIHtcbiAgICB2YXIgdHJhbnMgPSB0aGlzLl96b25lLnJ1bGVzKCkudHJhbnNpdGlvbih0aGlzLnRvTG9jYWxEYXRlVGltZSgpKTtcblxuICAgIGlmICh0cmFucyAhPSBudWxsKSB7XG4gICAgICB2YXIgbGF0ZXJPZmZzZXQgPSB0cmFucy5vZmZzZXRBZnRlcigpO1xuXG4gICAgICBpZiAobGF0ZXJPZmZzZXQuZXF1YWxzKHRoaXMuX29mZnNldCkgPT09IGZhbHNlKSB7XG4gICAgICAgIHJldHVybiBuZXcgWm9uZWREYXRlVGltZSh0aGlzLl9kYXRlVGltZSwgbGF0ZXJPZmZzZXQsIHRoaXMuX3pvbmUpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIF9wcm90by56b25lID0gZnVuY3Rpb24gem9uZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fem9uZTtcbiAgfTtcblxuICBfcHJvdG8ud2l0aFpvbmVTYW1lTG9jYWwgPSBmdW5jdGlvbiB3aXRoWm9uZVNhbWVMb2NhbCh6b25lKSB7XG4gICAgcmVxdWlyZU5vbk51bGwoem9uZSwgJ3pvbmUnKTtcbiAgICByZXR1cm4gdGhpcy5fem9uZS5lcXVhbHMoem9uZSkgPyB0aGlzIDogWm9uZWREYXRlVGltZS5vZkxvY2FsKHRoaXMuX2RhdGVUaW1lLCB6b25lLCB0aGlzLl9vZmZzZXQpO1xuICB9O1xuXG4gIF9wcm90by53aXRoWm9uZVNhbWVJbnN0YW50ID0gZnVuY3Rpb24gd2l0aFpvbmVTYW1lSW5zdGFudCh6b25lKSB7XG4gICAgcmVxdWlyZU5vbk51bGwoem9uZSwgJ3pvbmUnKTtcbiAgICByZXR1cm4gdGhpcy5fem9uZS5lcXVhbHMoem9uZSkgPyB0aGlzIDogWm9uZWREYXRlVGltZS5fY3JlYXRlKHRoaXMuX2RhdGVUaW1lLnRvRXBvY2hTZWNvbmQodGhpcy5fb2Zmc2V0KSwgdGhpcy5fZGF0ZVRpbWUubmFubygpLCB6b25lKTtcbiAgfTtcblxuICBfcHJvdG8ud2l0aEZpeGVkT2Zmc2V0Wm9uZSA9IGZ1bmN0aW9uIHdpdGhGaXhlZE9mZnNldFpvbmUoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3pvbmUuZXF1YWxzKHRoaXMuX29mZnNldCkgPyB0aGlzIDogbmV3IFpvbmVkRGF0ZVRpbWUodGhpcy5fZGF0ZVRpbWUsIHRoaXMuX29mZnNldCwgdGhpcy5fb2Zmc2V0KTtcbiAgfTtcblxuICBfcHJvdG8ueWVhciA9IGZ1bmN0aW9uIHllYXIoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2RhdGVUaW1lLnllYXIoKTtcbiAgfTtcblxuICBfcHJvdG8ubW9udGhWYWx1ZSA9IGZ1bmN0aW9uIG1vbnRoVmFsdWUoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2RhdGVUaW1lLm1vbnRoVmFsdWUoKTtcbiAgfTtcblxuICBfcHJvdG8ubW9udGggPSBmdW5jdGlvbiBtb250aCgpIHtcbiAgICByZXR1cm4gdGhpcy5fZGF0ZVRpbWUubW9udGgoKTtcbiAgfTtcblxuICBfcHJvdG8uZGF5T2ZNb250aCA9IGZ1bmN0aW9uIGRheU9mTW9udGgoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2RhdGVUaW1lLmRheU9mTW9udGgoKTtcbiAgfTtcblxuICBfcHJvdG8uZGF5T2ZZZWFyID0gZnVuY3Rpb24gZGF5T2ZZZWFyKCkge1xuICAgIHJldHVybiB0aGlzLl9kYXRlVGltZS5kYXlPZlllYXIoKTtcbiAgfTtcblxuICBfcHJvdG8uZGF5T2ZXZWVrID0gZnVuY3Rpb24gZGF5T2ZXZWVrKCkge1xuICAgIHJldHVybiB0aGlzLl9kYXRlVGltZS5kYXlPZldlZWsoKTtcbiAgfTtcblxuICBfcHJvdG8uaG91ciA9IGZ1bmN0aW9uIGhvdXIoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2RhdGVUaW1lLmhvdXIoKTtcbiAgfTtcblxuICBfcHJvdG8ubWludXRlID0gZnVuY3Rpb24gbWludXRlKCkge1xuICAgIHJldHVybiB0aGlzLl9kYXRlVGltZS5taW51dGUoKTtcbiAgfTtcblxuICBfcHJvdG8uc2Vjb25kID0gZnVuY3Rpb24gc2Vjb25kKCkge1xuICAgIHJldHVybiB0aGlzLl9kYXRlVGltZS5zZWNvbmQoKTtcbiAgfTtcblxuICBfcHJvdG8ubmFubyA9IGZ1bmN0aW9uIG5hbm8oKSB7XG4gICAgcmV0dXJuIHRoaXMuX2RhdGVUaW1lLm5hbm8oKTtcbiAgfTtcblxuICBfcHJvdG8ud2l0aEFkanVzdGVyID0gZnVuY3Rpb24gd2l0aEFkanVzdGVyKGFkanVzdGVyKSB7XG4gICAgaWYgKGFkanVzdGVyIGluc3RhbmNlb2YgTG9jYWxEYXRlKSB7XG4gICAgICByZXR1cm4gdGhpcy5fcmVzb2x2ZUxvY2FsKExvY2FsRGF0ZVRpbWUub2YoYWRqdXN0ZXIsIHRoaXMuX2RhdGVUaW1lLnRvTG9jYWxUaW1lKCkpKTtcbiAgICB9IGVsc2UgaWYgKGFkanVzdGVyIGluc3RhbmNlb2YgTG9jYWxUaW1lKSB7XG4gICAgICByZXR1cm4gdGhpcy5fcmVzb2x2ZUxvY2FsKExvY2FsRGF0ZVRpbWUub2YodGhpcy5fZGF0ZVRpbWUudG9Mb2NhbERhdGUoKSwgYWRqdXN0ZXIpKTtcbiAgICB9IGVsc2UgaWYgKGFkanVzdGVyIGluc3RhbmNlb2YgTG9jYWxEYXRlVGltZSkge1xuICAgICAgcmV0dXJuIHRoaXMuX3Jlc29sdmVMb2NhbChhZGp1c3Rlcik7XG4gICAgfSBlbHNlIGlmIChhZGp1c3RlciBpbnN0YW5jZW9mIEluc3RhbnQpIHtcbiAgICAgIHZhciBpbnN0YW50ID0gYWRqdXN0ZXI7XG4gICAgICByZXR1cm4gWm9uZWREYXRlVGltZS5fY3JlYXRlKGluc3RhbnQuZXBvY2hTZWNvbmQoKSwgaW5zdGFudC5uYW5vKCksIHRoaXMuX3pvbmUpO1xuICAgIH0gZWxzZSBpZiAoYWRqdXN0ZXIgaW5zdGFuY2VvZiBab25lT2Zmc2V0KSB7XG4gICAgICByZXR1cm4gdGhpcy5fcmVzb2x2ZU9mZnNldChhZGp1c3Rlcik7XG4gICAgfVxuXG4gICAgcmVxdWlyZU5vbk51bGwoYWRqdXN0ZXIsICdhZGp1c3RlcicpO1xuICAgIHJldHVybiBhZGp1c3Rlci5hZGp1c3RJbnRvKHRoaXMpO1xuICB9O1xuXG4gIF9wcm90by53aXRoRmllbGRWYWx1ZSA9IGZ1bmN0aW9uIHdpdGhGaWVsZFZhbHVlKGZpZWxkLCBuZXdWYWx1ZSkge1xuICAgIGlmIChmaWVsZCBpbnN0YW5jZW9mIENocm9ub0ZpZWxkKSB7XG4gICAgICBzd2l0Y2ggKGZpZWxkKSB7XG4gICAgICAgIGNhc2UgQ2hyb25vRmllbGQuSU5TVEFOVF9TRUNPTkRTOlxuICAgICAgICAgIHJldHVybiBab25lZERhdGVUaW1lLl9jcmVhdGUobmV3VmFsdWUsIHRoaXMubmFubygpLCB0aGlzLl96b25lKTtcblxuICAgICAgICBjYXNlIENocm9ub0ZpZWxkLk9GRlNFVF9TRUNPTkRTOlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIHZhciBvZmZzZXQgPSBab25lT2Zmc2V0Lm9mVG90YWxTZWNvbmRzKGZpZWxkLmNoZWNrVmFsaWRJbnRWYWx1ZShuZXdWYWx1ZSkpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3Jlc29sdmVPZmZzZXQob2Zmc2V0KTtcbiAgICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzLl9yZXNvbHZlTG9jYWwodGhpcy5fZGF0ZVRpbWUud2l0aChmaWVsZCwgbmV3VmFsdWUpKTtcbiAgICB9XG5cbiAgICByZXR1cm4gZmllbGQuYWRqdXN0SW50byh0aGlzLCBuZXdWYWx1ZSk7XG4gIH07XG5cbiAgX3Byb3RvLndpdGhZZWFyID0gZnVuY3Rpb24gd2l0aFllYXIoeWVhcikge1xuICAgIHJldHVybiB0aGlzLl9yZXNvbHZlTG9jYWwodGhpcy5fZGF0ZVRpbWUud2l0aFllYXIoeWVhcikpO1xuICB9O1xuXG4gIF9wcm90by53aXRoTW9udGggPSBmdW5jdGlvbiB3aXRoTW9udGgobW9udGgpIHtcbiAgICByZXR1cm4gdGhpcy5fcmVzb2x2ZUxvY2FsKHRoaXMuX2RhdGVUaW1lLndpdGhNb250aChtb250aCkpO1xuICB9O1xuXG4gIF9wcm90by53aXRoRGF5T2ZNb250aCA9IGZ1bmN0aW9uIHdpdGhEYXlPZk1vbnRoKGRheU9mTW9udGgpIHtcbiAgICByZXR1cm4gdGhpcy5fcmVzb2x2ZUxvY2FsKHRoaXMuX2RhdGVUaW1lLndpdGhEYXlPZk1vbnRoKGRheU9mTW9udGgpKTtcbiAgfTtcblxuICBfcHJvdG8ud2l0aERheU9mWWVhciA9IGZ1bmN0aW9uIHdpdGhEYXlPZlllYXIoZGF5T2ZZZWFyKSB7XG4gICAgcmV0dXJuIHRoaXMuX3Jlc29sdmVMb2NhbCh0aGlzLl9kYXRlVGltZS53aXRoRGF5T2ZZZWFyKGRheU9mWWVhcikpO1xuICB9O1xuXG4gIF9wcm90by53aXRoSG91ciA9IGZ1bmN0aW9uIHdpdGhIb3VyKGhvdXIpIHtcbiAgICByZXR1cm4gdGhpcy5fcmVzb2x2ZUxvY2FsKHRoaXMuX2RhdGVUaW1lLndpdGhIb3VyKGhvdXIpKTtcbiAgfTtcblxuICBfcHJvdG8ud2l0aE1pbnV0ZSA9IGZ1bmN0aW9uIHdpdGhNaW51dGUobWludXRlKSB7XG4gICAgcmV0dXJuIHRoaXMuX3Jlc29sdmVMb2NhbCh0aGlzLl9kYXRlVGltZS53aXRoTWludXRlKG1pbnV0ZSkpO1xuICB9O1xuXG4gIF9wcm90by53aXRoU2Vjb25kID0gZnVuY3Rpb24gd2l0aFNlY29uZChzZWNvbmQpIHtcbiAgICByZXR1cm4gdGhpcy5fcmVzb2x2ZUxvY2FsKHRoaXMuX2RhdGVUaW1lLndpdGhTZWNvbmQoc2Vjb25kKSk7XG4gIH07XG5cbiAgX3Byb3RvLndpdGhOYW5vID0gZnVuY3Rpb24gd2l0aE5hbm8obmFub09mU2Vjb25kKSB7XG4gICAgcmV0dXJuIHRoaXMuX3Jlc29sdmVMb2NhbCh0aGlzLl9kYXRlVGltZS53aXRoTmFubyhuYW5vT2ZTZWNvbmQpKTtcbiAgfTtcblxuICBfcHJvdG8udHJ1bmNhdGVkVG8gPSBmdW5jdGlvbiB0cnVuY2F0ZWRUbyh1bml0KSB7XG4gICAgcmV0dXJuIHRoaXMuX3Jlc29sdmVMb2NhbCh0aGlzLl9kYXRlVGltZS50cnVuY2F0ZWRUbyh1bml0KSk7XG4gIH07XG5cbiAgX3Byb3RvLnBsdXNBbW91bnQgPSBmdW5jdGlvbiBwbHVzQW1vdW50KGFtb3VudCkge1xuICAgIHJlcXVpcmVOb25OdWxsKGFtb3VudCk7XG4gICAgcmV0dXJuIGFtb3VudC5hZGRUbyh0aGlzKTtcbiAgfTtcblxuICBfcHJvdG8ucGx1c0Ftb3VudFVuaXQgPSBmdW5jdGlvbiBwbHVzQW1vdW50VW5pdChhbW91bnRUb0FkZCwgdW5pdCkge1xuICAgIGlmICh1bml0IGluc3RhbmNlb2YgQ2hyb25vVW5pdCkge1xuICAgICAgaWYgKHVuaXQuaXNEYXRlQmFzZWQoKSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcmVzb2x2ZUxvY2FsKHRoaXMuX2RhdGVUaW1lLnBsdXMoYW1vdW50VG9BZGQsIHVuaXQpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9yZXNvbHZlSW5zdGFudCh0aGlzLl9kYXRlVGltZS5wbHVzKGFtb3VudFRvQWRkLCB1bml0KSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmVxdWlyZU5vbk51bGwodW5pdCwgJ3VuaXQnKTtcbiAgICByZXR1cm4gdW5pdC5hZGRUbyh0aGlzLCBhbW91bnRUb0FkZCk7XG4gIH07XG5cbiAgX3Byb3RvLnBsdXNZZWFycyA9IGZ1bmN0aW9uIHBsdXNZZWFycyh5ZWFycykge1xuICAgIHJldHVybiB0aGlzLl9yZXNvbHZlTG9jYWwodGhpcy5fZGF0ZVRpbWUucGx1c1llYXJzKHllYXJzKSk7XG4gIH07XG5cbiAgX3Byb3RvLnBsdXNNb250aHMgPSBmdW5jdGlvbiBwbHVzTW9udGhzKG1vbnRocykge1xuICAgIHJldHVybiB0aGlzLl9yZXNvbHZlTG9jYWwodGhpcy5fZGF0ZVRpbWUucGx1c01vbnRocyhtb250aHMpKTtcbiAgfTtcblxuICBfcHJvdG8ucGx1c1dlZWtzID0gZnVuY3Rpb24gcGx1c1dlZWtzKHdlZWtzKSB7XG4gICAgcmV0dXJuIHRoaXMuX3Jlc29sdmVMb2NhbCh0aGlzLl9kYXRlVGltZS5wbHVzV2Vla3Mod2Vla3MpKTtcbiAgfTtcblxuICBfcHJvdG8ucGx1c0RheXMgPSBmdW5jdGlvbiBwbHVzRGF5cyhkYXlzKSB7XG4gICAgcmV0dXJuIHRoaXMuX3Jlc29sdmVMb2NhbCh0aGlzLl9kYXRlVGltZS5wbHVzRGF5cyhkYXlzKSk7XG4gIH07XG5cbiAgX3Byb3RvLnBsdXNIb3VycyA9IGZ1bmN0aW9uIHBsdXNIb3Vycyhob3Vycykge1xuICAgIHJldHVybiB0aGlzLl9yZXNvbHZlSW5zdGFudCh0aGlzLl9kYXRlVGltZS5wbHVzSG91cnMoaG91cnMpKTtcbiAgfTtcblxuICBfcHJvdG8ucGx1c01pbnV0ZXMgPSBmdW5jdGlvbiBwbHVzTWludXRlcyhtaW51dGVzKSB7XG4gICAgcmV0dXJuIHRoaXMuX3Jlc29sdmVJbnN0YW50KHRoaXMuX2RhdGVUaW1lLnBsdXNNaW51dGVzKG1pbnV0ZXMpKTtcbiAgfTtcblxuICBfcHJvdG8ucGx1c1NlY29uZHMgPSBmdW5jdGlvbiBwbHVzU2Vjb25kcyhzZWNvbmRzKSB7XG4gICAgcmV0dXJuIHRoaXMuX3Jlc29sdmVJbnN0YW50KHRoaXMuX2RhdGVUaW1lLnBsdXNTZWNvbmRzKHNlY29uZHMpKTtcbiAgfTtcblxuICBfcHJvdG8ucGx1c05hbm9zID0gZnVuY3Rpb24gcGx1c05hbm9zKG5hbm9zKSB7XG4gICAgcmV0dXJuIHRoaXMuX3Jlc29sdmVJbnN0YW50KHRoaXMuX2RhdGVUaW1lLnBsdXNOYW5vcyhuYW5vcykpO1xuICB9O1xuXG4gIF9wcm90by5taW51c0Ftb3VudCA9IGZ1bmN0aW9uIG1pbnVzQW1vdW50KGFtb3VudCkge1xuICAgIHJlcXVpcmVOb25OdWxsKGFtb3VudCwgJ2Ftb3VudCcpO1xuICAgIHJldHVybiBhbW91bnQuc3VidHJhY3RGcm9tKHRoaXMpO1xuICB9O1xuXG4gIF9wcm90by5taW51c0Ftb3VudFVuaXQgPSBmdW5jdGlvbiBtaW51c0Ftb3VudFVuaXQoYW1vdW50VG9TdWJ0cmFjdCwgdW5pdCkge1xuICAgIHJldHVybiB0aGlzLnBsdXNBbW91bnRVbml0KC0xICogYW1vdW50VG9TdWJ0cmFjdCwgdW5pdCk7XG4gIH07XG5cbiAgX3Byb3RvLm1pbnVzWWVhcnMgPSBmdW5jdGlvbiBtaW51c1llYXJzKHllYXJzKSB7XG4gICAgcmV0dXJuIHRoaXMucGx1c1llYXJzKC0xICogeWVhcnMpO1xuICB9O1xuXG4gIF9wcm90by5taW51c01vbnRocyA9IGZ1bmN0aW9uIG1pbnVzTW9udGhzKG1vbnRocykge1xuICAgIHJldHVybiB0aGlzLnBsdXNNb250aHMoLTEgKiBtb250aHMpO1xuICB9O1xuXG4gIF9wcm90by5taW51c1dlZWtzID0gZnVuY3Rpb24gbWludXNXZWVrcyh3ZWVrcykge1xuICAgIHJldHVybiB0aGlzLnBsdXNXZWVrcygtMSAqIHdlZWtzKTtcbiAgfTtcblxuICBfcHJvdG8ubWludXNEYXlzID0gZnVuY3Rpb24gbWludXNEYXlzKGRheXMpIHtcbiAgICByZXR1cm4gdGhpcy5wbHVzRGF5cygtMSAqIGRheXMpO1xuICB9O1xuXG4gIF9wcm90by5taW51c0hvdXJzID0gZnVuY3Rpb24gbWludXNIb3Vycyhob3Vycykge1xuICAgIHJldHVybiB0aGlzLnBsdXNIb3VycygtMSAqIGhvdXJzKTtcbiAgfTtcblxuICBfcHJvdG8ubWludXNNaW51dGVzID0gZnVuY3Rpb24gbWludXNNaW51dGVzKG1pbnV0ZXMpIHtcbiAgICByZXR1cm4gdGhpcy5wbHVzTWludXRlcygtMSAqIG1pbnV0ZXMpO1xuICB9O1xuXG4gIF9wcm90by5taW51c1NlY29uZHMgPSBmdW5jdGlvbiBtaW51c1NlY29uZHMoc2Vjb25kcykge1xuICAgIHJldHVybiB0aGlzLnBsdXNTZWNvbmRzKC0xICogc2Vjb25kcyk7XG4gIH07XG5cbiAgX3Byb3RvLm1pbnVzTmFub3MgPSBmdW5jdGlvbiBtaW51c05hbm9zKG5hbm9zKSB7XG4gICAgcmV0dXJuIHRoaXMucGx1c05hbm9zKC0xICogbmFub3MpO1xuICB9O1xuXG4gIF9wcm90by5xdWVyeSA9IGZ1bmN0aW9uIHF1ZXJ5KF9xdWVyeSkge1xuICAgIGlmIChfcXVlcnkgPT09IFRlbXBvcmFsUXVlcmllcy5sb2NhbERhdGUoKSkge1xuICAgICAgcmV0dXJuIHRoaXMudG9Mb2NhbERhdGUoKTtcbiAgICB9XG5cbiAgICByZXF1aXJlTm9uTnVsbChfcXVlcnksICdxdWVyeScpO1xuICAgIHJldHVybiBfQ2hyb25vWm9uZWREYXRlVGltZS5wcm90b3R5cGUucXVlcnkuY2FsbCh0aGlzLCBfcXVlcnkpO1xuICB9O1xuXG4gIF9wcm90by51bnRpbCA9IGZ1bmN0aW9uIHVudGlsKGVuZEV4Y2x1c2l2ZSwgdW5pdCkge1xuICAgIHZhciBlbmQgPSBab25lZERhdGVUaW1lLmZyb20oZW5kRXhjbHVzaXZlKTtcblxuICAgIGlmICh1bml0IGluc3RhbmNlb2YgQ2hyb25vVW5pdCkge1xuICAgICAgZW5kID0gZW5kLndpdGhab25lU2FtZUluc3RhbnQodGhpcy5fem9uZSk7XG5cbiAgICAgIGlmICh1bml0LmlzRGF0ZUJhc2VkKCkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2RhdGVUaW1lLnVudGlsKGVuZC5fZGF0ZVRpbWUsIHVuaXQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIGRpZmZlcmVuY2UgPSB0aGlzLl9vZmZzZXQudG90YWxTZWNvbmRzKCkgLSBlbmQuX29mZnNldC50b3RhbFNlY29uZHMoKTtcblxuICAgICAgICB2YXIgYWRqdXN0ZWRFbmQgPSBlbmQuX2RhdGVUaW1lLnBsdXNTZWNvbmRzKGRpZmZlcmVuY2UpO1xuXG4gICAgICAgIHJldHVybiB0aGlzLl9kYXRlVGltZS51bnRpbChhZGp1c3RlZEVuZCwgdW5pdCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHVuaXQuYmV0d2Vlbih0aGlzLCBlbmQpO1xuICB9O1xuXG4gIF9wcm90by50b0xvY2FsRGF0ZVRpbWUgPSBmdW5jdGlvbiB0b0xvY2FsRGF0ZVRpbWUoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2RhdGVUaW1lO1xuICB9O1xuXG4gIF9wcm90by50b0xvY2FsRGF0ZSA9IGZ1bmN0aW9uIHRvTG9jYWxEYXRlKCkge1xuICAgIHJldHVybiB0aGlzLl9kYXRlVGltZS50b0xvY2FsRGF0ZSgpO1xuICB9O1xuXG4gIF9wcm90by50b0xvY2FsVGltZSA9IGZ1bmN0aW9uIHRvTG9jYWxUaW1lKCkge1xuICAgIHJldHVybiB0aGlzLl9kYXRlVGltZS50b0xvY2FsVGltZSgpO1xuICB9O1xuXG4gIF9wcm90by50b09mZnNldERhdGVUaW1lID0gZnVuY3Rpb24gdG9PZmZzZXREYXRlVGltZSgpIHtcbiAgICByZXR1cm4gT2Zmc2V0RGF0ZVRpbWUub2YodGhpcy5fZGF0ZVRpbWUsIHRoaXMuX29mZnNldCk7XG4gIH07XG5cbiAgX3Byb3RvLmVxdWFscyA9IGZ1bmN0aW9uIGVxdWFscyhvdGhlcikge1xuICAgIGlmICh0aGlzID09PSBvdGhlcikge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgaWYgKG90aGVyIGluc3RhbmNlb2YgWm9uZWREYXRlVGltZSkge1xuICAgICAgcmV0dXJuIHRoaXMuX2RhdGVUaW1lLmVxdWFscyhvdGhlci5fZGF0ZVRpbWUpICYmIHRoaXMuX29mZnNldC5lcXVhbHMob3RoZXIuX29mZnNldCkgJiYgdGhpcy5fem9uZS5lcXVhbHMob3RoZXIuX3pvbmUpO1xuICAgIH1cblxuICAgIHJldHVybiBmYWxzZTtcbiAgfTtcblxuICBfcHJvdG8uaGFzaENvZGUgPSBmdW5jdGlvbiBoYXNoQ29kZSgpIHtcbiAgICByZXR1cm4gTWF0aFV0aWwuaGFzaENvZGUodGhpcy5fZGF0ZVRpbWUuaGFzaENvZGUoKSwgdGhpcy5fb2Zmc2V0Lmhhc2hDb2RlKCksIHRoaXMuX3pvbmUuaGFzaENvZGUoKSk7XG4gIH07XG5cbiAgX3Byb3RvLnRvU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG4gICAgdmFyIHN0ciA9IHRoaXMuX2RhdGVUaW1lLnRvU3RyaW5nKCkgKyB0aGlzLl9vZmZzZXQudG9TdHJpbmcoKTtcblxuICAgIGlmICh0aGlzLl9vZmZzZXQgIT09IHRoaXMuX3pvbmUpIHtcbiAgICAgIHN0ciArPSAnWycgKyB0aGlzLl96b25lLnRvU3RyaW5nKCkgKyAnXSc7XG4gICAgfVxuXG4gICAgcmV0dXJuIHN0cjtcbiAgfTtcblxuICBfcHJvdG8udG9KU09OID0gZnVuY3Rpb24gdG9KU09OKCkge1xuICAgIHJldHVybiB0aGlzLnRvU3RyaW5nKCk7XG4gIH07XG5cbiAgX3Byb3RvLmZvcm1hdCA9IGZ1bmN0aW9uIGZvcm1hdChmb3JtYXR0ZXIpIHtcbiAgICByZXR1cm4gX0Nocm9ub1pvbmVkRGF0ZVRpbWUucHJvdG90eXBlLmZvcm1hdC5jYWxsKHRoaXMsIGZvcm1hdHRlcik7XG4gIH07XG5cbiAgcmV0dXJuIFpvbmVkRGF0ZVRpbWU7XG59KENocm9ub1pvbmVkRGF0ZVRpbWUpO1xuZnVuY3Rpb24gX2luaXQkZygpIHtcbiAgWm9uZWREYXRlVGltZS5GUk9NID0gY3JlYXRlVGVtcG9yYWxRdWVyeSgnWm9uZWREYXRlVGltZS5GUk9NJywgZnVuY3Rpb24gKHRlbXBvcmFsKSB7XG4gICAgcmV0dXJuIFpvbmVkRGF0ZVRpbWUuZnJvbSh0ZW1wb3JhbCk7XG4gIH0pO1xufVxuXG52YXIgT2Zmc2V0RGF0ZVRpbWUgPSBmdW5jdGlvbiAoX0RlZmF1bHRJbnRlcmZhY2VUZW1wKSB7XG4gIF9pbmhlcml0c0xvb3NlKE9mZnNldERhdGVUaW1lLCBfRGVmYXVsdEludGVyZmFjZVRlbXApO1xuXG4gIE9mZnNldERhdGVUaW1lLmZyb20gPSBmdW5jdGlvbiBmcm9tKHRlbXBvcmFsKSB7XG4gICAgcmVxdWlyZU5vbk51bGwodGVtcG9yYWwsICd0ZW1wb3JhbCcpO1xuXG4gICAgaWYgKHRlbXBvcmFsIGluc3RhbmNlb2YgT2Zmc2V0RGF0ZVRpbWUpIHtcbiAgICAgIHJldHVybiB0ZW1wb3JhbDtcbiAgICB9XG5cbiAgICB0cnkge1xuICAgICAgdmFyIG9mZnNldCA9IFpvbmVPZmZzZXQuZnJvbSh0ZW1wb3JhbCk7XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIHZhciBsZHQgPSBMb2NhbERhdGVUaW1lLmZyb20odGVtcG9yYWwpO1xuICAgICAgICByZXR1cm4gT2Zmc2V0RGF0ZVRpbWUub2YobGR0LCBvZmZzZXQpO1xuICAgICAgfSBjYXRjaCAoXykge1xuICAgICAgICB2YXIgaW5zdGFudCA9IEluc3RhbnQuZnJvbSh0ZW1wb3JhbCk7XG4gICAgICAgIHJldHVybiBPZmZzZXREYXRlVGltZS5vZkluc3RhbnQoaW5zdGFudCwgb2Zmc2V0KTtcbiAgICAgIH1cbiAgICB9IGNhdGNoIChleCkge1xuICAgICAgdGhyb3cgbmV3IERhdGVUaW1lRXhjZXB0aW9uKFwiVW5hYmxlIHRvIG9idGFpbiBPZmZzZXREYXRlVGltZSBUZW1wb3JhbEFjY2Vzc29yOiBcIiArIHRlbXBvcmFsICsgXCIsIHR5cGUgXCIgKyAodGVtcG9yYWwuY29uc3RydWN0b3IgIT0gbnVsbCA/IHRlbXBvcmFsLmNvbnN0cnVjdG9yLm5hbWUgOiAnJykpO1xuICAgIH1cbiAgfTtcblxuICBPZmZzZXREYXRlVGltZS5ub3cgPSBmdW5jdGlvbiBub3coY2xvY2tPclpvbmUpIHtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuIE9mZnNldERhdGVUaW1lLm5vdyhDbG9jay5zeXN0ZW1EZWZhdWx0Wm9uZSgpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVxdWlyZU5vbk51bGwoY2xvY2tPclpvbmUsICdjbG9ja09yWm9uZScpO1xuXG4gICAgICBpZiAoY2xvY2tPclpvbmUgaW5zdGFuY2VvZiBab25lSWQpIHtcbiAgICAgICAgcmV0dXJuIE9mZnNldERhdGVUaW1lLm5vdyhDbG9jay5zeXN0ZW0oY2xvY2tPclpvbmUpKTtcbiAgICAgIH0gZWxzZSBpZiAoY2xvY2tPclpvbmUgaW5zdGFuY2VvZiBDbG9jaykge1xuICAgICAgICB2YXIgbm93ID0gY2xvY2tPclpvbmUuaW5zdGFudCgpO1xuICAgICAgICByZXR1cm4gT2Zmc2V0RGF0ZVRpbWUub2ZJbnN0YW50KG5vdywgY2xvY2tPclpvbmUuem9uZSgpLnJ1bGVzKCkub2Zmc2V0KG5vdykpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IElsbGVnYWxBcmd1bWVudEV4Y2VwdGlvbignY2xvY2tPclpvbmUgbXVzdCBiZSBhbiBpbnN0YW5jZSBvZiBab25lSWQgb3IgQ2xvY2snKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgT2Zmc2V0RGF0ZVRpbWUub2YgPSBmdW5jdGlvbiBvZigpIHtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA8PSAyKSB7XG4gICAgICByZXR1cm4gT2Zmc2V0RGF0ZVRpbWUub2ZEYXRlVGltZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH0gZWxzZSBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMykge1xuICAgICAgcmV0dXJuIE9mZnNldERhdGVUaW1lLm9mRGF0ZUFuZFRpbWUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIE9mZnNldERhdGVUaW1lLm9mTnVtYmVycy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgfTtcblxuICBPZmZzZXREYXRlVGltZS5vZkRhdGVUaW1lID0gZnVuY3Rpb24gb2ZEYXRlVGltZShkYXRlVGltZSwgb2Zmc2V0KSB7XG4gICAgcmV0dXJuIG5ldyBPZmZzZXREYXRlVGltZShkYXRlVGltZSwgb2Zmc2V0KTtcbiAgfTtcblxuICBPZmZzZXREYXRlVGltZS5vZkRhdGVBbmRUaW1lID0gZnVuY3Rpb24gb2ZEYXRlQW5kVGltZShkYXRlLCB0aW1lLCBvZmZzZXQpIHtcbiAgICB2YXIgZHQgPSBMb2NhbERhdGVUaW1lLm9mKGRhdGUsIHRpbWUpO1xuICAgIHJldHVybiBuZXcgT2Zmc2V0RGF0ZVRpbWUoZHQsIG9mZnNldCk7XG4gIH07XG5cbiAgT2Zmc2V0RGF0ZVRpbWUub2ZOdW1iZXJzID0gZnVuY3Rpb24gb2ZOdW1iZXJzKHllYXIsIG1vbnRoLCBkYXlPZk1vbnRoLCBob3VyLCBtaW51dGUsIHNlY29uZCwgbmFub09mU2Vjb25kLCBvZmZzZXQpIHtcbiAgICBpZiAoaG91ciA9PT0gdm9pZCAwKSB7XG4gICAgICBob3VyID0gMDtcbiAgICB9XG5cbiAgICBpZiAobWludXRlID09PSB2b2lkIDApIHtcbiAgICAgIG1pbnV0ZSA9IDA7XG4gICAgfVxuXG4gICAgaWYgKHNlY29uZCA9PT0gdm9pZCAwKSB7XG4gICAgICBzZWNvbmQgPSAwO1xuICAgIH1cblxuICAgIGlmIChuYW5vT2ZTZWNvbmQgPT09IHZvaWQgMCkge1xuICAgICAgbmFub09mU2Vjb25kID0gMDtcbiAgICB9XG5cbiAgICB2YXIgZHQgPSBMb2NhbERhdGVUaW1lLm9mKHllYXIsIG1vbnRoLCBkYXlPZk1vbnRoLCBob3VyLCBtaW51dGUsIHNlY29uZCwgbmFub09mU2Vjb25kKTtcbiAgICByZXR1cm4gbmV3IE9mZnNldERhdGVUaW1lKGR0LCBvZmZzZXQpO1xuICB9O1xuXG4gIE9mZnNldERhdGVUaW1lLm9mSW5zdGFudCA9IGZ1bmN0aW9uIG9mSW5zdGFudChpbnN0YW50LCB6b25lKSB7XG4gICAgcmVxdWlyZU5vbk51bGwoaW5zdGFudCwgJ2luc3RhbnQnKTtcbiAgICByZXF1aXJlTm9uTnVsbCh6b25lLCAnem9uZScpO1xuICAgIHZhciBydWxlcyA9IHpvbmUucnVsZXMoKTtcbiAgICB2YXIgb2Zmc2V0ID0gcnVsZXMub2Zmc2V0KGluc3RhbnQpO1xuICAgIHZhciBsZHQgPSBMb2NhbERhdGVUaW1lLm9mRXBvY2hTZWNvbmQoaW5zdGFudC5lcG9jaFNlY29uZCgpLCBpbnN0YW50Lm5hbm8oKSwgb2Zmc2V0KTtcbiAgICByZXR1cm4gbmV3IE9mZnNldERhdGVUaW1lKGxkdCwgb2Zmc2V0KTtcbiAgfTtcblxuICBPZmZzZXREYXRlVGltZS5wYXJzZSA9IGZ1bmN0aW9uIHBhcnNlKHRleHQsIGZvcm1hdHRlcikge1xuICAgIGlmIChmb3JtYXR0ZXIgPT09IHZvaWQgMCkge1xuICAgICAgZm9ybWF0dGVyID0gRGF0ZVRpbWVGb3JtYXR0ZXIuSVNPX09GRlNFVF9EQVRFX1RJTUU7XG4gICAgfVxuXG4gICAgcmVxdWlyZU5vbk51bGwoZm9ybWF0dGVyLCAnZm9ybWF0dGVyJyk7XG4gICAgcmV0dXJuIGZvcm1hdHRlci5wYXJzZSh0ZXh0LCBPZmZzZXREYXRlVGltZS5GUk9NKTtcbiAgfTtcblxuICBmdW5jdGlvbiBPZmZzZXREYXRlVGltZShkYXRlVGltZSwgb2Zmc2V0KSB7XG4gICAgdmFyIF90aGlzO1xuXG4gICAgX3RoaXMgPSBfRGVmYXVsdEludGVyZmFjZVRlbXAuY2FsbCh0aGlzKSB8fCB0aGlzO1xuICAgIHJlcXVpcmVOb25OdWxsKGRhdGVUaW1lLCAnZGF0ZVRpbWUnKTtcbiAgICByZXF1aXJlSW5zdGFuY2UoZGF0ZVRpbWUsIExvY2FsRGF0ZVRpbWUsICdkYXRlVGltZScpO1xuICAgIHJlcXVpcmVOb25OdWxsKG9mZnNldCwgJ29mZnNldCcpO1xuICAgIHJlcXVpcmVJbnN0YW5jZShvZmZzZXQsIFpvbmVPZmZzZXQsICdvZmZzZXQnKTtcbiAgICBfdGhpcy5fZGF0ZVRpbWUgPSBkYXRlVGltZTtcbiAgICBfdGhpcy5fb2Zmc2V0ID0gb2Zmc2V0O1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuXG4gIHZhciBfcHJvdG8gPSBPZmZzZXREYXRlVGltZS5wcm90b3R5cGU7XG5cbiAgX3Byb3RvLmFkanVzdEludG8gPSBmdW5jdGlvbiBhZGp1c3RJbnRvKHRlbXBvcmFsKSB7XG4gICAgcmV0dXJuIHRlbXBvcmFsLndpdGgoQ2hyb25vRmllbGQuRVBPQ0hfREFZLCB0aGlzLnRvTG9jYWxEYXRlKCkudG9FcG9jaERheSgpKS53aXRoKENocm9ub0ZpZWxkLk5BTk9fT0ZfREFZLCB0aGlzLnRvTG9jYWxUaW1lKCkudG9OYW5vT2ZEYXkoKSkud2l0aChDaHJvbm9GaWVsZC5PRkZTRVRfU0VDT05EUywgdGhpcy5vZmZzZXQoKS50b3RhbFNlY29uZHMoKSk7XG4gIH07XG5cbiAgX3Byb3RvLnVudGlsID0gZnVuY3Rpb24gdW50aWwoZW5kRXhjbHVzaXZlLCB1bml0KSB7XG4gICAgdmFyIGVuZCA9IE9mZnNldERhdGVUaW1lLmZyb20oZW5kRXhjbHVzaXZlKTtcblxuICAgIGlmICh1bml0IGluc3RhbmNlb2YgQ2hyb25vVW5pdCkge1xuICAgICAgZW5kID0gZW5kLndpdGhPZmZzZXRTYW1lSW5zdGFudCh0aGlzLl9vZmZzZXQpO1xuICAgICAgcmV0dXJuIHRoaXMuX2RhdGVUaW1lLnVudGlsKGVuZC5fZGF0ZVRpbWUsIHVuaXQpO1xuICAgIH1cblxuICAgIHJldHVybiB1bml0LmJldHdlZW4odGhpcywgZW5kKTtcbiAgfTtcblxuICBfcHJvdG8uYXRab25lU2FtZUluc3RhbnQgPSBmdW5jdGlvbiBhdFpvbmVTYW1lSW5zdGFudCh6b25lKSB7XG4gICAgcmV0dXJuIFpvbmVkRGF0ZVRpbWUub2ZJbnN0YW50KHRoaXMuX2RhdGVUaW1lLCB0aGlzLl9vZmZzZXQsIHpvbmUpO1xuICB9O1xuXG4gIF9wcm90by5hdFpvbmVTaW1pbGFyTG9jYWwgPSBmdW5jdGlvbiBhdFpvbmVTaW1pbGFyTG9jYWwoem9uZSkge1xuICAgIHJldHVybiBab25lZERhdGVUaW1lLm9mTG9jYWwodGhpcy5fZGF0ZVRpbWUsIHpvbmUsIHRoaXMuX29mZnNldCk7XG4gIH07XG5cbiAgX3Byb3RvLnF1ZXJ5ID0gZnVuY3Rpb24gcXVlcnkoX3F1ZXJ5KSB7XG4gICAgcmVxdWlyZU5vbk51bGwoX3F1ZXJ5LCAncXVlcnknKTtcblxuICAgIGlmIChfcXVlcnkgPT09IFRlbXBvcmFsUXVlcmllcy5jaHJvbm9sb2d5KCkpIHtcbiAgICAgIHJldHVybiBJc29DaHJvbm9sb2d5LklOU1RBTkNFO1xuICAgIH0gZWxzZSBpZiAoX3F1ZXJ5ID09PSBUZW1wb3JhbFF1ZXJpZXMucHJlY2lzaW9uKCkpIHtcbiAgICAgIHJldHVybiBDaHJvbm9Vbml0Lk5BTk9TO1xuICAgIH0gZWxzZSBpZiAoX3F1ZXJ5ID09PSBUZW1wb3JhbFF1ZXJpZXMub2Zmc2V0KCkgfHwgX3F1ZXJ5ID09PSBUZW1wb3JhbFF1ZXJpZXMuem9uZSgpKSB7XG4gICAgICByZXR1cm4gdGhpcy5vZmZzZXQoKTtcbiAgICB9IGVsc2UgaWYgKF9xdWVyeSA9PT0gVGVtcG9yYWxRdWVyaWVzLmxvY2FsRGF0ZSgpKSB7XG4gICAgICByZXR1cm4gdGhpcy50b0xvY2FsRGF0ZSgpO1xuICAgIH0gZWxzZSBpZiAoX3F1ZXJ5ID09PSBUZW1wb3JhbFF1ZXJpZXMubG9jYWxUaW1lKCkpIHtcbiAgICAgIHJldHVybiB0aGlzLnRvTG9jYWxUaW1lKCk7XG4gICAgfSBlbHNlIGlmIChfcXVlcnkgPT09IFRlbXBvcmFsUXVlcmllcy56b25lSWQoKSkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgcmV0dXJuIF9EZWZhdWx0SW50ZXJmYWNlVGVtcC5wcm90b3R5cGUucXVlcnkuY2FsbCh0aGlzLCBfcXVlcnkpO1xuICB9O1xuXG4gIF9wcm90by5nZXQgPSBmdW5jdGlvbiBnZXQoZmllbGQpIHtcbiAgICBpZiAoZmllbGQgaW5zdGFuY2VvZiBDaHJvbm9GaWVsZCkge1xuICAgICAgc3dpdGNoIChmaWVsZCkge1xuICAgICAgICBjYXNlIENocm9ub0ZpZWxkLklOU1RBTlRfU0VDT05EUzpcbiAgICAgICAgICB0aHJvdyBuZXcgRGF0ZVRpbWVFeGNlcHRpb24oJ0ZpZWxkIHRvbyBsYXJnZSBmb3IgYW4gaW50OiAnICsgZmllbGQpO1xuXG4gICAgICAgIGNhc2UgQ2hyb25vRmllbGQuT0ZGU0VUX1NFQ09ORFM6XG4gICAgICAgICAgcmV0dXJuIHRoaXMub2Zmc2V0KCkudG90YWxTZWNvbmRzKCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzLl9kYXRlVGltZS5nZXQoZmllbGQpO1xuICAgIH1cblxuICAgIHJldHVybiBfRGVmYXVsdEludGVyZmFjZVRlbXAucHJvdG90eXBlLmdldC5jYWxsKHRoaXMsIGZpZWxkKTtcbiAgfTtcblxuICBfcHJvdG8uZ2V0TG9uZyA9IGZ1bmN0aW9uIGdldExvbmcoZmllbGQpIHtcbiAgICBpZiAoZmllbGQgaW5zdGFuY2VvZiBDaHJvbm9GaWVsZCkge1xuICAgICAgc3dpdGNoIChmaWVsZCkge1xuICAgICAgICBjYXNlIENocm9ub0ZpZWxkLklOU1RBTlRfU0VDT05EUzpcbiAgICAgICAgICByZXR1cm4gdGhpcy50b0Vwb2NoU2Vjb25kKCk7XG5cbiAgICAgICAgY2FzZSBDaHJvbm9GaWVsZC5PRkZTRVRfU0VDT05EUzpcbiAgICAgICAgICByZXR1cm4gdGhpcy5vZmZzZXQoKS50b3RhbFNlY29uZHMoKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXMuX2RhdGVUaW1lLmdldExvbmcoZmllbGQpO1xuICAgIH1cblxuICAgIHJldHVybiBmaWVsZC5nZXRGcm9tKHRoaXMpO1xuICB9O1xuXG4gIF9wcm90by5vZmZzZXQgPSBmdW5jdGlvbiBvZmZzZXQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX29mZnNldDtcbiAgfTtcblxuICBfcHJvdG8ueWVhciA9IGZ1bmN0aW9uIHllYXIoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2RhdGVUaW1lLnllYXIoKTtcbiAgfTtcblxuICBfcHJvdG8ubW9udGhWYWx1ZSA9IGZ1bmN0aW9uIG1vbnRoVmFsdWUoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2RhdGVUaW1lLm1vbnRoVmFsdWUoKTtcbiAgfTtcblxuICBfcHJvdG8ubW9udGggPSBmdW5jdGlvbiBtb250aCgpIHtcbiAgICByZXR1cm4gdGhpcy5fZGF0ZVRpbWUubW9udGgoKTtcbiAgfTtcblxuICBfcHJvdG8uZGF5T2ZNb250aCA9IGZ1bmN0aW9uIGRheU9mTW9udGgoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2RhdGVUaW1lLmRheU9mTW9udGgoKTtcbiAgfTtcblxuICBfcHJvdG8uZGF5T2ZZZWFyID0gZnVuY3Rpb24gZGF5T2ZZZWFyKCkge1xuICAgIHJldHVybiB0aGlzLl9kYXRlVGltZS5kYXlPZlllYXIoKTtcbiAgfTtcblxuICBfcHJvdG8uZGF5T2ZXZWVrID0gZnVuY3Rpb24gZGF5T2ZXZWVrKCkge1xuICAgIHJldHVybiB0aGlzLl9kYXRlVGltZS5kYXlPZldlZWsoKTtcbiAgfTtcblxuICBfcHJvdG8uaG91ciA9IGZ1bmN0aW9uIGhvdXIoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2RhdGVUaW1lLmhvdXIoKTtcbiAgfTtcblxuICBfcHJvdG8ubWludXRlID0gZnVuY3Rpb24gbWludXRlKCkge1xuICAgIHJldHVybiB0aGlzLl9kYXRlVGltZS5taW51dGUoKTtcbiAgfTtcblxuICBfcHJvdG8uc2Vjb25kID0gZnVuY3Rpb24gc2Vjb25kKCkge1xuICAgIHJldHVybiB0aGlzLl9kYXRlVGltZS5zZWNvbmQoKTtcbiAgfTtcblxuICBfcHJvdG8ubmFubyA9IGZ1bmN0aW9uIG5hbm8oKSB7XG4gICAgcmV0dXJuIHRoaXMuX2RhdGVUaW1lLm5hbm8oKTtcbiAgfTtcblxuICBfcHJvdG8udG9Mb2NhbERhdGVUaW1lID0gZnVuY3Rpb24gdG9Mb2NhbERhdGVUaW1lKCkge1xuICAgIHJldHVybiB0aGlzLl9kYXRlVGltZTtcbiAgfTtcblxuICBfcHJvdG8udG9Mb2NhbERhdGUgPSBmdW5jdGlvbiB0b0xvY2FsRGF0ZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fZGF0ZVRpbWUudG9Mb2NhbERhdGUoKTtcbiAgfTtcblxuICBfcHJvdG8udG9Mb2NhbFRpbWUgPSBmdW5jdGlvbiB0b0xvY2FsVGltZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fZGF0ZVRpbWUudG9Mb2NhbFRpbWUoKTtcbiAgfTtcblxuICBfcHJvdG8udG9PZmZzZXRUaW1lID0gZnVuY3Rpb24gdG9PZmZzZXRUaW1lKCkge1xuICAgIHJldHVybiBPZmZzZXRUaW1lLm9mKHRoaXMuX2RhdGVUaW1lLnRvTG9jYWxUaW1lKCksIHRoaXMuX29mZnNldCk7XG4gIH07XG5cbiAgX3Byb3RvLnRvWm9uZWREYXRlVGltZSA9IGZ1bmN0aW9uIHRvWm9uZWREYXRlVGltZSgpIHtcbiAgICByZXR1cm4gWm9uZWREYXRlVGltZS5vZih0aGlzLl9kYXRlVGltZSwgdGhpcy5fb2Zmc2V0KTtcbiAgfTtcblxuICBfcHJvdG8udG9JbnN0YW50ID0gZnVuY3Rpb24gdG9JbnN0YW50KCkge1xuICAgIHJldHVybiB0aGlzLl9kYXRlVGltZS50b0luc3RhbnQodGhpcy5fb2Zmc2V0KTtcbiAgfTtcblxuICBfcHJvdG8udG9FcG9jaFNlY29uZCA9IGZ1bmN0aW9uIHRvRXBvY2hTZWNvbmQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2RhdGVUaW1lLnRvRXBvY2hTZWNvbmQodGhpcy5fb2Zmc2V0KTtcbiAgfTtcblxuICBfcHJvdG8uaXNTdXBwb3J0ZWQgPSBmdW5jdGlvbiBpc1N1cHBvcnRlZChmaWVsZE9yVW5pdCkge1xuICAgIGlmIChmaWVsZE9yVW5pdCBpbnN0YW5jZW9mIENocm9ub0ZpZWxkKSB7XG4gICAgICByZXR1cm4gZmllbGRPclVuaXQuaXNEYXRlQmFzZWQoKSB8fCBmaWVsZE9yVW5pdC5pc1RpbWVCYXNlZCgpO1xuICAgIH1cblxuICAgIGlmIChmaWVsZE9yVW5pdCBpbnN0YW5jZW9mIENocm9ub1VuaXQpIHtcbiAgICAgIHJldHVybiBmaWVsZE9yVW5pdC5pc0RhdGVCYXNlZCgpIHx8IGZpZWxkT3JVbml0LmlzVGltZUJhc2VkKCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZpZWxkT3JVbml0ICE9IG51bGwgJiYgZmllbGRPclVuaXQuaXNTdXBwb3J0ZWRCeSh0aGlzKTtcbiAgfTtcblxuICBfcHJvdG8ucmFuZ2UgPSBmdW5jdGlvbiByYW5nZShmaWVsZCkge1xuICAgIGlmIChmaWVsZCBpbnN0YW5jZW9mIENocm9ub0ZpZWxkKSB7XG4gICAgICBpZiAoZmllbGQgPT09IENocm9ub0ZpZWxkLklOU1RBTlRfU0VDT05EUyB8fCBmaWVsZCA9PT0gQ2hyb25vRmllbGQuT0ZGU0VUX1NFQ09ORFMpIHtcbiAgICAgICAgcmV0dXJuIGZpZWxkLnJhbmdlKCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzLl9kYXRlVGltZS5yYW5nZShmaWVsZCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZpZWxkLnJhbmdlUmVmaW5lZEJ5KHRoaXMpO1xuICB9O1xuXG4gIF9wcm90by53aXRoQWRqdXN0ZXIgPSBmdW5jdGlvbiB3aXRoQWRqdXN0ZXIoYWRqdXN0ZXIpIHtcbiAgICByZXF1aXJlTm9uTnVsbChhZGp1c3Rlcik7XG5cbiAgICBpZiAoYWRqdXN0ZXIgaW5zdGFuY2VvZiBMb2NhbERhdGUgfHwgYWRqdXN0ZXIgaW5zdGFuY2VvZiBMb2NhbFRpbWUgfHwgYWRqdXN0ZXIgaW5zdGFuY2VvZiBMb2NhbERhdGVUaW1lKSB7XG4gICAgICByZXR1cm4gdGhpcy5fd2l0aERhdGVUaW1lT2Zmc2V0KHRoaXMuX2RhdGVUaW1lLndpdGgoYWRqdXN0ZXIpLCB0aGlzLl9vZmZzZXQpO1xuICAgIH0gZWxzZSBpZiAoYWRqdXN0ZXIgaW5zdGFuY2VvZiBJbnN0YW50KSB7XG4gICAgICByZXR1cm4gT2Zmc2V0RGF0ZVRpbWUub2ZJbnN0YW50KGFkanVzdGVyLCB0aGlzLl9vZmZzZXQpO1xuICAgIH0gZWxzZSBpZiAoYWRqdXN0ZXIgaW5zdGFuY2VvZiBab25lT2Zmc2V0KSB7XG4gICAgICByZXR1cm4gdGhpcy5fd2l0aERhdGVUaW1lT2Zmc2V0KHRoaXMuX2RhdGVUaW1lLCBhZGp1c3Rlcik7XG4gICAgfSBlbHNlIGlmIChhZGp1c3RlciBpbnN0YW5jZW9mIE9mZnNldERhdGVUaW1lKSB7XG4gICAgICByZXR1cm4gYWRqdXN0ZXI7XG4gICAgfVxuXG4gICAgcmV0dXJuIGFkanVzdGVyLmFkanVzdEludG8odGhpcyk7XG4gIH07XG5cbiAgX3Byb3RvLndpdGhGaWVsZFZhbHVlID0gZnVuY3Rpb24gd2l0aEZpZWxkVmFsdWUoZmllbGQsIG5ld1ZhbHVlKSB7XG4gICAgcmVxdWlyZU5vbk51bGwoZmllbGQpO1xuXG4gICAgaWYgKGZpZWxkIGluc3RhbmNlb2YgQ2hyb25vRmllbGQpIHtcbiAgICAgIHZhciBmID0gZmllbGQ7XG5cbiAgICAgIHN3aXRjaCAoZikge1xuICAgICAgICBjYXNlIENocm9ub0ZpZWxkLklOU1RBTlRfU0VDT05EUzpcbiAgICAgICAgICByZXR1cm4gT2Zmc2V0RGF0ZVRpbWUub2ZJbnN0YW50KEluc3RhbnQub2ZFcG9jaFNlY29uZChuZXdWYWx1ZSwgdGhpcy5uYW5vKCkpLCB0aGlzLl9vZmZzZXQpO1xuXG4gICAgICAgIGNhc2UgQ2hyb25vRmllbGQuT0ZGU0VUX1NFQ09ORFM6XG4gICAgICAgICAge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3dpdGhEYXRlVGltZU9mZnNldCh0aGlzLl9kYXRlVGltZSwgWm9uZU9mZnNldC5vZlRvdGFsU2Vjb25kcyhmLmNoZWNrVmFsaWRJbnRWYWx1ZShuZXdWYWx1ZSkpKTtcbiAgICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzLl93aXRoRGF0ZVRpbWVPZmZzZXQodGhpcy5fZGF0ZVRpbWUud2l0aChmaWVsZCwgbmV3VmFsdWUpLCB0aGlzLl9vZmZzZXQpO1xuICAgIH1cblxuICAgIHJldHVybiBmaWVsZC5hZGp1c3RJbnRvKHRoaXMsIG5ld1ZhbHVlKTtcbiAgfTtcblxuICBfcHJvdG8uX3dpdGhEYXRlVGltZU9mZnNldCA9IGZ1bmN0aW9uIF93aXRoRGF0ZVRpbWVPZmZzZXQoZGF0ZVRpbWUsIG9mZnNldCkge1xuICAgIGlmICh0aGlzLl9kYXRlVGltZSA9PT0gZGF0ZVRpbWUgJiYgdGhpcy5fb2Zmc2V0LmVxdWFscyhvZmZzZXQpKSB7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICByZXR1cm4gbmV3IE9mZnNldERhdGVUaW1lKGRhdGVUaW1lLCBvZmZzZXQpO1xuICB9O1xuXG4gIF9wcm90by53aXRoWWVhciA9IGZ1bmN0aW9uIHdpdGhZZWFyKHllYXIpIHtcbiAgICByZXR1cm4gdGhpcy5fd2l0aERhdGVUaW1lT2Zmc2V0KHRoaXMuX2RhdGVUaW1lLndpdGhZZWFyKHllYXIpLCB0aGlzLl9vZmZzZXQpO1xuICB9O1xuXG4gIF9wcm90by53aXRoTW9udGggPSBmdW5jdGlvbiB3aXRoTW9udGgobW9udGgpIHtcbiAgICByZXR1cm4gdGhpcy5fd2l0aERhdGVUaW1lT2Zmc2V0KHRoaXMuX2RhdGVUaW1lLndpdGhNb250aChtb250aCksIHRoaXMuX29mZnNldCk7XG4gIH07XG5cbiAgX3Byb3RvLndpdGhEYXlPZk1vbnRoID0gZnVuY3Rpb24gd2l0aERheU9mTW9udGgoZGF5T2ZNb250aCkge1xuICAgIHJldHVybiB0aGlzLl93aXRoRGF0ZVRpbWVPZmZzZXQodGhpcy5fZGF0ZVRpbWUud2l0aERheU9mTW9udGgoZGF5T2ZNb250aCksIHRoaXMuX29mZnNldCk7XG4gIH07XG5cbiAgX3Byb3RvLndpdGhEYXlPZlllYXIgPSBmdW5jdGlvbiB3aXRoRGF5T2ZZZWFyKGRheU9mWWVhcikge1xuICAgIHJldHVybiB0aGlzLl93aXRoRGF0ZVRpbWVPZmZzZXQodGhpcy5fZGF0ZVRpbWUud2l0aERheU9mWWVhcihkYXlPZlllYXIpLCB0aGlzLl9vZmZzZXQpO1xuICB9O1xuXG4gIF9wcm90by53aXRoSG91ciA9IGZ1bmN0aW9uIHdpdGhIb3VyKGhvdXIpIHtcbiAgICByZXR1cm4gdGhpcy5fd2l0aERhdGVUaW1lT2Zmc2V0KHRoaXMuX2RhdGVUaW1lLndpdGhIb3VyKGhvdXIpLCB0aGlzLl9vZmZzZXQpO1xuICB9O1xuXG4gIF9wcm90by53aXRoTWludXRlID0gZnVuY3Rpb24gd2l0aE1pbnV0ZShtaW51dGUpIHtcbiAgICByZXR1cm4gdGhpcy5fd2l0aERhdGVUaW1lT2Zmc2V0KHRoaXMuX2RhdGVUaW1lLndpdGhNaW51dGUobWludXRlKSwgdGhpcy5fb2Zmc2V0KTtcbiAgfTtcblxuICBfcHJvdG8ud2l0aFNlY29uZCA9IGZ1bmN0aW9uIHdpdGhTZWNvbmQoc2Vjb25kKSB7XG4gICAgcmV0dXJuIHRoaXMuX3dpdGhEYXRlVGltZU9mZnNldCh0aGlzLl9kYXRlVGltZS53aXRoU2Vjb25kKHNlY29uZCksIHRoaXMuX29mZnNldCk7XG4gIH07XG5cbiAgX3Byb3RvLndpdGhOYW5vID0gZnVuY3Rpb24gd2l0aE5hbm8obmFub09mU2Vjb25kKSB7XG4gICAgcmV0dXJuIHRoaXMuX3dpdGhEYXRlVGltZU9mZnNldCh0aGlzLl9kYXRlVGltZS53aXRoTmFubyhuYW5vT2ZTZWNvbmQpLCB0aGlzLl9vZmZzZXQpO1xuICB9O1xuXG4gIF9wcm90by53aXRoT2Zmc2V0U2FtZUxvY2FsID0gZnVuY3Rpb24gd2l0aE9mZnNldFNhbWVMb2NhbChvZmZzZXQpIHtcbiAgICByZXF1aXJlTm9uTnVsbChvZmZzZXQsICdvZmZzZXQnKTtcbiAgICByZXR1cm4gdGhpcy5fd2l0aERhdGVUaW1lT2Zmc2V0KHRoaXMuX2RhdGVUaW1lLCBvZmZzZXQpO1xuICB9O1xuXG4gIF9wcm90by53aXRoT2Zmc2V0U2FtZUluc3RhbnQgPSBmdW5jdGlvbiB3aXRoT2Zmc2V0U2FtZUluc3RhbnQob2Zmc2V0KSB7XG4gICAgcmVxdWlyZU5vbk51bGwob2Zmc2V0LCAnb2Zmc2V0Jyk7XG5cbiAgICBpZiAob2Zmc2V0LmVxdWFscyh0aGlzLl9vZmZzZXQpKSB7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICB2YXIgZGlmZmVyZW5jZSA9IG9mZnNldC50b3RhbFNlY29uZHMoKSAtIHRoaXMuX29mZnNldC50b3RhbFNlY29uZHMoKTtcblxuICAgIHZhciBhZGp1c3RlZCA9IHRoaXMuX2RhdGVUaW1lLnBsdXNTZWNvbmRzKGRpZmZlcmVuY2UpO1xuXG4gICAgcmV0dXJuIG5ldyBPZmZzZXREYXRlVGltZShhZGp1c3RlZCwgb2Zmc2V0KTtcbiAgfTtcblxuICBfcHJvdG8udHJ1bmNhdGVkVG8gPSBmdW5jdGlvbiB0cnVuY2F0ZWRUbyh1bml0KSB7XG4gICAgcmV0dXJuIHRoaXMuX3dpdGhEYXRlVGltZU9mZnNldCh0aGlzLl9kYXRlVGltZS50cnVuY2F0ZWRUbyh1bml0KSwgdGhpcy5fb2Zmc2V0KTtcbiAgfTtcblxuICBfcHJvdG8ucGx1c0Ftb3VudCA9IGZ1bmN0aW9uIHBsdXNBbW91bnQoYW1vdW50KSB7XG4gICAgcmVxdWlyZU5vbk51bGwoYW1vdW50LCAnYW1vdW50Jyk7XG4gICAgcmV0dXJuIGFtb3VudC5hZGRUbyh0aGlzKTtcbiAgfTtcblxuICBfcHJvdG8ucGx1c0Ftb3VudFVuaXQgPSBmdW5jdGlvbiBwbHVzQW1vdW50VW5pdChhbW91bnRUb0FkZCwgdW5pdCkge1xuICAgIGlmICh1bml0IGluc3RhbmNlb2YgQ2hyb25vVW5pdCkge1xuICAgICAgcmV0dXJuIHRoaXMuX3dpdGhEYXRlVGltZU9mZnNldCh0aGlzLl9kYXRlVGltZS5wbHVzKGFtb3VudFRvQWRkLCB1bml0KSwgdGhpcy5fb2Zmc2V0KTtcbiAgICB9XG5cbiAgICByZXR1cm4gdW5pdC5hZGRUbyh0aGlzLCBhbW91bnRUb0FkZCk7XG4gIH07XG5cbiAgX3Byb3RvLnBsdXNZZWFycyA9IGZ1bmN0aW9uIHBsdXNZZWFycyh5ZWFycykge1xuICAgIHJldHVybiB0aGlzLl93aXRoRGF0ZVRpbWVPZmZzZXQodGhpcy5fZGF0ZVRpbWUucGx1c1llYXJzKHllYXJzKSwgdGhpcy5fb2Zmc2V0KTtcbiAgfTtcblxuICBfcHJvdG8ucGx1c01vbnRocyA9IGZ1bmN0aW9uIHBsdXNNb250aHMobW9udGhzKSB7XG4gICAgcmV0dXJuIHRoaXMuX3dpdGhEYXRlVGltZU9mZnNldCh0aGlzLl9kYXRlVGltZS5wbHVzTW9udGhzKG1vbnRocyksIHRoaXMuX29mZnNldCk7XG4gIH07XG5cbiAgX3Byb3RvLnBsdXNXZWVrcyA9IGZ1bmN0aW9uIHBsdXNXZWVrcyh3ZWVrcykge1xuICAgIHJldHVybiB0aGlzLl93aXRoRGF0ZVRpbWVPZmZzZXQodGhpcy5fZGF0ZVRpbWUucGx1c1dlZWtzKHdlZWtzKSwgdGhpcy5fb2Zmc2V0KTtcbiAgfTtcblxuICBfcHJvdG8ucGx1c0RheXMgPSBmdW5jdGlvbiBwbHVzRGF5cyhkYXlzKSB7XG4gICAgcmV0dXJuIHRoaXMuX3dpdGhEYXRlVGltZU9mZnNldCh0aGlzLl9kYXRlVGltZS5wbHVzRGF5cyhkYXlzKSwgdGhpcy5fb2Zmc2V0KTtcbiAgfTtcblxuICBfcHJvdG8ucGx1c0hvdXJzID0gZnVuY3Rpb24gcGx1c0hvdXJzKGhvdXJzKSB7XG4gICAgcmV0dXJuIHRoaXMuX3dpdGhEYXRlVGltZU9mZnNldCh0aGlzLl9kYXRlVGltZS5wbHVzSG91cnMoaG91cnMpLCB0aGlzLl9vZmZzZXQpO1xuICB9O1xuXG4gIF9wcm90by5wbHVzTWludXRlcyA9IGZ1bmN0aW9uIHBsdXNNaW51dGVzKG1pbnV0ZXMpIHtcbiAgICByZXR1cm4gdGhpcy5fd2l0aERhdGVUaW1lT2Zmc2V0KHRoaXMuX2RhdGVUaW1lLnBsdXNNaW51dGVzKG1pbnV0ZXMpLCB0aGlzLl9vZmZzZXQpO1xuICB9O1xuXG4gIF9wcm90by5wbHVzU2Vjb25kcyA9IGZ1bmN0aW9uIHBsdXNTZWNvbmRzKHNlY29uZHMpIHtcbiAgICByZXR1cm4gdGhpcy5fd2l0aERhdGVUaW1lT2Zmc2V0KHRoaXMuX2RhdGVUaW1lLnBsdXNTZWNvbmRzKHNlY29uZHMpLCB0aGlzLl9vZmZzZXQpO1xuICB9O1xuXG4gIF9wcm90by5wbHVzTmFub3MgPSBmdW5jdGlvbiBwbHVzTmFub3MobmFub3MpIHtcbiAgICByZXR1cm4gdGhpcy5fd2l0aERhdGVUaW1lT2Zmc2V0KHRoaXMuX2RhdGVUaW1lLnBsdXNOYW5vcyhuYW5vcyksIHRoaXMuX29mZnNldCk7XG4gIH07XG5cbiAgX3Byb3RvLm1pbnVzQW1vdW50ID0gZnVuY3Rpb24gbWludXNBbW91bnQoYW1vdW50KSB7XG4gICAgcmVxdWlyZU5vbk51bGwoYW1vdW50KTtcbiAgICByZXR1cm4gYW1vdW50LnN1YnRyYWN0RnJvbSh0aGlzKTtcbiAgfTtcblxuICBfcHJvdG8ubWludXNBbW91bnRVbml0ID0gZnVuY3Rpb24gbWludXNBbW91bnRVbml0KGFtb3VudFRvU3VidHJhY3QsIHVuaXQpIHtcbiAgICByZXR1cm4gdGhpcy5wbHVzKC0xICogYW1vdW50VG9TdWJ0cmFjdCwgdW5pdCk7XG4gIH07XG5cbiAgX3Byb3RvLm1pbnVzWWVhcnMgPSBmdW5jdGlvbiBtaW51c1llYXJzKHllYXJzKSB7XG4gICAgcmV0dXJuIHRoaXMuX3dpdGhEYXRlVGltZU9mZnNldCh0aGlzLl9kYXRlVGltZS5taW51c1llYXJzKHllYXJzKSwgdGhpcy5fb2Zmc2V0KTtcbiAgfTtcblxuICBfcHJvdG8ubWludXNNb250aHMgPSBmdW5jdGlvbiBtaW51c01vbnRocyhtb250aHMpIHtcbiAgICByZXR1cm4gdGhpcy5fd2l0aERhdGVUaW1lT2Zmc2V0KHRoaXMuX2RhdGVUaW1lLm1pbnVzTW9udGhzKG1vbnRocyksIHRoaXMuX29mZnNldCk7XG4gIH07XG5cbiAgX3Byb3RvLm1pbnVzV2Vla3MgPSBmdW5jdGlvbiBtaW51c1dlZWtzKHdlZWtzKSB7XG4gICAgcmV0dXJuIHRoaXMuX3dpdGhEYXRlVGltZU9mZnNldCh0aGlzLl9kYXRlVGltZS5taW51c1dlZWtzKHdlZWtzKSwgdGhpcy5fb2Zmc2V0KTtcbiAgfTtcblxuICBfcHJvdG8ubWludXNEYXlzID0gZnVuY3Rpb24gbWludXNEYXlzKGRheXMpIHtcbiAgICByZXR1cm4gdGhpcy5fd2l0aERhdGVUaW1lT2Zmc2V0KHRoaXMuX2RhdGVUaW1lLm1pbnVzRGF5cyhkYXlzKSwgdGhpcy5fb2Zmc2V0KTtcbiAgfTtcblxuICBfcHJvdG8ubWludXNIb3VycyA9IGZ1bmN0aW9uIG1pbnVzSG91cnMoaG91cnMpIHtcbiAgICByZXR1cm4gdGhpcy5fd2l0aERhdGVUaW1lT2Zmc2V0KHRoaXMuX2RhdGVUaW1lLm1pbnVzSG91cnMoaG91cnMpLCB0aGlzLl9vZmZzZXQpO1xuICB9O1xuXG4gIF9wcm90by5taW51c01pbnV0ZXMgPSBmdW5jdGlvbiBtaW51c01pbnV0ZXMobWludXRlcykge1xuICAgIHJldHVybiB0aGlzLl93aXRoRGF0ZVRpbWVPZmZzZXQodGhpcy5fZGF0ZVRpbWUubWludXNNaW51dGVzKG1pbnV0ZXMpLCB0aGlzLl9vZmZzZXQpO1xuICB9O1xuXG4gIF9wcm90by5taW51c1NlY29uZHMgPSBmdW5jdGlvbiBtaW51c1NlY29uZHMoc2Vjb25kcykge1xuICAgIHJldHVybiB0aGlzLl93aXRoRGF0ZVRpbWVPZmZzZXQodGhpcy5fZGF0ZVRpbWUubWludXNTZWNvbmRzKHNlY29uZHMpLCB0aGlzLl9vZmZzZXQpO1xuICB9O1xuXG4gIF9wcm90by5taW51c05hbm9zID0gZnVuY3Rpb24gbWludXNOYW5vcyhuYW5vcykge1xuICAgIHJldHVybiB0aGlzLl93aXRoRGF0ZVRpbWVPZmZzZXQodGhpcy5fZGF0ZVRpbWUubWludXNOYW5vcyhuYW5vcyksIHRoaXMuX29mZnNldCk7XG4gIH07XG5cbiAgX3Byb3RvLmNvbXBhcmVUbyA9IGZ1bmN0aW9uIGNvbXBhcmVUbyhvdGhlcikge1xuICAgIHJlcXVpcmVOb25OdWxsKG90aGVyLCAnb3RoZXInKTtcbiAgICByZXF1aXJlSW5zdGFuY2Uob3RoZXIsIE9mZnNldERhdGVUaW1lLCAnb3RoZXInKTtcblxuICAgIGlmICh0aGlzLm9mZnNldCgpLmVxdWFscyhvdGhlci5vZmZzZXQoKSkpIHtcbiAgICAgIHJldHVybiB0aGlzLnRvTG9jYWxEYXRlVGltZSgpLmNvbXBhcmVUbyhvdGhlci50b0xvY2FsRGF0ZVRpbWUoKSk7XG4gICAgfVxuXG4gICAgdmFyIGNtcCA9IE1hdGhVdGlsLmNvbXBhcmVOdW1iZXJzKHRoaXMudG9FcG9jaFNlY29uZCgpLCBvdGhlci50b0Vwb2NoU2Vjb25kKCkpO1xuXG4gICAgaWYgKGNtcCA9PT0gMCkge1xuICAgICAgY21wID0gdGhpcy50b0xvY2FsVGltZSgpLm5hbm8oKSAtIG90aGVyLnRvTG9jYWxUaW1lKCkubmFubygpO1xuXG4gICAgICBpZiAoY21wID09PSAwKSB7XG4gICAgICAgIGNtcCA9IHRoaXMudG9Mb2NhbERhdGVUaW1lKCkuY29tcGFyZVRvKG90aGVyLnRvTG9jYWxEYXRlVGltZSgpKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gY21wO1xuICB9O1xuXG4gIF9wcm90by5pc0FmdGVyID0gZnVuY3Rpb24gaXNBZnRlcihvdGhlcikge1xuICAgIHJlcXVpcmVOb25OdWxsKG90aGVyLCAnb3RoZXInKTtcbiAgICB2YXIgdGhpc0Vwb2NoU2VjID0gdGhpcy50b0Vwb2NoU2Vjb25kKCk7XG4gICAgdmFyIG90aGVyRXBvY2hTZWMgPSBvdGhlci50b0Vwb2NoU2Vjb25kKCk7XG4gICAgcmV0dXJuIHRoaXNFcG9jaFNlYyA+IG90aGVyRXBvY2hTZWMgfHwgdGhpc0Vwb2NoU2VjID09PSBvdGhlckVwb2NoU2VjICYmIHRoaXMudG9Mb2NhbFRpbWUoKS5uYW5vKCkgPiBvdGhlci50b0xvY2FsVGltZSgpLm5hbm8oKTtcbiAgfTtcblxuICBfcHJvdG8uaXNCZWZvcmUgPSBmdW5jdGlvbiBpc0JlZm9yZShvdGhlcikge1xuICAgIHJlcXVpcmVOb25OdWxsKG90aGVyLCAnb3RoZXInKTtcbiAgICB2YXIgdGhpc0Vwb2NoU2VjID0gdGhpcy50b0Vwb2NoU2Vjb25kKCk7XG4gICAgdmFyIG90aGVyRXBvY2hTZWMgPSBvdGhlci50b0Vwb2NoU2Vjb25kKCk7XG4gICAgcmV0dXJuIHRoaXNFcG9jaFNlYyA8IG90aGVyRXBvY2hTZWMgfHwgdGhpc0Vwb2NoU2VjID09PSBvdGhlckVwb2NoU2VjICYmIHRoaXMudG9Mb2NhbFRpbWUoKS5uYW5vKCkgPCBvdGhlci50b0xvY2FsVGltZSgpLm5hbm8oKTtcbiAgfTtcblxuICBfcHJvdG8uaXNFcXVhbCA9IGZ1bmN0aW9uIGlzRXF1YWwob3RoZXIpIHtcbiAgICByZXF1aXJlTm9uTnVsbChvdGhlciwgJ290aGVyJyk7XG4gICAgcmV0dXJuIHRoaXMudG9FcG9jaFNlY29uZCgpID09PSBvdGhlci50b0Vwb2NoU2Vjb25kKCkgJiYgdGhpcy50b0xvY2FsVGltZSgpLm5hbm8oKSA9PT0gb3RoZXIudG9Mb2NhbFRpbWUoKS5uYW5vKCk7XG4gIH07XG5cbiAgX3Byb3RvLmVxdWFscyA9IGZ1bmN0aW9uIGVxdWFscyhvdGhlcikge1xuICAgIGlmICh0aGlzID09PSBvdGhlcikge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgaWYgKG90aGVyIGluc3RhbmNlb2YgT2Zmc2V0RGF0ZVRpbWUpIHtcbiAgICAgIHJldHVybiB0aGlzLl9kYXRlVGltZS5lcXVhbHMob3RoZXIuX2RhdGVUaW1lKSAmJiB0aGlzLl9vZmZzZXQuZXF1YWxzKG90aGVyLl9vZmZzZXQpO1xuICAgIH1cblxuICAgIHJldHVybiBmYWxzZTtcbiAgfTtcblxuICBfcHJvdG8uaGFzaENvZGUgPSBmdW5jdGlvbiBoYXNoQ29kZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fZGF0ZVRpbWUuaGFzaENvZGUoKSBeIHRoaXMuX29mZnNldC5oYXNoQ29kZSgpO1xuICB9O1xuXG4gIF9wcm90by50b1N0cmluZyA9IGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuICAgIHJldHVybiB0aGlzLl9kYXRlVGltZS50b1N0cmluZygpICsgdGhpcy5fb2Zmc2V0LnRvU3RyaW5nKCk7XG4gIH07XG5cbiAgX3Byb3RvLnRvSlNPTiA9IGZ1bmN0aW9uIHRvSlNPTigpIHtcbiAgICByZXR1cm4gdGhpcy50b1N0cmluZygpO1xuICB9O1xuXG4gIF9wcm90by5mb3JtYXQgPSBmdW5jdGlvbiBmb3JtYXQoZm9ybWF0dGVyKSB7XG4gICAgcmVxdWlyZU5vbk51bGwoZm9ybWF0dGVyLCAnZm9ybWF0dGVyJyk7XG4gICAgcmV0dXJuIGZvcm1hdHRlci5mb3JtYXQodGhpcyk7XG4gIH07XG5cbiAgcmV0dXJuIE9mZnNldERhdGVUaW1lO1xufShEZWZhdWx0SW50ZXJmYWNlVGVtcG9yYWwpO1xuZnVuY3Rpb24gX2luaXQkaCgpIHtcbiAgT2Zmc2V0RGF0ZVRpbWUuTUlOID0gTG9jYWxEYXRlVGltZS5NSU4uYXRPZmZzZXQoWm9uZU9mZnNldC5NQVgpO1xuICBPZmZzZXREYXRlVGltZS5NQVggPSBMb2NhbERhdGVUaW1lLk1BWC5hdE9mZnNldChab25lT2Zmc2V0Lk1JTik7XG4gIE9mZnNldERhdGVUaW1lLkZST00gPSBjcmVhdGVUZW1wb3JhbFF1ZXJ5KCdPZmZzZXREYXRlVGltZS5GUk9NJywgZnVuY3Rpb24gKHRlbXBvcmFsKSB7XG4gICAgcmV0dXJuIE9mZnNldERhdGVUaW1lLmZyb20odGVtcG9yYWwpO1xuICB9KTtcbn1cblxudmFyIERBWVNfUEVSX0NZQ0xFID0gMTQ2MDk3O1xudmFyIERBWVNfMDAwMF9UT18xOTcwID0gREFZU19QRVJfQ1lDTEUgKiA1IC0gKDMwICogMzY1ICsgNyk7XG52YXIgTG9jYWxEYXRlID0gZnVuY3Rpb24gKF9DaHJvbm9Mb2NhbERhdGUpIHtcbiAgX2luaGVyaXRzTG9vc2UoTG9jYWxEYXRlLCBfQ2hyb25vTG9jYWxEYXRlKTtcblxuICBMb2NhbERhdGUubm93ID0gZnVuY3Rpb24gbm93KGNsb2NrT3Jab25lKSB7XG4gICAgdmFyIGNsb2NrO1xuXG4gICAgaWYgKGNsb2NrT3Jab25lID09IG51bGwpIHtcbiAgICAgIGNsb2NrID0gQ2xvY2suc3lzdGVtRGVmYXVsdFpvbmUoKTtcbiAgICB9IGVsc2UgaWYgKGNsb2NrT3Jab25lIGluc3RhbmNlb2YgWm9uZUlkKSB7XG4gICAgICBjbG9jayA9IENsb2NrLnN5c3RlbShjbG9ja09yWm9uZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNsb2NrID0gY2xvY2tPclpvbmU7XG4gICAgfVxuXG4gICAgcmV0dXJuIExvY2FsRGF0ZS5vZkluc3RhbnQoY2xvY2suaW5zdGFudCgpLCBjbG9jay56b25lKCkpO1xuICB9O1xuXG4gIExvY2FsRGF0ZS5vZkluc3RhbnQgPSBmdW5jdGlvbiBvZkluc3RhbnQoaW5zdGFudCwgem9uZSkge1xuICAgIGlmICh6b25lID09PSB2b2lkIDApIHtcbiAgICAgIHpvbmUgPSBab25lSWQuc3lzdGVtRGVmYXVsdCgpO1xuICAgIH1cblxuICAgIHJlcXVpcmVOb25OdWxsKGluc3RhbnQsICdpbnN0YW50Jyk7XG4gICAgdmFyIG9mZnNldCA9IHpvbmUucnVsZXMoKS5vZmZzZXQoaW5zdGFudCk7XG4gICAgdmFyIGVwb2NoU2VjID0gaW5zdGFudC5lcG9jaFNlY29uZCgpICsgb2Zmc2V0LnRvdGFsU2Vjb25kcygpO1xuICAgIHZhciBlcG9jaERheSA9IE1hdGhVdGlsLmZsb29yRGl2KGVwb2NoU2VjLCBMb2NhbFRpbWUuU0VDT05EU19QRVJfREFZKTtcbiAgICByZXR1cm4gTG9jYWxEYXRlLm9mRXBvY2hEYXkoZXBvY2hEYXkpO1xuICB9O1xuXG4gIExvY2FsRGF0ZS5vZiA9IGZ1bmN0aW9uIG9mKHllYXIsIG1vbnRoLCBkYXlPZk1vbnRoKSB7XG4gICAgcmV0dXJuIG5ldyBMb2NhbERhdGUoeWVhciwgbW9udGgsIGRheU9mTW9udGgpO1xuICB9O1xuXG4gIExvY2FsRGF0ZS5vZlllYXJEYXkgPSBmdW5jdGlvbiBvZlllYXJEYXkoeWVhciwgZGF5T2ZZZWFyKSB7XG4gICAgQ2hyb25vRmllbGQuWUVBUi5jaGVja1ZhbGlkVmFsdWUoeWVhcik7XG4gICAgdmFyIGxlYXAgPSBJc29DaHJvbm9sb2d5LmlzTGVhcFllYXIoeWVhcik7XG5cbiAgICBpZiAoZGF5T2ZZZWFyID09PSAzNjYgJiYgbGVhcCA9PT0gZmFsc2UpIHtcbiAgICAgIGFzc2VydChmYWxzZSwgJ0ludmFsaWQgZGF0ZSBcXCdEYXlPZlllYXIgMzY2XFwnIGFzIFxcJycgKyB5ZWFyICsgJ1xcJyBpcyBub3QgYSBsZWFwIHllYXInLCBEYXRlVGltZUV4Y2VwdGlvbik7XG4gICAgfVxuXG4gICAgdmFyIG1veSA9IE1vbnRoLm9mKE1hdGguZmxvb3IoKGRheU9mWWVhciAtIDEpIC8gMzEgKyAxKSk7XG4gICAgdmFyIG1vbnRoRW5kID0gbW95LmZpcnN0RGF5T2ZZZWFyKGxlYXApICsgbW95Lmxlbmd0aChsZWFwKSAtIDE7XG5cbiAgICBpZiAoZGF5T2ZZZWFyID4gbW9udGhFbmQpIHtcbiAgICAgIG1veSA9IG1veS5wbHVzKDEpO1xuICAgIH1cblxuICAgIHZhciBkb20gPSBkYXlPZlllYXIgLSBtb3kuZmlyc3REYXlPZlllYXIobGVhcCkgKyAxO1xuICAgIHJldHVybiBuZXcgTG9jYWxEYXRlKHllYXIsIG1veS52YWx1ZSgpLCBkb20pO1xuICB9O1xuXG4gIExvY2FsRGF0ZS5vZkVwb2NoRGF5ID0gZnVuY3Rpb24gb2ZFcG9jaERheShlcG9jaERheSkge1xuICAgIGlmIChlcG9jaERheSA9PT0gdm9pZCAwKSB7XG4gICAgICBlcG9jaERheSA9IDA7XG4gICAgfVxuXG4gICAgdmFyIGFkanVzdCwgYWRqdXN0Q3ljbGVzLCBkb3lFc3QsIHllYXJFc3QsIHplcm9EYXk7XG4gICAgemVyb0RheSA9IGVwb2NoRGF5ICsgREFZU18wMDAwX1RPXzE5NzA7XG4gICAgemVyb0RheSAtPSA2MDtcbiAgICBhZGp1c3QgPSAwO1xuXG4gICAgaWYgKHplcm9EYXkgPCAwKSB7XG4gICAgICBhZGp1c3RDeWNsZXMgPSBNYXRoVXRpbC5pbnREaXYoemVyb0RheSArIDEsIERBWVNfUEVSX0NZQ0xFKSAtIDE7XG4gICAgICBhZGp1c3QgPSBhZGp1c3RDeWNsZXMgKiA0MDA7XG4gICAgICB6ZXJvRGF5ICs9IC1hZGp1c3RDeWNsZXMgKiBEQVlTX1BFUl9DWUNMRTtcbiAgICB9XG5cbiAgICB5ZWFyRXN0ID0gTWF0aFV0aWwuaW50RGl2KDQwMCAqIHplcm9EYXkgKyA1OTEsIERBWVNfUEVSX0NZQ0xFKTtcbiAgICBkb3lFc3QgPSB6ZXJvRGF5IC0gKDM2NSAqIHllYXJFc3QgKyBNYXRoVXRpbC5pbnREaXYoeWVhckVzdCwgNCkgLSBNYXRoVXRpbC5pbnREaXYoeWVhckVzdCwgMTAwKSArIE1hdGhVdGlsLmludERpdih5ZWFyRXN0LCA0MDApKTtcblxuICAgIGlmIChkb3lFc3QgPCAwKSB7XG4gICAgICB5ZWFyRXN0LS07XG4gICAgICBkb3lFc3QgPSB6ZXJvRGF5IC0gKDM2NSAqIHllYXJFc3QgKyBNYXRoVXRpbC5pbnREaXYoeWVhckVzdCwgNCkgLSBNYXRoVXRpbC5pbnREaXYoeWVhckVzdCwgMTAwKSArIE1hdGhVdGlsLmludERpdih5ZWFyRXN0LCA0MDApKTtcbiAgICB9XG5cbiAgICB5ZWFyRXN0ICs9IGFkanVzdDtcbiAgICB2YXIgbWFyY2hEb3kwID0gZG95RXN0O1xuICAgIHZhciBtYXJjaE1vbnRoMCA9IE1hdGhVdGlsLmludERpdihtYXJjaERveTAgKiA1ICsgMiwgMTUzKTtcbiAgICB2YXIgbW9udGggPSAobWFyY2hNb250aDAgKyAyKSAlIDEyICsgMTtcbiAgICB2YXIgZG9tID0gbWFyY2hEb3kwIC0gTWF0aFV0aWwuaW50RGl2KG1hcmNoTW9udGgwICogMzA2ICsgNSwgMTApICsgMTtcbiAgICB5ZWFyRXN0ICs9IE1hdGhVdGlsLmludERpdihtYXJjaE1vbnRoMCwgMTApO1xuICAgIHZhciB5ZWFyID0geWVhckVzdDtcbiAgICByZXR1cm4gbmV3IExvY2FsRGF0ZSh5ZWFyLCBtb250aCwgZG9tKTtcbiAgfTtcblxuICBMb2NhbERhdGUuZnJvbSA9IGZ1bmN0aW9uIGZyb20odGVtcG9yYWwpIHtcbiAgICByZXF1aXJlTm9uTnVsbCh0ZW1wb3JhbCwgJ3RlbXBvcmFsJyk7XG4gICAgdmFyIGRhdGUgPSB0ZW1wb3JhbC5xdWVyeShUZW1wb3JhbFF1ZXJpZXMubG9jYWxEYXRlKCkpO1xuXG4gICAgaWYgKGRhdGUgPT0gbnVsbCkge1xuICAgICAgdGhyb3cgbmV3IERhdGVUaW1lRXhjZXB0aW9uKFwiVW5hYmxlIHRvIG9idGFpbiBMb2NhbERhdGUgZnJvbSBUZW1wb3JhbEFjY2Vzc29yOiBcIiArIHRlbXBvcmFsICsgXCIsIHR5cGUgXCIgKyAodGVtcG9yYWwuY29uc3RydWN0b3IgIT0gbnVsbCA/IHRlbXBvcmFsLmNvbnN0cnVjdG9yLm5hbWUgOiAnJykpO1xuICAgIH1cblxuICAgIHJldHVybiBkYXRlO1xuICB9O1xuXG4gIExvY2FsRGF0ZS5wYXJzZSA9IGZ1bmN0aW9uIHBhcnNlKHRleHQsIGZvcm1hdHRlcikge1xuICAgIGlmIChmb3JtYXR0ZXIgPT09IHZvaWQgMCkge1xuICAgICAgZm9ybWF0dGVyID0gRGF0ZVRpbWVGb3JtYXR0ZXIuSVNPX0xPQ0FMX0RBVEU7XG4gICAgfVxuXG4gICAgYXNzZXJ0KGZvcm1hdHRlciAhPSBudWxsLCAnZm9ybWF0dGVyJywgTnVsbFBvaW50ZXJFeGNlcHRpb24pO1xuICAgIHJldHVybiBmb3JtYXR0ZXIucGFyc2UodGV4dCwgTG9jYWxEYXRlLkZST00pO1xuICB9O1xuXG4gIExvY2FsRGF0ZS5fcmVzb2x2ZVByZXZpb3VzVmFsaWQgPSBmdW5jdGlvbiBfcmVzb2x2ZVByZXZpb3VzVmFsaWQoeWVhciwgbW9udGgsIGRheSkge1xuICAgIHN3aXRjaCAobW9udGgpIHtcbiAgICAgIGNhc2UgMjpcbiAgICAgICAgZGF5ID0gTWF0aC5taW4oZGF5LCBJc29DaHJvbm9sb2d5LmlzTGVhcFllYXIoeWVhcikgPyAyOSA6IDI4KTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgNDpcbiAgICAgIGNhc2UgNjpcbiAgICAgIGNhc2UgOTpcbiAgICAgIGNhc2UgMTE6XG4gICAgICAgIGRheSA9IE1hdGgubWluKGRheSwgMzApO1xuICAgICAgICBicmVhaztcbiAgICB9XG5cbiAgICByZXR1cm4gTG9jYWxEYXRlLm9mKHllYXIsIG1vbnRoLCBkYXkpO1xuICB9O1xuXG4gIGZ1bmN0aW9uIExvY2FsRGF0ZSh5ZWFyLCBtb250aCwgZGF5T2ZNb250aCkge1xuICAgIHZhciBfdGhpcztcblxuICAgIF90aGlzID0gX0Nocm9ub0xvY2FsRGF0ZS5jYWxsKHRoaXMpIHx8IHRoaXM7XG4gICAgcmVxdWlyZU5vbk51bGwoeWVhciwgJ3llYXInKTtcbiAgICByZXF1aXJlTm9uTnVsbChtb250aCwgJ21vbnRoJyk7XG4gICAgcmVxdWlyZU5vbk51bGwoZGF5T2ZNb250aCwgJ2RheU9mTW9udGgnKTtcblxuICAgIGlmIChtb250aCBpbnN0YW5jZW9mIE1vbnRoKSB7XG4gICAgICBtb250aCA9IG1vbnRoLnZhbHVlKCk7XG4gICAgfVxuXG4gICAgX3RoaXMuX3llYXIgPSBNYXRoVXRpbC5zYWZlVG9JbnQoeWVhcik7XG4gICAgX3RoaXMuX21vbnRoID0gTWF0aFV0aWwuc2FmZVRvSW50KG1vbnRoKTtcbiAgICBfdGhpcy5fZGF5ID0gTWF0aFV0aWwuc2FmZVRvSW50KGRheU9mTW9udGgpO1xuXG4gICAgTG9jYWxEYXRlLl92YWxpZGF0ZShfdGhpcy5feWVhciwgX3RoaXMuX21vbnRoLCBfdGhpcy5fZGF5KTtcblxuICAgIHJldHVybiBfdGhpcztcbiAgfVxuXG4gIExvY2FsRGF0ZS5fdmFsaWRhdGUgPSBmdW5jdGlvbiBfdmFsaWRhdGUoeWVhciwgbW9udGgsIGRheU9mTW9udGgpIHtcbiAgICB2YXIgZG9tO1xuICAgIENocm9ub0ZpZWxkLllFQVIuY2hlY2tWYWxpZFZhbHVlKHllYXIpO1xuICAgIENocm9ub0ZpZWxkLk1PTlRIX09GX1lFQVIuY2hlY2tWYWxpZFZhbHVlKG1vbnRoKTtcbiAgICBDaHJvbm9GaWVsZC5EQVlfT0ZfTU9OVEguY2hlY2tWYWxpZFZhbHVlKGRheU9mTW9udGgpO1xuXG4gICAgaWYgKGRheU9mTW9udGggPiAyOCkge1xuICAgICAgZG9tID0gMzE7XG5cbiAgICAgIHN3aXRjaCAobW9udGgpIHtcbiAgICAgICAgY2FzZSAyOlxuICAgICAgICAgIGRvbSA9IElzb0Nocm9ub2xvZ3kuaXNMZWFwWWVhcih5ZWFyKSA/IDI5IDogMjg7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSA0OlxuICAgICAgICBjYXNlIDY6XG4gICAgICAgIGNhc2UgOTpcbiAgICAgICAgY2FzZSAxMTpcbiAgICAgICAgICBkb20gPSAzMDtcbiAgICAgIH1cblxuICAgICAgaWYgKGRheU9mTW9udGggPiBkb20pIHtcbiAgICAgICAgaWYgKGRheU9mTW9udGggPT09IDI5KSB7XG4gICAgICAgICAgYXNzZXJ0KGZhbHNlLCAnSW52YWxpZCBkYXRlIFxcJ0ZlYnJ1YXJ5IDI5XFwnIGFzIFxcJycgKyB5ZWFyICsgJ1xcJyBpcyBub3QgYSBsZWFwIHllYXInLCBEYXRlVGltZUV4Y2VwdGlvbik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgYXNzZXJ0KGZhbHNlLCAnSW52YWxpZCBkYXRlIFxcJycgKyB5ZWFyICsgJ1xcJyBcXCcnICsgbW9udGggKyAnXFwnIFxcJycgKyBkYXlPZk1vbnRoICsgJ1xcJycsIERhdGVUaW1lRXhjZXB0aW9uKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICB2YXIgX3Byb3RvID0gTG9jYWxEYXRlLnByb3RvdHlwZTtcblxuICBfcHJvdG8uaXNTdXBwb3J0ZWQgPSBmdW5jdGlvbiBpc1N1cHBvcnRlZChmaWVsZCkge1xuICAgIHJldHVybiBfQ2hyb25vTG9jYWxEYXRlLnByb3RvdHlwZS5pc1N1cHBvcnRlZC5jYWxsKHRoaXMsIGZpZWxkKTtcbiAgfTtcblxuICBfcHJvdG8ucmFuZ2UgPSBmdW5jdGlvbiByYW5nZShmaWVsZCkge1xuICAgIGlmIChmaWVsZCBpbnN0YW5jZW9mIENocm9ub0ZpZWxkKSB7XG4gICAgICBpZiAoZmllbGQuaXNEYXRlQmFzZWQoKSkge1xuICAgICAgICBzd2l0Y2ggKGZpZWxkKSB7XG4gICAgICAgICAgY2FzZSBDaHJvbm9GaWVsZC5EQVlfT0ZfTU9OVEg6XG4gICAgICAgICAgICByZXR1cm4gVmFsdWVSYW5nZS5vZigxLCB0aGlzLmxlbmd0aE9mTW9udGgoKSk7XG5cbiAgICAgICAgICBjYXNlIENocm9ub0ZpZWxkLkRBWV9PRl9ZRUFSOlxuICAgICAgICAgICAgcmV0dXJuIFZhbHVlUmFuZ2Uub2YoMSwgdGhpcy5sZW5ndGhPZlllYXIoKSk7XG5cbiAgICAgICAgICBjYXNlIENocm9ub0ZpZWxkLkFMSUdORURfV0VFS19PRl9NT05USDpcbiAgICAgICAgICAgIHJldHVybiBWYWx1ZVJhbmdlLm9mKDEsIHRoaXMubW9udGgoKSA9PT0gTW9udGguRkVCUlVBUlkgJiYgdGhpcy5pc0xlYXBZZWFyKCkgPT09IGZhbHNlID8gNCA6IDUpO1xuXG4gICAgICAgICAgY2FzZSBDaHJvbm9GaWVsZC5ZRUFSX09GX0VSQTpcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl95ZWFyIDw9IDAgPyBWYWx1ZVJhbmdlLm9mKDEsIFllYXIuTUFYX1ZBTFVFICsgMSkgOiBWYWx1ZVJhbmdlLm9mKDEsIFllYXIuTUFYX1ZBTFVFKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBmaWVsZC5yYW5nZSgpO1xuICAgICAgfVxuXG4gICAgICB0aHJvdyBuZXcgVW5zdXBwb3J0ZWRUZW1wb3JhbFR5cGVFeGNlcHRpb24oJ1Vuc3VwcG9ydGVkIGZpZWxkOiAnICsgZmllbGQpO1xuICAgIH1cblxuICAgIHJldHVybiBmaWVsZC5yYW5nZVJlZmluZWRCeSh0aGlzKTtcbiAgfTtcblxuICBfcHJvdG8uZ2V0ID0gZnVuY3Rpb24gZ2V0KGZpZWxkKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0TG9uZyhmaWVsZCk7XG4gIH07XG5cbiAgX3Byb3RvLmdldExvbmcgPSBmdW5jdGlvbiBnZXRMb25nKGZpZWxkKSB7XG4gICAgYXNzZXJ0KGZpZWxkICE9IG51bGwsICcnLCBOdWxsUG9pbnRlckV4Y2VwdGlvbik7XG5cbiAgICBpZiAoZmllbGQgaW5zdGFuY2VvZiBDaHJvbm9GaWVsZCkge1xuICAgICAgcmV0dXJuIHRoaXMuX2dldDAoZmllbGQpO1xuICAgIH1cblxuICAgIHJldHVybiBmaWVsZC5nZXRGcm9tKHRoaXMpO1xuICB9O1xuXG4gIF9wcm90by5fZ2V0MCA9IGZ1bmN0aW9uIF9nZXQwKGZpZWxkKSB7XG4gICAgc3dpdGNoIChmaWVsZCkge1xuICAgICAgY2FzZSBDaHJvbm9GaWVsZC5EQVlfT0ZfV0VFSzpcbiAgICAgICAgcmV0dXJuIHRoaXMuZGF5T2ZXZWVrKCkudmFsdWUoKTtcblxuICAgICAgY2FzZSBDaHJvbm9GaWVsZC5BTElHTkVEX0RBWV9PRl9XRUVLX0lOX01PTlRIOlxuICAgICAgICByZXR1cm4gTWF0aFV0aWwuaW50TW9kKHRoaXMuX2RheSAtIDEsIDcpICsgMTtcblxuICAgICAgY2FzZSBDaHJvbm9GaWVsZC5BTElHTkVEX0RBWV9PRl9XRUVLX0lOX1lFQVI6XG4gICAgICAgIHJldHVybiBNYXRoVXRpbC5pbnRNb2QodGhpcy5kYXlPZlllYXIoKSAtIDEsIDcpICsgMTtcblxuICAgICAgY2FzZSBDaHJvbm9GaWVsZC5EQVlfT0ZfTU9OVEg6XG4gICAgICAgIHJldHVybiB0aGlzLl9kYXk7XG5cbiAgICAgIGNhc2UgQ2hyb25vRmllbGQuREFZX09GX1lFQVI6XG4gICAgICAgIHJldHVybiB0aGlzLmRheU9mWWVhcigpO1xuXG4gICAgICBjYXNlIENocm9ub0ZpZWxkLkVQT0NIX0RBWTpcbiAgICAgICAgcmV0dXJuIHRoaXMudG9FcG9jaERheSgpO1xuXG4gICAgICBjYXNlIENocm9ub0ZpZWxkLkFMSUdORURfV0VFS19PRl9NT05USDpcbiAgICAgICAgcmV0dXJuIE1hdGhVdGlsLmludERpdih0aGlzLl9kYXkgLSAxLCA3KSArIDE7XG5cbiAgICAgIGNhc2UgQ2hyb25vRmllbGQuQUxJR05FRF9XRUVLX09GX1lFQVI6XG4gICAgICAgIHJldHVybiBNYXRoVXRpbC5pbnREaXYodGhpcy5kYXlPZlllYXIoKSAtIDEsIDcpICsgMTtcblxuICAgICAgY2FzZSBDaHJvbm9GaWVsZC5NT05USF9PRl9ZRUFSOlxuICAgICAgICByZXR1cm4gdGhpcy5fbW9udGg7XG5cbiAgICAgIGNhc2UgQ2hyb25vRmllbGQuUFJPTEVQVElDX01PTlRIOlxuICAgICAgICByZXR1cm4gdGhpcy5fcHJvbGVwdGljTW9udGgoKTtcblxuICAgICAgY2FzZSBDaHJvbm9GaWVsZC5ZRUFSX09GX0VSQTpcbiAgICAgICAgcmV0dXJuIHRoaXMuX3llYXIgPj0gMSA/IHRoaXMuX3llYXIgOiAxIC0gdGhpcy5feWVhcjtcblxuICAgICAgY2FzZSBDaHJvbm9GaWVsZC5ZRUFSOlxuICAgICAgICByZXR1cm4gdGhpcy5feWVhcjtcblxuICAgICAgY2FzZSBDaHJvbm9GaWVsZC5FUkE6XG4gICAgICAgIHJldHVybiB0aGlzLl95ZWFyID49IDEgPyAxIDogMDtcbiAgICB9XG5cbiAgICB0aHJvdyBuZXcgVW5zdXBwb3J0ZWRUZW1wb3JhbFR5cGVFeGNlcHRpb24oJ1Vuc3VwcG9ydGVkIGZpZWxkOiAnICsgZmllbGQpO1xuICB9O1xuXG4gIF9wcm90by5fcHJvbGVwdGljTW9udGggPSBmdW5jdGlvbiBfcHJvbGVwdGljTW9udGgoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3llYXIgKiAxMiArICh0aGlzLl9tb250aCAtIDEpO1xuICB9O1xuXG4gIF9wcm90by5jaHJvbm9sb2d5ID0gZnVuY3Rpb24gY2hyb25vbG9neSgpIHtcbiAgICByZXR1cm4gSXNvQ2hyb25vbG9neS5JTlNUQU5DRTtcbiAgfTtcblxuICBfcHJvdG8ueWVhciA9IGZ1bmN0aW9uIHllYXIoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3llYXI7XG4gIH07XG5cbiAgX3Byb3RvLm1vbnRoVmFsdWUgPSBmdW5jdGlvbiBtb250aFZhbHVlKCkge1xuICAgIHJldHVybiB0aGlzLl9tb250aDtcbiAgfTtcblxuICBfcHJvdG8ubW9udGggPSBmdW5jdGlvbiBtb250aCgpIHtcbiAgICByZXR1cm4gTW9udGgub2YodGhpcy5fbW9udGgpO1xuICB9O1xuXG4gIF9wcm90by5kYXlPZk1vbnRoID0gZnVuY3Rpb24gZGF5T2ZNb250aCgpIHtcbiAgICByZXR1cm4gdGhpcy5fZGF5O1xuICB9O1xuXG4gIF9wcm90by5kYXlPZlllYXIgPSBmdW5jdGlvbiBkYXlPZlllYXIoKSB7XG4gICAgcmV0dXJuIHRoaXMubW9udGgoKS5maXJzdERheU9mWWVhcih0aGlzLmlzTGVhcFllYXIoKSkgKyB0aGlzLl9kYXkgLSAxO1xuICB9O1xuXG4gIF9wcm90by5kYXlPZldlZWsgPSBmdW5jdGlvbiBkYXlPZldlZWsoKSB7XG4gICAgdmFyIGRvdzAgPSBNYXRoVXRpbC5mbG9vck1vZCh0aGlzLnRvRXBvY2hEYXkoKSArIDMsIDcpO1xuICAgIHJldHVybiBEYXlPZldlZWsub2YoZG93MCArIDEpO1xuICB9O1xuXG4gIF9wcm90by5pc0xlYXBZZWFyID0gZnVuY3Rpb24gaXNMZWFwWWVhcigpIHtcbiAgICByZXR1cm4gSXNvQ2hyb25vbG9neS5pc0xlYXBZZWFyKHRoaXMuX3llYXIpO1xuICB9O1xuXG4gIF9wcm90by5sZW5ndGhPZk1vbnRoID0gZnVuY3Rpb24gbGVuZ3RoT2ZNb250aCgpIHtcbiAgICBzd2l0Y2ggKHRoaXMuX21vbnRoKSB7XG4gICAgICBjYXNlIDI6XG4gICAgICAgIHJldHVybiB0aGlzLmlzTGVhcFllYXIoKSA/IDI5IDogMjg7XG5cbiAgICAgIGNhc2UgNDpcbiAgICAgIGNhc2UgNjpcbiAgICAgIGNhc2UgOTpcbiAgICAgIGNhc2UgMTE6XG4gICAgICAgIHJldHVybiAzMDtcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIDMxO1xuICAgIH1cbiAgfTtcblxuICBfcHJvdG8ubGVuZ3RoT2ZZZWFyID0gZnVuY3Rpb24gbGVuZ3RoT2ZZZWFyKCkge1xuICAgIHJldHVybiB0aGlzLmlzTGVhcFllYXIoKSA/IDM2NiA6IDM2NTtcbiAgfTtcblxuICBfcHJvdG8ud2l0aEFkanVzdGVyID0gZnVuY3Rpb24gd2l0aEFkanVzdGVyKGFkanVzdGVyKSB7XG4gICAgcmVxdWlyZU5vbk51bGwoYWRqdXN0ZXIsICdhZGp1c3RlcicpO1xuXG4gICAgaWYgKGFkanVzdGVyIGluc3RhbmNlb2YgTG9jYWxEYXRlKSB7XG4gICAgICByZXR1cm4gYWRqdXN0ZXI7XG4gICAgfVxuXG4gICAgYXNzZXJ0KHR5cGVvZiBhZGp1c3Rlci5hZGp1c3RJbnRvID09PSAnZnVuY3Rpb24nLCAnYWRqdXN0ZXInLCBJbGxlZ2FsQXJndW1lbnRFeGNlcHRpb24pO1xuICAgIHJldHVybiBhZGp1c3Rlci5hZGp1c3RJbnRvKHRoaXMpO1xuICB9O1xuXG4gIF9wcm90by53aXRoRmllbGRWYWx1ZSA9IGZ1bmN0aW9uIHdpdGhGaWVsZFZhbHVlKGZpZWxkLCBuZXdWYWx1ZSkge1xuICAgIGFzc2VydChmaWVsZCAhPSBudWxsLCAnZmllbGQnLCBOdWxsUG9pbnRlckV4Y2VwdGlvbik7XG5cbiAgICBpZiAoZmllbGQgaW5zdGFuY2VvZiBDaHJvbm9GaWVsZCkge1xuICAgICAgdmFyIGYgPSBmaWVsZDtcbiAgICAgIGYuY2hlY2tWYWxpZFZhbHVlKG5ld1ZhbHVlKTtcblxuICAgICAgc3dpdGNoIChmKSB7XG4gICAgICAgIGNhc2UgQ2hyb25vRmllbGQuREFZX09GX1dFRUs6XG4gICAgICAgICAgcmV0dXJuIHRoaXMucGx1c0RheXMobmV3VmFsdWUgLSB0aGlzLmRheU9mV2VlaygpLnZhbHVlKCkpO1xuXG4gICAgICAgIGNhc2UgQ2hyb25vRmllbGQuQUxJR05FRF9EQVlfT0ZfV0VFS19JTl9NT05USDpcbiAgICAgICAgICByZXR1cm4gdGhpcy5wbHVzRGF5cyhuZXdWYWx1ZSAtIHRoaXMuZ2V0TG9uZyhDaHJvbm9GaWVsZC5BTElHTkVEX0RBWV9PRl9XRUVLX0lOX01PTlRIKSk7XG5cbiAgICAgICAgY2FzZSBDaHJvbm9GaWVsZC5BTElHTkVEX0RBWV9PRl9XRUVLX0lOX1lFQVI6XG4gICAgICAgICAgcmV0dXJuIHRoaXMucGx1c0RheXMobmV3VmFsdWUgLSB0aGlzLmdldExvbmcoQ2hyb25vRmllbGQuQUxJR05FRF9EQVlfT0ZfV0VFS19JTl9ZRUFSKSk7XG5cbiAgICAgICAgY2FzZSBDaHJvbm9GaWVsZC5EQVlfT0ZfTU9OVEg6XG4gICAgICAgICAgcmV0dXJuIHRoaXMud2l0aERheU9mTW9udGgobmV3VmFsdWUpO1xuXG4gICAgICAgIGNhc2UgQ2hyb25vRmllbGQuREFZX09GX1lFQVI6XG4gICAgICAgICAgcmV0dXJuIHRoaXMud2l0aERheU9mWWVhcihuZXdWYWx1ZSk7XG5cbiAgICAgICAgY2FzZSBDaHJvbm9GaWVsZC5FUE9DSF9EQVk6XG4gICAgICAgICAgcmV0dXJuIExvY2FsRGF0ZS5vZkVwb2NoRGF5KG5ld1ZhbHVlKTtcblxuICAgICAgICBjYXNlIENocm9ub0ZpZWxkLkFMSUdORURfV0VFS19PRl9NT05USDpcbiAgICAgICAgICByZXR1cm4gdGhpcy5wbHVzV2Vla3MobmV3VmFsdWUgLSB0aGlzLmdldExvbmcoQ2hyb25vRmllbGQuQUxJR05FRF9XRUVLX09GX01PTlRIKSk7XG5cbiAgICAgICAgY2FzZSBDaHJvbm9GaWVsZC5BTElHTkVEX1dFRUtfT0ZfWUVBUjpcbiAgICAgICAgICByZXR1cm4gdGhpcy5wbHVzV2Vla3MobmV3VmFsdWUgLSB0aGlzLmdldExvbmcoQ2hyb25vRmllbGQuQUxJR05FRF9XRUVLX09GX1lFQVIpKTtcblxuICAgICAgICBjYXNlIENocm9ub0ZpZWxkLk1PTlRIX09GX1lFQVI6XG4gICAgICAgICAgcmV0dXJuIHRoaXMud2l0aE1vbnRoKG5ld1ZhbHVlKTtcblxuICAgICAgICBjYXNlIENocm9ub0ZpZWxkLlBST0xFUFRJQ19NT05USDpcbiAgICAgICAgICByZXR1cm4gdGhpcy5wbHVzTW9udGhzKG5ld1ZhbHVlIC0gdGhpcy5nZXRMb25nKENocm9ub0ZpZWxkLlBST0xFUFRJQ19NT05USCkpO1xuXG4gICAgICAgIGNhc2UgQ2hyb25vRmllbGQuWUVBUl9PRl9FUkE6XG4gICAgICAgICAgcmV0dXJuIHRoaXMud2l0aFllYXIodGhpcy5feWVhciA+PSAxID8gbmV3VmFsdWUgOiAxIC0gbmV3VmFsdWUpO1xuXG4gICAgICAgIGNhc2UgQ2hyb25vRmllbGQuWUVBUjpcbiAgICAgICAgICByZXR1cm4gdGhpcy53aXRoWWVhcihuZXdWYWx1ZSk7XG5cbiAgICAgICAgY2FzZSBDaHJvbm9GaWVsZC5FUkE6XG4gICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0TG9uZyhDaHJvbm9GaWVsZC5FUkEpID09PSBuZXdWYWx1ZSA/IHRoaXMgOiB0aGlzLndpdGhZZWFyKDEgLSB0aGlzLl95ZWFyKTtcbiAgICAgIH1cblxuICAgICAgdGhyb3cgbmV3IFVuc3VwcG9ydGVkVGVtcG9yYWxUeXBlRXhjZXB0aW9uKCdVbnN1cHBvcnRlZCBmaWVsZDogJyArIGZpZWxkKTtcbiAgICB9XG5cbiAgICByZXR1cm4gZmllbGQuYWRqdXN0SW50byh0aGlzLCBuZXdWYWx1ZSk7XG4gIH07XG5cbiAgX3Byb3RvLndpdGhZZWFyID0gZnVuY3Rpb24gd2l0aFllYXIoeWVhcikge1xuICAgIGlmICh0aGlzLl95ZWFyID09PSB5ZWFyKSB7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICBDaHJvbm9GaWVsZC5ZRUFSLmNoZWNrVmFsaWRWYWx1ZSh5ZWFyKTtcbiAgICByZXR1cm4gTG9jYWxEYXRlLl9yZXNvbHZlUHJldmlvdXNWYWxpZCh5ZWFyLCB0aGlzLl9tb250aCwgdGhpcy5fZGF5KTtcbiAgfTtcblxuICBfcHJvdG8ud2l0aE1vbnRoID0gZnVuY3Rpb24gd2l0aE1vbnRoKG1vbnRoKSB7XG4gICAgdmFyIG0gPSBtb250aCBpbnN0YW5jZW9mIE1vbnRoID8gbW9udGgudmFsdWUoKSA6IG1vbnRoO1xuXG4gICAgaWYgKHRoaXMuX21vbnRoID09PSBtKSB7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICBDaHJvbm9GaWVsZC5NT05USF9PRl9ZRUFSLmNoZWNrVmFsaWRWYWx1ZShtKTtcbiAgICByZXR1cm4gTG9jYWxEYXRlLl9yZXNvbHZlUHJldmlvdXNWYWxpZCh0aGlzLl95ZWFyLCBtLCB0aGlzLl9kYXkpO1xuICB9O1xuXG4gIF9wcm90by53aXRoRGF5T2ZNb250aCA9IGZ1bmN0aW9uIHdpdGhEYXlPZk1vbnRoKGRheU9mTW9udGgpIHtcbiAgICBpZiAodGhpcy5fZGF5ID09PSBkYXlPZk1vbnRoKSB7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICByZXR1cm4gTG9jYWxEYXRlLm9mKHRoaXMuX3llYXIsIHRoaXMuX21vbnRoLCBkYXlPZk1vbnRoKTtcbiAgfTtcblxuICBfcHJvdG8ud2l0aERheU9mWWVhciA9IGZ1bmN0aW9uIHdpdGhEYXlPZlllYXIoZGF5T2ZZZWFyKSB7XG4gICAgaWYgKHRoaXMuZGF5T2ZZZWFyKCkgPT09IGRheU9mWWVhcikge1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgcmV0dXJuIExvY2FsRGF0ZS5vZlllYXJEYXkodGhpcy5feWVhciwgZGF5T2ZZZWFyKTtcbiAgfTtcblxuICBfcHJvdG8ucGx1c0Ftb3VudCA9IGZ1bmN0aW9uIHBsdXNBbW91bnQoYW1vdW50KSB7XG4gICAgcmVxdWlyZU5vbk51bGwoYW1vdW50LCAnYW1vdW50Jyk7XG4gICAgcmV0dXJuIGFtb3VudC5hZGRUbyh0aGlzKTtcbiAgfTtcblxuICBfcHJvdG8ucGx1c0Ftb3VudFVuaXQgPSBmdW5jdGlvbiBwbHVzQW1vdW50VW5pdChhbW91bnRUb0FkZCwgdW5pdCkge1xuICAgIHJlcXVpcmVOb25OdWxsKGFtb3VudFRvQWRkLCAnYW1vdW50VG9BZGQnKTtcbiAgICByZXF1aXJlTm9uTnVsbCh1bml0LCAndW5pdCcpO1xuXG4gICAgaWYgKHVuaXQgaW5zdGFuY2VvZiBDaHJvbm9Vbml0KSB7XG4gICAgICBzd2l0Y2ggKHVuaXQpIHtcbiAgICAgICAgY2FzZSBDaHJvbm9Vbml0LkRBWVM6XG4gICAgICAgICAgcmV0dXJuIHRoaXMucGx1c0RheXMoYW1vdW50VG9BZGQpO1xuXG4gICAgICAgIGNhc2UgQ2hyb25vVW5pdC5XRUVLUzpcbiAgICAgICAgICByZXR1cm4gdGhpcy5wbHVzV2Vla3MoYW1vdW50VG9BZGQpO1xuXG4gICAgICAgIGNhc2UgQ2hyb25vVW5pdC5NT05USFM6XG4gICAgICAgICAgcmV0dXJuIHRoaXMucGx1c01vbnRocyhhbW91bnRUb0FkZCk7XG5cbiAgICAgICAgY2FzZSBDaHJvbm9Vbml0LllFQVJTOlxuICAgICAgICAgIHJldHVybiB0aGlzLnBsdXNZZWFycyhhbW91bnRUb0FkZCk7XG5cbiAgICAgICAgY2FzZSBDaHJvbm9Vbml0LkRFQ0FERVM6XG4gICAgICAgICAgcmV0dXJuIHRoaXMucGx1c1llYXJzKE1hdGhVdGlsLnNhZmVNdWx0aXBseShhbW91bnRUb0FkZCwgMTApKTtcblxuICAgICAgICBjYXNlIENocm9ub1VuaXQuQ0VOVFVSSUVTOlxuICAgICAgICAgIHJldHVybiB0aGlzLnBsdXNZZWFycyhNYXRoVXRpbC5zYWZlTXVsdGlwbHkoYW1vdW50VG9BZGQsIDEwMCkpO1xuXG4gICAgICAgIGNhc2UgQ2hyb25vVW5pdC5NSUxMRU5OSUE6XG4gICAgICAgICAgcmV0dXJuIHRoaXMucGx1c1llYXJzKE1hdGhVdGlsLnNhZmVNdWx0aXBseShhbW91bnRUb0FkZCwgMTAwMCkpO1xuXG4gICAgICAgIGNhc2UgQ2hyb25vVW5pdC5FUkFTOlxuICAgICAgICAgIHJldHVybiB0aGlzLndpdGgoQ2hyb25vRmllbGQuRVJBLCBNYXRoVXRpbC5zYWZlQWRkKHRoaXMuZ2V0TG9uZyhDaHJvbm9GaWVsZC5FUkEpLCBhbW91bnRUb0FkZCkpO1xuICAgICAgfVxuXG4gICAgICB0aHJvdyBuZXcgVW5zdXBwb3J0ZWRUZW1wb3JhbFR5cGVFeGNlcHRpb24oJ1Vuc3VwcG9ydGVkIHVuaXQ6ICcgKyB1bml0KTtcbiAgICB9XG5cbiAgICByZXR1cm4gdW5pdC5hZGRUbyh0aGlzLCBhbW91bnRUb0FkZCk7XG4gIH07XG5cbiAgX3Byb3RvLnBsdXNZZWFycyA9IGZ1bmN0aW9uIHBsdXNZZWFycyh5ZWFyc1RvQWRkKSB7XG4gICAgaWYgKHllYXJzVG9BZGQgPT09IDApIHtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIHZhciBuZXdZZWFyID0gQ2hyb25vRmllbGQuWUVBUi5jaGVja1ZhbGlkSW50VmFsdWUodGhpcy5feWVhciArIHllYXJzVG9BZGQpO1xuICAgIHJldHVybiBMb2NhbERhdGUuX3Jlc29sdmVQcmV2aW91c1ZhbGlkKG5ld1llYXIsIHRoaXMuX21vbnRoLCB0aGlzLl9kYXkpO1xuICB9O1xuXG4gIF9wcm90by5wbHVzTW9udGhzID0gZnVuY3Rpb24gcGx1c01vbnRocyhtb250aHNUb0FkZCkge1xuICAgIGlmIChtb250aHNUb0FkZCA9PT0gMCkge1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgdmFyIG1vbnRoQ291bnQgPSB0aGlzLl95ZWFyICogMTIgKyAodGhpcy5fbW9udGggLSAxKTtcbiAgICB2YXIgY2FsY01vbnRocyA9IG1vbnRoQ291bnQgKyBtb250aHNUb0FkZDtcbiAgICB2YXIgbmV3WWVhciA9IENocm9ub0ZpZWxkLllFQVIuY2hlY2tWYWxpZEludFZhbHVlKE1hdGhVdGlsLmZsb29yRGl2KGNhbGNNb250aHMsIDEyKSk7XG4gICAgdmFyIG5ld01vbnRoID0gTWF0aFV0aWwuZmxvb3JNb2QoY2FsY01vbnRocywgMTIpICsgMTtcbiAgICByZXR1cm4gTG9jYWxEYXRlLl9yZXNvbHZlUHJldmlvdXNWYWxpZChuZXdZZWFyLCBuZXdNb250aCwgdGhpcy5fZGF5KTtcbiAgfTtcblxuICBfcHJvdG8ucGx1c1dlZWtzID0gZnVuY3Rpb24gcGx1c1dlZWtzKHdlZWtzVG9BZGQpIHtcbiAgICByZXR1cm4gdGhpcy5wbHVzRGF5cyhNYXRoVXRpbC5zYWZlTXVsdGlwbHkod2Vla3NUb0FkZCwgNykpO1xuICB9O1xuXG4gIF9wcm90by5wbHVzRGF5cyA9IGZ1bmN0aW9uIHBsdXNEYXlzKGRheXNUb0FkZCkge1xuICAgIGlmIChkYXlzVG9BZGQgPT09IDApIHtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIHZhciBtakRheSA9IE1hdGhVdGlsLnNhZmVBZGQodGhpcy50b0Vwb2NoRGF5KCksIGRheXNUb0FkZCk7XG4gICAgcmV0dXJuIExvY2FsRGF0ZS5vZkVwb2NoRGF5KG1qRGF5KTtcbiAgfTtcblxuICBfcHJvdG8ubWludXNBbW91bnQgPSBmdW5jdGlvbiBtaW51c0Ftb3VudChhbW91bnQpIHtcbiAgICByZXF1aXJlTm9uTnVsbChhbW91bnQsICdhbW91bnQnKTtcbiAgICByZXR1cm4gYW1vdW50LnN1YnRyYWN0RnJvbSh0aGlzKTtcbiAgfTtcblxuICBfcHJvdG8ubWludXNBbW91bnRVbml0ID0gZnVuY3Rpb24gbWludXNBbW91bnRVbml0KGFtb3VudFRvU3VidHJhY3QsIHVuaXQpIHtcbiAgICByZXF1aXJlTm9uTnVsbChhbW91bnRUb1N1YnRyYWN0LCAnYW1vdW50VG9TdWJ0cmFjdCcpO1xuICAgIHJlcXVpcmVOb25OdWxsKHVuaXQsICd1bml0Jyk7XG4gICAgcmV0dXJuIHRoaXMucGx1c0Ftb3VudFVuaXQoLTEgKiBhbW91bnRUb1N1YnRyYWN0LCB1bml0KTtcbiAgfTtcblxuICBfcHJvdG8ubWludXNZZWFycyA9IGZ1bmN0aW9uIG1pbnVzWWVhcnMoeWVhcnNUb1N1YnRyYWN0KSB7XG4gICAgcmV0dXJuIHRoaXMucGx1c1llYXJzKHllYXJzVG9TdWJ0cmFjdCAqIC0xKTtcbiAgfTtcblxuICBfcHJvdG8ubWludXNNb250aHMgPSBmdW5jdGlvbiBtaW51c01vbnRocyhtb250aHNUb1N1YnRyYWN0KSB7XG4gICAgcmV0dXJuIHRoaXMucGx1c01vbnRocyhtb250aHNUb1N1YnRyYWN0ICogLTEpO1xuICB9O1xuXG4gIF9wcm90by5taW51c1dlZWtzID0gZnVuY3Rpb24gbWludXNXZWVrcyh3ZWVrc1RvU3VidHJhY3QpIHtcbiAgICByZXR1cm4gdGhpcy5wbHVzV2Vla3Mod2Vla3NUb1N1YnRyYWN0ICogLTEpO1xuICB9O1xuXG4gIF9wcm90by5taW51c0RheXMgPSBmdW5jdGlvbiBtaW51c0RheXMoZGF5c1RvU3VidHJhY3QpIHtcbiAgICByZXR1cm4gdGhpcy5wbHVzRGF5cyhkYXlzVG9TdWJ0cmFjdCAqIC0xKTtcbiAgfTtcblxuICBfcHJvdG8ucXVlcnkgPSBmdW5jdGlvbiBxdWVyeShfcXVlcnkpIHtcbiAgICByZXF1aXJlTm9uTnVsbChfcXVlcnksICdxdWVyeScpO1xuXG4gICAgaWYgKF9xdWVyeSA9PT0gVGVtcG9yYWxRdWVyaWVzLmxvY2FsRGF0ZSgpKSB7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICByZXR1cm4gX0Nocm9ub0xvY2FsRGF0ZS5wcm90b3R5cGUucXVlcnkuY2FsbCh0aGlzLCBfcXVlcnkpO1xuICB9O1xuXG4gIF9wcm90by5hZGp1c3RJbnRvID0gZnVuY3Rpb24gYWRqdXN0SW50byh0ZW1wb3JhbCkge1xuICAgIHJldHVybiBfQ2hyb25vTG9jYWxEYXRlLnByb3RvdHlwZS5hZGp1c3RJbnRvLmNhbGwodGhpcywgdGVtcG9yYWwpO1xuICB9O1xuXG4gIF9wcm90by51bnRpbCA9IGZ1bmN0aW9uIHVudGlsKHAxLCBwMikge1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoIDwgMikge1xuICAgICAgcmV0dXJuIHRoaXMudW50aWwxKHAxKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHRoaXMudW50aWwyKHAxLCBwMik7XG4gICAgfVxuICB9O1xuXG4gIF9wcm90by51bnRpbDIgPSBmdW5jdGlvbiB1bnRpbDIoZW5kRXhjbHVzaXZlLCB1bml0KSB7XG4gICAgdmFyIGVuZCA9IExvY2FsRGF0ZS5mcm9tKGVuZEV4Y2x1c2l2ZSk7XG5cbiAgICBpZiAodW5pdCBpbnN0YW5jZW9mIENocm9ub1VuaXQpIHtcbiAgICAgIHN3aXRjaCAodW5pdCkge1xuICAgICAgICBjYXNlIENocm9ub1VuaXQuREFZUzpcbiAgICAgICAgICByZXR1cm4gdGhpcy5kYXlzVW50aWwoZW5kKTtcblxuICAgICAgICBjYXNlIENocm9ub1VuaXQuV0VFS1M6XG4gICAgICAgICAgcmV0dXJuIE1hdGhVdGlsLmludERpdih0aGlzLmRheXNVbnRpbChlbmQpLCA3KTtcblxuICAgICAgICBjYXNlIENocm9ub1VuaXQuTU9OVEhTOlxuICAgICAgICAgIHJldHVybiB0aGlzLl9tb250aHNVbnRpbChlbmQpO1xuXG4gICAgICAgIGNhc2UgQ2hyb25vVW5pdC5ZRUFSUzpcbiAgICAgICAgICByZXR1cm4gTWF0aFV0aWwuaW50RGl2KHRoaXMuX21vbnRoc1VudGlsKGVuZCksIDEyKTtcblxuICAgICAgICBjYXNlIENocm9ub1VuaXQuREVDQURFUzpcbiAgICAgICAgICByZXR1cm4gTWF0aFV0aWwuaW50RGl2KHRoaXMuX21vbnRoc1VudGlsKGVuZCksIDEyMCk7XG5cbiAgICAgICAgY2FzZSBDaHJvbm9Vbml0LkNFTlRVUklFUzpcbiAgICAgICAgICByZXR1cm4gTWF0aFV0aWwuaW50RGl2KHRoaXMuX21vbnRoc1VudGlsKGVuZCksIDEyMDApO1xuXG4gICAgICAgIGNhc2UgQ2hyb25vVW5pdC5NSUxMRU5OSUE6XG4gICAgICAgICAgcmV0dXJuIE1hdGhVdGlsLmludERpdih0aGlzLl9tb250aHNVbnRpbChlbmQpLCAxMjAwMCk7XG5cbiAgICAgICAgY2FzZSBDaHJvbm9Vbml0LkVSQVM6XG4gICAgICAgICAgcmV0dXJuIGVuZC5nZXRMb25nKENocm9ub0ZpZWxkLkVSQSkgLSB0aGlzLmdldExvbmcoQ2hyb25vRmllbGQuRVJBKTtcbiAgICAgIH1cblxuICAgICAgdGhyb3cgbmV3IFVuc3VwcG9ydGVkVGVtcG9yYWxUeXBlRXhjZXB0aW9uKCdVbnN1cHBvcnRlZCB1bml0OiAnICsgdW5pdCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHVuaXQuYmV0d2Vlbih0aGlzLCBlbmQpO1xuICB9O1xuXG4gIF9wcm90by5kYXlzVW50aWwgPSBmdW5jdGlvbiBkYXlzVW50aWwoZW5kKSB7XG4gICAgcmV0dXJuIGVuZC50b0Vwb2NoRGF5KCkgLSB0aGlzLnRvRXBvY2hEYXkoKTtcbiAgfTtcblxuICBfcHJvdG8uX21vbnRoc1VudGlsID0gZnVuY3Rpb24gX21vbnRoc1VudGlsKGVuZCkge1xuICAgIHZhciBwYWNrZWQxID0gdGhpcy5fcHJvbGVwdGljTW9udGgoKSAqIDMyICsgdGhpcy5kYXlPZk1vbnRoKCk7XG4gICAgdmFyIHBhY2tlZDIgPSBlbmQuX3Byb2xlcHRpY01vbnRoKCkgKiAzMiArIGVuZC5kYXlPZk1vbnRoKCk7XG4gICAgcmV0dXJuIE1hdGhVdGlsLmludERpdihwYWNrZWQyIC0gcGFja2VkMSwgMzIpO1xuICB9O1xuXG4gIF9wcm90by51bnRpbDEgPSBmdW5jdGlvbiB1bnRpbDEoZW5kRGF0ZSkge1xuICAgIHZhciBlbmQgPSBMb2NhbERhdGUuZnJvbShlbmREYXRlKTtcblxuICAgIHZhciB0b3RhbE1vbnRocyA9IGVuZC5fcHJvbGVwdGljTW9udGgoKSAtIHRoaXMuX3Byb2xlcHRpY01vbnRoKCk7XG5cbiAgICB2YXIgZGF5cyA9IGVuZC5fZGF5IC0gdGhpcy5fZGF5O1xuXG4gICAgaWYgKHRvdGFsTW9udGhzID4gMCAmJiBkYXlzIDwgMCkge1xuICAgICAgdG90YWxNb250aHMtLTtcbiAgICAgIHZhciBjYWxjRGF0ZSA9IHRoaXMucGx1c01vbnRocyh0b3RhbE1vbnRocyk7XG4gICAgICBkYXlzID0gZW5kLnRvRXBvY2hEYXkoKSAtIGNhbGNEYXRlLnRvRXBvY2hEYXkoKTtcbiAgICB9IGVsc2UgaWYgKHRvdGFsTW9udGhzIDwgMCAmJiBkYXlzID4gMCkge1xuICAgICAgdG90YWxNb250aHMrKztcbiAgICAgIGRheXMgLT0gZW5kLmxlbmd0aE9mTW9udGgoKTtcbiAgICB9XG5cbiAgICB2YXIgeWVhcnMgPSBNYXRoVXRpbC5pbnREaXYodG90YWxNb250aHMsIDEyKTtcbiAgICB2YXIgbW9udGhzID0gTWF0aFV0aWwuaW50TW9kKHRvdGFsTW9udGhzLCAxMik7XG4gICAgcmV0dXJuIFBlcmlvZC5vZih5ZWFycywgbW9udGhzLCBkYXlzKTtcbiAgfTtcblxuICBfcHJvdG8uYXRUaW1lID0gZnVuY3Rpb24gYXRUaW1lKCkge1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAxKSB7XG4gICAgICByZXR1cm4gdGhpcy5hdFRpbWUxLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB0aGlzLmF0VGltZTQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gIH07XG5cbiAgX3Byb3RvLmF0VGltZTEgPSBmdW5jdGlvbiBhdFRpbWUxKHRpbWUpIHtcbiAgICByZXF1aXJlTm9uTnVsbCh0aW1lLCAndGltZScpO1xuXG4gICAgaWYgKHRpbWUgaW5zdGFuY2VvZiBMb2NhbFRpbWUpIHtcbiAgICAgIHJldHVybiBMb2NhbERhdGVUaW1lLm9mKHRoaXMsIHRpbWUpO1xuICAgIH0gZWxzZSBpZiAodGltZSBpbnN0YW5jZW9mIE9mZnNldFRpbWUpIHtcbiAgICAgIHJldHVybiB0aGlzLl9hdFRpbWVPZmZzZXRUaW1lKHRpbWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgSWxsZWdhbEFyZ3VtZW50RXhjZXB0aW9uKCd0aW1lIG11c3QgYmUgYW4gaW5zdGFuY2Ugb2YgTG9jYWxUaW1lIG9yIE9mZnNldFRpbWUnICsgKHRpbWUgJiYgdGltZS5jb25zdHJ1Y3RvciAmJiB0aW1lLmNvbnN0cnVjdG9yLm5hbWUgPyAnLCBidXQgaXMgJyArIHRpbWUuY29uc3RydWN0b3IubmFtZSA6ICcnKSk7XG4gICAgfVxuICB9O1xuXG4gIF9wcm90by5hdFRpbWU0ID0gZnVuY3Rpb24gYXRUaW1lNChob3VyLCBtaW51dGUsIHNlY29uZCwgbmFub09mU2Vjb25kKSB7XG4gICAgaWYgKHNlY29uZCA9PT0gdm9pZCAwKSB7XG4gICAgICBzZWNvbmQgPSAwO1xuICAgIH1cblxuICAgIGlmIChuYW5vT2ZTZWNvbmQgPT09IHZvaWQgMCkge1xuICAgICAgbmFub09mU2Vjb25kID0gMDtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5hdFRpbWUxKExvY2FsVGltZS5vZihob3VyLCBtaW51dGUsIHNlY29uZCwgbmFub09mU2Vjb25kKSk7XG4gIH07XG5cbiAgX3Byb3RvLl9hdFRpbWVPZmZzZXRUaW1lID0gZnVuY3Rpb24gX2F0VGltZU9mZnNldFRpbWUodGltZSkge1xuICAgIHJldHVybiBPZmZzZXREYXRlVGltZS5vZihMb2NhbERhdGVUaW1lLm9mKHRoaXMsIHRpbWUudG9Mb2NhbFRpbWUoKSksIHRpbWUub2Zmc2V0KCkpO1xuICB9O1xuXG4gIF9wcm90by5hdFN0YXJ0T2ZEYXkgPSBmdW5jdGlvbiBhdFN0YXJ0T2ZEYXkoem9uZSkge1xuICAgIGlmICh6b25lICE9IG51bGwpIHtcbiAgICAgIHJldHVybiB0aGlzLmF0U3RhcnRPZkRheVdpdGhab25lKHpvbmUpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gTG9jYWxEYXRlVGltZS5vZih0aGlzLCBMb2NhbFRpbWUuTUlETklHSFQpO1xuICAgIH1cbiAgfTtcblxuICBfcHJvdG8uYXRTdGFydE9mRGF5V2l0aFpvbmUgPSBmdW5jdGlvbiBhdFN0YXJ0T2ZEYXlXaXRoWm9uZSh6b25lKSB7XG4gICAgcmVxdWlyZU5vbk51bGwoem9uZSwgJ3pvbmUnKTtcbiAgICB2YXIgbGR0ID0gdGhpcy5hdFRpbWUoTG9jYWxUaW1lLk1JRE5JR0hUKTtcblxuICAgIGlmICh6b25lIGluc3RhbmNlb2YgWm9uZU9mZnNldCA9PT0gZmFsc2UpIHtcbiAgICAgIHZhciB0cmFucyA9IHpvbmUucnVsZXMoKS50cmFuc2l0aW9uKGxkdCk7XG5cbiAgICAgIGlmICh0cmFucyAhPSBudWxsICYmIHRyYW5zLmlzR2FwKCkpIHtcbiAgICAgICAgbGR0ID0gdHJhbnMuZGF0ZVRpbWVBZnRlcigpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBab25lZERhdGVUaW1lLm9mKGxkdCwgem9uZSk7XG4gIH07XG5cbiAgX3Byb3RvLnRvRXBvY2hEYXkgPSBmdW5jdGlvbiB0b0Vwb2NoRGF5KCkge1xuICAgIHZhciB5ID0gdGhpcy5feWVhcjtcbiAgICB2YXIgbSA9IHRoaXMuX21vbnRoO1xuICAgIHZhciB0b3RhbCA9IDA7XG4gICAgdG90YWwgKz0gMzY1ICogeTtcblxuICAgIGlmICh5ID49IDApIHtcbiAgICAgIHRvdGFsICs9IE1hdGhVdGlsLmludERpdih5ICsgMywgNCkgLSBNYXRoVXRpbC5pbnREaXYoeSArIDk5LCAxMDApICsgTWF0aFV0aWwuaW50RGl2KHkgKyAzOTksIDQwMCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRvdGFsIC09IE1hdGhVdGlsLmludERpdih5LCAtNCkgLSBNYXRoVXRpbC5pbnREaXYoeSwgLTEwMCkgKyBNYXRoVXRpbC5pbnREaXYoeSwgLTQwMCk7XG4gICAgfVxuXG4gICAgdG90YWwgKz0gTWF0aFV0aWwuaW50RGl2KDM2NyAqIG0gLSAzNjIsIDEyKTtcbiAgICB0b3RhbCArPSB0aGlzLmRheU9mTW9udGgoKSAtIDE7XG5cbiAgICBpZiAobSA+IDIpIHtcbiAgICAgIHRvdGFsLS07XG5cbiAgICAgIGlmICghSXNvQ2hyb25vbG9neS5pc0xlYXBZZWFyKHkpKSB7XG4gICAgICAgIHRvdGFsLS07XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRvdGFsIC0gREFZU18wMDAwX1RPXzE5NzA7XG4gIH07XG5cbiAgX3Byb3RvLmNvbXBhcmVUbyA9IGZ1bmN0aW9uIGNvbXBhcmVUbyhvdGhlcikge1xuICAgIHJlcXVpcmVOb25OdWxsKG90aGVyLCAnb3RoZXInKTtcbiAgICByZXF1aXJlSW5zdGFuY2Uob3RoZXIsIExvY2FsRGF0ZSwgJ290aGVyJyk7XG4gICAgcmV0dXJuIHRoaXMuX2NvbXBhcmVUbzAob3RoZXIpO1xuICB9O1xuXG4gIF9wcm90by5fY29tcGFyZVRvMCA9IGZ1bmN0aW9uIF9jb21wYXJlVG8wKG90aGVyRGF0ZSkge1xuICAgIHZhciBjbXAgPSB0aGlzLl95ZWFyIC0gb3RoZXJEYXRlLl95ZWFyO1xuXG4gICAgaWYgKGNtcCA9PT0gMCkge1xuICAgICAgY21wID0gdGhpcy5fbW9udGggLSBvdGhlckRhdGUuX21vbnRoO1xuXG4gICAgICBpZiAoY21wID09PSAwKSB7XG4gICAgICAgIGNtcCA9IHRoaXMuX2RheSAtIG90aGVyRGF0ZS5fZGF5O1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBjbXA7XG4gIH07XG5cbiAgX3Byb3RvLmlzQWZ0ZXIgPSBmdW5jdGlvbiBpc0FmdGVyKG90aGVyKSB7XG4gICAgcmV0dXJuIHRoaXMuY29tcGFyZVRvKG90aGVyKSA+IDA7XG4gIH07XG5cbiAgX3Byb3RvLmlzQmVmb3JlID0gZnVuY3Rpb24gaXNCZWZvcmUob3RoZXIpIHtcbiAgICByZXR1cm4gdGhpcy5jb21wYXJlVG8ob3RoZXIpIDwgMDtcbiAgfTtcblxuICBfcHJvdG8uaXNFcXVhbCA9IGZ1bmN0aW9uIGlzRXF1YWwob3RoZXIpIHtcbiAgICByZXR1cm4gdGhpcy5jb21wYXJlVG8ob3RoZXIpID09PSAwO1xuICB9O1xuXG4gIF9wcm90by5lcXVhbHMgPSBmdW5jdGlvbiBlcXVhbHMob3RoZXIpIHtcbiAgICBpZiAodGhpcyA9PT0gb3RoZXIpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIGlmIChvdGhlciBpbnN0YW5jZW9mIExvY2FsRGF0ZSkge1xuICAgICAgcmV0dXJuIHRoaXMuX2NvbXBhcmVUbzAob3RoZXIpID09PSAwO1xuICAgIH1cblxuICAgIHJldHVybiBmYWxzZTtcbiAgfTtcblxuICBfcHJvdG8uaGFzaENvZGUgPSBmdW5jdGlvbiBoYXNoQ29kZSgpIHtcbiAgICB2YXIgeWVhclZhbHVlID0gdGhpcy5feWVhcjtcbiAgICB2YXIgbW9udGhWYWx1ZSA9IHRoaXMuX21vbnRoO1xuICAgIHZhciBkYXlWYWx1ZSA9IHRoaXMuX2RheTtcbiAgICByZXR1cm4gTWF0aFV0aWwuaGFzaCh5ZWFyVmFsdWUgJiAweEZGRkZGODAwIF4gKHllYXJWYWx1ZSA8PCAxMSkgKyAobW9udGhWYWx1ZSA8PCA2KSArIGRheVZhbHVlKTtcbiAgfTtcblxuICBfcHJvdG8udG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZygpIHtcbiAgICB2YXIgZGF5U3RyaW5nLCBtb250aFN0cmluZywgeWVhclN0cmluZztcbiAgICB2YXIgeWVhclZhbHVlID0gdGhpcy5feWVhcjtcbiAgICB2YXIgbW9udGhWYWx1ZSA9IHRoaXMuX21vbnRoO1xuICAgIHZhciBkYXlWYWx1ZSA9IHRoaXMuX2RheTtcbiAgICB2YXIgYWJzWWVhciA9IE1hdGguYWJzKHllYXJWYWx1ZSk7XG5cbiAgICBpZiAoYWJzWWVhciA8IDEwMDApIHtcbiAgICAgIGlmICh5ZWFyVmFsdWUgPCAwKSB7XG4gICAgICAgIHllYXJTdHJpbmcgPSAnLScgKyAoJycgKyAoeWVhclZhbHVlIC0gMTAwMDApKS5zbGljZSgtNCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB5ZWFyU3RyaW5nID0gKCcnICsgKHllYXJWYWx1ZSArIDEwMDAwKSkuc2xpY2UoLTQpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoeWVhclZhbHVlID4gOTk5OSkge1xuICAgICAgICB5ZWFyU3RyaW5nID0gJysnICsgeWVhclZhbHVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgeWVhclN0cmluZyA9ICcnICsgeWVhclZhbHVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChtb250aFZhbHVlIDwgMTApIHtcbiAgICAgIG1vbnRoU3RyaW5nID0gJy0wJyArIG1vbnRoVmFsdWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIG1vbnRoU3RyaW5nID0gJy0nICsgbW9udGhWYWx1ZTtcbiAgICB9XG5cbiAgICBpZiAoZGF5VmFsdWUgPCAxMCkge1xuICAgICAgZGF5U3RyaW5nID0gJy0wJyArIGRheVZhbHVlO1xuICAgIH0gZWxzZSB7XG4gICAgICBkYXlTdHJpbmcgPSAnLScgKyBkYXlWYWx1ZTtcbiAgICB9XG5cbiAgICByZXR1cm4geWVhclN0cmluZyArIG1vbnRoU3RyaW5nICsgZGF5U3RyaW5nO1xuICB9O1xuXG4gIF9wcm90by50b0pTT04gPSBmdW5jdGlvbiB0b0pTT04oKSB7XG4gICAgcmV0dXJuIHRoaXMudG9TdHJpbmcoKTtcbiAgfTtcblxuICBfcHJvdG8uZm9ybWF0ID0gZnVuY3Rpb24gZm9ybWF0KGZvcm1hdHRlcikge1xuICAgIHJlcXVpcmVOb25OdWxsKGZvcm1hdHRlciwgJ2Zvcm1hdHRlcicpO1xuICAgIHJlcXVpcmVJbnN0YW5jZShmb3JtYXR0ZXIsIERhdGVUaW1lRm9ybWF0dGVyLCAnZm9ybWF0dGVyJyk7XG4gICAgcmV0dXJuIF9DaHJvbm9Mb2NhbERhdGUucHJvdG90eXBlLmZvcm1hdC5jYWxsKHRoaXMsIGZvcm1hdHRlcik7XG4gIH07XG5cbiAgcmV0dXJuIExvY2FsRGF0ZTtcbn0oQ2hyb25vTG9jYWxEYXRlKTtcbmZ1bmN0aW9uIF9pbml0JGkoKSB7XG4gIExvY2FsRGF0ZS5NSU4gPSBMb2NhbERhdGUub2YoWWVhckNvbnN0YW50cy5NSU5fVkFMVUUsIDEsIDEpO1xuICBMb2NhbERhdGUuTUFYID0gTG9jYWxEYXRlLm9mKFllYXJDb25zdGFudHMuTUFYX1ZBTFVFLCAxMiwgMzEpO1xuICBMb2NhbERhdGUuRVBPQ0hfMCA9IExvY2FsRGF0ZS5vZkVwb2NoRGF5KDApO1xuICBMb2NhbERhdGUuRlJPTSA9IGNyZWF0ZVRlbXBvcmFsUXVlcnkoJ0xvY2FsRGF0ZS5GUk9NJywgZnVuY3Rpb24gKHRlbXBvcmFsKSB7XG4gICAgcmV0dXJuIExvY2FsRGF0ZS5mcm9tKHRlbXBvcmFsKTtcbiAgfSk7XG59XG5cbnZhciBDaHJvbm9Mb2NhbERhdGVUaW1lID0gZnVuY3Rpb24gKF9EZWZhdWx0SW50ZXJmYWNlVGVtcCkge1xuICBfaW5oZXJpdHNMb29zZShDaHJvbm9Mb2NhbERhdGVUaW1lLCBfRGVmYXVsdEludGVyZmFjZVRlbXApO1xuXG4gIGZ1bmN0aW9uIENocm9ub0xvY2FsRGF0ZVRpbWUoKSB7XG4gICAgcmV0dXJuIF9EZWZhdWx0SW50ZXJmYWNlVGVtcC5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gIH1cblxuICB2YXIgX3Byb3RvID0gQ2hyb25vTG9jYWxEYXRlVGltZS5wcm90b3R5cGU7XG5cbiAgX3Byb3RvLmNocm9ub2xvZ3kgPSBmdW5jdGlvbiBjaHJvbm9sb2d5KCkge1xuICAgIHJldHVybiB0aGlzLnRvTG9jYWxEYXRlKCkuY2hyb25vbG9neSgpO1xuICB9O1xuXG4gIF9wcm90by5xdWVyeSA9IGZ1bmN0aW9uIHF1ZXJ5KF9xdWVyeSkge1xuICAgIGlmIChfcXVlcnkgPT09IFRlbXBvcmFsUXVlcmllcy5jaHJvbm9sb2d5KCkpIHtcbiAgICAgIHJldHVybiB0aGlzLmNocm9ub2xvZ3koKTtcbiAgICB9IGVsc2UgaWYgKF9xdWVyeSA9PT0gVGVtcG9yYWxRdWVyaWVzLnByZWNpc2lvbigpKSB7XG4gICAgICByZXR1cm4gQ2hyb25vVW5pdC5OQU5PUztcbiAgICB9IGVsc2UgaWYgKF9xdWVyeSA9PT0gVGVtcG9yYWxRdWVyaWVzLmxvY2FsRGF0ZSgpKSB7XG4gICAgICByZXR1cm4gTG9jYWxEYXRlLm9mRXBvY2hEYXkodGhpcy50b0xvY2FsRGF0ZSgpLnRvRXBvY2hEYXkoKSk7XG4gICAgfSBlbHNlIGlmIChfcXVlcnkgPT09IFRlbXBvcmFsUXVlcmllcy5sb2NhbFRpbWUoKSkge1xuICAgICAgcmV0dXJuIHRoaXMudG9Mb2NhbFRpbWUoKTtcbiAgICB9IGVsc2UgaWYgKF9xdWVyeSA9PT0gVGVtcG9yYWxRdWVyaWVzLnpvbmUoKSB8fCBfcXVlcnkgPT09IFRlbXBvcmFsUXVlcmllcy56b25lSWQoKSB8fCBfcXVlcnkgPT09IFRlbXBvcmFsUXVlcmllcy5vZmZzZXQoKSkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgcmV0dXJuIF9EZWZhdWx0SW50ZXJmYWNlVGVtcC5wcm90b3R5cGUucXVlcnkuY2FsbCh0aGlzLCBfcXVlcnkpO1xuICB9O1xuXG4gIF9wcm90by5hZGp1c3RJbnRvID0gZnVuY3Rpb24gYWRqdXN0SW50byh0ZW1wb3JhbCkge1xuICAgIHJldHVybiB0ZW1wb3JhbC53aXRoKENocm9ub0ZpZWxkLkVQT0NIX0RBWSwgdGhpcy50b0xvY2FsRGF0ZSgpLnRvRXBvY2hEYXkoKSkud2l0aChDaHJvbm9GaWVsZC5OQU5PX09GX0RBWSwgdGhpcy50b0xvY2FsVGltZSgpLnRvTmFub09mRGF5KCkpO1xuICB9O1xuXG4gIF9wcm90by50b0luc3RhbnQgPSBmdW5jdGlvbiB0b0luc3RhbnQob2Zmc2V0KSB7XG4gICAgcmVxdWlyZUluc3RhbmNlKG9mZnNldCwgWm9uZU9mZnNldCwgJ3pvbmVJZCcpO1xuICAgIHJldHVybiBJbnN0YW50Lm9mRXBvY2hTZWNvbmQodGhpcy50b0Vwb2NoU2Vjb25kKG9mZnNldCksIHRoaXMudG9Mb2NhbFRpbWUoKS5uYW5vKCkpO1xuICB9O1xuXG4gIF9wcm90by50b0Vwb2NoU2Vjb25kID0gZnVuY3Rpb24gdG9FcG9jaFNlY29uZChvZmZzZXQpIHtcbiAgICByZXF1aXJlTm9uTnVsbChvZmZzZXQsICdvZmZzZXQnKTtcbiAgICB2YXIgZXBvY2hEYXkgPSB0aGlzLnRvTG9jYWxEYXRlKCkudG9FcG9jaERheSgpO1xuICAgIHZhciBzZWNzID0gZXBvY2hEYXkgKiA4NjQwMCArIHRoaXMudG9Mb2NhbFRpbWUoKS50b1NlY29uZE9mRGF5KCk7XG4gICAgc2VjcyAtPSBvZmZzZXQudG90YWxTZWNvbmRzKCk7XG4gICAgcmV0dXJuIE1hdGhVdGlsLnNhZmVUb0ludChzZWNzKTtcbiAgfTtcblxuICByZXR1cm4gQ2hyb25vTG9jYWxEYXRlVGltZTtcbn0oRGVmYXVsdEludGVyZmFjZVRlbXBvcmFsKTtcblxudmFyIExvY2FsRGF0ZVRpbWUgPSBmdW5jdGlvbiAoX0Nocm9ub0xvY2FsRGF0ZVRpbWUpIHtcbiAgX2luaGVyaXRzTG9vc2UoTG9jYWxEYXRlVGltZSwgX0Nocm9ub0xvY2FsRGF0ZVRpbWUpO1xuXG4gIExvY2FsRGF0ZVRpbWUubm93ID0gZnVuY3Rpb24gbm93KGNsb2NrT3Jab25lKSB7XG4gICAgaWYgKGNsb2NrT3Jab25lID09IG51bGwpIHtcbiAgICAgIHJldHVybiBMb2NhbERhdGVUaW1lLl9ub3coQ2xvY2suc3lzdGVtRGVmYXVsdFpvbmUoKSk7XG4gICAgfSBlbHNlIGlmIChjbG9ja09yWm9uZSBpbnN0YW5jZW9mIENsb2NrKSB7XG4gICAgICByZXR1cm4gTG9jYWxEYXRlVGltZS5fbm93KGNsb2NrT3Jab25lKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIExvY2FsRGF0ZVRpbWUuX25vdyhDbG9jay5zeXN0ZW0oY2xvY2tPclpvbmUpKTtcbiAgICB9XG4gIH07XG5cbiAgTG9jYWxEYXRlVGltZS5fbm93ID0gZnVuY3Rpb24gX25vdyhjbG9jaykge1xuICAgIHJlcXVpcmVOb25OdWxsKGNsb2NrLCAnY2xvY2snKTtcbiAgICByZXR1cm4gTG9jYWxEYXRlVGltZS5vZkluc3RhbnQoY2xvY2suaW5zdGFudCgpLCBjbG9jay56b25lKCkpO1xuICB9O1xuXG4gIExvY2FsRGF0ZVRpbWUuX29mRXBvY2hNaWxsaXMgPSBmdW5jdGlvbiBfb2ZFcG9jaE1pbGxpcyhlcG9jaE1pbGxpLCBvZmZzZXQpIHtcbiAgICB2YXIgbG9jYWxTZWNvbmQgPSBNYXRoVXRpbC5mbG9vckRpdihlcG9jaE1pbGxpLCAxMDAwKSArIG9mZnNldC50b3RhbFNlY29uZHMoKTtcbiAgICB2YXIgbG9jYWxFcG9jaERheSA9IE1hdGhVdGlsLmZsb29yRGl2KGxvY2FsU2Vjb25kLCBMb2NhbFRpbWUuU0VDT05EU19QRVJfREFZKTtcbiAgICB2YXIgc2Vjc09mRGF5ID0gTWF0aFV0aWwuZmxvb3JNb2QobG9jYWxTZWNvbmQsIExvY2FsVGltZS5TRUNPTkRTX1BFUl9EQVkpO1xuICAgIHZhciBuYW5vT2ZTZWNvbmQgPSBNYXRoVXRpbC5mbG9vck1vZChlcG9jaE1pbGxpLCAxMDAwKSAqIDEwMDAwMDA7XG4gICAgdmFyIGRhdGUgPSBMb2NhbERhdGUub2ZFcG9jaERheShsb2NhbEVwb2NoRGF5KTtcbiAgICB2YXIgdGltZSA9IExvY2FsVGltZS5vZlNlY29uZE9mRGF5KHNlY3NPZkRheSwgbmFub09mU2Vjb25kKTtcbiAgICByZXR1cm4gbmV3IExvY2FsRGF0ZVRpbWUoZGF0ZSwgdGltZSk7XG4gIH07XG5cbiAgTG9jYWxEYXRlVGltZS5vZiA9IGZ1bmN0aW9uIG9mKCkge1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoIDw9IDIpIHtcbiAgICAgIHJldHVybiBMb2NhbERhdGVUaW1lLm9mRGF0ZUFuZFRpbWUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIExvY2FsRGF0ZVRpbWUub2ZOdW1iZXJzLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuICB9O1xuXG4gIExvY2FsRGF0ZVRpbWUub2ZOdW1iZXJzID0gZnVuY3Rpb24gb2ZOdW1iZXJzKHllYXIsIG1vbnRoLCBkYXlPZk1vbnRoLCBob3VyLCBtaW51dGUsIHNlY29uZCwgbmFub09mU2Vjb25kKSB7XG4gICAgaWYgKGhvdXIgPT09IHZvaWQgMCkge1xuICAgICAgaG91ciA9IDA7XG4gICAgfVxuXG4gICAgaWYgKG1pbnV0ZSA9PT0gdm9pZCAwKSB7XG4gICAgICBtaW51dGUgPSAwO1xuICAgIH1cblxuICAgIGlmIChzZWNvbmQgPT09IHZvaWQgMCkge1xuICAgICAgc2Vjb25kID0gMDtcbiAgICB9XG5cbiAgICBpZiAobmFub09mU2Vjb25kID09PSB2b2lkIDApIHtcbiAgICAgIG5hbm9PZlNlY29uZCA9IDA7XG4gICAgfVxuXG4gICAgdmFyIGRhdGUgPSBMb2NhbERhdGUub2YoeWVhciwgbW9udGgsIGRheU9mTW9udGgpO1xuICAgIHZhciB0aW1lID0gTG9jYWxUaW1lLm9mKGhvdXIsIG1pbnV0ZSwgc2Vjb25kLCBuYW5vT2ZTZWNvbmQpO1xuICAgIHJldHVybiBuZXcgTG9jYWxEYXRlVGltZShkYXRlLCB0aW1lKTtcbiAgfTtcblxuICBMb2NhbERhdGVUaW1lLm9mRGF0ZUFuZFRpbWUgPSBmdW5jdGlvbiBvZkRhdGVBbmRUaW1lKGRhdGUsIHRpbWUpIHtcbiAgICByZXF1aXJlTm9uTnVsbChkYXRlLCAnZGF0ZScpO1xuICAgIHJlcXVpcmVOb25OdWxsKHRpbWUsICd0aW1lJyk7XG4gICAgcmV0dXJuIG5ldyBMb2NhbERhdGVUaW1lKGRhdGUsIHRpbWUpO1xuICB9O1xuXG4gIExvY2FsRGF0ZVRpbWUub2ZJbnN0YW50ID0gZnVuY3Rpb24gb2ZJbnN0YW50KGluc3RhbnQsIHpvbmUpIHtcbiAgICBpZiAoem9uZSA9PT0gdm9pZCAwKSB7XG4gICAgICB6b25lID0gWm9uZUlkLnN5c3RlbURlZmF1bHQoKTtcbiAgICB9XG5cbiAgICByZXF1aXJlTm9uTnVsbChpbnN0YW50LCAnaW5zdGFudCcpO1xuICAgIHJlcXVpcmVJbnN0YW5jZShpbnN0YW50LCBJbnN0YW50LCAnaW5zdGFudCcpO1xuICAgIHJlcXVpcmVOb25OdWxsKHpvbmUsICd6b25lJyk7XG4gICAgdmFyIG9mZnNldCA9IHpvbmUucnVsZXMoKS5vZmZzZXQoaW5zdGFudCk7XG4gICAgcmV0dXJuIExvY2FsRGF0ZVRpbWUub2ZFcG9jaFNlY29uZChpbnN0YW50LmVwb2NoU2Vjb25kKCksIGluc3RhbnQubmFubygpLCBvZmZzZXQpO1xuICB9O1xuXG4gIExvY2FsRGF0ZVRpbWUub2ZFcG9jaFNlY29uZCA9IGZ1bmN0aW9uIG9mRXBvY2hTZWNvbmQoZXBvY2hTZWNvbmQsIG5hbm9PZlNlY29uZCwgb2Zmc2V0KSB7XG4gICAgaWYgKGVwb2NoU2Vjb25kID09PSB2b2lkIDApIHtcbiAgICAgIGVwb2NoU2Vjb25kID0gMDtcbiAgICB9XG5cbiAgICBpZiAobmFub09mU2Vjb25kID09PSB2b2lkIDApIHtcbiAgICAgIG5hbm9PZlNlY29uZCA9IDA7XG4gICAgfVxuXG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDIgJiYgbmFub09mU2Vjb25kIGluc3RhbmNlb2YgWm9uZU9mZnNldCkge1xuICAgICAgb2Zmc2V0ID0gbmFub09mU2Vjb25kO1xuICAgICAgbmFub09mU2Vjb25kID0gMDtcbiAgICB9XG5cbiAgICByZXF1aXJlTm9uTnVsbChvZmZzZXQsICdvZmZzZXQnKTtcbiAgICB2YXIgbG9jYWxTZWNvbmQgPSBlcG9jaFNlY29uZCArIG9mZnNldC50b3RhbFNlY29uZHMoKTtcbiAgICB2YXIgbG9jYWxFcG9jaERheSA9IE1hdGhVdGlsLmZsb29yRGl2KGxvY2FsU2Vjb25kLCBMb2NhbFRpbWUuU0VDT05EU19QRVJfREFZKTtcbiAgICB2YXIgc2Vjc09mRGF5ID0gTWF0aFV0aWwuZmxvb3JNb2QobG9jYWxTZWNvbmQsIExvY2FsVGltZS5TRUNPTkRTX1BFUl9EQVkpO1xuICAgIHZhciBkYXRlID0gTG9jYWxEYXRlLm9mRXBvY2hEYXkobG9jYWxFcG9jaERheSk7XG4gICAgdmFyIHRpbWUgPSBMb2NhbFRpbWUub2ZTZWNvbmRPZkRheShzZWNzT2ZEYXksIG5hbm9PZlNlY29uZCk7XG4gICAgcmV0dXJuIG5ldyBMb2NhbERhdGVUaW1lKGRhdGUsIHRpbWUpO1xuICB9O1xuXG4gIExvY2FsRGF0ZVRpbWUuZnJvbSA9IGZ1bmN0aW9uIGZyb20odGVtcG9yYWwpIHtcbiAgICByZXF1aXJlTm9uTnVsbCh0ZW1wb3JhbCwgJ3RlbXBvcmFsJyk7XG5cbiAgICBpZiAodGVtcG9yYWwgaW5zdGFuY2VvZiBMb2NhbERhdGVUaW1lKSB7XG4gICAgICByZXR1cm4gdGVtcG9yYWw7XG4gICAgfSBlbHNlIGlmICh0ZW1wb3JhbCBpbnN0YW5jZW9mIFpvbmVkRGF0ZVRpbWUpIHtcbiAgICAgIHJldHVybiB0ZW1wb3JhbC50b0xvY2FsRGF0ZVRpbWUoKTtcbiAgICB9XG5cbiAgICB0cnkge1xuICAgICAgdmFyIGRhdGUgPSBMb2NhbERhdGUuZnJvbSh0ZW1wb3JhbCk7XG4gICAgICB2YXIgdGltZSA9IExvY2FsVGltZS5mcm9tKHRlbXBvcmFsKTtcbiAgICAgIHJldHVybiBuZXcgTG9jYWxEYXRlVGltZShkYXRlLCB0aW1lKTtcbiAgICB9IGNhdGNoIChleCkge1xuICAgICAgdGhyb3cgbmV3IERhdGVUaW1lRXhjZXB0aW9uKFwiVW5hYmxlIHRvIG9idGFpbiBMb2NhbERhdGVUaW1lIFRlbXBvcmFsQWNjZXNzb3I6IFwiICsgdGVtcG9yYWwgKyBcIiwgdHlwZSBcIiArICh0ZW1wb3JhbC5jb25zdHJ1Y3RvciAhPSBudWxsID8gdGVtcG9yYWwuY29uc3RydWN0b3IubmFtZSA6ICcnKSk7XG4gICAgfVxuICB9O1xuXG4gIExvY2FsRGF0ZVRpbWUucGFyc2UgPSBmdW5jdGlvbiBwYXJzZSh0ZXh0LCBmb3JtYXR0ZXIpIHtcbiAgICBpZiAoZm9ybWF0dGVyID09PSB2b2lkIDApIHtcbiAgICAgIGZvcm1hdHRlciA9IERhdGVUaW1lRm9ybWF0dGVyLklTT19MT0NBTF9EQVRFX1RJTUU7XG4gICAgfVxuXG4gICAgcmVxdWlyZU5vbk51bGwoZm9ybWF0dGVyLCAnZm9ybWF0dGVyJyk7XG4gICAgcmV0dXJuIGZvcm1hdHRlci5wYXJzZSh0ZXh0LCBMb2NhbERhdGVUaW1lLkZST00pO1xuICB9O1xuXG4gIGZ1bmN0aW9uIExvY2FsRGF0ZVRpbWUoZGF0ZSwgdGltZSkge1xuICAgIHZhciBfdGhpcztcblxuICAgIF90aGlzID0gX0Nocm9ub0xvY2FsRGF0ZVRpbWUuY2FsbCh0aGlzKSB8fCB0aGlzO1xuICAgIHJlcXVpcmVJbnN0YW5jZShkYXRlLCBMb2NhbERhdGUsICdkYXRlJyk7XG4gICAgcmVxdWlyZUluc3RhbmNlKHRpbWUsIExvY2FsVGltZSwgJ3RpbWUnKTtcbiAgICBfdGhpcy5fZGF0ZSA9IGRhdGU7XG4gICAgX3RoaXMuX3RpbWUgPSB0aW1lO1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuXG4gIHZhciBfcHJvdG8gPSBMb2NhbERhdGVUaW1lLnByb3RvdHlwZTtcblxuICBfcHJvdG8uX3dpdGhEYXRlVGltZSA9IGZ1bmN0aW9uIF93aXRoRGF0ZVRpbWUobmV3RGF0ZSwgbmV3VGltZSkge1xuICAgIGlmICh0aGlzLl9kYXRlLmVxdWFscyhuZXdEYXRlKSAmJiB0aGlzLl90aW1lLmVxdWFscyhuZXdUaW1lKSkge1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgcmV0dXJuIG5ldyBMb2NhbERhdGVUaW1lKG5ld0RhdGUsIG5ld1RpbWUpO1xuICB9O1xuXG4gIF9wcm90by5pc1N1cHBvcnRlZCA9IGZ1bmN0aW9uIGlzU3VwcG9ydGVkKGZpZWxkT3JVbml0KSB7XG4gICAgaWYgKGZpZWxkT3JVbml0IGluc3RhbmNlb2YgQ2hyb25vRmllbGQpIHtcbiAgICAgIHJldHVybiBmaWVsZE9yVW5pdC5pc0RhdGVCYXNlZCgpIHx8IGZpZWxkT3JVbml0LmlzVGltZUJhc2VkKCk7XG4gICAgfSBlbHNlIGlmIChmaWVsZE9yVW5pdCBpbnN0YW5jZW9mIENocm9ub1VuaXQpIHtcbiAgICAgIHJldHVybiBmaWVsZE9yVW5pdC5pc0RhdGVCYXNlZCgpIHx8IGZpZWxkT3JVbml0LmlzVGltZUJhc2VkKCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZpZWxkT3JVbml0ICE9IG51bGwgJiYgZmllbGRPclVuaXQuaXNTdXBwb3J0ZWRCeSh0aGlzKTtcbiAgfTtcblxuICBfcHJvdG8ucmFuZ2UgPSBmdW5jdGlvbiByYW5nZShmaWVsZCkge1xuICAgIGlmIChmaWVsZCBpbnN0YW5jZW9mIENocm9ub0ZpZWxkKSB7XG4gICAgICByZXR1cm4gZmllbGQuaXNUaW1lQmFzZWQoKSA/IHRoaXMuX3RpbWUucmFuZ2UoZmllbGQpIDogdGhpcy5fZGF0ZS5yYW5nZShmaWVsZCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZpZWxkLnJhbmdlUmVmaW5lZEJ5KHRoaXMpO1xuICB9O1xuXG4gIF9wcm90by5nZXQgPSBmdW5jdGlvbiBnZXQoZmllbGQpIHtcbiAgICBpZiAoZmllbGQgaW5zdGFuY2VvZiBDaHJvbm9GaWVsZCkge1xuICAgICAgcmV0dXJuIGZpZWxkLmlzVGltZUJhc2VkKCkgPyB0aGlzLl90aW1lLmdldChmaWVsZCkgOiB0aGlzLl9kYXRlLmdldChmaWVsZCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIF9DaHJvbm9Mb2NhbERhdGVUaW1lLnByb3RvdHlwZS5nZXQuY2FsbCh0aGlzLCBmaWVsZCk7XG4gIH07XG5cbiAgX3Byb3RvLmdldExvbmcgPSBmdW5jdGlvbiBnZXRMb25nKGZpZWxkKSB7XG4gICAgcmVxdWlyZU5vbk51bGwoZmllbGQsICdmaWVsZCcpO1xuXG4gICAgaWYgKGZpZWxkIGluc3RhbmNlb2YgQ2hyb25vRmllbGQpIHtcbiAgICAgIHJldHVybiBmaWVsZC5pc1RpbWVCYXNlZCgpID8gdGhpcy5fdGltZS5nZXRMb25nKGZpZWxkKSA6IHRoaXMuX2RhdGUuZ2V0TG9uZyhmaWVsZCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZpZWxkLmdldEZyb20odGhpcyk7XG4gIH07XG5cbiAgX3Byb3RvLnllYXIgPSBmdW5jdGlvbiB5ZWFyKCkge1xuICAgIHJldHVybiB0aGlzLl9kYXRlLnllYXIoKTtcbiAgfTtcblxuICBfcHJvdG8ubW9udGhWYWx1ZSA9IGZ1bmN0aW9uIG1vbnRoVmFsdWUoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2RhdGUubW9udGhWYWx1ZSgpO1xuICB9O1xuXG4gIF9wcm90by5tb250aCA9IGZ1bmN0aW9uIG1vbnRoKCkge1xuICAgIHJldHVybiB0aGlzLl9kYXRlLm1vbnRoKCk7XG4gIH07XG5cbiAgX3Byb3RvLmRheU9mTW9udGggPSBmdW5jdGlvbiBkYXlPZk1vbnRoKCkge1xuICAgIHJldHVybiB0aGlzLl9kYXRlLmRheU9mTW9udGgoKTtcbiAgfTtcblxuICBfcHJvdG8uZGF5T2ZZZWFyID0gZnVuY3Rpb24gZGF5T2ZZZWFyKCkge1xuICAgIHJldHVybiB0aGlzLl9kYXRlLmRheU9mWWVhcigpO1xuICB9O1xuXG4gIF9wcm90by5kYXlPZldlZWsgPSBmdW5jdGlvbiBkYXlPZldlZWsoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2RhdGUuZGF5T2ZXZWVrKCk7XG4gIH07XG5cbiAgX3Byb3RvLmhvdXIgPSBmdW5jdGlvbiBob3VyKCkge1xuICAgIHJldHVybiB0aGlzLl90aW1lLmhvdXIoKTtcbiAgfTtcblxuICBfcHJvdG8ubWludXRlID0gZnVuY3Rpb24gbWludXRlKCkge1xuICAgIHJldHVybiB0aGlzLl90aW1lLm1pbnV0ZSgpO1xuICB9O1xuXG4gIF9wcm90by5zZWNvbmQgPSBmdW5jdGlvbiBzZWNvbmQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3RpbWUuc2Vjb25kKCk7XG4gIH07XG5cbiAgX3Byb3RvLm5hbm8gPSBmdW5jdGlvbiBuYW5vKCkge1xuICAgIHJldHVybiB0aGlzLl90aW1lLm5hbm8oKTtcbiAgfTtcblxuICBfcHJvdG8ud2l0aEFkanVzdGVyID0gZnVuY3Rpb24gd2l0aEFkanVzdGVyKGFkanVzdGVyKSB7XG4gICAgcmVxdWlyZU5vbk51bGwoYWRqdXN0ZXIsICdhZGp1c3RlcicpO1xuXG4gICAgaWYgKGFkanVzdGVyIGluc3RhbmNlb2YgTG9jYWxEYXRlKSB7XG4gICAgICByZXR1cm4gdGhpcy5fd2l0aERhdGVUaW1lKGFkanVzdGVyLCB0aGlzLl90aW1lKTtcbiAgICB9IGVsc2UgaWYgKGFkanVzdGVyIGluc3RhbmNlb2YgTG9jYWxUaW1lKSB7XG4gICAgICByZXR1cm4gdGhpcy5fd2l0aERhdGVUaW1lKHRoaXMuX2RhdGUsIGFkanVzdGVyKTtcbiAgICB9IGVsc2UgaWYgKGFkanVzdGVyIGluc3RhbmNlb2YgTG9jYWxEYXRlVGltZSkge1xuICAgICAgcmV0dXJuIGFkanVzdGVyO1xuICAgIH1cblxuICAgIGFzc2VydCh0eXBlb2YgYWRqdXN0ZXIuYWRqdXN0SW50byA9PT0gJ2Z1bmN0aW9uJywgJ2FkanVzdGVyJywgSWxsZWdhbEFyZ3VtZW50RXhjZXB0aW9uKTtcbiAgICByZXR1cm4gYWRqdXN0ZXIuYWRqdXN0SW50byh0aGlzKTtcbiAgfTtcblxuICBfcHJvdG8ud2l0aEZpZWxkVmFsdWUgPSBmdW5jdGlvbiB3aXRoRmllbGRWYWx1ZShmaWVsZCwgbmV3VmFsdWUpIHtcbiAgICByZXF1aXJlTm9uTnVsbChmaWVsZCwgJ2ZpZWxkJyk7XG5cbiAgICBpZiAoZmllbGQgaW5zdGFuY2VvZiBDaHJvbm9GaWVsZCkge1xuICAgICAgaWYgKGZpZWxkLmlzVGltZUJhc2VkKCkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3dpdGhEYXRlVGltZSh0aGlzLl9kYXRlLCB0aGlzLl90aW1lLndpdGgoZmllbGQsIG5ld1ZhbHVlKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gdGhpcy5fd2l0aERhdGVUaW1lKHRoaXMuX2RhdGUud2l0aChmaWVsZCwgbmV3VmFsdWUpLCB0aGlzLl90aW1lKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gZmllbGQuYWRqdXN0SW50byh0aGlzLCBuZXdWYWx1ZSk7XG4gIH07XG5cbiAgX3Byb3RvLndpdGhZZWFyID0gZnVuY3Rpb24gd2l0aFllYXIoeWVhcikge1xuICAgIHJldHVybiB0aGlzLl93aXRoRGF0ZVRpbWUodGhpcy5fZGF0ZS53aXRoWWVhcih5ZWFyKSwgdGhpcy5fdGltZSk7XG4gIH07XG5cbiAgX3Byb3RvLndpdGhNb250aCA9IGZ1bmN0aW9uIHdpdGhNb250aChtb250aCkge1xuICAgIHJldHVybiB0aGlzLl93aXRoRGF0ZVRpbWUodGhpcy5fZGF0ZS53aXRoTW9udGgobW9udGgpLCB0aGlzLl90aW1lKTtcbiAgfTtcblxuICBfcHJvdG8ud2l0aERheU9mTW9udGggPSBmdW5jdGlvbiB3aXRoRGF5T2ZNb250aChkYXlPZk1vbnRoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3dpdGhEYXRlVGltZSh0aGlzLl9kYXRlLndpdGhEYXlPZk1vbnRoKGRheU9mTW9udGgpLCB0aGlzLl90aW1lKTtcbiAgfTtcblxuICBfcHJvdG8ud2l0aERheU9mWWVhciA9IGZ1bmN0aW9uIHdpdGhEYXlPZlllYXIoZGF5T2ZZZWFyKSB7XG4gICAgcmV0dXJuIHRoaXMuX3dpdGhEYXRlVGltZSh0aGlzLl9kYXRlLndpdGhEYXlPZlllYXIoZGF5T2ZZZWFyKSwgdGhpcy5fdGltZSk7XG4gIH07XG5cbiAgX3Byb3RvLndpdGhIb3VyID0gZnVuY3Rpb24gd2l0aEhvdXIoaG91cikge1xuICAgIHZhciBuZXdUaW1lID0gdGhpcy5fdGltZS53aXRoSG91cihob3VyKTtcblxuICAgIHJldHVybiB0aGlzLl93aXRoRGF0ZVRpbWUodGhpcy5fZGF0ZSwgbmV3VGltZSk7XG4gIH07XG5cbiAgX3Byb3RvLndpdGhNaW51dGUgPSBmdW5jdGlvbiB3aXRoTWludXRlKG1pbnV0ZSkge1xuICAgIHZhciBuZXdUaW1lID0gdGhpcy5fdGltZS53aXRoTWludXRlKG1pbnV0ZSk7XG5cbiAgICByZXR1cm4gdGhpcy5fd2l0aERhdGVUaW1lKHRoaXMuX2RhdGUsIG5ld1RpbWUpO1xuICB9O1xuXG4gIF9wcm90by53aXRoU2Vjb25kID0gZnVuY3Rpb24gd2l0aFNlY29uZChzZWNvbmQpIHtcbiAgICB2YXIgbmV3VGltZSA9IHRoaXMuX3RpbWUud2l0aFNlY29uZChzZWNvbmQpO1xuXG4gICAgcmV0dXJuIHRoaXMuX3dpdGhEYXRlVGltZSh0aGlzLl9kYXRlLCBuZXdUaW1lKTtcbiAgfTtcblxuICBfcHJvdG8ud2l0aE5hbm8gPSBmdW5jdGlvbiB3aXRoTmFubyhuYW5vT2ZTZWNvbmQpIHtcbiAgICB2YXIgbmV3VGltZSA9IHRoaXMuX3RpbWUud2l0aE5hbm8obmFub09mU2Vjb25kKTtcblxuICAgIHJldHVybiB0aGlzLl93aXRoRGF0ZVRpbWUodGhpcy5fZGF0ZSwgbmV3VGltZSk7XG4gIH07XG5cbiAgX3Byb3RvLnRydW5jYXRlZFRvID0gZnVuY3Rpb24gdHJ1bmNhdGVkVG8odW5pdCkge1xuICAgIHJldHVybiB0aGlzLl93aXRoRGF0ZVRpbWUodGhpcy5fZGF0ZSwgdGhpcy5fdGltZS50cnVuY2F0ZWRUbyh1bml0KSk7XG4gIH07XG5cbiAgX3Byb3RvLnBsdXNBbW91bnQgPSBmdW5jdGlvbiBwbHVzQW1vdW50KGFtb3VudCkge1xuICAgIHJlcXVpcmVOb25OdWxsKGFtb3VudCwgJ2Ftb3VudCcpO1xuICAgIHJldHVybiBhbW91bnQuYWRkVG8odGhpcyk7XG4gIH07XG5cbiAgX3Byb3RvLnBsdXNBbW91bnRVbml0ID0gZnVuY3Rpb24gcGx1c0Ftb3VudFVuaXQoYW1vdW50VG9BZGQsIHVuaXQpIHtcbiAgICByZXF1aXJlTm9uTnVsbCh1bml0LCAndW5pdCcpO1xuXG4gICAgaWYgKHVuaXQgaW5zdGFuY2VvZiBDaHJvbm9Vbml0KSB7XG4gICAgICBzd2l0Y2ggKHVuaXQpIHtcbiAgICAgICAgY2FzZSBDaHJvbm9Vbml0Lk5BTk9TOlxuICAgICAgICAgIHJldHVybiB0aGlzLnBsdXNOYW5vcyhhbW91bnRUb0FkZCk7XG5cbiAgICAgICAgY2FzZSBDaHJvbm9Vbml0Lk1JQ1JPUzpcbiAgICAgICAgICByZXR1cm4gdGhpcy5wbHVzRGF5cyhNYXRoVXRpbC5pbnREaXYoYW1vdW50VG9BZGQsIExvY2FsVGltZS5NSUNST1NfUEVSX0RBWSkpLnBsdXNOYW5vcyhNYXRoVXRpbC5pbnRNb2QoYW1vdW50VG9BZGQsIExvY2FsVGltZS5NSUNST1NfUEVSX0RBWSkgKiAxMDAwKTtcblxuICAgICAgICBjYXNlIENocm9ub1VuaXQuTUlMTElTOlxuICAgICAgICAgIHJldHVybiB0aGlzLnBsdXNEYXlzKE1hdGhVdGlsLmludERpdihhbW91bnRUb0FkZCwgTG9jYWxUaW1lLk1JTExJU19QRVJfREFZKSkucGx1c05hbm9zKE1hdGhVdGlsLmludE1vZChhbW91bnRUb0FkZCwgTG9jYWxUaW1lLk1JTExJU19QRVJfREFZKSAqIDEwMDAwMDApO1xuXG4gICAgICAgIGNhc2UgQ2hyb25vVW5pdC5TRUNPTkRTOlxuICAgICAgICAgIHJldHVybiB0aGlzLnBsdXNTZWNvbmRzKGFtb3VudFRvQWRkKTtcblxuICAgICAgICBjYXNlIENocm9ub1VuaXQuTUlOVVRFUzpcbiAgICAgICAgICByZXR1cm4gdGhpcy5wbHVzTWludXRlcyhhbW91bnRUb0FkZCk7XG5cbiAgICAgICAgY2FzZSBDaHJvbm9Vbml0LkhPVVJTOlxuICAgICAgICAgIHJldHVybiB0aGlzLnBsdXNIb3VycyhhbW91bnRUb0FkZCk7XG5cbiAgICAgICAgY2FzZSBDaHJvbm9Vbml0LkhBTEZfREFZUzpcbiAgICAgICAgICByZXR1cm4gdGhpcy5wbHVzRGF5cyhNYXRoVXRpbC5pbnREaXYoYW1vdW50VG9BZGQsIDI1NikpLnBsdXNIb3VycyhNYXRoVXRpbC5pbnRNb2QoYW1vdW50VG9BZGQsIDI1NikgKiAxMik7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzLl93aXRoRGF0ZVRpbWUodGhpcy5fZGF0ZS5wbHVzKGFtb3VudFRvQWRkLCB1bml0KSwgdGhpcy5fdGltZSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHVuaXQuYWRkVG8odGhpcywgYW1vdW50VG9BZGQpO1xuICB9O1xuXG4gIF9wcm90by5wbHVzWWVhcnMgPSBmdW5jdGlvbiBwbHVzWWVhcnMoeWVhcnMpIHtcbiAgICB2YXIgbmV3RGF0ZSA9IHRoaXMuX2RhdGUucGx1c1llYXJzKHllYXJzKTtcblxuICAgIHJldHVybiB0aGlzLl93aXRoRGF0ZVRpbWUobmV3RGF0ZSwgdGhpcy5fdGltZSk7XG4gIH07XG5cbiAgX3Byb3RvLnBsdXNNb250aHMgPSBmdW5jdGlvbiBwbHVzTW9udGhzKG1vbnRocykge1xuICAgIHZhciBuZXdEYXRlID0gdGhpcy5fZGF0ZS5wbHVzTW9udGhzKG1vbnRocyk7XG5cbiAgICByZXR1cm4gdGhpcy5fd2l0aERhdGVUaW1lKG5ld0RhdGUsIHRoaXMuX3RpbWUpO1xuICB9O1xuXG4gIF9wcm90by5wbHVzV2Vla3MgPSBmdW5jdGlvbiBwbHVzV2Vla3Mod2Vla3MpIHtcbiAgICB2YXIgbmV3RGF0ZSA9IHRoaXMuX2RhdGUucGx1c1dlZWtzKHdlZWtzKTtcblxuICAgIHJldHVybiB0aGlzLl93aXRoRGF0ZVRpbWUobmV3RGF0ZSwgdGhpcy5fdGltZSk7XG4gIH07XG5cbiAgX3Byb3RvLnBsdXNEYXlzID0gZnVuY3Rpb24gcGx1c0RheXMoZGF5cykge1xuICAgIHZhciBuZXdEYXRlID0gdGhpcy5fZGF0ZS5wbHVzRGF5cyhkYXlzKTtcblxuICAgIHJldHVybiB0aGlzLl93aXRoRGF0ZVRpbWUobmV3RGF0ZSwgdGhpcy5fdGltZSk7XG4gIH07XG5cbiAgX3Byb3RvLnBsdXNIb3VycyA9IGZ1bmN0aW9uIHBsdXNIb3Vycyhob3Vycykge1xuICAgIHJldHVybiB0aGlzLl9wbHVzV2l0aE92ZXJmbG93KHRoaXMuX2RhdGUsIGhvdXJzLCAwLCAwLCAwLCAxKTtcbiAgfTtcblxuICBfcHJvdG8ucGx1c01pbnV0ZXMgPSBmdW5jdGlvbiBwbHVzTWludXRlcyhtaW51dGVzKSB7XG4gICAgcmV0dXJuIHRoaXMuX3BsdXNXaXRoT3ZlcmZsb3codGhpcy5fZGF0ZSwgMCwgbWludXRlcywgMCwgMCwgMSk7XG4gIH07XG5cbiAgX3Byb3RvLnBsdXNTZWNvbmRzID0gZnVuY3Rpb24gcGx1c1NlY29uZHMoc2Vjb25kcykge1xuICAgIHJldHVybiB0aGlzLl9wbHVzV2l0aE92ZXJmbG93KHRoaXMuX2RhdGUsIDAsIDAsIHNlY29uZHMsIDAsIDEpO1xuICB9O1xuXG4gIF9wcm90by5wbHVzTmFub3MgPSBmdW5jdGlvbiBwbHVzTmFub3MobmFub3MpIHtcbiAgICByZXR1cm4gdGhpcy5fcGx1c1dpdGhPdmVyZmxvdyh0aGlzLl9kYXRlLCAwLCAwLCAwLCBuYW5vcywgMSk7XG4gIH07XG5cbiAgX3Byb3RvLm1pbnVzQW1vdW50ID0gZnVuY3Rpb24gbWludXNBbW91bnQoYW1vdW50KSB7XG4gICAgcmVxdWlyZU5vbk51bGwoYW1vdW50LCAnYW1vdW50Jyk7XG4gICAgcmV0dXJuIGFtb3VudC5zdWJ0cmFjdEZyb20odGhpcyk7XG4gIH07XG5cbiAgX3Byb3RvLm1pbnVzQW1vdW50VW5pdCA9IGZ1bmN0aW9uIG1pbnVzQW1vdW50VW5pdChhbW91bnRUb1N1YnRyYWN0LCB1bml0KSB7XG4gICAgcmVxdWlyZU5vbk51bGwodW5pdCwgJ3VuaXQnKTtcbiAgICByZXR1cm4gdGhpcy5wbHVzQW1vdW50VW5pdCgtMSAqIGFtb3VudFRvU3VidHJhY3QsIHVuaXQpO1xuICB9O1xuXG4gIF9wcm90by5taW51c1llYXJzID0gZnVuY3Rpb24gbWludXNZZWFycyh5ZWFycykge1xuICAgIHJldHVybiB0aGlzLnBsdXNZZWFycygtMSAqIHllYXJzKTtcbiAgfTtcblxuICBfcHJvdG8ubWludXNNb250aHMgPSBmdW5jdGlvbiBtaW51c01vbnRocyhtb250aHMpIHtcbiAgICByZXR1cm4gdGhpcy5wbHVzTW9udGhzKC0xICogbW9udGhzKTtcbiAgfTtcblxuICBfcHJvdG8ubWludXNXZWVrcyA9IGZ1bmN0aW9uIG1pbnVzV2Vla3Mod2Vla3MpIHtcbiAgICByZXR1cm4gdGhpcy5wbHVzV2Vla3MoLTEgKiB3ZWVrcyk7XG4gIH07XG5cbiAgX3Byb3RvLm1pbnVzRGF5cyA9IGZ1bmN0aW9uIG1pbnVzRGF5cyhkYXlzKSB7XG4gICAgcmV0dXJuIHRoaXMucGx1c0RheXMoLTEgKiBkYXlzKTtcbiAgfTtcblxuICBfcHJvdG8ubWludXNIb3VycyA9IGZ1bmN0aW9uIG1pbnVzSG91cnMoaG91cnMpIHtcbiAgICByZXR1cm4gdGhpcy5fcGx1c1dpdGhPdmVyZmxvdyh0aGlzLl9kYXRlLCBob3VycywgMCwgMCwgMCwgLTEpO1xuICB9O1xuXG4gIF9wcm90by5taW51c01pbnV0ZXMgPSBmdW5jdGlvbiBtaW51c01pbnV0ZXMobWludXRlcykge1xuICAgIHJldHVybiB0aGlzLl9wbHVzV2l0aE92ZXJmbG93KHRoaXMuX2RhdGUsIDAsIG1pbnV0ZXMsIDAsIDAsIC0xKTtcbiAgfTtcblxuICBfcHJvdG8ubWludXNTZWNvbmRzID0gZnVuY3Rpb24gbWludXNTZWNvbmRzKHNlY29uZHMpIHtcbiAgICByZXR1cm4gdGhpcy5fcGx1c1dpdGhPdmVyZmxvdyh0aGlzLl9kYXRlLCAwLCAwLCBzZWNvbmRzLCAwLCAtMSk7XG4gIH07XG5cbiAgX3Byb3RvLm1pbnVzTmFub3MgPSBmdW5jdGlvbiBtaW51c05hbm9zKG5hbm9zKSB7XG4gICAgcmV0dXJuIHRoaXMuX3BsdXNXaXRoT3ZlcmZsb3codGhpcy5fZGF0ZSwgMCwgMCwgMCwgbmFub3MsIC0xKTtcbiAgfTtcblxuICBfcHJvdG8uX3BsdXNXaXRoT3ZlcmZsb3cgPSBmdW5jdGlvbiBfcGx1c1dpdGhPdmVyZmxvdyhuZXdEYXRlLCBob3VycywgbWludXRlcywgc2Vjb25kcywgbmFub3MsIHNpZ24pIHtcbiAgICBpZiAoaG91cnMgPT09IDAgJiYgbWludXRlcyA9PT0gMCAmJiBzZWNvbmRzID09PSAwICYmIG5hbm9zID09PSAwKSB7XG4gICAgICByZXR1cm4gdGhpcy5fd2l0aERhdGVUaW1lKG5ld0RhdGUsIHRoaXMuX3RpbWUpO1xuICAgIH1cblxuICAgIHZhciB0b3REYXlzID0gTWF0aFV0aWwuaW50RGl2KG5hbm9zLCBMb2NhbFRpbWUuTkFOT1NfUEVSX0RBWSkgKyBNYXRoVXRpbC5pbnREaXYoc2Vjb25kcywgTG9jYWxUaW1lLlNFQ09ORFNfUEVSX0RBWSkgKyBNYXRoVXRpbC5pbnREaXYobWludXRlcywgTG9jYWxUaW1lLk1JTlVURVNfUEVSX0RBWSkgKyBNYXRoVXRpbC5pbnREaXYoaG91cnMsIExvY2FsVGltZS5IT1VSU19QRVJfREFZKTtcbiAgICB0b3REYXlzICo9IHNpZ247XG4gICAgdmFyIHRvdE5hbm9zID0gTWF0aFV0aWwuaW50TW9kKG5hbm9zLCBMb2NhbFRpbWUuTkFOT1NfUEVSX0RBWSkgKyBNYXRoVXRpbC5pbnRNb2Qoc2Vjb25kcywgTG9jYWxUaW1lLlNFQ09ORFNfUEVSX0RBWSkgKiBMb2NhbFRpbWUuTkFOT1NfUEVSX1NFQ09ORCArIE1hdGhVdGlsLmludE1vZChtaW51dGVzLCBMb2NhbFRpbWUuTUlOVVRFU19QRVJfREFZKSAqIExvY2FsVGltZS5OQU5PU19QRVJfTUlOVVRFICsgTWF0aFV0aWwuaW50TW9kKGhvdXJzLCBMb2NhbFRpbWUuSE9VUlNfUEVSX0RBWSkgKiBMb2NhbFRpbWUuTkFOT1NfUEVSX0hPVVI7XG5cbiAgICB2YXIgY3VyTm9EID0gdGhpcy5fdGltZS50b05hbm9PZkRheSgpO1xuXG4gICAgdG90TmFub3MgPSB0b3ROYW5vcyAqIHNpZ24gKyBjdXJOb0Q7XG4gICAgdG90RGF5cyArPSBNYXRoVXRpbC5mbG9vckRpdih0b3ROYW5vcywgTG9jYWxUaW1lLk5BTk9TX1BFUl9EQVkpO1xuICAgIHZhciBuZXdOb0QgPSBNYXRoVXRpbC5mbG9vck1vZCh0b3ROYW5vcywgTG9jYWxUaW1lLk5BTk9TX1BFUl9EQVkpO1xuICAgIHZhciBuZXdUaW1lID0gbmV3Tm9EID09PSBjdXJOb0QgPyB0aGlzLl90aW1lIDogTG9jYWxUaW1lLm9mTmFub09mRGF5KG5ld05vRCk7XG4gICAgcmV0dXJuIHRoaXMuX3dpdGhEYXRlVGltZShuZXdEYXRlLnBsdXNEYXlzKHRvdERheXMpLCBuZXdUaW1lKTtcbiAgfTtcblxuICBfcHJvdG8ucXVlcnkgPSBmdW5jdGlvbiBxdWVyeShfcXVlcnkpIHtcbiAgICByZXF1aXJlTm9uTnVsbChfcXVlcnksICdxdWVyeScpO1xuXG4gICAgaWYgKF9xdWVyeSA9PT0gVGVtcG9yYWxRdWVyaWVzLmxvY2FsRGF0ZSgpKSB7XG4gICAgICByZXR1cm4gdGhpcy50b0xvY2FsRGF0ZSgpO1xuICAgIH1cblxuICAgIHJldHVybiBfQ2hyb25vTG9jYWxEYXRlVGltZS5wcm90b3R5cGUucXVlcnkuY2FsbCh0aGlzLCBfcXVlcnkpO1xuICB9O1xuXG4gIF9wcm90by5hZGp1c3RJbnRvID0gZnVuY3Rpb24gYWRqdXN0SW50byh0ZW1wb3JhbCkge1xuICAgIHJldHVybiBfQ2hyb25vTG9jYWxEYXRlVGltZS5wcm90b3R5cGUuYWRqdXN0SW50by5jYWxsKHRoaXMsIHRlbXBvcmFsKTtcbiAgfTtcblxuICBfcHJvdG8udW50aWwgPSBmdW5jdGlvbiB1bnRpbChlbmRFeGNsdXNpdmUsIHVuaXQpIHtcbiAgICByZXF1aXJlTm9uTnVsbChlbmRFeGNsdXNpdmUsICdlbmRFeGNsdXNpdmUnKTtcbiAgICByZXF1aXJlTm9uTnVsbCh1bml0LCAndW5pdCcpO1xuICAgIHZhciBlbmQgPSBMb2NhbERhdGVUaW1lLmZyb20oZW5kRXhjbHVzaXZlKTtcblxuICAgIGlmICh1bml0IGluc3RhbmNlb2YgQ2hyb25vVW5pdCkge1xuICAgICAgaWYgKHVuaXQuaXNUaW1lQmFzZWQoKSkge1xuICAgICAgICB2YXIgZGF5c1VudGlsID0gdGhpcy5fZGF0ZS5kYXlzVW50aWwoZW5kLl9kYXRlKTtcblxuICAgICAgICB2YXIgdGltZVVudGlsID0gZW5kLl90aW1lLnRvTmFub09mRGF5KCkgLSB0aGlzLl90aW1lLnRvTmFub09mRGF5KCk7XG5cbiAgICAgICAgaWYgKGRheXNVbnRpbCA+IDAgJiYgdGltZVVudGlsIDwgMCkge1xuICAgICAgICAgIGRheXNVbnRpbC0tO1xuICAgICAgICAgIHRpbWVVbnRpbCArPSBMb2NhbFRpbWUuTkFOT1NfUEVSX0RBWTtcbiAgICAgICAgfSBlbHNlIGlmIChkYXlzVW50aWwgPCAwICYmIHRpbWVVbnRpbCA+IDApIHtcbiAgICAgICAgICBkYXlzVW50aWwrKztcbiAgICAgICAgICB0aW1lVW50aWwgLT0gTG9jYWxUaW1lLk5BTk9TX1BFUl9EQVk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgYW1vdW50ID0gZGF5c1VudGlsO1xuXG4gICAgICAgIHN3aXRjaCAodW5pdCkge1xuICAgICAgICAgIGNhc2UgQ2hyb25vVW5pdC5OQU5PUzpcbiAgICAgICAgICAgIGFtb3VudCA9IE1hdGhVdGlsLnNhZmVNdWx0aXBseShhbW91bnQsIExvY2FsVGltZS5OQU5PU19QRVJfREFZKTtcbiAgICAgICAgICAgIHJldHVybiBNYXRoVXRpbC5zYWZlQWRkKGFtb3VudCwgdGltZVVudGlsKTtcblxuICAgICAgICAgIGNhc2UgQ2hyb25vVW5pdC5NSUNST1M6XG4gICAgICAgICAgICBhbW91bnQgPSBNYXRoVXRpbC5zYWZlTXVsdGlwbHkoYW1vdW50LCBMb2NhbFRpbWUuTUlDUk9TX1BFUl9EQVkpO1xuICAgICAgICAgICAgcmV0dXJuIE1hdGhVdGlsLnNhZmVBZGQoYW1vdW50LCBNYXRoVXRpbC5pbnREaXYodGltZVVudGlsLCAxMDAwKSk7XG5cbiAgICAgICAgICBjYXNlIENocm9ub1VuaXQuTUlMTElTOlxuICAgICAgICAgICAgYW1vdW50ID0gTWF0aFV0aWwuc2FmZU11bHRpcGx5KGFtb3VudCwgTG9jYWxUaW1lLk1JTExJU19QRVJfREFZKTtcbiAgICAgICAgICAgIHJldHVybiBNYXRoVXRpbC5zYWZlQWRkKGFtb3VudCwgTWF0aFV0aWwuaW50RGl2KHRpbWVVbnRpbCwgMTAwMDAwMCkpO1xuXG4gICAgICAgICAgY2FzZSBDaHJvbm9Vbml0LlNFQ09ORFM6XG4gICAgICAgICAgICBhbW91bnQgPSBNYXRoVXRpbC5zYWZlTXVsdGlwbHkoYW1vdW50LCBMb2NhbFRpbWUuU0VDT05EU19QRVJfREFZKTtcbiAgICAgICAgICAgIHJldHVybiBNYXRoVXRpbC5zYWZlQWRkKGFtb3VudCwgTWF0aFV0aWwuaW50RGl2KHRpbWVVbnRpbCwgTG9jYWxUaW1lLk5BTk9TX1BFUl9TRUNPTkQpKTtcblxuICAgICAgICAgIGNhc2UgQ2hyb25vVW5pdC5NSU5VVEVTOlxuICAgICAgICAgICAgYW1vdW50ID0gTWF0aFV0aWwuc2FmZU11bHRpcGx5KGFtb3VudCwgTG9jYWxUaW1lLk1JTlVURVNfUEVSX0RBWSk7XG4gICAgICAgICAgICByZXR1cm4gTWF0aFV0aWwuc2FmZUFkZChhbW91bnQsIE1hdGhVdGlsLmludERpdih0aW1lVW50aWwsIExvY2FsVGltZS5OQU5PU19QRVJfTUlOVVRFKSk7XG5cbiAgICAgICAgICBjYXNlIENocm9ub1VuaXQuSE9VUlM6XG4gICAgICAgICAgICBhbW91bnQgPSBNYXRoVXRpbC5zYWZlTXVsdGlwbHkoYW1vdW50LCBMb2NhbFRpbWUuSE9VUlNfUEVSX0RBWSk7XG4gICAgICAgICAgICByZXR1cm4gTWF0aFV0aWwuc2FmZUFkZChhbW91bnQsIE1hdGhVdGlsLmludERpdih0aW1lVW50aWwsIExvY2FsVGltZS5OQU5PU19QRVJfSE9VUikpO1xuXG4gICAgICAgICAgY2FzZSBDaHJvbm9Vbml0LkhBTEZfREFZUzpcbiAgICAgICAgICAgIGFtb3VudCA9IE1hdGhVdGlsLnNhZmVNdWx0aXBseShhbW91bnQsIDIpO1xuICAgICAgICAgICAgcmV0dXJuIE1hdGhVdGlsLnNhZmVBZGQoYW1vdW50LCBNYXRoVXRpbC5pbnREaXYodGltZVVudGlsLCBMb2NhbFRpbWUuTkFOT1NfUEVSX0hPVVIgKiAxMikpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhyb3cgbmV3IFVuc3VwcG9ydGVkVGVtcG9yYWxUeXBlRXhjZXB0aW9uKCdVbnN1cHBvcnRlZCB1bml0OiAnICsgdW5pdCk7XG4gICAgICB9XG5cbiAgICAgIHZhciBlbmREYXRlID0gZW5kLl9kYXRlO1xuICAgICAgdmFyIGVuZFRpbWUgPSBlbmQuX3RpbWU7XG5cbiAgICAgIGlmIChlbmREYXRlLmlzQWZ0ZXIodGhpcy5fZGF0ZSkgJiYgZW5kVGltZS5pc0JlZm9yZSh0aGlzLl90aW1lKSkge1xuICAgICAgICBlbmREYXRlID0gZW5kRGF0ZS5taW51c0RheXMoMSk7XG4gICAgICB9IGVsc2UgaWYgKGVuZERhdGUuaXNCZWZvcmUodGhpcy5fZGF0ZSkgJiYgZW5kVGltZS5pc0FmdGVyKHRoaXMuX3RpbWUpKSB7XG4gICAgICAgIGVuZERhdGUgPSBlbmREYXRlLnBsdXNEYXlzKDEpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcy5fZGF0ZS51bnRpbChlbmREYXRlLCB1bml0KTtcbiAgICB9XG5cbiAgICByZXR1cm4gdW5pdC5iZXR3ZWVuKHRoaXMsIGVuZCk7XG4gIH07XG5cbiAgX3Byb3RvLmF0T2Zmc2V0ID0gZnVuY3Rpb24gYXRPZmZzZXQob2Zmc2V0KSB7XG4gICAgcmV0dXJuIE9mZnNldERhdGVUaW1lLm9mKHRoaXMsIG9mZnNldCk7XG4gIH07XG5cbiAgX3Byb3RvLmF0Wm9uZSA9IGZ1bmN0aW9uIGF0Wm9uZSh6b25lKSB7XG4gICAgcmV0dXJuIFpvbmVkRGF0ZVRpbWUub2YodGhpcywgem9uZSk7XG4gIH07XG5cbiAgX3Byb3RvLnRvTG9jYWxEYXRlID0gZnVuY3Rpb24gdG9Mb2NhbERhdGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2RhdGU7XG4gIH07XG5cbiAgX3Byb3RvLnRvTG9jYWxUaW1lID0gZnVuY3Rpb24gdG9Mb2NhbFRpbWUoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3RpbWU7XG4gIH07XG5cbiAgX3Byb3RvLmNvbXBhcmVUbyA9IGZ1bmN0aW9uIGNvbXBhcmVUbyhvdGhlcikge1xuICAgIHJlcXVpcmVOb25OdWxsKG90aGVyLCAnb3RoZXInKTtcbiAgICByZXF1aXJlSW5zdGFuY2Uob3RoZXIsIExvY2FsRGF0ZVRpbWUsICdvdGhlcicpO1xuICAgIHJldHVybiB0aGlzLl9jb21wYXJlVG8wKG90aGVyKTtcbiAgfTtcblxuICBfcHJvdG8uX2NvbXBhcmVUbzAgPSBmdW5jdGlvbiBfY29tcGFyZVRvMChvdGhlcikge1xuICAgIHZhciBjbXAgPSB0aGlzLl9kYXRlLmNvbXBhcmVUbyhvdGhlci50b0xvY2FsRGF0ZSgpKTtcblxuICAgIGlmIChjbXAgPT09IDApIHtcbiAgICAgIGNtcCA9IHRoaXMuX3RpbWUuY29tcGFyZVRvKG90aGVyLnRvTG9jYWxUaW1lKCkpO1xuICAgIH1cblxuICAgIHJldHVybiBjbXA7XG4gIH07XG5cbiAgX3Byb3RvLmlzQWZ0ZXIgPSBmdW5jdGlvbiBpc0FmdGVyKG90aGVyKSB7XG4gICAgcmV0dXJuIHRoaXMuY29tcGFyZVRvKG90aGVyKSA+IDA7XG4gIH07XG5cbiAgX3Byb3RvLmlzQmVmb3JlID0gZnVuY3Rpb24gaXNCZWZvcmUob3RoZXIpIHtcbiAgICByZXR1cm4gdGhpcy5jb21wYXJlVG8ob3RoZXIpIDwgMDtcbiAgfTtcblxuICBfcHJvdG8uaXNFcXVhbCA9IGZ1bmN0aW9uIGlzRXF1YWwob3RoZXIpIHtcbiAgICByZXR1cm4gdGhpcy5jb21wYXJlVG8ob3RoZXIpID09PSAwO1xuICB9O1xuXG4gIF9wcm90by5lcXVhbHMgPSBmdW5jdGlvbiBlcXVhbHMob3RoZXIpIHtcbiAgICBpZiAodGhpcyA9PT0gb3RoZXIpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIGlmIChvdGhlciBpbnN0YW5jZW9mIExvY2FsRGF0ZVRpbWUpIHtcbiAgICAgIHJldHVybiB0aGlzLl9kYXRlLmVxdWFscyhvdGhlci5fZGF0ZSkgJiYgdGhpcy5fdGltZS5lcXVhbHMob3RoZXIuX3RpbWUpO1xuICAgIH1cblxuICAgIHJldHVybiBmYWxzZTtcbiAgfTtcblxuICBfcHJvdG8uaGFzaENvZGUgPSBmdW5jdGlvbiBoYXNoQ29kZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fZGF0ZS5oYXNoQ29kZSgpIF4gdGhpcy5fdGltZS5oYXNoQ29kZSgpO1xuICB9O1xuXG4gIF9wcm90by50b1N0cmluZyA9IGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuICAgIHJldHVybiB0aGlzLl9kYXRlLnRvU3RyaW5nKCkgKyAnVCcgKyB0aGlzLl90aW1lLnRvU3RyaW5nKCk7XG4gIH07XG5cbiAgX3Byb3RvLnRvSlNPTiA9IGZ1bmN0aW9uIHRvSlNPTigpIHtcbiAgICByZXR1cm4gdGhpcy50b1N0cmluZygpO1xuICB9O1xuXG4gIF9wcm90by5mb3JtYXQgPSBmdW5jdGlvbiBmb3JtYXQoZm9ybWF0dGVyKSB7XG4gICAgcmVxdWlyZU5vbk51bGwoZm9ybWF0dGVyLCAnZm9ybWF0dGVyJyk7XG4gICAgcmV0dXJuIGZvcm1hdHRlci5mb3JtYXQodGhpcyk7XG4gIH07XG5cbiAgcmV0dXJuIExvY2FsRGF0ZVRpbWU7XG59KENocm9ub0xvY2FsRGF0ZVRpbWUpO1xuZnVuY3Rpb24gX2luaXQkaigpIHtcbiAgTG9jYWxEYXRlVGltZS5NSU4gPSBMb2NhbERhdGVUaW1lLm9mKExvY2FsRGF0ZS5NSU4sIExvY2FsVGltZS5NSU4pO1xuICBMb2NhbERhdGVUaW1lLk1BWCA9IExvY2FsRGF0ZVRpbWUub2YoTG9jYWxEYXRlLk1BWCwgTG9jYWxUaW1lLk1BWCk7XG4gIExvY2FsRGF0ZVRpbWUuRlJPTSA9IGNyZWF0ZVRlbXBvcmFsUXVlcnkoJ0xvY2FsRGF0ZVRpbWUuRlJPTScsIGZ1bmN0aW9uICh0ZW1wb3JhbCkge1xuICAgIHJldHVybiBMb2NhbERhdGVUaW1lLmZyb20odGVtcG9yYWwpO1xuICB9KTtcbn1cblxudmFyIExvY2FsVGltZSA9IGZ1bmN0aW9uIChfVGVtcG9yYWwpIHtcbiAgX2luaGVyaXRzTG9vc2UoTG9jYWxUaW1lLCBfVGVtcG9yYWwpO1xuXG4gIExvY2FsVGltZS5ub3cgPSBmdW5jdGlvbiBub3coY2xvY2tPclpvbmUpIHtcbiAgICBpZiAoY2xvY2tPclpvbmUgPT0gbnVsbCkge1xuICAgICAgcmV0dXJuIExvY2FsVGltZS5fbm93KENsb2NrLnN5c3RlbURlZmF1bHRab25lKCkpO1xuICAgIH0gZWxzZSBpZiAoY2xvY2tPclpvbmUgaW5zdGFuY2VvZiBDbG9jaykge1xuICAgICAgcmV0dXJuIExvY2FsVGltZS5fbm93KGNsb2NrT3Jab25lKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIExvY2FsVGltZS5fbm93KENsb2NrLnN5c3RlbShjbG9ja09yWm9uZSkpO1xuICAgIH1cbiAgfTtcblxuICBMb2NhbFRpbWUuX25vdyA9IGZ1bmN0aW9uIF9ub3coY2xvY2spIHtcbiAgICBpZiAoY2xvY2sgPT09IHZvaWQgMCkge1xuICAgICAgY2xvY2sgPSBDbG9jay5zeXN0ZW1EZWZhdWx0Wm9uZSgpO1xuICAgIH1cblxuICAgIHJlcXVpcmVOb25OdWxsKGNsb2NrLCAnY2xvY2snKTtcbiAgICByZXR1cm4gTG9jYWxUaW1lLm9mSW5zdGFudChjbG9jay5pbnN0YW50KCksIGNsb2NrLnpvbmUoKSk7XG4gIH07XG5cbiAgTG9jYWxUaW1lLm9mSW5zdGFudCA9IGZ1bmN0aW9uIG9mSW5zdGFudChpbnN0YW50LCB6b25lKSB7XG4gICAgaWYgKHpvbmUgPT09IHZvaWQgMCkge1xuICAgICAgem9uZSA9IFpvbmVJZC5zeXN0ZW1EZWZhdWx0KCk7XG4gICAgfVxuXG4gICAgdmFyIG9mZnNldCA9IHpvbmUucnVsZXMoKS5vZmZzZXQoaW5zdGFudCk7XG4gICAgdmFyIHNlY3NPZkRheSA9IE1hdGhVdGlsLmludE1vZChpbnN0YW50LmVwb2NoU2Vjb25kKCksIExvY2FsVGltZS5TRUNPTkRTX1BFUl9EQVkpO1xuICAgIHNlY3NPZkRheSA9IE1hdGhVdGlsLmludE1vZChzZWNzT2ZEYXkgKyBvZmZzZXQudG90YWxTZWNvbmRzKCksIExvY2FsVGltZS5TRUNPTkRTX1BFUl9EQVkpO1xuXG4gICAgaWYgKHNlY3NPZkRheSA8IDApIHtcbiAgICAgIHNlY3NPZkRheSArPSBMb2NhbFRpbWUuU0VDT05EU19QRVJfREFZO1xuICAgIH1cblxuICAgIHJldHVybiBMb2NhbFRpbWUub2ZTZWNvbmRPZkRheShzZWNzT2ZEYXksIGluc3RhbnQubmFubygpKTtcbiAgfTtcblxuICBMb2NhbFRpbWUub2YgPSBmdW5jdGlvbiBvZihob3VyLCBtaW51dGUsIHNlY29uZCwgbmFub09mU2Vjb25kKSB7XG4gICAgcmV0dXJuIG5ldyBMb2NhbFRpbWUoaG91ciwgbWludXRlLCBzZWNvbmQsIG5hbm9PZlNlY29uZCk7XG4gIH07XG5cbiAgTG9jYWxUaW1lLm9mU2Vjb25kT2ZEYXkgPSBmdW5jdGlvbiBvZlNlY29uZE9mRGF5KHNlY29uZE9mRGF5LCBuYW5vT2ZTZWNvbmQpIHtcbiAgICBpZiAoc2Vjb25kT2ZEYXkgPT09IHZvaWQgMCkge1xuICAgICAgc2Vjb25kT2ZEYXkgPSAwO1xuICAgIH1cblxuICAgIGlmIChuYW5vT2ZTZWNvbmQgPT09IHZvaWQgMCkge1xuICAgICAgbmFub09mU2Vjb25kID0gMDtcbiAgICB9XG5cbiAgICBDaHJvbm9GaWVsZC5TRUNPTkRfT0ZfREFZLmNoZWNrVmFsaWRWYWx1ZShzZWNvbmRPZkRheSk7XG4gICAgQ2hyb25vRmllbGQuTkFOT19PRl9TRUNPTkQuY2hlY2tWYWxpZFZhbHVlKG5hbm9PZlNlY29uZCk7XG4gICAgdmFyIGhvdXJzID0gTWF0aFV0aWwuaW50RGl2KHNlY29uZE9mRGF5LCBMb2NhbFRpbWUuU0VDT05EU19QRVJfSE9VUik7XG4gICAgc2Vjb25kT2ZEYXkgLT0gaG91cnMgKiBMb2NhbFRpbWUuU0VDT05EU19QRVJfSE9VUjtcbiAgICB2YXIgbWludXRlcyA9IE1hdGhVdGlsLmludERpdihzZWNvbmRPZkRheSwgTG9jYWxUaW1lLlNFQ09ORFNfUEVSX01JTlVURSk7XG4gICAgc2Vjb25kT2ZEYXkgLT0gbWludXRlcyAqIExvY2FsVGltZS5TRUNPTkRTX1BFUl9NSU5VVEU7XG4gICAgcmV0dXJuIG5ldyBMb2NhbFRpbWUoaG91cnMsIG1pbnV0ZXMsIHNlY29uZE9mRGF5LCBuYW5vT2ZTZWNvbmQpO1xuICB9O1xuXG4gIExvY2FsVGltZS5vZk5hbm9PZkRheSA9IGZ1bmN0aW9uIG9mTmFub09mRGF5KG5hbm9PZkRheSkge1xuICAgIGlmIChuYW5vT2ZEYXkgPT09IHZvaWQgMCkge1xuICAgICAgbmFub09mRGF5ID0gMDtcbiAgICB9XG5cbiAgICBDaHJvbm9GaWVsZC5OQU5PX09GX0RBWS5jaGVja1ZhbGlkVmFsdWUobmFub09mRGF5KTtcbiAgICB2YXIgaG91cnMgPSBNYXRoVXRpbC5pbnREaXYobmFub09mRGF5LCBMb2NhbFRpbWUuTkFOT1NfUEVSX0hPVVIpO1xuICAgIG5hbm9PZkRheSAtPSBob3VycyAqIExvY2FsVGltZS5OQU5PU19QRVJfSE9VUjtcbiAgICB2YXIgbWludXRlcyA9IE1hdGhVdGlsLmludERpdihuYW5vT2ZEYXksIExvY2FsVGltZS5OQU5PU19QRVJfTUlOVVRFKTtcbiAgICBuYW5vT2ZEYXkgLT0gbWludXRlcyAqIExvY2FsVGltZS5OQU5PU19QRVJfTUlOVVRFO1xuICAgIHZhciBzZWNvbmRzID0gTWF0aFV0aWwuaW50RGl2KG5hbm9PZkRheSwgTG9jYWxUaW1lLk5BTk9TX1BFUl9TRUNPTkQpO1xuICAgIG5hbm9PZkRheSAtPSBzZWNvbmRzICogTG9jYWxUaW1lLk5BTk9TX1BFUl9TRUNPTkQ7XG4gICAgcmV0dXJuIG5ldyBMb2NhbFRpbWUoaG91cnMsIG1pbnV0ZXMsIHNlY29uZHMsIG5hbm9PZkRheSk7XG4gIH07XG5cbiAgTG9jYWxUaW1lLmZyb20gPSBmdW5jdGlvbiBmcm9tKHRlbXBvcmFsKSB7XG4gICAgcmVxdWlyZU5vbk51bGwodGVtcG9yYWwsICd0ZW1wb3JhbCcpO1xuICAgIHZhciB0aW1lID0gdGVtcG9yYWwucXVlcnkoVGVtcG9yYWxRdWVyaWVzLmxvY2FsVGltZSgpKTtcblxuICAgIGlmICh0aW1lID09IG51bGwpIHtcbiAgICAgIHRocm93IG5ldyBEYXRlVGltZUV4Y2VwdGlvbihcIlVuYWJsZSB0byBvYnRhaW4gTG9jYWxUaW1lIFRlbXBvcmFsQWNjZXNzb3I6IFwiICsgdGVtcG9yYWwgKyBcIiwgdHlwZSBcIiArICh0ZW1wb3JhbC5jb25zdHJ1Y3RvciAhPSBudWxsID8gdGVtcG9yYWwuY29uc3RydWN0b3IubmFtZSA6ICcnKSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRpbWU7XG4gIH07XG5cbiAgTG9jYWxUaW1lLnBhcnNlID0gZnVuY3Rpb24gcGFyc2UodGV4dCwgZm9ybWF0dGVyKSB7XG4gICAgaWYgKGZvcm1hdHRlciA9PT0gdm9pZCAwKSB7XG4gICAgICBmb3JtYXR0ZXIgPSBEYXRlVGltZUZvcm1hdHRlci5JU09fTE9DQUxfVElNRTtcbiAgICB9XG5cbiAgICByZXF1aXJlTm9uTnVsbChmb3JtYXR0ZXIsICdmb3JtYXR0ZXInKTtcbiAgICByZXR1cm4gZm9ybWF0dGVyLnBhcnNlKHRleHQsIExvY2FsVGltZS5GUk9NKTtcbiAgfTtcblxuICBmdW5jdGlvbiBMb2NhbFRpbWUoaG91ciwgbWludXRlLCBzZWNvbmQsIG5hbm9PZlNlY29uZCkge1xuICAgIHZhciBfdGhpcztcblxuICAgIGlmIChob3VyID09PSB2b2lkIDApIHtcbiAgICAgIGhvdXIgPSAwO1xuICAgIH1cblxuICAgIGlmIChtaW51dGUgPT09IHZvaWQgMCkge1xuICAgICAgbWludXRlID0gMDtcbiAgICB9XG5cbiAgICBpZiAoc2Vjb25kID09PSB2b2lkIDApIHtcbiAgICAgIHNlY29uZCA9IDA7XG4gICAgfVxuXG4gICAgaWYgKG5hbm9PZlNlY29uZCA9PT0gdm9pZCAwKSB7XG4gICAgICBuYW5vT2ZTZWNvbmQgPSAwO1xuICAgIH1cblxuICAgIF90aGlzID0gX1RlbXBvcmFsLmNhbGwodGhpcykgfHwgdGhpcztcblxuICAgIHZhciBfaG91ciA9IE1hdGhVdGlsLnNhZmVUb0ludChob3VyKTtcblxuICAgIHZhciBfbWludXRlID0gTWF0aFV0aWwuc2FmZVRvSW50KG1pbnV0ZSk7XG5cbiAgICB2YXIgX3NlY29uZCA9IE1hdGhVdGlsLnNhZmVUb0ludChzZWNvbmQpO1xuXG4gICAgdmFyIF9uYW5vT2ZTZWNvbmQgPSBNYXRoVXRpbC5zYWZlVG9JbnQobmFub09mU2Vjb25kKTtcblxuICAgIExvY2FsVGltZS5fdmFsaWRhdGUoX2hvdXIsIF9taW51dGUsIF9zZWNvbmQsIF9uYW5vT2ZTZWNvbmQpO1xuXG4gICAgaWYgKF9taW51dGUgPT09IDAgJiYgX3NlY29uZCA9PT0gMCAmJiBfbmFub09mU2Vjb25kID09PSAwKSB7XG4gICAgICBpZiAoIUxvY2FsVGltZS5IT1VSU1tfaG91cl0pIHtcbiAgICAgICAgX3RoaXMuX2hvdXIgPSBfaG91cjtcbiAgICAgICAgX3RoaXMuX21pbnV0ZSA9IF9taW51dGU7XG4gICAgICAgIF90aGlzLl9zZWNvbmQgPSBfc2Vjb25kO1xuICAgICAgICBfdGhpcy5fbmFubyA9IF9uYW5vT2ZTZWNvbmQ7XG4gICAgICAgIExvY2FsVGltZS5IT1VSU1tfaG91cl0gPSBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIExvY2FsVGltZS5IT1VSU1tfaG91cl0gfHwgX2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpcyk7XG4gICAgfVxuXG4gICAgX3RoaXMuX2hvdXIgPSBfaG91cjtcbiAgICBfdGhpcy5fbWludXRlID0gX21pbnV0ZTtcbiAgICBfdGhpcy5fc2Vjb25kID0gX3NlY29uZDtcbiAgICBfdGhpcy5fbmFubyA9IF9uYW5vT2ZTZWNvbmQ7XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG5cbiAgTG9jYWxUaW1lLl92YWxpZGF0ZSA9IGZ1bmN0aW9uIF92YWxpZGF0ZShob3VyLCBtaW51dGUsIHNlY29uZCwgbmFub09mU2Vjb25kKSB7XG4gICAgQ2hyb25vRmllbGQuSE9VUl9PRl9EQVkuY2hlY2tWYWxpZFZhbHVlKGhvdXIpO1xuICAgIENocm9ub0ZpZWxkLk1JTlVURV9PRl9IT1VSLmNoZWNrVmFsaWRWYWx1ZShtaW51dGUpO1xuICAgIENocm9ub0ZpZWxkLlNFQ09ORF9PRl9NSU5VVEUuY2hlY2tWYWxpZFZhbHVlKHNlY29uZCk7XG4gICAgQ2hyb25vRmllbGQuTkFOT19PRl9TRUNPTkQuY2hlY2tWYWxpZFZhbHVlKG5hbm9PZlNlY29uZCk7XG4gIH07XG5cbiAgdmFyIF9wcm90byA9IExvY2FsVGltZS5wcm90b3R5cGU7XG5cbiAgX3Byb3RvLmlzU3VwcG9ydGVkID0gZnVuY3Rpb24gaXNTdXBwb3J0ZWQoZmllbGRPclVuaXQpIHtcbiAgICBpZiAoZmllbGRPclVuaXQgaW5zdGFuY2VvZiBDaHJvbm9GaWVsZCkge1xuICAgICAgcmV0dXJuIGZpZWxkT3JVbml0LmlzVGltZUJhc2VkKCk7XG4gICAgfSBlbHNlIGlmIChmaWVsZE9yVW5pdCBpbnN0YW5jZW9mIENocm9ub1VuaXQpIHtcbiAgICAgIHJldHVybiBmaWVsZE9yVW5pdC5pc1RpbWVCYXNlZCgpO1xuICAgIH1cblxuICAgIHJldHVybiBmaWVsZE9yVW5pdCAhPSBudWxsICYmIGZpZWxkT3JVbml0LmlzU3VwcG9ydGVkQnkodGhpcyk7XG4gIH07XG5cbiAgX3Byb3RvLnJhbmdlID0gZnVuY3Rpb24gcmFuZ2UoZmllbGQpIHtcbiAgICByZXF1aXJlTm9uTnVsbChmaWVsZCk7XG4gICAgcmV0dXJuIF9UZW1wb3JhbC5wcm90b3R5cGUucmFuZ2UuY2FsbCh0aGlzLCBmaWVsZCk7XG4gIH07XG5cbiAgX3Byb3RvLmdldCA9IGZ1bmN0aW9uIGdldChmaWVsZCkge1xuICAgIHJldHVybiB0aGlzLmdldExvbmcoZmllbGQpO1xuICB9O1xuXG4gIF9wcm90by5nZXRMb25nID0gZnVuY3Rpb24gZ2V0TG9uZyhmaWVsZCkge1xuICAgIHJlcXVpcmVOb25OdWxsKGZpZWxkLCAnZmllbGQnKTtcblxuICAgIGlmIChmaWVsZCBpbnN0YW5jZW9mIENocm9ub0ZpZWxkKSB7XG4gICAgICByZXR1cm4gdGhpcy5fZ2V0MChmaWVsZCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZpZWxkLmdldEZyb20odGhpcyk7XG4gIH07XG5cbiAgX3Byb3RvLl9nZXQwID0gZnVuY3Rpb24gX2dldDAoZmllbGQpIHtcbiAgICBzd2l0Y2ggKGZpZWxkKSB7XG4gICAgICBjYXNlIENocm9ub0ZpZWxkLk5BTk9fT0ZfU0VDT05EOlxuICAgICAgICByZXR1cm4gdGhpcy5fbmFubztcblxuICAgICAgY2FzZSBDaHJvbm9GaWVsZC5OQU5PX09GX0RBWTpcbiAgICAgICAgcmV0dXJuIHRoaXMudG9OYW5vT2ZEYXkoKTtcblxuICAgICAgY2FzZSBDaHJvbm9GaWVsZC5NSUNST19PRl9TRUNPTkQ6XG4gICAgICAgIHJldHVybiBNYXRoVXRpbC5pbnREaXYodGhpcy5fbmFubywgMTAwMCk7XG5cbiAgICAgIGNhc2UgQ2hyb25vRmllbGQuTUlDUk9fT0ZfREFZOlxuICAgICAgICByZXR1cm4gTWF0aFV0aWwuaW50RGl2KHRoaXMudG9OYW5vT2ZEYXkoKSwgMTAwMCk7XG5cbiAgICAgIGNhc2UgQ2hyb25vRmllbGQuTUlMTElfT0ZfU0VDT05EOlxuICAgICAgICByZXR1cm4gTWF0aFV0aWwuaW50RGl2KHRoaXMuX25hbm8sIDEwMDAwMDApO1xuXG4gICAgICBjYXNlIENocm9ub0ZpZWxkLk1JTExJX09GX0RBWTpcbiAgICAgICAgcmV0dXJuIE1hdGhVdGlsLmludERpdih0aGlzLnRvTmFub09mRGF5KCksIDEwMDAwMDApO1xuXG4gICAgICBjYXNlIENocm9ub0ZpZWxkLlNFQ09ORF9PRl9NSU5VVEU6XG4gICAgICAgIHJldHVybiB0aGlzLl9zZWNvbmQ7XG5cbiAgICAgIGNhc2UgQ2hyb25vRmllbGQuU0VDT05EX09GX0RBWTpcbiAgICAgICAgcmV0dXJuIHRoaXMudG9TZWNvbmRPZkRheSgpO1xuXG4gICAgICBjYXNlIENocm9ub0ZpZWxkLk1JTlVURV9PRl9IT1VSOlxuICAgICAgICByZXR1cm4gdGhpcy5fbWludXRlO1xuXG4gICAgICBjYXNlIENocm9ub0ZpZWxkLk1JTlVURV9PRl9EQVk6XG4gICAgICAgIHJldHVybiB0aGlzLl9ob3VyICogNjAgKyB0aGlzLl9taW51dGU7XG5cbiAgICAgIGNhc2UgQ2hyb25vRmllbGQuSE9VUl9PRl9BTVBNOlxuICAgICAgICByZXR1cm4gTWF0aFV0aWwuaW50TW9kKHRoaXMuX2hvdXIsIDEyKTtcblxuICAgICAgY2FzZSBDaHJvbm9GaWVsZC5DTE9DS19IT1VSX09GX0FNUE06XG4gICAgICAgIHtcbiAgICAgICAgICB2YXIgaGFtID0gTWF0aFV0aWwuaW50TW9kKHRoaXMuX2hvdXIsIDEyKTtcbiAgICAgICAgICByZXR1cm4gaGFtICUgMTIgPT09IDAgPyAxMiA6IGhhbTtcbiAgICAgICAgfVxuXG4gICAgICBjYXNlIENocm9ub0ZpZWxkLkhPVVJfT0ZfREFZOlxuICAgICAgICByZXR1cm4gdGhpcy5faG91cjtcblxuICAgICAgY2FzZSBDaHJvbm9GaWVsZC5DTE9DS19IT1VSX09GX0RBWTpcbiAgICAgICAgcmV0dXJuIHRoaXMuX2hvdXIgPT09IDAgPyAyNCA6IHRoaXMuX2hvdXI7XG5cbiAgICAgIGNhc2UgQ2hyb25vRmllbGQuQU1QTV9PRl9EQVk6XG4gICAgICAgIHJldHVybiBNYXRoVXRpbC5pbnREaXYodGhpcy5faG91ciwgMTIpO1xuICAgIH1cblxuICAgIHRocm93IG5ldyBVbnN1cHBvcnRlZFRlbXBvcmFsVHlwZUV4Y2VwdGlvbignVW5zdXBwb3J0ZWQgZmllbGQ6ICcgKyBmaWVsZCk7XG4gIH07XG5cbiAgX3Byb3RvLmhvdXIgPSBmdW5jdGlvbiBob3VyKCkge1xuICAgIHJldHVybiB0aGlzLl9ob3VyO1xuICB9O1xuXG4gIF9wcm90by5taW51dGUgPSBmdW5jdGlvbiBtaW51dGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuX21pbnV0ZTtcbiAgfTtcblxuICBfcHJvdG8uc2Vjb25kID0gZnVuY3Rpb24gc2Vjb25kKCkge1xuICAgIHJldHVybiB0aGlzLl9zZWNvbmQ7XG4gIH07XG5cbiAgX3Byb3RvLm5hbm8gPSBmdW5jdGlvbiBuYW5vKCkge1xuICAgIHJldHVybiB0aGlzLl9uYW5vO1xuICB9O1xuXG4gIF9wcm90by53aXRoQWRqdXN0ZXIgPSBmdW5jdGlvbiB3aXRoQWRqdXN0ZXIoYWRqdXN0ZXIpIHtcbiAgICByZXF1aXJlTm9uTnVsbChhZGp1c3RlciwgJ2FkanVzdGVyJyk7XG5cbiAgICBpZiAoYWRqdXN0ZXIgaW5zdGFuY2VvZiBMb2NhbFRpbWUpIHtcbiAgICAgIHJldHVybiBhZGp1c3RlcjtcbiAgICB9XG5cbiAgICBhc3NlcnQodHlwZW9mIGFkanVzdGVyLmFkanVzdEludG8gPT09ICdmdW5jdGlvbicsICdhZGp1c3RlcicsIElsbGVnYWxBcmd1bWVudEV4Y2VwdGlvbik7XG4gICAgcmV0dXJuIGFkanVzdGVyLmFkanVzdEludG8odGhpcyk7XG4gIH07XG5cbiAgX3Byb3RvLndpdGhGaWVsZFZhbHVlID0gZnVuY3Rpb24gd2l0aEZpZWxkVmFsdWUoZmllbGQsIG5ld1ZhbHVlKSB7XG4gICAgcmVxdWlyZU5vbk51bGwoZmllbGQsICdmaWVsZCcpO1xuICAgIHJlcXVpcmVJbnN0YW5jZShmaWVsZCwgVGVtcG9yYWxGaWVsZCwgJ2ZpZWxkJyk7XG5cbiAgICBpZiAoZmllbGQgaW5zdGFuY2VvZiBDaHJvbm9GaWVsZCkge1xuICAgICAgZmllbGQuY2hlY2tWYWxpZFZhbHVlKG5ld1ZhbHVlKTtcblxuICAgICAgc3dpdGNoIChmaWVsZCkge1xuICAgICAgICBjYXNlIENocm9ub0ZpZWxkLk5BTk9fT0ZfU0VDT05EOlxuICAgICAgICAgIHJldHVybiB0aGlzLndpdGhOYW5vKG5ld1ZhbHVlKTtcblxuICAgICAgICBjYXNlIENocm9ub0ZpZWxkLk5BTk9fT0ZfREFZOlxuICAgICAgICAgIHJldHVybiBMb2NhbFRpbWUub2ZOYW5vT2ZEYXkobmV3VmFsdWUpO1xuXG4gICAgICAgIGNhc2UgQ2hyb25vRmllbGQuTUlDUk9fT0ZfU0VDT05EOlxuICAgICAgICAgIHJldHVybiB0aGlzLndpdGhOYW5vKG5ld1ZhbHVlICogMTAwMCk7XG5cbiAgICAgICAgY2FzZSBDaHJvbm9GaWVsZC5NSUNST19PRl9EQVk6XG4gICAgICAgICAgcmV0dXJuIExvY2FsVGltZS5vZk5hbm9PZkRheShuZXdWYWx1ZSAqIDEwMDApO1xuXG4gICAgICAgIGNhc2UgQ2hyb25vRmllbGQuTUlMTElfT0ZfU0VDT05EOlxuICAgICAgICAgIHJldHVybiB0aGlzLndpdGhOYW5vKG5ld1ZhbHVlICogMTAwMDAwMCk7XG5cbiAgICAgICAgY2FzZSBDaHJvbm9GaWVsZC5NSUxMSV9PRl9EQVk6XG4gICAgICAgICAgcmV0dXJuIExvY2FsVGltZS5vZk5hbm9PZkRheShuZXdWYWx1ZSAqIDEwMDAwMDApO1xuXG4gICAgICAgIGNhc2UgQ2hyb25vRmllbGQuU0VDT05EX09GX01JTlVURTpcbiAgICAgICAgICByZXR1cm4gdGhpcy53aXRoU2Vjb25kKG5ld1ZhbHVlKTtcblxuICAgICAgICBjYXNlIENocm9ub0ZpZWxkLlNFQ09ORF9PRl9EQVk6XG4gICAgICAgICAgcmV0dXJuIHRoaXMucGx1c1NlY29uZHMobmV3VmFsdWUgLSB0aGlzLnRvU2Vjb25kT2ZEYXkoKSk7XG5cbiAgICAgICAgY2FzZSBDaHJvbm9GaWVsZC5NSU5VVEVfT0ZfSE9VUjpcbiAgICAgICAgICByZXR1cm4gdGhpcy53aXRoTWludXRlKG5ld1ZhbHVlKTtcblxuICAgICAgICBjYXNlIENocm9ub0ZpZWxkLk1JTlVURV9PRl9EQVk6XG4gICAgICAgICAgcmV0dXJuIHRoaXMucGx1c01pbnV0ZXMobmV3VmFsdWUgLSAodGhpcy5faG91ciAqIDYwICsgdGhpcy5fbWludXRlKSk7XG5cbiAgICAgICAgY2FzZSBDaHJvbm9GaWVsZC5IT1VSX09GX0FNUE06XG4gICAgICAgICAgcmV0dXJuIHRoaXMucGx1c0hvdXJzKG5ld1ZhbHVlIC0gTWF0aFV0aWwuaW50TW9kKHRoaXMuX2hvdXIsIDEyKSk7XG5cbiAgICAgICAgY2FzZSBDaHJvbm9GaWVsZC5DTE9DS19IT1VSX09GX0FNUE06XG4gICAgICAgICAgcmV0dXJuIHRoaXMucGx1c0hvdXJzKChuZXdWYWx1ZSA9PT0gMTIgPyAwIDogbmV3VmFsdWUpIC0gTWF0aFV0aWwuaW50TW9kKHRoaXMuX2hvdXIsIDEyKSk7XG5cbiAgICAgICAgY2FzZSBDaHJvbm9GaWVsZC5IT1VSX09GX0RBWTpcbiAgICAgICAgICByZXR1cm4gdGhpcy53aXRoSG91cihuZXdWYWx1ZSk7XG5cbiAgICAgICAgY2FzZSBDaHJvbm9GaWVsZC5DTE9DS19IT1VSX09GX0RBWTpcbiAgICAgICAgICByZXR1cm4gdGhpcy53aXRoSG91cihuZXdWYWx1ZSA9PT0gMjQgPyAwIDogbmV3VmFsdWUpO1xuXG4gICAgICAgIGNhc2UgQ2hyb25vRmllbGQuQU1QTV9PRl9EQVk6XG4gICAgICAgICAgcmV0dXJuIHRoaXMucGx1c0hvdXJzKChuZXdWYWx1ZSAtIE1hdGhVdGlsLmludERpdih0aGlzLl9ob3VyLCAxMikpICogMTIpO1xuICAgICAgfVxuXG4gICAgICB0aHJvdyBuZXcgVW5zdXBwb3J0ZWRUZW1wb3JhbFR5cGVFeGNlcHRpb24oJ1Vuc3VwcG9ydGVkIGZpZWxkOiAnICsgZmllbGQpO1xuICAgIH1cblxuICAgIHJldHVybiBmaWVsZC5hZGp1c3RJbnRvKHRoaXMsIG5ld1ZhbHVlKTtcbiAgfTtcblxuICBfcHJvdG8ud2l0aEhvdXIgPSBmdW5jdGlvbiB3aXRoSG91cihob3VyKSB7XG4gICAgaWYgKGhvdXIgPT09IHZvaWQgMCkge1xuICAgICAgaG91ciA9IDA7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuX2hvdXIgPT09IGhvdXIpIHtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIHJldHVybiBuZXcgTG9jYWxUaW1lKGhvdXIsIHRoaXMuX21pbnV0ZSwgdGhpcy5fc2Vjb25kLCB0aGlzLl9uYW5vKTtcbiAgfTtcblxuICBfcHJvdG8ud2l0aE1pbnV0ZSA9IGZ1bmN0aW9uIHdpdGhNaW51dGUobWludXRlKSB7XG4gICAgaWYgKG1pbnV0ZSA9PT0gdm9pZCAwKSB7XG4gICAgICBtaW51dGUgPSAwO1xuICAgIH1cblxuICAgIGlmICh0aGlzLl9taW51dGUgPT09IG1pbnV0ZSkge1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgcmV0dXJuIG5ldyBMb2NhbFRpbWUodGhpcy5faG91ciwgbWludXRlLCB0aGlzLl9zZWNvbmQsIHRoaXMuX25hbm8pO1xuICB9O1xuXG4gIF9wcm90by53aXRoU2Vjb25kID0gZnVuY3Rpb24gd2l0aFNlY29uZChzZWNvbmQpIHtcbiAgICBpZiAoc2Vjb25kID09PSB2b2lkIDApIHtcbiAgICAgIHNlY29uZCA9IDA7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuX3NlY29uZCA9PT0gc2Vjb25kKSB7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICByZXR1cm4gbmV3IExvY2FsVGltZSh0aGlzLl9ob3VyLCB0aGlzLl9taW51dGUsIHNlY29uZCwgdGhpcy5fbmFubyk7XG4gIH07XG5cbiAgX3Byb3RvLndpdGhOYW5vID0gZnVuY3Rpb24gd2l0aE5hbm8obmFub09mU2Vjb25kKSB7XG4gICAgaWYgKG5hbm9PZlNlY29uZCA9PT0gdm9pZCAwKSB7XG4gICAgICBuYW5vT2ZTZWNvbmQgPSAwO1xuICAgIH1cblxuICAgIGlmICh0aGlzLl9uYW5vID09PSBuYW5vT2ZTZWNvbmQpIHtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIHJldHVybiBuZXcgTG9jYWxUaW1lKHRoaXMuX2hvdXIsIHRoaXMuX21pbnV0ZSwgdGhpcy5fc2Vjb25kLCBuYW5vT2ZTZWNvbmQpO1xuICB9O1xuXG4gIF9wcm90by50cnVuY2F0ZWRUbyA9IGZ1bmN0aW9uIHRydW5jYXRlZFRvKHVuaXQpIHtcbiAgICByZXF1aXJlTm9uTnVsbCh1bml0LCAndW5pdCcpO1xuXG4gICAgaWYgKHVuaXQgPT09IENocm9ub1VuaXQuTkFOT1MpIHtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIHZhciB1bml0RHVyID0gdW5pdC5kdXJhdGlvbigpO1xuXG4gICAgaWYgKHVuaXREdXIuc2Vjb25kcygpID4gTG9jYWxUaW1lLlNFQ09ORFNfUEVSX0RBWSkge1xuICAgICAgdGhyb3cgbmV3IERhdGVUaW1lRXhjZXB0aW9uKCdVbml0IGlzIHRvbyBsYXJnZSB0byBiZSB1c2VkIGZvciB0cnVuY2F0aW9uJyk7XG4gICAgfVxuXG4gICAgdmFyIGR1ciA9IHVuaXREdXIudG9OYW5vcygpO1xuXG4gICAgaWYgKE1hdGhVdGlsLmludE1vZChMb2NhbFRpbWUuTkFOT1NfUEVSX0RBWSwgZHVyKSAhPT0gMCkge1xuICAgICAgdGhyb3cgbmV3IERhdGVUaW1lRXhjZXB0aW9uKCdVbml0IG11c3QgZGl2aWRlIGludG8gYSBzdGFuZGFyZCBkYXkgd2l0aG91dCByZW1haW5kZXInKTtcbiAgICB9XG5cbiAgICB2YXIgbm9kID0gdGhpcy50b05hbm9PZkRheSgpO1xuICAgIHJldHVybiBMb2NhbFRpbWUub2ZOYW5vT2ZEYXkoTWF0aFV0aWwuaW50RGl2KG5vZCwgZHVyKSAqIGR1cik7XG4gIH07XG5cbiAgX3Byb3RvLnBsdXNBbW91bnQgPSBmdW5jdGlvbiBwbHVzQW1vdW50KGFtb3VudCkge1xuICAgIHJlcXVpcmVOb25OdWxsKGFtb3VudCwgJ2Ftb3VudCcpO1xuICAgIHJldHVybiBhbW91bnQuYWRkVG8odGhpcyk7XG4gIH07XG5cbiAgX3Byb3RvLnBsdXNBbW91bnRVbml0ID0gZnVuY3Rpb24gcGx1c0Ftb3VudFVuaXQoYW1vdW50VG9BZGQsIHVuaXQpIHtcbiAgICByZXF1aXJlTm9uTnVsbCh1bml0LCAndW5pdCcpO1xuXG4gICAgaWYgKHVuaXQgaW5zdGFuY2VvZiBDaHJvbm9Vbml0KSB7XG4gICAgICBzd2l0Y2ggKHVuaXQpIHtcbiAgICAgICAgY2FzZSBDaHJvbm9Vbml0Lk5BTk9TOlxuICAgICAgICAgIHJldHVybiB0aGlzLnBsdXNOYW5vcyhhbW91bnRUb0FkZCk7XG5cbiAgICAgICAgY2FzZSBDaHJvbm9Vbml0Lk1JQ1JPUzpcbiAgICAgICAgICByZXR1cm4gdGhpcy5wbHVzTmFub3MoTWF0aFV0aWwuaW50TW9kKGFtb3VudFRvQWRkLCBMb2NhbFRpbWUuTUlDUk9TX1BFUl9EQVkpICogMTAwMCk7XG5cbiAgICAgICAgY2FzZSBDaHJvbm9Vbml0Lk1JTExJUzpcbiAgICAgICAgICByZXR1cm4gdGhpcy5wbHVzTmFub3MoTWF0aFV0aWwuaW50TW9kKGFtb3VudFRvQWRkLCBMb2NhbFRpbWUuTUlMTElTX1BFUl9EQVkpICogMTAwMDAwMCk7XG5cbiAgICAgICAgY2FzZSBDaHJvbm9Vbml0LlNFQ09ORFM6XG4gICAgICAgICAgcmV0dXJuIHRoaXMucGx1c1NlY29uZHMoYW1vdW50VG9BZGQpO1xuXG4gICAgICAgIGNhc2UgQ2hyb25vVW5pdC5NSU5VVEVTOlxuICAgICAgICAgIHJldHVybiB0aGlzLnBsdXNNaW51dGVzKGFtb3VudFRvQWRkKTtcblxuICAgICAgICBjYXNlIENocm9ub1VuaXQuSE9VUlM6XG4gICAgICAgICAgcmV0dXJuIHRoaXMucGx1c0hvdXJzKGFtb3VudFRvQWRkKTtcblxuICAgICAgICBjYXNlIENocm9ub1VuaXQuSEFMRl9EQVlTOlxuICAgICAgICAgIHJldHVybiB0aGlzLnBsdXNIb3VycyhNYXRoVXRpbC5pbnRNb2QoYW1vdW50VG9BZGQsIDIpICogMTIpO1xuICAgICAgfVxuXG4gICAgICB0aHJvdyBuZXcgVW5zdXBwb3J0ZWRUZW1wb3JhbFR5cGVFeGNlcHRpb24oJ1Vuc3VwcG9ydGVkIHVuaXQ6ICcgKyB1bml0KTtcbiAgICB9XG5cbiAgICByZXR1cm4gdW5pdC5hZGRUbyh0aGlzLCBhbW91bnRUb0FkZCk7XG4gIH07XG5cbiAgX3Byb3RvLnBsdXNIb3VycyA9IGZ1bmN0aW9uIHBsdXNIb3Vycyhob3Vyc1RvQWRkKSB7XG4gICAgaWYgKGhvdXJzVG9BZGQgPT09IDApIHtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIHZhciBuZXdIb3VyID0gTWF0aFV0aWwuaW50TW9kKE1hdGhVdGlsLmludE1vZChob3Vyc1RvQWRkLCBMb2NhbFRpbWUuSE9VUlNfUEVSX0RBWSkgKyB0aGlzLl9ob3VyICsgTG9jYWxUaW1lLkhPVVJTX1BFUl9EQVksIExvY2FsVGltZS5IT1VSU19QRVJfREFZKTtcbiAgICByZXR1cm4gbmV3IExvY2FsVGltZShuZXdIb3VyLCB0aGlzLl9taW51dGUsIHRoaXMuX3NlY29uZCwgdGhpcy5fbmFubyk7XG4gIH07XG5cbiAgX3Byb3RvLnBsdXNNaW51dGVzID0gZnVuY3Rpb24gcGx1c01pbnV0ZXMobWludXRlc1RvQWRkKSB7XG4gICAgaWYgKG1pbnV0ZXNUb0FkZCA9PT0gMCkge1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgdmFyIG1vZmQgPSB0aGlzLl9ob3VyICogTG9jYWxUaW1lLk1JTlVURVNfUEVSX0hPVVIgKyB0aGlzLl9taW51dGU7XG4gICAgdmFyIG5ld01vZmQgPSBNYXRoVXRpbC5pbnRNb2QoTWF0aFV0aWwuaW50TW9kKG1pbnV0ZXNUb0FkZCwgTG9jYWxUaW1lLk1JTlVURVNfUEVSX0RBWSkgKyBtb2ZkICsgTG9jYWxUaW1lLk1JTlVURVNfUEVSX0RBWSwgTG9jYWxUaW1lLk1JTlVURVNfUEVSX0RBWSk7XG5cbiAgICBpZiAobW9mZCA9PT0gbmV3TW9mZCkge1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgdmFyIG5ld0hvdXIgPSBNYXRoVXRpbC5pbnREaXYobmV3TW9mZCwgTG9jYWxUaW1lLk1JTlVURVNfUEVSX0hPVVIpO1xuICAgIHZhciBuZXdNaW51dGUgPSBNYXRoVXRpbC5pbnRNb2QobmV3TW9mZCwgTG9jYWxUaW1lLk1JTlVURVNfUEVSX0hPVVIpO1xuICAgIHJldHVybiBuZXcgTG9jYWxUaW1lKG5ld0hvdXIsIG5ld01pbnV0ZSwgdGhpcy5fc2Vjb25kLCB0aGlzLl9uYW5vKTtcbiAgfTtcblxuICBfcHJvdG8ucGx1c1NlY29uZHMgPSBmdW5jdGlvbiBwbHVzU2Vjb25kcyhzZWNvbmRzVG9BZGQpIHtcbiAgICBpZiAoc2Vjb25kc1RvQWRkID09PSAwKSB7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICB2YXIgc29mZCA9IHRoaXMuX2hvdXIgKiBMb2NhbFRpbWUuU0VDT05EU19QRVJfSE9VUiArIHRoaXMuX21pbnV0ZSAqIExvY2FsVGltZS5TRUNPTkRTX1BFUl9NSU5VVEUgKyB0aGlzLl9zZWNvbmQ7XG4gICAgdmFyIG5ld1NvZmQgPSBNYXRoVXRpbC5pbnRNb2QoTWF0aFV0aWwuaW50TW9kKHNlY29uZHNUb0FkZCwgTG9jYWxUaW1lLlNFQ09ORFNfUEVSX0RBWSkgKyBzb2ZkICsgTG9jYWxUaW1lLlNFQ09ORFNfUEVSX0RBWSwgTG9jYWxUaW1lLlNFQ09ORFNfUEVSX0RBWSk7XG5cbiAgICBpZiAoc29mZCA9PT0gbmV3U29mZCkge1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgdmFyIG5ld0hvdXIgPSBNYXRoVXRpbC5pbnREaXYobmV3U29mZCwgTG9jYWxUaW1lLlNFQ09ORFNfUEVSX0hPVVIpO1xuICAgIHZhciBuZXdNaW51dGUgPSBNYXRoVXRpbC5pbnRNb2QoTWF0aFV0aWwuaW50RGl2KG5ld1NvZmQsIExvY2FsVGltZS5TRUNPTkRTX1BFUl9NSU5VVEUpLCBMb2NhbFRpbWUuTUlOVVRFU19QRVJfSE9VUik7XG4gICAgdmFyIG5ld1NlY29uZCA9IE1hdGhVdGlsLmludE1vZChuZXdTb2ZkLCBMb2NhbFRpbWUuU0VDT05EU19QRVJfTUlOVVRFKTtcbiAgICByZXR1cm4gbmV3IExvY2FsVGltZShuZXdIb3VyLCBuZXdNaW51dGUsIG5ld1NlY29uZCwgdGhpcy5fbmFubyk7XG4gIH07XG5cbiAgX3Byb3RvLnBsdXNOYW5vcyA9IGZ1bmN0aW9uIHBsdXNOYW5vcyhuYW5vc1RvQWRkKSB7XG4gICAgaWYgKG5hbm9zVG9BZGQgPT09IDApIHtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIHZhciBub2ZkID0gdGhpcy50b05hbm9PZkRheSgpO1xuICAgIHZhciBuZXdOb2ZkID0gTWF0aFV0aWwuaW50TW9kKE1hdGhVdGlsLmludE1vZChuYW5vc1RvQWRkLCBMb2NhbFRpbWUuTkFOT1NfUEVSX0RBWSkgKyBub2ZkICsgTG9jYWxUaW1lLk5BTk9TX1BFUl9EQVksIExvY2FsVGltZS5OQU5PU19QRVJfREFZKTtcblxuICAgIGlmIChub2ZkID09PSBuZXdOb2ZkKSB7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICB2YXIgbmV3SG91ciA9IE1hdGhVdGlsLmludERpdihuZXdOb2ZkLCBMb2NhbFRpbWUuTkFOT1NfUEVSX0hPVVIpO1xuICAgIHZhciBuZXdNaW51dGUgPSBNYXRoVXRpbC5pbnRNb2QoTWF0aFV0aWwuaW50RGl2KG5ld05vZmQsIExvY2FsVGltZS5OQU5PU19QRVJfTUlOVVRFKSwgTG9jYWxUaW1lLk1JTlVURVNfUEVSX0hPVVIpO1xuICAgIHZhciBuZXdTZWNvbmQgPSBNYXRoVXRpbC5pbnRNb2QoTWF0aFV0aWwuaW50RGl2KG5ld05vZmQsIExvY2FsVGltZS5OQU5PU19QRVJfU0VDT05EKSwgTG9jYWxUaW1lLlNFQ09ORFNfUEVSX01JTlVURSk7XG4gICAgdmFyIG5ld05hbm8gPSBNYXRoVXRpbC5pbnRNb2QobmV3Tm9mZCwgTG9jYWxUaW1lLk5BTk9TX1BFUl9TRUNPTkQpO1xuICAgIHJldHVybiBuZXcgTG9jYWxUaW1lKG5ld0hvdXIsIG5ld01pbnV0ZSwgbmV3U2Vjb25kLCBuZXdOYW5vKTtcbiAgfTtcblxuICBfcHJvdG8ubWludXNBbW91bnQgPSBmdW5jdGlvbiBtaW51c0Ftb3VudChhbW91bnQpIHtcbiAgICByZXF1aXJlTm9uTnVsbChhbW91bnQsICdhbW91bnQnKTtcbiAgICByZXR1cm4gYW1vdW50LnN1YnRyYWN0RnJvbSh0aGlzKTtcbiAgfTtcblxuICBfcHJvdG8ubWludXNBbW91bnRVbml0ID0gZnVuY3Rpb24gbWludXNBbW91bnRVbml0KGFtb3VudFRvU3VidHJhY3QsIHVuaXQpIHtcbiAgICByZXF1aXJlTm9uTnVsbCh1bml0LCAndW5pdCcpO1xuICAgIHJldHVybiB0aGlzLnBsdXNBbW91bnRVbml0KC0xICogYW1vdW50VG9TdWJ0cmFjdCwgdW5pdCk7XG4gIH07XG5cbiAgX3Byb3RvLm1pbnVzSG91cnMgPSBmdW5jdGlvbiBtaW51c0hvdXJzKGhvdXJzVG9TdWJ0cmFjdCkge1xuICAgIHJldHVybiB0aGlzLnBsdXNIb3VycygtMSAqIE1hdGhVdGlsLmludE1vZChob3Vyc1RvU3VidHJhY3QsIExvY2FsVGltZS5IT1VSU19QRVJfREFZKSk7XG4gIH07XG5cbiAgX3Byb3RvLm1pbnVzTWludXRlcyA9IGZ1bmN0aW9uIG1pbnVzTWludXRlcyhtaW51dGVzVG9TdWJ0cmFjdCkge1xuICAgIHJldHVybiB0aGlzLnBsdXNNaW51dGVzKC0xICogTWF0aFV0aWwuaW50TW9kKG1pbnV0ZXNUb1N1YnRyYWN0LCBMb2NhbFRpbWUuTUlOVVRFU19QRVJfREFZKSk7XG4gIH07XG5cbiAgX3Byb3RvLm1pbnVzU2Vjb25kcyA9IGZ1bmN0aW9uIG1pbnVzU2Vjb25kcyhzZWNvbmRzVG9TdWJ0cmFjdCkge1xuICAgIHJldHVybiB0aGlzLnBsdXNTZWNvbmRzKC0xICogTWF0aFV0aWwuaW50TW9kKHNlY29uZHNUb1N1YnRyYWN0LCBMb2NhbFRpbWUuU0VDT05EU19QRVJfREFZKSk7XG4gIH07XG5cbiAgX3Byb3RvLm1pbnVzTmFub3MgPSBmdW5jdGlvbiBtaW51c05hbm9zKG5hbm9zVG9TdWJ0cmFjdCkge1xuICAgIHJldHVybiB0aGlzLnBsdXNOYW5vcygtMSAqIE1hdGhVdGlsLmludE1vZChuYW5vc1RvU3VidHJhY3QsIExvY2FsVGltZS5OQU5PU19QRVJfREFZKSk7XG4gIH07XG5cbiAgX3Byb3RvLnF1ZXJ5ID0gZnVuY3Rpb24gcXVlcnkoX3F1ZXJ5KSB7XG4gICAgcmVxdWlyZU5vbk51bGwoX3F1ZXJ5LCAncXVlcnknKTtcblxuICAgIGlmIChfcXVlcnkgPT09IFRlbXBvcmFsUXVlcmllcy5wcmVjaXNpb24oKSkge1xuICAgICAgcmV0dXJuIENocm9ub1VuaXQuTkFOT1M7XG4gICAgfSBlbHNlIGlmIChfcXVlcnkgPT09IFRlbXBvcmFsUXVlcmllcy5sb2NhbFRpbWUoKSkge1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgaWYgKF9xdWVyeSA9PT0gVGVtcG9yYWxRdWVyaWVzLmNocm9ub2xvZ3koKSB8fCBfcXVlcnkgPT09IFRlbXBvcmFsUXVlcmllcy56b25lSWQoKSB8fCBfcXVlcnkgPT09IFRlbXBvcmFsUXVlcmllcy56b25lKCkgfHwgX3F1ZXJ5ID09PSBUZW1wb3JhbFF1ZXJpZXMub2Zmc2V0KCkgfHwgX3F1ZXJ5ID09PSBUZW1wb3JhbFF1ZXJpZXMubG9jYWxEYXRlKCkpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIHJldHVybiBfcXVlcnkucXVlcnlGcm9tKHRoaXMpO1xuICB9O1xuXG4gIF9wcm90by5hZGp1c3RJbnRvID0gZnVuY3Rpb24gYWRqdXN0SW50byh0ZW1wb3JhbCkge1xuICAgIHJldHVybiB0ZW1wb3JhbC53aXRoKExvY2FsVGltZS5OQU5PX09GX0RBWSwgdGhpcy50b05hbm9PZkRheSgpKTtcbiAgfTtcblxuICBfcHJvdG8udW50aWwgPSBmdW5jdGlvbiB1bnRpbChlbmRFeGNsdXNpdmUsIHVuaXQpIHtcbiAgICByZXF1aXJlTm9uTnVsbChlbmRFeGNsdXNpdmUsICdlbmRFeGNsdXNpdmUnKTtcbiAgICByZXF1aXJlTm9uTnVsbCh1bml0LCAndW5pdCcpO1xuICAgIHZhciBlbmQgPSBMb2NhbFRpbWUuZnJvbShlbmRFeGNsdXNpdmUpO1xuXG4gICAgaWYgKHVuaXQgaW5zdGFuY2VvZiBDaHJvbm9Vbml0KSB7XG4gICAgICB2YXIgbmFub3NVbnRpbCA9IGVuZC50b05hbm9PZkRheSgpIC0gdGhpcy50b05hbm9PZkRheSgpO1xuXG4gICAgICBzd2l0Y2ggKHVuaXQpIHtcbiAgICAgICAgY2FzZSBDaHJvbm9Vbml0Lk5BTk9TOlxuICAgICAgICAgIHJldHVybiBuYW5vc1VudGlsO1xuXG4gICAgICAgIGNhc2UgQ2hyb25vVW5pdC5NSUNST1M6XG4gICAgICAgICAgcmV0dXJuIE1hdGhVdGlsLmludERpdihuYW5vc1VudGlsLCAxMDAwKTtcblxuICAgICAgICBjYXNlIENocm9ub1VuaXQuTUlMTElTOlxuICAgICAgICAgIHJldHVybiBNYXRoVXRpbC5pbnREaXYobmFub3NVbnRpbCwgMTAwMDAwMCk7XG5cbiAgICAgICAgY2FzZSBDaHJvbm9Vbml0LlNFQ09ORFM6XG4gICAgICAgICAgcmV0dXJuIE1hdGhVdGlsLmludERpdihuYW5vc1VudGlsLCBMb2NhbFRpbWUuTkFOT1NfUEVSX1NFQ09ORCk7XG5cbiAgICAgICAgY2FzZSBDaHJvbm9Vbml0Lk1JTlVURVM6XG4gICAgICAgICAgcmV0dXJuIE1hdGhVdGlsLmludERpdihuYW5vc1VudGlsLCBMb2NhbFRpbWUuTkFOT1NfUEVSX01JTlVURSk7XG5cbiAgICAgICAgY2FzZSBDaHJvbm9Vbml0LkhPVVJTOlxuICAgICAgICAgIHJldHVybiBNYXRoVXRpbC5pbnREaXYobmFub3NVbnRpbCwgTG9jYWxUaW1lLk5BTk9TX1BFUl9IT1VSKTtcblxuICAgICAgICBjYXNlIENocm9ub1VuaXQuSEFMRl9EQVlTOlxuICAgICAgICAgIHJldHVybiBNYXRoVXRpbC5pbnREaXYobmFub3NVbnRpbCwgMTIgKiBMb2NhbFRpbWUuTkFOT1NfUEVSX0hPVVIpO1xuICAgICAgfVxuXG4gICAgICB0aHJvdyBuZXcgVW5zdXBwb3J0ZWRUZW1wb3JhbFR5cGVFeGNlcHRpb24oJ1Vuc3VwcG9ydGVkIHVuaXQ6ICcgKyB1bml0KTtcbiAgICB9XG5cbiAgICByZXR1cm4gdW5pdC5iZXR3ZWVuKHRoaXMsIGVuZCk7XG4gIH07XG5cbiAgX3Byb3RvLmF0RGF0ZSA9IGZ1bmN0aW9uIGF0RGF0ZShkYXRlKSB7XG4gICAgcmV0dXJuIExvY2FsRGF0ZVRpbWUub2YoZGF0ZSwgdGhpcyk7XG4gIH07XG5cbiAgX3Byb3RvLnRvU2Vjb25kT2ZEYXkgPSBmdW5jdGlvbiB0b1NlY29uZE9mRGF5KCkge1xuICAgIHZhciB0b3RhbCA9IHRoaXMuX2hvdXIgKiBMb2NhbFRpbWUuU0VDT05EU19QRVJfSE9VUjtcbiAgICB0b3RhbCArPSB0aGlzLl9taW51dGUgKiBMb2NhbFRpbWUuU0VDT05EU19QRVJfTUlOVVRFO1xuICAgIHRvdGFsICs9IHRoaXMuX3NlY29uZDtcbiAgICByZXR1cm4gdG90YWw7XG4gIH07XG5cbiAgX3Byb3RvLnRvTmFub09mRGF5ID0gZnVuY3Rpb24gdG9OYW5vT2ZEYXkoKSB7XG4gICAgdmFyIHRvdGFsID0gdGhpcy5faG91ciAqIExvY2FsVGltZS5OQU5PU19QRVJfSE9VUjtcbiAgICB0b3RhbCArPSB0aGlzLl9taW51dGUgKiBMb2NhbFRpbWUuTkFOT1NfUEVSX01JTlVURTtcbiAgICB0b3RhbCArPSB0aGlzLl9zZWNvbmQgKiBMb2NhbFRpbWUuTkFOT1NfUEVSX1NFQ09ORDtcbiAgICB0b3RhbCArPSB0aGlzLl9uYW5vO1xuICAgIHJldHVybiB0b3RhbDtcbiAgfTtcblxuICBfcHJvdG8uY29tcGFyZVRvID0gZnVuY3Rpb24gY29tcGFyZVRvKG90aGVyKSB7XG4gICAgcmVxdWlyZU5vbk51bGwob3RoZXIsICdvdGhlcicpO1xuICAgIHJlcXVpcmVJbnN0YW5jZShvdGhlciwgTG9jYWxUaW1lLCAnb3RoZXInKTtcbiAgICB2YXIgY21wID0gTWF0aFV0aWwuY29tcGFyZU51bWJlcnModGhpcy5faG91ciwgb3RoZXIuX2hvdXIpO1xuXG4gICAgaWYgKGNtcCA9PT0gMCkge1xuICAgICAgY21wID0gTWF0aFV0aWwuY29tcGFyZU51bWJlcnModGhpcy5fbWludXRlLCBvdGhlci5fbWludXRlKTtcblxuICAgICAgaWYgKGNtcCA9PT0gMCkge1xuICAgICAgICBjbXAgPSBNYXRoVXRpbC5jb21wYXJlTnVtYmVycyh0aGlzLl9zZWNvbmQsIG90aGVyLl9zZWNvbmQpO1xuXG4gICAgICAgIGlmIChjbXAgPT09IDApIHtcbiAgICAgICAgICBjbXAgPSBNYXRoVXRpbC5jb21wYXJlTnVtYmVycyh0aGlzLl9uYW5vLCBvdGhlci5fbmFubyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gY21wO1xuICB9O1xuXG4gIF9wcm90by5pc0FmdGVyID0gZnVuY3Rpb24gaXNBZnRlcihvdGhlcikge1xuICAgIHJldHVybiB0aGlzLmNvbXBhcmVUbyhvdGhlcikgPiAwO1xuICB9O1xuXG4gIF9wcm90by5pc0JlZm9yZSA9IGZ1bmN0aW9uIGlzQmVmb3JlKG90aGVyKSB7XG4gICAgcmV0dXJuIHRoaXMuY29tcGFyZVRvKG90aGVyKSA8IDA7XG4gIH07XG5cbiAgX3Byb3RvLmVxdWFscyA9IGZ1bmN0aW9uIGVxdWFscyhvdGhlcikge1xuICAgIGlmICh0aGlzID09PSBvdGhlcikge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgaWYgKG90aGVyIGluc3RhbmNlb2YgTG9jYWxUaW1lKSB7XG4gICAgICByZXR1cm4gdGhpcy5faG91ciA9PT0gb3RoZXIuX2hvdXIgJiYgdGhpcy5fbWludXRlID09PSBvdGhlci5fbWludXRlICYmIHRoaXMuX3NlY29uZCA9PT0gb3RoZXIuX3NlY29uZCAmJiB0aGlzLl9uYW5vID09PSBvdGhlci5fbmFubztcbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2U7XG4gIH07XG5cbiAgX3Byb3RvLmhhc2hDb2RlID0gZnVuY3Rpb24gaGFzaENvZGUoKSB7XG4gICAgdmFyIG5vZCA9IHRoaXMudG9OYW5vT2ZEYXkoKTtcbiAgICByZXR1cm4gTWF0aFV0aWwuaGFzaChub2QpO1xuICB9O1xuXG4gIF9wcm90by50b1N0cmluZyA9IGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuICAgIHZhciBidWYgPSAnJztcbiAgICB2YXIgaG91clZhbHVlID0gdGhpcy5faG91cjtcbiAgICB2YXIgbWludXRlVmFsdWUgPSB0aGlzLl9taW51dGU7XG4gICAgdmFyIHNlY29uZFZhbHVlID0gdGhpcy5fc2Vjb25kO1xuICAgIHZhciBuYW5vVmFsdWUgPSB0aGlzLl9uYW5vO1xuICAgIGJ1ZiArPSBob3VyVmFsdWUgPCAxMCA/ICcwJyA6ICcnO1xuICAgIGJ1ZiArPSBob3VyVmFsdWU7XG4gICAgYnVmICs9IG1pbnV0ZVZhbHVlIDwgMTAgPyAnOjAnIDogJzonO1xuICAgIGJ1ZiArPSBtaW51dGVWYWx1ZTtcblxuICAgIGlmIChzZWNvbmRWYWx1ZSA+IDAgfHwgbmFub1ZhbHVlID4gMCkge1xuICAgICAgYnVmICs9IHNlY29uZFZhbHVlIDwgMTAgPyAnOjAnIDogJzonO1xuICAgICAgYnVmICs9IHNlY29uZFZhbHVlO1xuXG4gICAgICBpZiAobmFub1ZhbHVlID4gMCkge1xuICAgICAgICBidWYgKz0gJy4nO1xuXG4gICAgICAgIGlmIChNYXRoVXRpbC5pbnRNb2QobmFub1ZhbHVlLCAxMDAwMDAwKSA9PT0gMCkge1xuICAgICAgICAgIGJ1ZiArPSAoJycgKyAoTWF0aFV0aWwuaW50RGl2KG5hbm9WYWx1ZSwgMTAwMDAwMCkgKyAxMDAwKSkuc3Vic3RyaW5nKDEpO1xuICAgICAgICB9IGVsc2UgaWYgKE1hdGhVdGlsLmludE1vZChuYW5vVmFsdWUsIDEwMDApID09PSAwKSB7XG4gICAgICAgICAgYnVmICs9ICgnJyArIChNYXRoVXRpbC5pbnREaXYobmFub1ZhbHVlLCAxMDAwKSArIDEwMDAwMDApKS5zdWJzdHJpbmcoMSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgYnVmICs9ICgnJyArIChuYW5vVmFsdWUgKyAxMDAwMDAwMDAwKSkuc3Vic3RyaW5nKDEpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGJ1ZjtcbiAgfTtcblxuICBfcHJvdG8udG9KU09OID0gZnVuY3Rpb24gdG9KU09OKCkge1xuICAgIHJldHVybiB0aGlzLnRvU3RyaW5nKCk7XG4gIH07XG5cbiAgX3Byb3RvLmZvcm1hdCA9IGZ1bmN0aW9uIGZvcm1hdChmb3JtYXR0ZXIpIHtcbiAgICByZXF1aXJlTm9uTnVsbChmb3JtYXR0ZXIsICdmb3JtYXR0ZXInKTtcbiAgICByZXR1cm4gZm9ybWF0dGVyLmZvcm1hdCh0aGlzKTtcbiAgfTtcblxuICByZXR1cm4gTG9jYWxUaW1lO1xufShUZW1wb3JhbCk7XG5mdW5jdGlvbiBfaW5pdCRrKCkge1xuICBMb2NhbFRpbWUuSE9VUlMgPSBbXTtcblxuICBmb3IgKHZhciBob3VyID0gMDsgaG91ciA8IDI0OyBob3VyKyspIHtcbiAgICBMb2NhbFRpbWUub2YoaG91ciwgMCwgMCwgMCk7XG4gIH1cblxuICBMb2NhbFRpbWUuTUlOID0gTG9jYWxUaW1lLkhPVVJTWzBdO1xuICBMb2NhbFRpbWUuTUFYID0gbmV3IExvY2FsVGltZSgyMywgNTksIDU5LCA5OTk5OTk5OTkpO1xuICBMb2NhbFRpbWUuTUlETklHSFQgPSBMb2NhbFRpbWUuSE9VUlNbMF07XG4gIExvY2FsVGltZS5OT09OID0gTG9jYWxUaW1lLkhPVVJTWzEyXTtcbiAgTG9jYWxUaW1lLkZST00gPSBjcmVhdGVUZW1wb3JhbFF1ZXJ5KCdMb2NhbFRpbWUuRlJPTScsIGZ1bmN0aW9uICh0ZW1wb3JhbCkge1xuICAgIHJldHVybiBMb2NhbFRpbWUuZnJvbSh0ZW1wb3JhbCk7XG4gIH0pO1xufVxuTG9jYWxUaW1lLkhPVVJTX1BFUl9EQVkgPSAyNDtcbkxvY2FsVGltZS5NSU5VVEVTX1BFUl9IT1VSID0gNjA7XG5Mb2NhbFRpbWUuTUlOVVRFU19QRVJfREFZID0gTG9jYWxUaW1lLk1JTlVURVNfUEVSX0hPVVIgKiBMb2NhbFRpbWUuSE9VUlNfUEVSX0RBWTtcbkxvY2FsVGltZS5TRUNPTkRTX1BFUl9NSU5VVEUgPSA2MDtcbkxvY2FsVGltZS5TRUNPTkRTX1BFUl9IT1VSID0gTG9jYWxUaW1lLlNFQ09ORFNfUEVSX01JTlVURSAqIExvY2FsVGltZS5NSU5VVEVTX1BFUl9IT1VSO1xuTG9jYWxUaW1lLlNFQ09ORFNfUEVSX0RBWSA9IExvY2FsVGltZS5TRUNPTkRTX1BFUl9IT1VSICogTG9jYWxUaW1lLkhPVVJTX1BFUl9EQVk7XG5Mb2NhbFRpbWUuTUlMTElTX1BFUl9EQVkgPSBMb2NhbFRpbWUuU0VDT05EU19QRVJfREFZICogMTAwMDtcbkxvY2FsVGltZS5NSUNST1NfUEVSX0RBWSA9IExvY2FsVGltZS5TRUNPTkRTX1BFUl9EQVkgKiAxMDAwMDAwO1xuTG9jYWxUaW1lLk5BTk9TX1BFUl9TRUNPTkQgPSAxMDAwMDAwMDAwO1xuTG9jYWxUaW1lLk5BTk9TX1BFUl9NSU5VVEUgPSBMb2NhbFRpbWUuTkFOT1NfUEVSX1NFQ09ORCAqIExvY2FsVGltZS5TRUNPTkRTX1BFUl9NSU5VVEU7XG5Mb2NhbFRpbWUuTkFOT1NfUEVSX0hPVVIgPSBMb2NhbFRpbWUuTkFOT1NfUEVSX01JTlVURSAqIExvY2FsVGltZS5NSU5VVEVTX1BFUl9IT1VSO1xuTG9jYWxUaW1lLk5BTk9TX1BFUl9EQVkgPSBMb2NhbFRpbWUuTkFOT1NfUEVSX0hPVVIgKiBMb2NhbFRpbWUuSE9VUlNfUEVSX0RBWTtcblxudmFyIE5BTk9TX1BFUl9NSUxMSSA9IDEwMDAwMDA7XG52YXIgSW5zdGFudCA9IGZ1bmN0aW9uIChfVGVtcG9yYWwpIHtcbiAgX2luaGVyaXRzTG9vc2UoSW5zdGFudCwgX1RlbXBvcmFsKTtcblxuICBJbnN0YW50Lm5vdyA9IGZ1bmN0aW9uIG5vdyhjbG9jaykge1xuICAgIGlmIChjbG9jayA9PT0gdm9pZCAwKSB7XG4gICAgICBjbG9jayA9IENsb2NrLnN5c3RlbVVUQygpO1xuICAgIH1cblxuICAgIHJldHVybiBjbG9jay5pbnN0YW50KCk7XG4gIH07XG5cbiAgSW5zdGFudC5vZkVwb2NoU2Vjb25kID0gZnVuY3Rpb24gb2ZFcG9jaFNlY29uZChlcG9jaFNlY29uZCwgbmFub0FkanVzdG1lbnQpIHtcbiAgICBpZiAobmFub0FkanVzdG1lbnQgPT09IHZvaWQgMCkge1xuICAgICAgbmFub0FkanVzdG1lbnQgPSAwO1xuICAgIH1cblxuICAgIHZhciBzZWNzID0gZXBvY2hTZWNvbmQgKyBNYXRoVXRpbC5mbG9vckRpdihuYW5vQWRqdXN0bWVudCwgTG9jYWxUaW1lLk5BTk9TX1BFUl9TRUNPTkQpO1xuICAgIHZhciBub3MgPSBNYXRoVXRpbC5mbG9vck1vZChuYW5vQWRqdXN0bWVudCwgTG9jYWxUaW1lLk5BTk9TX1BFUl9TRUNPTkQpO1xuICAgIHJldHVybiBJbnN0YW50Ll9jcmVhdGUoc2Vjcywgbm9zKTtcbiAgfTtcblxuICBJbnN0YW50Lm9mRXBvY2hNaWxsaSA9IGZ1bmN0aW9uIG9mRXBvY2hNaWxsaShlcG9jaE1pbGxpKSB7XG4gICAgdmFyIHNlY3MgPSBNYXRoVXRpbC5mbG9vckRpdihlcG9jaE1pbGxpLCAxMDAwKTtcbiAgICB2YXIgbW9zID0gTWF0aFV0aWwuZmxvb3JNb2QoZXBvY2hNaWxsaSwgMTAwMCk7XG4gICAgcmV0dXJuIEluc3RhbnQuX2NyZWF0ZShzZWNzLCBtb3MgKiAxMDAwMDAwKTtcbiAgfTtcblxuICBJbnN0YW50LmZyb20gPSBmdW5jdGlvbiBmcm9tKHRlbXBvcmFsKSB7XG4gICAgdHJ5IHtcbiAgICAgIHZhciBpbnN0YW50U2VjcyA9IHRlbXBvcmFsLmdldExvbmcoQ2hyb25vRmllbGQuSU5TVEFOVF9TRUNPTkRTKTtcbiAgICAgIHZhciBuYW5vT2ZTZWNvbmQgPSB0ZW1wb3JhbC5nZXQoQ2hyb25vRmllbGQuTkFOT19PRl9TRUNPTkQpO1xuICAgICAgcmV0dXJuIEluc3RhbnQub2ZFcG9jaFNlY29uZChpbnN0YW50U2VjcywgbmFub09mU2Vjb25kKTtcbiAgICB9IGNhdGNoIChleCkge1xuICAgICAgdGhyb3cgbmV3IERhdGVUaW1lRXhjZXB0aW9uKCdVbmFibGUgdG8gb2J0YWluIEluc3RhbnQgZnJvbSBUZW1wb3JhbEFjY2Vzc29yOiAnICsgdGVtcG9yYWwgKyAnLCB0eXBlICcgKyB0eXBlb2YgdGVtcG9yYWwsIGV4KTtcbiAgICB9XG4gIH07XG5cbiAgSW5zdGFudC5wYXJzZSA9IGZ1bmN0aW9uIHBhcnNlKHRleHQpIHtcbiAgICByZXR1cm4gRGF0ZVRpbWVGb3JtYXR0ZXIuSVNPX0lOU1RBTlQucGFyc2UodGV4dCwgSW5zdGFudC5GUk9NKTtcbiAgfTtcblxuICBJbnN0YW50Ll9jcmVhdGUgPSBmdW5jdGlvbiBfY3JlYXRlKHNlY29uZHMsIG5hbm9PZlNlY29uZCkge1xuICAgIGlmIChzZWNvbmRzID09PSAwICYmIG5hbm9PZlNlY29uZCA9PT0gMCkge1xuICAgICAgcmV0dXJuIEluc3RhbnQuRVBPQ0g7XG4gICAgfVxuXG4gICAgcmV0dXJuIG5ldyBJbnN0YW50KHNlY29uZHMsIG5hbm9PZlNlY29uZCk7XG4gIH07XG5cbiAgSW5zdGFudC5fdmFsaWRhdGUgPSBmdW5jdGlvbiBfdmFsaWRhdGUoc2Vjb25kcywgbmFub09mU2Vjb25kKSB7XG4gICAgaWYgKHNlY29uZHMgPCBJbnN0YW50Lk1JTl9TRUNPTkRTIHx8IHNlY29uZHMgPiBJbnN0YW50Lk1BWF9TRUNPTkRTKSB7XG4gICAgICB0aHJvdyBuZXcgRGF0ZVRpbWVFeGNlcHRpb24oJ0luc3RhbnQgZXhjZWVkcyBtaW5pbXVtIG9yIG1heGltdW0gaW5zdGFudCcpO1xuICAgIH1cblxuICAgIGlmIChuYW5vT2ZTZWNvbmQgPCAwIHx8IG5hbm9PZlNlY29uZCA+IExvY2FsVGltZS5OQU5PU19QRVJfU0VDT05EKSB7XG4gICAgICB0aHJvdyBuZXcgRGF0ZVRpbWVFeGNlcHRpb24oJ0luc3RhbnQgZXhjZWVkcyBtaW5pbXVtIG9yIG1heGltdW0gaW5zdGFudCcpO1xuICAgIH1cbiAgfTtcblxuICBmdW5jdGlvbiBJbnN0YW50KHNlY29uZHMsIG5hbm9PZlNlY29uZCkge1xuICAgIHZhciBfdGhpcztcblxuICAgIF90aGlzID0gX1RlbXBvcmFsLmNhbGwodGhpcykgfHwgdGhpcztcblxuICAgIEluc3RhbnQuX3ZhbGlkYXRlKHNlY29uZHMsIG5hbm9PZlNlY29uZCk7XG5cbiAgICBfdGhpcy5fc2Vjb25kcyA9IE1hdGhVdGlsLnNhZmVUb0ludChzZWNvbmRzKTtcbiAgICBfdGhpcy5fbmFub3MgPSBNYXRoVXRpbC5zYWZlVG9JbnQobmFub09mU2Vjb25kKTtcbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cblxuICB2YXIgX3Byb3RvID0gSW5zdGFudC5wcm90b3R5cGU7XG5cbiAgX3Byb3RvLmlzU3VwcG9ydGVkID0gZnVuY3Rpb24gaXNTdXBwb3J0ZWQoZmllbGRPclVuaXQpIHtcbiAgICBpZiAoZmllbGRPclVuaXQgaW5zdGFuY2VvZiBDaHJvbm9GaWVsZCkge1xuICAgICAgcmV0dXJuIGZpZWxkT3JVbml0ID09PSBDaHJvbm9GaWVsZC5JTlNUQU5UX1NFQ09ORFMgfHwgZmllbGRPclVuaXQgPT09IENocm9ub0ZpZWxkLk5BTk9fT0ZfU0VDT05EIHx8IGZpZWxkT3JVbml0ID09PSBDaHJvbm9GaWVsZC5NSUNST19PRl9TRUNPTkQgfHwgZmllbGRPclVuaXQgPT09IENocm9ub0ZpZWxkLk1JTExJX09GX1NFQ09ORDtcbiAgICB9XG5cbiAgICBpZiAoZmllbGRPclVuaXQgaW5zdGFuY2VvZiBDaHJvbm9Vbml0KSB7XG4gICAgICByZXR1cm4gZmllbGRPclVuaXQuaXNUaW1lQmFzZWQoKSB8fCBmaWVsZE9yVW5pdCA9PT0gQ2hyb25vVW5pdC5EQVlTO1xuICAgIH1cblxuICAgIHJldHVybiBmaWVsZE9yVW5pdCAhPSBudWxsICYmIGZpZWxkT3JVbml0LmlzU3VwcG9ydGVkQnkodGhpcyk7XG4gIH07XG5cbiAgX3Byb3RvLnJhbmdlID0gZnVuY3Rpb24gcmFuZ2UoZmllbGQpIHtcbiAgICByZXR1cm4gX1RlbXBvcmFsLnByb3RvdHlwZS5yYW5nZS5jYWxsKHRoaXMsIGZpZWxkKTtcbiAgfTtcblxuICBfcHJvdG8uZ2V0ID0gZnVuY3Rpb24gZ2V0KGZpZWxkKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0TG9uZyhmaWVsZCk7XG4gIH07XG5cbiAgX3Byb3RvLmdldExvbmcgPSBmdW5jdGlvbiBnZXRMb25nKGZpZWxkKSB7XG4gICAgaWYgKGZpZWxkIGluc3RhbmNlb2YgQ2hyb25vRmllbGQpIHtcbiAgICAgIHN3aXRjaCAoZmllbGQpIHtcbiAgICAgICAgY2FzZSBDaHJvbm9GaWVsZC5OQU5PX09GX1NFQ09ORDpcbiAgICAgICAgICByZXR1cm4gdGhpcy5fbmFub3M7XG5cbiAgICAgICAgY2FzZSBDaHJvbm9GaWVsZC5NSUNST19PRl9TRUNPTkQ6XG4gICAgICAgICAgcmV0dXJuIE1hdGhVdGlsLmludERpdih0aGlzLl9uYW5vcywgMTAwMCk7XG5cbiAgICAgICAgY2FzZSBDaHJvbm9GaWVsZC5NSUxMSV9PRl9TRUNPTkQ6XG4gICAgICAgICAgcmV0dXJuIE1hdGhVdGlsLmludERpdih0aGlzLl9uYW5vcywgTkFOT1NfUEVSX01JTExJKTtcblxuICAgICAgICBjYXNlIENocm9ub0ZpZWxkLklOU1RBTlRfU0VDT05EUzpcbiAgICAgICAgICByZXR1cm4gdGhpcy5fc2Vjb25kcztcbiAgICAgIH1cblxuICAgICAgdGhyb3cgbmV3IFVuc3VwcG9ydGVkVGVtcG9yYWxUeXBlRXhjZXB0aW9uKCdVbnN1cHBvcnRlZCBmaWVsZDogJyArIGZpZWxkKTtcbiAgICB9XG5cbiAgICByZXR1cm4gZmllbGQuZ2V0RnJvbSh0aGlzKTtcbiAgfTtcblxuICBfcHJvdG8uZXBvY2hTZWNvbmQgPSBmdW5jdGlvbiBlcG9jaFNlY29uZCgpIHtcbiAgICByZXR1cm4gdGhpcy5fc2Vjb25kcztcbiAgfTtcblxuICBfcHJvdG8ubmFubyA9IGZ1bmN0aW9uIG5hbm8oKSB7XG4gICAgcmV0dXJuIHRoaXMuX25hbm9zO1xuICB9O1xuXG4gIF9wcm90by53aXRoQWRqdXN0ZXIgPSBmdW5jdGlvbiB3aXRoQWRqdXN0ZXIoYWRqdXN0ZXIpIHtcbiAgICByZXF1aXJlTm9uTnVsbChhZGp1c3RlciwgJ2FkanVzdGVyJyk7XG4gICAgcmV0dXJuIGFkanVzdGVyLmFkanVzdEludG8odGhpcyk7XG4gIH07XG5cbiAgX3Byb3RvLndpdGhGaWVsZFZhbHVlID0gZnVuY3Rpb24gd2l0aEZpZWxkVmFsdWUoZmllbGQsIG5ld1ZhbHVlKSB7XG4gICAgcmVxdWlyZU5vbk51bGwoZmllbGQsICdmaWVsZCcpO1xuXG4gICAgaWYgKGZpZWxkIGluc3RhbmNlb2YgQ2hyb25vRmllbGQpIHtcbiAgICAgIGZpZWxkLmNoZWNrVmFsaWRWYWx1ZShuZXdWYWx1ZSk7XG5cbiAgICAgIHN3aXRjaCAoZmllbGQpIHtcbiAgICAgICAgY2FzZSBDaHJvbm9GaWVsZC5NSUxMSV9PRl9TRUNPTkQ6XG4gICAgICAgICAge1xuICAgICAgICAgICAgdmFyIG52YWwgPSBuZXdWYWx1ZSAqIE5BTk9TX1BFUl9NSUxMSTtcbiAgICAgICAgICAgIHJldHVybiBudmFsICE9PSB0aGlzLl9uYW5vcyA/IEluc3RhbnQuX2NyZWF0ZSh0aGlzLl9zZWNvbmRzLCBudmFsKSA6IHRoaXM7XG4gICAgICAgICAgfVxuXG4gICAgICAgIGNhc2UgQ2hyb25vRmllbGQuTUlDUk9fT0ZfU0VDT05EOlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIHZhciBfbnZhbCA9IG5ld1ZhbHVlICogMTAwMDtcblxuICAgICAgICAgICAgcmV0dXJuIF9udmFsICE9PSB0aGlzLl9uYW5vcyA/IEluc3RhbnQuX2NyZWF0ZSh0aGlzLl9zZWNvbmRzLCBfbnZhbCkgOiB0aGlzO1xuICAgICAgICAgIH1cblxuICAgICAgICBjYXNlIENocm9ub0ZpZWxkLk5BTk9fT0ZfU0VDT05EOlxuICAgICAgICAgIHJldHVybiBuZXdWYWx1ZSAhPT0gdGhpcy5fbmFub3MgPyBJbnN0YW50Ll9jcmVhdGUodGhpcy5fc2Vjb25kcywgbmV3VmFsdWUpIDogdGhpcztcblxuICAgICAgICBjYXNlIENocm9ub0ZpZWxkLklOU1RBTlRfU0VDT05EUzpcbiAgICAgICAgICByZXR1cm4gbmV3VmFsdWUgIT09IHRoaXMuX3NlY29uZHMgPyBJbnN0YW50Ll9jcmVhdGUobmV3VmFsdWUsIHRoaXMuX25hbm9zKSA6IHRoaXM7XG4gICAgICB9XG5cbiAgICAgIHRocm93IG5ldyBVbnN1cHBvcnRlZFRlbXBvcmFsVHlwZUV4Y2VwdGlvbignVW5zdXBwb3J0ZWQgZmllbGQ6ICcgKyBmaWVsZCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZpZWxkLmFkanVzdEludG8odGhpcywgbmV3VmFsdWUpO1xuICB9O1xuXG4gIF9wcm90by50cnVuY2F0ZWRUbyA9IGZ1bmN0aW9uIHRydW5jYXRlZFRvKHVuaXQpIHtcbiAgICByZXF1aXJlTm9uTnVsbCh1bml0LCAndW5pdCcpO1xuXG4gICAgaWYgKHVuaXQgPT09IENocm9ub1VuaXQuTkFOT1MpIHtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIHZhciB1bml0RHVyID0gdW5pdC5kdXJhdGlvbigpO1xuXG4gICAgaWYgKHVuaXREdXIuc2Vjb25kcygpID4gTG9jYWxUaW1lLlNFQ09ORFNfUEVSX0RBWSkge1xuICAgICAgdGhyb3cgbmV3IERhdGVUaW1lRXhjZXB0aW9uKCdVbml0IGlzIHRvbyBsYXJnZSB0byBiZSB1c2VkIGZvciB0cnVuY2F0aW9uJyk7XG4gICAgfVxuXG4gICAgdmFyIGR1ciA9IHVuaXREdXIudG9OYW5vcygpO1xuXG4gICAgaWYgKE1hdGhVdGlsLmludE1vZChMb2NhbFRpbWUuTkFOT1NfUEVSX0RBWSwgZHVyKSAhPT0gMCkge1xuICAgICAgdGhyb3cgbmV3IERhdGVUaW1lRXhjZXB0aW9uKCdVbml0IG11c3QgZGl2aWRlIGludG8gYSBzdGFuZGFyZCBkYXkgd2l0aG91dCByZW1haW5kZXInKTtcbiAgICB9XG5cbiAgICB2YXIgbm9kID0gTWF0aFV0aWwuaW50TW9kKHRoaXMuX3NlY29uZHMsIExvY2FsVGltZS5TRUNPTkRTX1BFUl9EQVkpICogTG9jYWxUaW1lLk5BTk9TX1BFUl9TRUNPTkQgKyB0aGlzLl9uYW5vcztcblxuICAgIHZhciByZXN1bHQgPSBNYXRoVXRpbC5pbnREaXYobm9kLCBkdXIpICogZHVyO1xuICAgIHJldHVybiB0aGlzLnBsdXNOYW5vcyhyZXN1bHQgLSBub2QpO1xuICB9O1xuXG4gIF9wcm90by5wbHVzQW1vdW50ID0gZnVuY3Rpb24gcGx1c0Ftb3VudChhbW91bnQpIHtcbiAgICByZXF1aXJlTm9uTnVsbChhbW91bnQsICdhbW91bnQnKTtcbiAgICByZXR1cm4gYW1vdW50LmFkZFRvKHRoaXMpO1xuICB9O1xuXG4gIF9wcm90by5wbHVzQW1vdW50VW5pdCA9IGZ1bmN0aW9uIHBsdXNBbW91bnRVbml0KGFtb3VudFRvQWRkLCB1bml0KSB7XG4gICAgcmVxdWlyZU5vbk51bGwoYW1vdW50VG9BZGQsICdhbW91bnRUb0FkZCcpO1xuICAgIHJlcXVpcmVOb25OdWxsKHVuaXQsICd1bml0Jyk7XG4gICAgcmVxdWlyZUluc3RhbmNlKHVuaXQsIFRlbXBvcmFsVW5pdCk7XG5cbiAgICBpZiAodW5pdCBpbnN0YW5jZW9mIENocm9ub1VuaXQpIHtcbiAgICAgIHN3aXRjaCAodW5pdCkge1xuICAgICAgICBjYXNlIENocm9ub1VuaXQuTkFOT1M6XG4gICAgICAgICAgcmV0dXJuIHRoaXMucGx1c05hbm9zKGFtb3VudFRvQWRkKTtcblxuICAgICAgICBjYXNlIENocm9ub1VuaXQuTUlDUk9TOlxuICAgICAgICAgIHJldHVybiB0aGlzLl9wbHVzKE1hdGhVdGlsLmludERpdihhbW91bnRUb0FkZCwgMTAwMDAwMCksIE1hdGhVdGlsLmludE1vZChhbW91bnRUb0FkZCwgMTAwMDAwMCkgKiAxMDAwKTtcblxuICAgICAgICBjYXNlIENocm9ub1VuaXQuTUlMTElTOlxuICAgICAgICAgIHJldHVybiB0aGlzLnBsdXNNaWxsaXMoYW1vdW50VG9BZGQpO1xuXG4gICAgICAgIGNhc2UgQ2hyb25vVW5pdC5TRUNPTkRTOlxuICAgICAgICAgIHJldHVybiB0aGlzLnBsdXNTZWNvbmRzKGFtb3VudFRvQWRkKTtcblxuICAgICAgICBjYXNlIENocm9ub1VuaXQuTUlOVVRFUzpcbiAgICAgICAgICByZXR1cm4gdGhpcy5wbHVzU2Vjb25kcyhNYXRoVXRpbC5zYWZlTXVsdGlwbHkoYW1vdW50VG9BZGQsIExvY2FsVGltZS5TRUNPTkRTX1BFUl9NSU5VVEUpKTtcblxuICAgICAgICBjYXNlIENocm9ub1VuaXQuSE9VUlM6XG4gICAgICAgICAgcmV0dXJuIHRoaXMucGx1c1NlY29uZHMoTWF0aFV0aWwuc2FmZU11bHRpcGx5KGFtb3VudFRvQWRkLCBMb2NhbFRpbWUuU0VDT05EU19QRVJfSE9VUikpO1xuXG4gICAgICAgIGNhc2UgQ2hyb25vVW5pdC5IQUxGX0RBWVM6XG4gICAgICAgICAgcmV0dXJuIHRoaXMucGx1c1NlY29uZHMoTWF0aFV0aWwuc2FmZU11bHRpcGx5KGFtb3VudFRvQWRkLCBMb2NhbFRpbWUuU0VDT05EU19QRVJfREFZIC8gMikpO1xuXG4gICAgICAgIGNhc2UgQ2hyb25vVW5pdC5EQVlTOlxuICAgICAgICAgIHJldHVybiB0aGlzLnBsdXNTZWNvbmRzKE1hdGhVdGlsLnNhZmVNdWx0aXBseShhbW91bnRUb0FkZCwgTG9jYWxUaW1lLlNFQ09ORFNfUEVSX0RBWSkpO1xuICAgICAgfVxuXG4gICAgICB0aHJvdyBuZXcgVW5zdXBwb3J0ZWRUZW1wb3JhbFR5cGVFeGNlcHRpb24oJ1Vuc3VwcG9ydGVkIHVuaXQ6ICcgKyB1bml0KTtcbiAgICB9XG5cbiAgICByZXR1cm4gdW5pdC5hZGRUbyh0aGlzLCBhbW91bnRUb0FkZCk7XG4gIH07XG5cbiAgX3Byb3RvLnBsdXNTZWNvbmRzID0gZnVuY3Rpb24gcGx1c1NlY29uZHMoc2Vjb25kc1RvQWRkKSB7XG4gICAgcmV0dXJuIHRoaXMuX3BsdXMoc2Vjb25kc1RvQWRkLCAwKTtcbiAgfTtcblxuICBfcHJvdG8ucGx1c01pbGxpcyA9IGZ1bmN0aW9uIHBsdXNNaWxsaXMobWlsbGlzVG9BZGQpIHtcbiAgICByZXR1cm4gdGhpcy5fcGx1cyhNYXRoVXRpbC5pbnREaXYobWlsbGlzVG9BZGQsIDEwMDApLCBNYXRoVXRpbC5pbnRNb2QobWlsbGlzVG9BZGQsIDEwMDApICogTkFOT1NfUEVSX01JTExJKTtcbiAgfTtcblxuICBfcHJvdG8ucGx1c05hbm9zID0gZnVuY3Rpb24gcGx1c05hbm9zKG5hbm9zVG9BZGQpIHtcbiAgICByZXR1cm4gdGhpcy5fcGx1cygwLCBuYW5vc1RvQWRkKTtcbiAgfTtcblxuICBfcHJvdG8uX3BsdXMgPSBmdW5jdGlvbiBfcGx1cyhzZWNvbmRzVG9BZGQsIG5hbm9zVG9BZGQpIHtcbiAgICBpZiAoc2Vjb25kc1RvQWRkID09PSAwICYmIG5hbm9zVG9BZGQgPT09IDApIHtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIHZhciBlcG9jaFNlYyA9IHRoaXMuX3NlY29uZHMgKyBzZWNvbmRzVG9BZGQ7XG4gICAgZXBvY2hTZWMgPSBlcG9jaFNlYyArIE1hdGhVdGlsLmludERpdihuYW5vc1RvQWRkLCBMb2NhbFRpbWUuTkFOT1NfUEVSX1NFQ09ORCk7XG4gICAgdmFyIG5hbm9BZGp1c3RtZW50ID0gdGhpcy5fbmFub3MgKyBuYW5vc1RvQWRkICUgTG9jYWxUaW1lLk5BTk9TX1BFUl9TRUNPTkQ7XG4gICAgcmV0dXJuIEluc3RhbnQub2ZFcG9jaFNlY29uZChlcG9jaFNlYywgbmFub0FkanVzdG1lbnQpO1xuICB9O1xuXG4gIF9wcm90by5taW51c0Ftb3VudCA9IGZ1bmN0aW9uIG1pbnVzQW1vdW50KGFtb3VudCkge1xuICAgIHJlcXVpcmVOb25OdWxsKGFtb3VudCwgJ2Ftb3VudCcpO1xuICAgIHJldHVybiBhbW91bnQuc3VidHJhY3RGcm9tKHRoaXMpO1xuICB9O1xuXG4gIF9wcm90by5taW51c0Ftb3VudFVuaXQgPSBmdW5jdGlvbiBtaW51c0Ftb3VudFVuaXQoYW1vdW50VG9TdWJ0cmFjdCwgdW5pdCkge1xuICAgIHJldHVybiB0aGlzLnBsdXNBbW91bnRVbml0KC0xICogYW1vdW50VG9TdWJ0cmFjdCwgdW5pdCk7XG4gIH07XG5cbiAgX3Byb3RvLm1pbnVzU2Vjb25kcyA9IGZ1bmN0aW9uIG1pbnVzU2Vjb25kcyhzZWNvbmRzVG9TdWJ0cmFjdCkge1xuICAgIHJldHVybiB0aGlzLnBsdXNTZWNvbmRzKHNlY29uZHNUb1N1YnRyYWN0ICogLTEpO1xuICB9O1xuXG4gIF9wcm90by5taW51c01pbGxpcyA9IGZ1bmN0aW9uIG1pbnVzTWlsbGlzKG1pbGxpc1RvU3VidHJhY3QpIHtcbiAgICByZXR1cm4gdGhpcy5wbHVzTWlsbGlzKC0xICogbWlsbGlzVG9TdWJ0cmFjdCk7XG4gIH07XG5cbiAgX3Byb3RvLm1pbnVzTmFub3MgPSBmdW5jdGlvbiBtaW51c05hbm9zKG5hbm9zVG9TdWJ0cmFjdCkge1xuICAgIHJldHVybiB0aGlzLnBsdXNOYW5vcygtMSAqIG5hbm9zVG9TdWJ0cmFjdCk7XG4gIH07XG5cbiAgX3Byb3RvLnF1ZXJ5ID0gZnVuY3Rpb24gcXVlcnkoX3F1ZXJ5KSB7XG4gICAgcmVxdWlyZU5vbk51bGwoX3F1ZXJ5LCAncXVlcnknKTtcblxuICAgIGlmIChfcXVlcnkgPT09IFRlbXBvcmFsUXVlcmllcy5wcmVjaXNpb24oKSkge1xuICAgICAgcmV0dXJuIENocm9ub1VuaXQuTkFOT1M7XG4gICAgfVxuXG4gICAgaWYgKF9xdWVyeSA9PT0gVGVtcG9yYWxRdWVyaWVzLmxvY2FsRGF0ZSgpIHx8IF9xdWVyeSA9PT0gVGVtcG9yYWxRdWVyaWVzLmxvY2FsVGltZSgpIHx8IF9xdWVyeSA9PT0gVGVtcG9yYWxRdWVyaWVzLmNocm9ub2xvZ3koKSB8fCBfcXVlcnkgPT09IFRlbXBvcmFsUXVlcmllcy56b25lSWQoKSB8fCBfcXVlcnkgPT09IFRlbXBvcmFsUXVlcmllcy56b25lKCkgfHwgX3F1ZXJ5ID09PSBUZW1wb3JhbFF1ZXJpZXMub2Zmc2V0KCkpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIHJldHVybiBfcXVlcnkucXVlcnlGcm9tKHRoaXMpO1xuICB9O1xuXG4gIF9wcm90by5hZGp1c3RJbnRvID0gZnVuY3Rpb24gYWRqdXN0SW50byh0ZW1wb3JhbCkge1xuICAgIHJlcXVpcmVOb25OdWxsKHRlbXBvcmFsLCAndGVtcG9yYWwnKTtcbiAgICByZXR1cm4gdGVtcG9yYWwud2l0aChDaHJvbm9GaWVsZC5JTlNUQU5UX1NFQ09ORFMsIHRoaXMuX3NlY29uZHMpLndpdGgoQ2hyb25vRmllbGQuTkFOT19PRl9TRUNPTkQsIHRoaXMuX25hbm9zKTtcbiAgfTtcblxuICBfcHJvdG8udW50aWwgPSBmdW5jdGlvbiB1bnRpbChlbmRFeGNsdXNpdmUsIHVuaXQpIHtcbiAgICByZXF1aXJlTm9uTnVsbChlbmRFeGNsdXNpdmUsICdlbmRFeGNsdXNpdmUnKTtcbiAgICByZXF1aXJlTm9uTnVsbCh1bml0LCAndW5pdCcpO1xuICAgIHZhciBlbmQgPSBJbnN0YW50LmZyb20oZW5kRXhjbHVzaXZlKTtcblxuICAgIGlmICh1bml0IGluc3RhbmNlb2YgQ2hyb25vVW5pdCkge1xuICAgICAgc3dpdGNoICh1bml0KSB7XG4gICAgICAgIGNhc2UgQ2hyb25vVW5pdC5OQU5PUzpcbiAgICAgICAgICByZXR1cm4gdGhpcy5fbmFub3NVbnRpbChlbmQpO1xuXG4gICAgICAgIGNhc2UgQ2hyb25vVW5pdC5NSUNST1M6XG4gICAgICAgICAgcmV0dXJuIE1hdGhVdGlsLmludERpdih0aGlzLl9uYW5vc1VudGlsKGVuZCksIDEwMDApO1xuXG4gICAgICAgIGNhc2UgQ2hyb25vVW5pdC5NSUxMSVM6XG4gICAgICAgICAgcmV0dXJuIE1hdGhVdGlsLnNhZmVTdWJ0cmFjdChlbmQudG9FcG9jaE1pbGxpKCksIHRoaXMudG9FcG9jaE1pbGxpKCkpO1xuXG4gICAgICAgIGNhc2UgQ2hyb25vVW5pdC5TRUNPTkRTOlxuICAgICAgICAgIHJldHVybiB0aGlzLl9zZWNvbmRzVW50aWwoZW5kKTtcblxuICAgICAgICBjYXNlIENocm9ub1VuaXQuTUlOVVRFUzpcbiAgICAgICAgICByZXR1cm4gTWF0aFV0aWwuaW50RGl2KHRoaXMuX3NlY29uZHNVbnRpbChlbmQpLCBMb2NhbFRpbWUuU0VDT05EU19QRVJfTUlOVVRFKTtcblxuICAgICAgICBjYXNlIENocm9ub1VuaXQuSE9VUlM6XG4gICAgICAgICAgcmV0dXJuIE1hdGhVdGlsLmludERpdih0aGlzLl9zZWNvbmRzVW50aWwoZW5kKSwgTG9jYWxUaW1lLlNFQ09ORFNfUEVSX0hPVVIpO1xuXG4gICAgICAgIGNhc2UgQ2hyb25vVW5pdC5IQUxGX0RBWVM6XG4gICAgICAgICAgcmV0dXJuIE1hdGhVdGlsLmludERpdih0aGlzLl9zZWNvbmRzVW50aWwoZW5kKSwgMTIgKiBMb2NhbFRpbWUuU0VDT05EU19QRVJfSE9VUik7XG5cbiAgICAgICAgY2FzZSBDaHJvbm9Vbml0LkRBWVM6XG4gICAgICAgICAgcmV0dXJuIE1hdGhVdGlsLmludERpdih0aGlzLl9zZWNvbmRzVW50aWwoZW5kKSwgTG9jYWxUaW1lLlNFQ09ORFNfUEVSX0RBWSk7XG4gICAgICB9XG5cbiAgICAgIHRocm93IG5ldyBVbnN1cHBvcnRlZFRlbXBvcmFsVHlwZUV4Y2VwdGlvbignVW5zdXBwb3J0ZWQgdW5pdDogJyArIHVuaXQpO1xuICAgIH1cblxuICAgIHJldHVybiB1bml0LmJldHdlZW4odGhpcywgZW5kKTtcbiAgfTtcblxuICBfcHJvdG8uX25hbm9zVW50aWwgPSBmdW5jdGlvbiBfbmFub3NVbnRpbChlbmQpIHtcbiAgICB2YXIgc2Vjc0RpZmYgPSBNYXRoVXRpbC5zYWZlU3VidHJhY3QoZW5kLmVwb2NoU2Vjb25kKCksIHRoaXMuZXBvY2hTZWNvbmQoKSk7XG4gICAgdmFyIHRvdGFsTmFub3MgPSBNYXRoVXRpbC5zYWZlTXVsdGlwbHkoc2Vjc0RpZmYsIExvY2FsVGltZS5OQU5PU19QRVJfU0VDT05EKTtcbiAgICByZXR1cm4gTWF0aFV0aWwuc2FmZUFkZCh0b3RhbE5hbm9zLCBlbmQubmFubygpIC0gdGhpcy5uYW5vKCkpO1xuICB9O1xuXG4gIF9wcm90by5fc2Vjb25kc1VudGlsID0gZnVuY3Rpb24gX3NlY29uZHNVbnRpbChlbmQpIHtcbiAgICB2YXIgc2Vjc0RpZmYgPSBNYXRoVXRpbC5zYWZlU3VidHJhY3QoZW5kLmVwb2NoU2Vjb25kKCksIHRoaXMuZXBvY2hTZWNvbmQoKSk7XG4gICAgdmFyIG5hbm9zRGlmZiA9IGVuZC5uYW5vKCkgLSB0aGlzLm5hbm8oKTtcblxuICAgIGlmIChzZWNzRGlmZiA+IDAgJiYgbmFub3NEaWZmIDwgMCkge1xuICAgICAgc2Vjc0RpZmYtLTtcbiAgICB9IGVsc2UgaWYgKHNlY3NEaWZmIDwgMCAmJiBuYW5vc0RpZmYgPiAwKSB7XG4gICAgICBzZWNzRGlmZisrO1xuICAgIH1cblxuICAgIHJldHVybiBzZWNzRGlmZjtcbiAgfTtcblxuICBfcHJvdG8uYXRPZmZzZXQgPSBmdW5jdGlvbiBhdE9mZnNldChvZmZzZXQpIHtcbiAgICByZXR1cm4gT2Zmc2V0RGF0ZVRpbWUub2ZJbnN0YW50KHRoaXMsIG9mZnNldCk7XG4gIH07XG5cbiAgX3Byb3RvLmF0Wm9uZSA9IGZ1bmN0aW9uIGF0Wm9uZSh6b25lKSB7XG4gICAgcmV0dXJuIFpvbmVkRGF0ZVRpbWUub2ZJbnN0YW50KHRoaXMsIHpvbmUpO1xuICB9O1xuXG4gIF9wcm90by50b0Vwb2NoTWlsbGkgPSBmdW5jdGlvbiB0b0Vwb2NoTWlsbGkoKSB7XG4gICAgdmFyIG1pbGxpcyA9IE1hdGhVdGlsLnNhZmVNdWx0aXBseSh0aGlzLl9zZWNvbmRzLCAxMDAwKTtcbiAgICByZXR1cm4gbWlsbGlzICsgTWF0aFV0aWwuaW50RGl2KHRoaXMuX25hbm9zLCBOQU5PU19QRVJfTUlMTEkpO1xuICB9O1xuXG4gIF9wcm90by5jb21wYXJlVG8gPSBmdW5jdGlvbiBjb21wYXJlVG8ob3RoZXJJbnN0YW50KSB7XG4gICAgcmVxdWlyZU5vbk51bGwob3RoZXJJbnN0YW50LCAnb3RoZXJJbnN0YW50Jyk7XG4gICAgcmVxdWlyZUluc3RhbmNlKG90aGVySW5zdGFudCwgSW5zdGFudCwgJ290aGVySW5zdGFudCcpO1xuICAgIHZhciBjbXAgPSBNYXRoVXRpbC5jb21wYXJlTnVtYmVycyh0aGlzLl9zZWNvbmRzLCBvdGhlckluc3RhbnQuX3NlY29uZHMpO1xuXG4gICAgaWYgKGNtcCAhPT0gMCkge1xuICAgICAgcmV0dXJuIGNtcDtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5fbmFub3MgLSBvdGhlckluc3RhbnQuX25hbm9zO1xuICB9O1xuXG4gIF9wcm90by5pc0FmdGVyID0gZnVuY3Rpb24gaXNBZnRlcihvdGhlckluc3RhbnQpIHtcbiAgICByZXR1cm4gdGhpcy5jb21wYXJlVG8ob3RoZXJJbnN0YW50KSA+IDA7XG4gIH07XG5cbiAgX3Byb3RvLmlzQmVmb3JlID0gZnVuY3Rpb24gaXNCZWZvcmUob3RoZXJJbnN0YW50KSB7XG4gICAgcmV0dXJuIHRoaXMuY29tcGFyZVRvKG90aGVySW5zdGFudCkgPCAwO1xuICB9O1xuXG4gIF9wcm90by5lcXVhbHMgPSBmdW5jdGlvbiBlcXVhbHMob3RoZXIpIHtcbiAgICBpZiAodGhpcyA9PT0gb3RoZXIpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIGlmIChvdGhlciBpbnN0YW5jZW9mIEluc3RhbnQpIHtcbiAgICAgIHJldHVybiB0aGlzLmVwb2NoU2Vjb25kKCkgPT09IG90aGVyLmVwb2NoU2Vjb25kKCkgJiYgdGhpcy5uYW5vKCkgPT09IG90aGVyLm5hbm8oKTtcbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2U7XG4gIH07XG5cbiAgX3Byb3RvLmhhc2hDb2RlID0gZnVuY3Rpb24gaGFzaENvZGUoKSB7XG4gICAgcmV0dXJuIE1hdGhVdGlsLmhhc2hDb2RlKHRoaXMuX3NlY29uZHMsIHRoaXMuX25hbm9zKTtcbiAgfTtcblxuICBfcHJvdG8udG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZygpIHtcbiAgICByZXR1cm4gRGF0ZVRpbWVGb3JtYXR0ZXIuSVNPX0lOU1RBTlQuZm9ybWF0KHRoaXMpO1xuICB9O1xuXG4gIF9wcm90by50b0pTT04gPSBmdW5jdGlvbiB0b0pTT04oKSB7XG4gICAgcmV0dXJuIHRoaXMudG9TdHJpbmcoKTtcbiAgfTtcblxuICByZXR1cm4gSW5zdGFudDtcbn0oVGVtcG9yYWwpO1xuZnVuY3Rpb24gX2luaXQkbCgpIHtcbiAgSW5zdGFudC5NSU5fU0VDT05EUyA9IC0zMTYxOTExOTIxOTIwMDtcbiAgSW5zdGFudC5NQVhfU0VDT05EUyA9IDMxNDk0ODE2NDAzMTk5O1xuICBJbnN0YW50LkVQT0NIID0gbmV3IEluc3RhbnQoMCwgMCk7XG4gIEluc3RhbnQuTUlOID0gSW5zdGFudC5vZkVwb2NoU2Vjb25kKEluc3RhbnQuTUlOX1NFQ09ORFMsIDApO1xuICBJbnN0YW50Lk1BWCA9IEluc3RhbnQub2ZFcG9jaFNlY29uZChJbnN0YW50Lk1BWF9TRUNPTkRTLCA5OTk5OTk5OTkpO1xuICBJbnN0YW50LkZST00gPSBjcmVhdGVUZW1wb3JhbFF1ZXJ5KCdJbnN0YW50LkZST00nLCBmdW5jdGlvbiAodGVtcG9yYWwpIHtcbiAgICByZXR1cm4gSW5zdGFudC5mcm9tKHRlbXBvcmFsKTtcbiAgfSk7XG59XG5cbnZhciBDbG9jayA9IGZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gQ2xvY2soKSB7fVxuXG4gIENsb2NrLnN5c3RlbVVUQyA9IGZ1bmN0aW9uIHN5c3RlbVVUQygpIHtcbiAgICByZXR1cm4gbmV3IFN5c3RlbUNsb2NrKFpvbmVPZmZzZXQuVVRDKTtcbiAgfTtcblxuICBDbG9jay5zeXN0ZW1EZWZhdWx0Wm9uZSA9IGZ1bmN0aW9uIHN5c3RlbURlZmF1bHRab25lKCkge1xuICAgIHJldHVybiBuZXcgU3lzdGVtQ2xvY2soWm9uZUlkLnN5c3RlbURlZmF1bHQoKSk7XG4gIH07XG5cbiAgQ2xvY2suc3lzdGVtID0gZnVuY3Rpb24gc3lzdGVtKHpvbmUpIHtcbiAgICByZXR1cm4gbmV3IFN5c3RlbUNsb2NrKHpvbmUpO1xuICB9O1xuXG4gIENsb2NrLmZpeGVkID0gZnVuY3Rpb24gZml4ZWQoZml4ZWRJbnN0YW50LCB6b25lSWQpIHtcbiAgICByZXR1cm4gbmV3IEZpeGVkQ2xvY2soZml4ZWRJbnN0YW50LCB6b25lSWQpO1xuICB9O1xuXG4gIENsb2NrLm9mZnNldCA9IGZ1bmN0aW9uIG9mZnNldChiYXNlQ2xvY2ssIGR1cmF0aW9uKSB7XG4gICAgcmV0dXJuIG5ldyBPZmZzZXRDbG9jayhiYXNlQ2xvY2ssIGR1cmF0aW9uKTtcbiAgfTtcblxuICB2YXIgX3Byb3RvID0gQ2xvY2sucHJvdG90eXBlO1xuXG4gIF9wcm90by5taWxsaXMgPSBmdW5jdGlvbiBtaWxsaXMoKSB7XG4gICAgYWJzdHJhY3RNZXRob2RGYWlsKCdDbG9jay5taWxsaXMnKTtcbiAgfTtcblxuICBfcHJvdG8uaW5zdGFudCA9IGZ1bmN0aW9uIGluc3RhbnQoKSB7XG4gICAgYWJzdHJhY3RNZXRob2RGYWlsKCdDbG9jay5pbnN0YW50Jyk7XG4gIH07XG5cbiAgX3Byb3RvLnpvbmUgPSBmdW5jdGlvbiB6b25lKCkge1xuICAgIGFic3RyYWN0TWV0aG9kRmFpbCgnQ2xvY2suem9uZScpO1xuICB9O1xuXG4gIF9wcm90by53aXRoWm9uZSA9IGZ1bmN0aW9uIHdpdGhab25lKCkge1xuICAgIGFic3RyYWN0TWV0aG9kRmFpbCgnQ2xvY2sud2l0aFpvbmUnKTtcbiAgfTtcblxuICByZXR1cm4gQ2xvY2s7XG59KCk7XG5cbnZhciBTeXN0ZW1DbG9jayA9IGZ1bmN0aW9uIChfQ2xvY2spIHtcbiAgX2luaGVyaXRzTG9vc2UoU3lzdGVtQ2xvY2ssIF9DbG9jayk7XG5cbiAgZnVuY3Rpb24gU3lzdGVtQ2xvY2soem9uZSkge1xuICAgIHZhciBfdGhpcztcblxuICAgIHJlcXVpcmVOb25OdWxsKHpvbmUsICd6b25lJyk7XG4gICAgX3RoaXMgPSBfQ2xvY2suY2FsbCh0aGlzKSB8fCB0aGlzO1xuICAgIF90aGlzLl96b25lID0gem9uZTtcbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cblxuICB2YXIgX3Byb3RvMiA9IFN5c3RlbUNsb2NrLnByb3RvdHlwZTtcblxuICBfcHJvdG8yLnpvbmUgPSBmdW5jdGlvbiB6b25lKCkge1xuICAgIHJldHVybiB0aGlzLl96b25lO1xuICB9O1xuXG4gIF9wcm90bzIubWlsbGlzID0gZnVuY3Rpb24gbWlsbGlzKCkge1xuICAgIHJldHVybiBuZXcgRGF0ZSgpLmdldFRpbWUoKTtcbiAgfTtcblxuICBfcHJvdG8yLmluc3RhbnQgPSBmdW5jdGlvbiBpbnN0YW50KCkge1xuICAgIHJldHVybiBJbnN0YW50Lm9mRXBvY2hNaWxsaSh0aGlzLm1pbGxpcygpKTtcbiAgfTtcblxuICBfcHJvdG8yLmVxdWFscyA9IGZ1bmN0aW9uIGVxdWFscyhvYmopIHtcbiAgICBpZiAob2JqIGluc3RhbmNlb2YgU3lzdGVtQ2xvY2spIHtcbiAgICAgIHJldHVybiB0aGlzLl96b25lLmVxdWFscyhvYmouX3pvbmUpO1xuICAgIH1cblxuICAgIHJldHVybiBmYWxzZTtcbiAgfTtcblxuICBfcHJvdG8yLndpdGhab25lID0gZnVuY3Rpb24gd2l0aFpvbmUoem9uZSkge1xuICAgIGlmICh6b25lLmVxdWFscyh0aGlzLl96b25lKSkge1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgcmV0dXJuIG5ldyBTeXN0ZW1DbG9jayh6b25lKTtcbiAgfTtcblxuICBfcHJvdG8yLnRvU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG4gICAgcmV0dXJuICdTeXN0ZW1DbG9ja1snICsgdGhpcy5fem9uZS50b1N0cmluZygpICsgJ10nO1xuICB9O1xuXG4gIHJldHVybiBTeXN0ZW1DbG9jaztcbn0oQ2xvY2spO1xuXG52YXIgRml4ZWRDbG9jayA9IGZ1bmN0aW9uIChfQ2xvY2syKSB7XG4gIF9pbmhlcml0c0xvb3NlKEZpeGVkQ2xvY2ssIF9DbG9jazIpO1xuXG4gIGZ1bmN0aW9uIEZpeGVkQ2xvY2soZml4ZWRJbnN0YW50LCB6b25lSWQpIHtcbiAgICB2YXIgX3RoaXMyO1xuXG4gICAgX3RoaXMyID0gX0Nsb2NrMi5jYWxsKHRoaXMpIHx8IHRoaXM7XG4gICAgX3RoaXMyLl9pbnN0YW50ID0gZml4ZWRJbnN0YW50O1xuICAgIF90aGlzMi5fem9uZUlkID0gem9uZUlkO1xuICAgIHJldHVybiBfdGhpczI7XG4gIH1cblxuICB2YXIgX3Byb3RvMyA9IEZpeGVkQ2xvY2sucHJvdG90eXBlO1xuXG4gIF9wcm90bzMuaW5zdGFudCA9IGZ1bmN0aW9uIGluc3RhbnQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2luc3RhbnQ7XG4gIH07XG5cbiAgX3Byb3RvMy5taWxsaXMgPSBmdW5jdGlvbiBtaWxsaXMoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2luc3RhbnQudG9FcG9jaE1pbGxpKCk7XG4gIH07XG5cbiAgX3Byb3RvMy56b25lID0gZnVuY3Rpb24gem9uZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fem9uZUlkO1xuICB9O1xuXG4gIF9wcm90bzMudG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZygpIHtcbiAgICByZXR1cm4gJ0ZpeGVkQ2xvY2tbXSc7XG4gIH07XG5cbiAgX3Byb3RvMy5lcXVhbHMgPSBmdW5jdGlvbiBlcXVhbHMob2JqKSB7XG4gICAgaWYgKG9iaiBpbnN0YW5jZW9mIEZpeGVkQ2xvY2spIHtcbiAgICAgIHJldHVybiB0aGlzLl9pbnN0YW50LmVxdWFscyhvYmouX2luc3RhbnQpICYmIHRoaXMuX3pvbmVJZC5lcXVhbHMob2JqLl96b25lSWQpO1xuICAgIH1cblxuICAgIHJldHVybiBmYWxzZTtcbiAgfTtcblxuICBfcHJvdG8zLndpdGhab25lID0gZnVuY3Rpb24gd2l0aFpvbmUoem9uZSkge1xuICAgIGlmICh6b25lLmVxdWFscyh0aGlzLl96b25lSWQpKSB7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICByZXR1cm4gbmV3IEZpeGVkQ2xvY2sodGhpcy5faW5zdGFudCwgem9uZSk7XG4gIH07XG5cbiAgcmV0dXJuIEZpeGVkQ2xvY2s7XG59KENsb2NrKTtcblxudmFyIE9mZnNldENsb2NrID0gZnVuY3Rpb24gKF9DbG9jazMpIHtcbiAgX2luaGVyaXRzTG9vc2UoT2Zmc2V0Q2xvY2ssIF9DbG9jazMpO1xuXG4gIGZ1bmN0aW9uIE9mZnNldENsb2NrKGJhc2VDbG9jaywgb2Zmc2V0KSB7XG4gICAgdmFyIF90aGlzMztcblxuICAgIF90aGlzMyA9IF9DbG9jazMuY2FsbCh0aGlzKSB8fCB0aGlzO1xuICAgIF90aGlzMy5fYmFzZUNsb2NrID0gYmFzZUNsb2NrO1xuICAgIF90aGlzMy5fb2Zmc2V0ID0gb2Zmc2V0O1xuICAgIHJldHVybiBfdGhpczM7XG4gIH1cblxuICB2YXIgX3Byb3RvNCA9IE9mZnNldENsb2NrLnByb3RvdHlwZTtcblxuICBfcHJvdG80LnpvbmUgPSBmdW5jdGlvbiB6b25lKCkge1xuICAgIHJldHVybiB0aGlzLl9iYXNlQ2xvY2suem9uZSgpO1xuICB9O1xuXG4gIF9wcm90bzQud2l0aFpvbmUgPSBmdW5jdGlvbiB3aXRoWm9uZSh6b25lKSB7XG4gICAgaWYgKHpvbmUuZXF1YWxzKHRoaXMuX2Jhc2VDbG9jay56b25lKCkpKSB7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICByZXR1cm4gbmV3IE9mZnNldENsb2NrKHRoaXMuX2Jhc2VDbG9jay53aXRoWm9uZSh6b25lKSwgdGhpcy5fb2Zmc2V0KTtcbiAgfTtcblxuICBfcHJvdG80Lm1pbGxpcyA9IGZ1bmN0aW9uIG1pbGxpcygpIHtcbiAgICByZXR1cm4gdGhpcy5fYmFzZUNsb2NrLm1pbGxpcygpICsgdGhpcy5fb2Zmc2V0LnRvTWlsbGlzKCk7XG4gIH07XG5cbiAgX3Byb3RvNC5pbnN0YW50ID0gZnVuY3Rpb24gaW5zdGFudCgpIHtcbiAgICByZXR1cm4gdGhpcy5fYmFzZUNsb2NrLmluc3RhbnQoKS5wbHVzKHRoaXMuX29mZnNldCk7XG4gIH07XG5cbiAgX3Byb3RvNC5lcXVhbHMgPSBmdW5jdGlvbiBlcXVhbHMob2JqKSB7XG4gICAgaWYgKG9iaiBpbnN0YW5jZW9mIE9mZnNldENsb2NrKSB7XG4gICAgICByZXR1cm4gdGhpcy5fYmFzZUNsb2NrLmVxdWFscyhvYmouX2Jhc2VDbG9jaykgJiYgdGhpcy5fb2Zmc2V0LmVxdWFscyhvYmouX29mZnNldCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9O1xuXG4gIF9wcm90bzQudG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZygpIHtcbiAgICByZXR1cm4gJ09mZnNldENsb2NrWycgKyB0aGlzLl9iYXNlQ2xvY2sgKyAnLCcgKyB0aGlzLl9vZmZzZXQgKyAnXSc7XG4gIH07XG5cbiAgcmV0dXJuIE9mZnNldENsb2NrO1xufShDbG9jayk7XG5cbi8qXG4gKiBAY29weXJpZ2h0IChjKSAyMDE2LCBQaGlsaXBwIFRow7xyd8OkY2h0ZXIgJiBQYXR0cmljayBIw7xwZXJcbiAqIEBjb3B5cmlnaHQgKGMpIDIwMDctcHJlc2VudCwgU3RlcGhlbiBDb2xlYm91cm5lICYgTWljaGFlbCBOYXNjaW1lbnRvIFNhbnRvc1xuICogQGxpY2Vuc2UgQlNELTMtQ2xhdXNlIChzZWUgTElDRU5TRSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZSlcbiAqL1xudmFyIFpvbmVPZmZzZXRUcmFuc2l0aW9uID0gZnVuY3Rpb24gKCkge1xuICBab25lT2Zmc2V0VHJhbnNpdGlvbi5vZiA9IGZ1bmN0aW9uIG9mKHRyYW5zaXRpb24sIG9mZnNldEJlZm9yZSwgb2Zmc2V0QWZ0ZXIpIHtcbiAgICByZXR1cm4gbmV3IFpvbmVPZmZzZXRUcmFuc2l0aW9uKHRyYW5zaXRpb24sIG9mZnNldEJlZm9yZSwgb2Zmc2V0QWZ0ZXIpO1xuICB9O1xuXG4gIGZ1bmN0aW9uIFpvbmVPZmZzZXRUcmFuc2l0aW9uKHRyYW5zaXRpb24sIG9mZnNldEJlZm9yZSwgb2Zmc2V0QWZ0ZXIpIHtcbiAgICByZXF1aXJlTm9uTnVsbCh0cmFuc2l0aW9uLCAndHJhbnNpdGlvbicpO1xuICAgIHJlcXVpcmVOb25OdWxsKG9mZnNldEJlZm9yZSwgJ29mZnNldEJlZm9yZScpO1xuICAgIHJlcXVpcmVOb25OdWxsKG9mZnNldEFmdGVyLCAnb2Zmc2V0QWZ0ZXInKTtcblxuICAgIGlmIChvZmZzZXRCZWZvcmUuZXF1YWxzKG9mZnNldEFmdGVyKSkge1xuICAgICAgdGhyb3cgbmV3IElsbGVnYWxBcmd1bWVudEV4Y2VwdGlvbignT2Zmc2V0cyBtdXN0IG5vdCBiZSBlcXVhbCcpO1xuICAgIH1cblxuICAgIGlmICh0cmFuc2l0aW9uLm5hbm8oKSAhPT0gMCkge1xuICAgICAgdGhyb3cgbmV3IElsbGVnYWxBcmd1bWVudEV4Y2VwdGlvbignTmFuby1vZi1zZWNvbmQgbXVzdCBiZSB6ZXJvJyk7XG4gICAgfVxuXG4gICAgaWYgKHRyYW5zaXRpb24gaW5zdGFuY2VvZiBMb2NhbERhdGVUaW1lKSB7XG4gICAgICB0aGlzLl90cmFuc2l0aW9uID0gdHJhbnNpdGlvbjtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5fdHJhbnNpdGlvbiA9IExvY2FsRGF0ZVRpbWUub2ZFcG9jaFNlY29uZCh0cmFuc2l0aW9uLCAwLCBvZmZzZXRCZWZvcmUpO1xuICAgIH1cblxuICAgIHRoaXMuX29mZnNldEJlZm9yZSA9IG9mZnNldEJlZm9yZTtcbiAgICB0aGlzLl9vZmZzZXRBZnRlciA9IG9mZnNldEFmdGVyO1xuICB9XG5cbiAgdmFyIF9wcm90byA9IFpvbmVPZmZzZXRUcmFuc2l0aW9uLnByb3RvdHlwZTtcblxuICBfcHJvdG8uaW5zdGFudCA9IGZ1bmN0aW9uIGluc3RhbnQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3RyYW5zaXRpb24udG9JbnN0YW50KHRoaXMuX29mZnNldEJlZm9yZSk7XG4gIH07XG5cbiAgX3Byb3RvLnRvRXBvY2hTZWNvbmQgPSBmdW5jdGlvbiB0b0Vwb2NoU2Vjb25kKCkge1xuICAgIHJldHVybiB0aGlzLl90cmFuc2l0aW9uLnRvRXBvY2hTZWNvbmQodGhpcy5fb2Zmc2V0QmVmb3JlKTtcbiAgfTtcblxuICBfcHJvdG8uZGF0ZVRpbWVCZWZvcmUgPSBmdW5jdGlvbiBkYXRlVGltZUJlZm9yZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fdHJhbnNpdGlvbjtcbiAgfTtcblxuICBfcHJvdG8uZGF0ZVRpbWVBZnRlciA9IGZ1bmN0aW9uIGRhdGVUaW1lQWZ0ZXIoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3RyYW5zaXRpb24ucGx1c1NlY29uZHModGhpcy5kdXJhdGlvblNlY29uZHMoKSk7XG4gIH07XG5cbiAgX3Byb3RvLm9mZnNldEJlZm9yZSA9IGZ1bmN0aW9uIG9mZnNldEJlZm9yZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fb2Zmc2V0QmVmb3JlO1xuICB9O1xuXG4gIF9wcm90by5vZmZzZXRBZnRlciA9IGZ1bmN0aW9uIG9mZnNldEFmdGVyKCkge1xuICAgIHJldHVybiB0aGlzLl9vZmZzZXRBZnRlcjtcbiAgfTtcblxuICBfcHJvdG8uZHVyYXRpb24gPSBmdW5jdGlvbiBkdXJhdGlvbigpIHtcbiAgICByZXR1cm4gRHVyYXRpb24ub2ZTZWNvbmRzKHRoaXMuZHVyYXRpb25TZWNvbmRzKCkpO1xuICB9O1xuXG4gIF9wcm90by5kdXJhdGlvblNlY29uZHMgPSBmdW5jdGlvbiBkdXJhdGlvblNlY29uZHMoKSB7XG4gICAgcmV0dXJuIHRoaXMuX29mZnNldEFmdGVyLnRvdGFsU2Vjb25kcygpIC0gdGhpcy5fb2Zmc2V0QmVmb3JlLnRvdGFsU2Vjb25kcygpO1xuICB9O1xuXG4gIF9wcm90by5pc0dhcCA9IGZ1bmN0aW9uIGlzR2FwKCkge1xuICAgIHJldHVybiB0aGlzLl9vZmZzZXRBZnRlci50b3RhbFNlY29uZHMoKSA+IHRoaXMuX29mZnNldEJlZm9yZS50b3RhbFNlY29uZHMoKTtcbiAgfTtcblxuICBfcHJvdG8uaXNPdmVybGFwID0gZnVuY3Rpb24gaXNPdmVybGFwKCkge1xuICAgIHJldHVybiB0aGlzLl9vZmZzZXRBZnRlci50b3RhbFNlY29uZHMoKSA8IHRoaXMuX29mZnNldEJlZm9yZS50b3RhbFNlY29uZHMoKTtcbiAgfTtcblxuICBfcHJvdG8uaXNWYWxpZE9mZnNldCA9IGZ1bmN0aW9uIGlzVmFsaWRPZmZzZXQob2Zmc2V0KSB7XG4gICAgcmV0dXJuIHRoaXMuaXNHYXAoKSA/IGZhbHNlIDogdGhpcy5fb2Zmc2V0QmVmb3JlLmVxdWFscyhvZmZzZXQpIHx8IHRoaXMuX29mZnNldEFmdGVyLmVxdWFscyhvZmZzZXQpO1xuICB9O1xuXG4gIF9wcm90by52YWxpZE9mZnNldHMgPSBmdW5jdGlvbiB2YWxpZE9mZnNldHMoKSB7XG4gICAgaWYgKHRoaXMuaXNHYXAoKSkge1xuICAgICAgcmV0dXJuIFtdO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gW3RoaXMuX29mZnNldEJlZm9yZSwgdGhpcy5fb2Zmc2V0QWZ0ZXJdO1xuICAgIH1cbiAgfTtcblxuICBfcHJvdG8uY29tcGFyZVRvID0gZnVuY3Rpb24gY29tcGFyZVRvKHRyYW5zaXRpb24pIHtcbiAgICByZXR1cm4gdGhpcy5pbnN0YW50KCkuY29tcGFyZVRvKHRyYW5zaXRpb24uaW5zdGFudCgpKTtcbiAgfTtcblxuICBfcHJvdG8uZXF1YWxzID0gZnVuY3Rpb24gZXF1YWxzKG90aGVyKSB7XG4gICAgaWYgKG90aGVyID09PSB0aGlzKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICBpZiAob3RoZXIgaW5zdGFuY2VvZiBab25lT2Zmc2V0VHJhbnNpdGlvbikge1xuICAgICAgdmFyIGQgPSBvdGhlcjtcbiAgICAgIHJldHVybiB0aGlzLl90cmFuc2l0aW9uLmVxdWFscyhkLl90cmFuc2l0aW9uKSAmJiB0aGlzLl9vZmZzZXRCZWZvcmUuZXF1YWxzKGQub2Zmc2V0QmVmb3JlKCkpICYmIHRoaXMuX29mZnNldEFmdGVyLmVxdWFscyhkLm9mZnNldEFmdGVyKCkpO1xuICAgIH1cblxuICAgIHJldHVybiBmYWxzZTtcbiAgfTtcblxuICBfcHJvdG8uaGFzaENvZGUgPSBmdW5jdGlvbiBoYXNoQ29kZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fdHJhbnNpdGlvbi5oYXNoQ29kZSgpIF4gdGhpcy5fb2Zmc2V0QmVmb3JlLmhhc2hDb2RlKCkgXiB0aGlzLl9vZmZzZXRBZnRlci5oYXNoQ29kZSgpID4+PiAxNjtcbiAgfTtcblxuICBfcHJvdG8udG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZygpIHtcbiAgICByZXR1cm4gJ1RyYW5zaXRpb25bJyArICh0aGlzLmlzR2FwKCkgPyAnR2FwJyA6ICdPdmVybGFwJykgKyAnIGF0ICcgKyB0aGlzLl90cmFuc2l0aW9uLnRvU3RyaW5nKCkgKyB0aGlzLl9vZmZzZXRCZWZvcmUudG9TdHJpbmcoKSArICcgdG8gJyArIHRoaXMuX29mZnNldEFmdGVyICsgJ10nO1xuICB9O1xuXG4gIHJldHVybiBab25lT2Zmc2V0VHJhbnNpdGlvbjtcbn0oKTtcblxuLypcbiAqIEBjb3B5cmlnaHQgKGMpIDIwMTYsIFBoaWxpcHAgVGjDvHJ3w6RjaHRlciAmIFBhdHRyaWNrIEjDvHBlclxuICogQGNvcHlyaWdodCAoYykgMjAwNy1wcmVzZW50LCBTdGVwaGVuIENvbGVib3VybmUgJiBNaWNoYWVsIE5hc2NpbWVudG8gU2FudG9zXG4gKiBAbGljZW5zZSBCU0QtMy1DbGF1c2UgKHNlZSBMSUNFTlNFIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlKVxuICovXG5mdW5jdGlvbiBfaW5pdCRtKCkge1xuICBUZW1wb3JhbFF1ZXJpZXMuWk9ORV9JRCA9IGNyZWF0ZVRlbXBvcmFsUXVlcnkoJ1pPTkVfSUQnLCBmdW5jdGlvbiAodGVtcG9yYWwpIHtcbiAgICByZXR1cm4gdGVtcG9yYWwucXVlcnkoVGVtcG9yYWxRdWVyaWVzLlpPTkVfSUQpO1xuICB9KTtcbiAgVGVtcG9yYWxRdWVyaWVzLkNIUk9OTyA9IGNyZWF0ZVRlbXBvcmFsUXVlcnkoJ0NIUk9OTycsIGZ1bmN0aW9uICh0ZW1wb3JhbCkge1xuICAgIHJldHVybiB0ZW1wb3JhbC5xdWVyeShUZW1wb3JhbFF1ZXJpZXMuQ0hST05PKTtcbiAgfSk7XG4gIFRlbXBvcmFsUXVlcmllcy5QUkVDSVNJT04gPSBjcmVhdGVUZW1wb3JhbFF1ZXJ5KCdQUkVDSVNJT04nLCBmdW5jdGlvbiAodGVtcG9yYWwpIHtcbiAgICByZXR1cm4gdGVtcG9yYWwucXVlcnkoVGVtcG9yYWxRdWVyaWVzLlBSRUNJU0lPTik7XG4gIH0pO1xuICBUZW1wb3JhbFF1ZXJpZXMuT0ZGU0VUID0gY3JlYXRlVGVtcG9yYWxRdWVyeSgnT0ZGU0VUJywgZnVuY3Rpb24gKHRlbXBvcmFsKSB7XG4gICAgaWYgKHRlbXBvcmFsLmlzU3VwcG9ydGVkKENocm9ub0ZpZWxkLk9GRlNFVF9TRUNPTkRTKSkge1xuICAgICAgcmV0dXJuIFpvbmVPZmZzZXQub2ZUb3RhbFNlY29uZHModGVtcG9yYWwuZ2V0KENocm9ub0ZpZWxkLk9GRlNFVF9TRUNPTkRTKSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG51bGw7XG4gIH0pO1xuICBUZW1wb3JhbFF1ZXJpZXMuWk9ORSA9IGNyZWF0ZVRlbXBvcmFsUXVlcnkoJ1pPTkUnLCBmdW5jdGlvbiAodGVtcG9yYWwpIHtcbiAgICB2YXIgem9uZSA9IHRlbXBvcmFsLnF1ZXJ5KFRlbXBvcmFsUXVlcmllcy5aT05FX0lEKTtcbiAgICByZXR1cm4gem9uZSAhPSBudWxsID8gem9uZSA6IHRlbXBvcmFsLnF1ZXJ5KFRlbXBvcmFsUXVlcmllcy5PRkZTRVQpO1xuICB9KTtcbiAgVGVtcG9yYWxRdWVyaWVzLkxPQ0FMX0RBVEUgPSBjcmVhdGVUZW1wb3JhbFF1ZXJ5KCdMT0NBTF9EQVRFJywgZnVuY3Rpb24gKHRlbXBvcmFsKSB7XG4gICAgaWYgKHRlbXBvcmFsLmlzU3VwcG9ydGVkKENocm9ub0ZpZWxkLkVQT0NIX0RBWSkpIHtcbiAgICAgIHJldHVybiBMb2NhbERhdGUub2ZFcG9jaERheSh0ZW1wb3JhbC5nZXRMb25nKENocm9ub0ZpZWxkLkVQT0NIX0RBWSkpO1xuICAgIH1cblxuICAgIHJldHVybiBudWxsO1xuICB9KTtcbiAgVGVtcG9yYWxRdWVyaWVzLkxPQ0FMX1RJTUUgPSBjcmVhdGVUZW1wb3JhbFF1ZXJ5KCdMT0NBTF9USU1FJywgZnVuY3Rpb24gKHRlbXBvcmFsKSB7XG4gICAgaWYgKHRlbXBvcmFsLmlzU3VwcG9ydGVkKENocm9ub0ZpZWxkLk5BTk9fT0ZfREFZKSkge1xuICAgICAgcmV0dXJuIExvY2FsVGltZS5vZk5hbm9PZkRheSh0ZW1wb3JhbC5nZXRMb25nKENocm9ub0ZpZWxkLk5BTk9fT0ZfREFZKSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG51bGw7XG4gIH0pO1xufVxuXG52YXIgU3lzdGVtRGVmYXVsdFpvbmVSdWxlcyA9IGZ1bmN0aW9uIChfWm9uZVJ1bGVzKSB7XG4gIF9pbmhlcml0c0xvb3NlKFN5c3RlbURlZmF1bHRab25lUnVsZXMsIF9ab25lUnVsZXMpO1xuXG4gIGZ1bmN0aW9uIFN5c3RlbURlZmF1bHRab25lUnVsZXMoKSB7XG4gICAgcmV0dXJuIF9ab25lUnVsZXMuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICB9XG5cbiAgdmFyIF9wcm90byA9IFN5c3RlbURlZmF1bHRab25lUnVsZXMucHJvdG90eXBlO1xuXG4gIF9wcm90by5pc0ZpeGVkT2Zmc2V0ID0gZnVuY3Rpb24gaXNGaXhlZE9mZnNldCgpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH07XG5cbiAgX3Byb3RvLm9mZnNldE9mSW5zdGFudCA9IGZ1bmN0aW9uIG9mZnNldE9mSW5zdGFudChpbnN0YW50KSB7XG4gICAgdmFyIG9mZnNldEluTWludXRlcyA9IG5ldyBEYXRlKGluc3RhbnQudG9FcG9jaE1pbGxpKCkpLmdldFRpbWV6b25lT2Zmc2V0KCk7XG4gICAgcmV0dXJuIFpvbmVPZmZzZXQub2ZUb3RhbE1pbnV0ZXMob2Zmc2V0SW5NaW51dGVzICogLTEpO1xuICB9O1xuXG4gIF9wcm90by5vZmZzZXRPZkVwb2NoTWlsbGkgPSBmdW5jdGlvbiBvZmZzZXRPZkVwb2NoTWlsbGkoZXBvY2hNaWxsaSkge1xuICAgIHZhciBvZmZzZXRJbk1pbnV0ZXMgPSBuZXcgRGF0ZShlcG9jaE1pbGxpKS5nZXRUaW1lem9uZU9mZnNldCgpO1xuICAgIHJldHVybiBab25lT2Zmc2V0Lm9mVG90YWxNaW51dGVzKG9mZnNldEluTWludXRlcyAqIC0xKTtcbiAgfTtcblxuICBfcHJvdG8ub2Zmc2V0T2ZMb2NhbERhdGVUaW1lID0gZnVuY3Rpb24gb2Zmc2V0T2ZMb2NhbERhdGVUaW1lKGxvY2FsRGF0ZVRpbWUpIHtcbiAgICB2YXIgZXBvY2hNaWxsaSA9IGxvY2FsRGF0ZVRpbWUudG9FcG9jaFNlY29uZChab25lT2Zmc2V0LlVUQykgKiAxMDAwO1xuICAgIHZhciBvZmZzZXRJbk1pbnV0ZXNCZWZvcmVQb3NzaWJsZVRyYW5zaXRpb24gPSBuZXcgRGF0ZShlcG9jaE1pbGxpKS5nZXRUaW1lem9uZU9mZnNldCgpO1xuICAgIHZhciBlcG9jaE1pbGxpU3lzdGVtWm9uZSA9IGVwb2NoTWlsbGkgKyBvZmZzZXRJbk1pbnV0ZXNCZWZvcmVQb3NzaWJsZVRyYW5zaXRpb24gKiA2MDAwMDtcbiAgICB2YXIgb2Zmc2V0SW5NaW51dGVzQWZ0ZXJQb3NzaWJsZVRyYW5zaXRpb24gPSBuZXcgRGF0ZShlcG9jaE1pbGxpU3lzdGVtWm9uZSkuZ2V0VGltZXpvbmVPZmZzZXQoKTtcbiAgICByZXR1cm4gWm9uZU9mZnNldC5vZlRvdGFsTWludXRlcyhvZmZzZXRJbk1pbnV0ZXNBZnRlclBvc3NpYmxlVHJhbnNpdGlvbiAqIC0xKTtcbiAgfTtcblxuICBfcHJvdG8udmFsaWRPZmZzZXRzID0gZnVuY3Rpb24gdmFsaWRPZmZzZXRzKGxvY2FsRGF0ZVRpbWUpIHtcbiAgICByZXR1cm4gW3RoaXMub2Zmc2V0T2ZMb2NhbERhdGVUaW1lKGxvY2FsRGF0ZVRpbWUpXTtcbiAgfTtcblxuICBfcHJvdG8udHJhbnNpdGlvbiA9IGZ1bmN0aW9uIHRyYW5zaXRpb24oKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH07XG5cbiAgX3Byb3RvLnN0YW5kYXJkT2Zmc2V0ID0gZnVuY3Rpb24gc3RhbmRhcmRPZmZzZXQoaW5zdGFudCkge1xuICAgIHJldHVybiB0aGlzLm9mZnNldE9mSW5zdGFudChpbnN0YW50KTtcbiAgfTtcblxuICBfcHJvdG8uZGF5bGlnaHRTYXZpbmdzID0gZnVuY3Rpb24gZGF5bGlnaHRTYXZpbmdzKCkge1xuICAgIHRoaXMuX3Rocm93Tm90U3VwcG9ydGVkKCk7XG4gIH07XG5cbiAgX3Byb3RvLmlzRGF5bGlnaHRTYXZpbmdzID0gZnVuY3Rpb24gaXNEYXlsaWdodFNhdmluZ3MoKSB7XG4gICAgdGhpcy5fdGhyb3dOb3RTdXBwb3J0ZWQoKTtcbiAgfTtcblxuICBfcHJvdG8uaXNWYWxpZE9mZnNldCA9IGZ1bmN0aW9uIGlzVmFsaWRPZmZzZXQoZGF0ZVRpbWUsIG9mZnNldCkge1xuICAgIHJldHVybiB0aGlzLm9mZnNldE9mTG9jYWxEYXRlVGltZShkYXRlVGltZSkuZXF1YWxzKG9mZnNldCk7XG4gIH07XG5cbiAgX3Byb3RvLm5leHRUcmFuc2l0aW9uID0gZnVuY3Rpb24gbmV4dFRyYW5zaXRpb24oKSB7XG4gICAgdGhpcy5fdGhyb3dOb3RTdXBwb3J0ZWQoKTtcbiAgfTtcblxuICBfcHJvdG8ucHJldmlvdXNUcmFuc2l0aW9uID0gZnVuY3Rpb24gcHJldmlvdXNUcmFuc2l0aW9uKCkge1xuICAgIHRoaXMuX3Rocm93Tm90U3VwcG9ydGVkKCk7XG4gIH07XG5cbiAgX3Byb3RvLnRyYW5zaXRpb25zID0gZnVuY3Rpb24gdHJhbnNpdGlvbnMoKSB7XG4gICAgdGhpcy5fdGhyb3dOb3RTdXBwb3J0ZWQoKTtcbiAgfTtcblxuICBfcHJvdG8udHJhbnNpdGlvblJ1bGVzID0gZnVuY3Rpb24gdHJhbnNpdGlvblJ1bGVzKCkge1xuICAgIHRoaXMuX3Rocm93Tm90U3VwcG9ydGVkKCk7XG4gIH07XG5cbiAgX3Byb3RvLl90aHJvd05vdFN1cHBvcnRlZCA9IGZ1bmN0aW9uIF90aHJvd05vdFN1cHBvcnRlZCgpIHtcbiAgICB0aHJvdyBuZXcgRGF0ZVRpbWVFeGNlcHRpb24oJ25vdCBzdXBwb3J0ZWQgb3BlcmF0aW9uJyk7XG4gIH07XG5cbiAgX3Byb3RvLmVxdWFscyA9IGZ1bmN0aW9uIGVxdWFscyhvdGhlcikge1xuICAgIGlmICh0aGlzID09PSBvdGhlciB8fCBvdGhlciBpbnN0YW5jZW9mIFN5c3RlbURlZmF1bHRab25lUnVsZXMpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9O1xuXG4gIF9wcm90by50b1N0cmluZyA9IGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuICAgIHJldHVybiAnU1lTVEVNJztcbiAgfTtcblxuICByZXR1cm4gU3lzdGVtRGVmYXVsdFpvbmVSdWxlcztcbn0oWm9uZVJ1bGVzKTtcblxudmFyIFN5c3RlbURlZmF1bHRab25lSWQgPSBmdW5jdGlvbiAoX1pvbmVJZCkge1xuICBfaW5oZXJpdHNMb29zZShTeXN0ZW1EZWZhdWx0Wm9uZUlkLCBfWm9uZUlkKTtcblxuICBmdW5jdGlvbiBTeXN0ZW1EZWZhdWx0Wm9uZUlkKCkge1xuICAgIHZhciBfdGhpcztcblxuICAgIF90aGlzID0gX1pvbmVJZC5jYWxsKHRoaXMpIHx8IHRoaXM7XG4gICAgX3RoaXMuX3J1bGVzID0gbmV3IFN5c3RlbURlZmF1bHRab25lUnVsZXMoKTtcbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cblxuICB2YXIgX3Byb3RvID0gU3lzdGVtRGVmYXVsdFpvbmVJZC5wcm90b3R5cGU7XG5cbiAgX3Byb3RvLnJ1bGVzID0gZnVuY3Rpb24gcnVsZXMoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3J1bGVzO1xuICB9O1xuXG4gIF9wcm90by5lcXVhbHMgPSBmdW5jdGlvbiBlcXVhbHMob3RoZXIpIHtcbiAgICBpZiAodGhpcyA9PT0gb3RoZXIpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIHJldHVybiBmYWxzZTtcbiAgfTtcblxuICBfcHJvdG8uaWQgPSBmdW5jdGlvbiBpZCgpIHtcbiAgICByZXR1cm4gJ1NZU1RFTSc7XG4gIH07XG5cbiAgcmV0dXJuIFN5c3RlbURlZmF1bHRab25lSWQ7XG59KFpvbmVJZCk7XG5cbi8qXG4gKiBAY29weXJpZ2h0IChjKSAyMDE2LCBQaGlsaXBwIFRow7xyd8OkY2h0ZXIgJiBQYXR0cmljayBIw7xwZXJcbiAqIEBjb3B5cmlnaHQgKGMpIDIwMDctcHJlc2VudCwgU3RlcGhlbiBDb2xlYm91cm5lICYgTWljaGFlbCBOYXNjaW1lbnRvIFNhbnRvc1xuICogQGxpY2Vuc2UgQlNELTMtQ2xhdXNlIChzZWUgTElDRU5TRSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZSlcbiAqL1xudmFyIFpvbmVJZEZhY3RvcnkgPSBmdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIFpvbmVJZEZhY3RvcnkoKSB7fVxuXG4gIFpvbmVJZEZhY3Rvcnkuc3lzdGVtRGVmYXVsdCA9IGZ1bmN0aW9uIHN5c3RlbURlZmF1bHQoKSB7XG4gICAgcmV0dXJuIFNZU1RFTV9ERUZBVUxUX1pPTkVfSURfSU5TVEFOQ0U7XG4gIH07XG5cbiAgWm9uZUlkRmFjdG9yeS5nZXRBdmFpbGFibGVab25lSWRzID0gZnVuY3Rpb24gZ2V0QXZhaWxhYmxlWm9uZUlkcygpIHtcbiAgICByZXR1cm4gWm9uZVJ1bGVzUHJvdmlkZXIuZ2V0QXZhaWxhYmxlWm9uZUlkcygpO1xuICB9O1xuXG4gIFpvbmVJZEZhY3Rvcnkub2YgPSBmdW5jdGlvbiBvZih6b25lSWQpIHtcbiAgICByZXF1aXJlTm9uTnVsbCh6b25lSWQsICd6b25lSWQnKTtcblxuICAgIGlmICh6b25lSWQgPT09ICdaJykge1xuICAgICAgcmV0dXJuIFpvbmVPZmZzZXQuVVRDO1xuICAgIH1cblxuICAgIGlmICh6b25lSWQubGVuZ3RoID09PSAxKSB7XG4gICAgICB0aHJvdyBuZXcgRGF0ZVRpbWVFeGNlcHRpb24oJ0ludmFsaWQgem9uZTogJyArIHpvbmVJZCk7XG4gICAgfVxuXG4gICAgaWYgKFN0cmluZ1V0aWwuc3RhcnRzV2l0aCh6b25lSWQsICcrJykgfHwgU3RyaW5nVXRpbC5zdGFydHNXaXRoKHpvbmVJZCwgJy0nKSkge1xuICAgICAgcmV0dXJuIFpvbmVPZmZzZXQub2Yoem9uZUlkKTtcbiAgICB9XG5cbiAgICBpZiAoem9uZUlkID09PSAnVVRDJyB8fCB6b25lSWQgPT09ICdHTVQnIHx8IHpvbmVJZCA9PT0gJ0dNVDAnIHx8IHpvbmVJZCA9PT0gJ1VUJykge1xuICAgICAgcmV0dXJuIG5ldyBab25lUmVnaW9uKHpvbmVJZCwgWm9uZU9mZnNldC5VVEMucnVsZXMoKSk7XG4gICAgfVxuXG4gICAgaWYgKFN0cmluZ1V0aWwuc3RhcnRzV2l0aCh6b25lSWQsICdVVEMrJykgfHwgU3RyaW5nVXRpbC5zdGFydHNXaXRoKHpvbmVJZCwgJ0dNVCsnKSB8fCBTdHJpbmdVdGlsLnN0YXJ0c1dpdGgoem9uZUlkLCAnVVRDLScpIHx8IFN0cmluZ1V0aWwuc3RhcnRzV2l0aCh6b25lSWQsICdHTVQtJykpIHtcbiAgICAgIHZhciBvZmZzZXQgPSBab25lT2Zmc2V0Lm9mKHpvbmVJZC5zdWJzdHJpbmcoMykpO1xuXG4gICAgICBpZiAob2Zmc2V0LnRvdGFsU2Vjb25kcygpID09PSAwKSB7XG4gICAgICAgIHJldHVybiBuZXcgWm9uZVJlZ2lvbih6b25lSWQuc3Vic3RyaW5nKDAsIDMpLCBvZmZzZXQucnVsZXMoKSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBuZXcgWm9uZVJlZ2lvbih6b25lSWQuc3Vic3RyaW5nKDAsIDMpICsgb2Zmc2V0LmlkKCksIG9mZnNldC5ydWxlcygpKTtcbiAgICB9XG5cbiAgICBpZiAoU3RyaW5nVXRpbC5zdGFydHNXaXRoKHpvbmVJZCwgJ1VUKycpIHx8IFN0cmluZ1V0aWwuc3RhcnRzV2l0aCh6b25lSWQsICdVVC0nKSkge1xuICAgICAgdmFyIF9vZmZzZXQgPSBab25lT2Zmc2V0Lm9mKHpvbmVJZC5zdWJzdHJpbmcoMikpO1xuXG4gICAgICBpZiAoX29mZnNldC50b3RhbFNlY29uZHMoKSA9PT0gMCkge1xuICAgICAgICByZXR1cm4gbmV3IFpvbmVSZWdpb24oJ1VUJywgX29mZnNldC5ydWxlcygpKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG5ldyBab25lUmVnaW9uKCdVVCcgKyBfb2Zmc2V0LmlkKCksIF9vZmZzZXQucnVsZXMoKSk7XG4gICAgfVxuXG4gICAgaWYgKHpvbmVJZCA9PT0gJ1NZU1RFTScpIHtcbiAgICAgIHJldHVybiBab25lSWQuc3lzdGVtRGVmYXVsdCgpO1xuICAgIH1cblxuICAgIHJldHVybiBab25lUmVnaW9uLm9mSWQoem9uZUlkKTtcbiAgfTtcblxuICBab25lSWRGYWN0b3J5Lm9mT2Zmc2V0ID0gZnVuY3Rpb24gb2ZPZmZzZXQocHJlZml4LCBvZmZzZXQpIHtcbiAgICByZXF1aXJlTm9uTnVsbChwcmVmaXgsICdwcmVmaXgnKTtcbiAgICByZXF1aXJlTm9uTnVsbChvZmZzZXQsICdvZmZzZXQnKTtcblxuICAgIGlmIChwcmVmaXgubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm4gb2Zmc2V0O1xuICAgIH1cblxuICAgIGlmIChwcmVmaXggPT09ICdHTVQnIHx8IHByZWZpeCA9PT0gJ1VUQycgfHwgcHJlZml4ID09PSAnVVQnKSB7XG4gICAgICBpZiAob2Zmc2V0LnRvdGFsU2Vjb25kcygpID09PSAwKSB7XG4gICAgICAgIHJldHVybiBuZXcgWm9uZVJlZ2lvbihwcmVmaXgsIG9mZnNldC5ydWxlcygpKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG5ldyBab25lUmVnaW9uKHByZWZpeCArIG9mZnNldC5pZCgpLCBvZmZzZXQucnVsZXMoKSk7XG4gICAgfVxuXG4gICAgdGhyb3cgbmV3IElsbGVnYWxBcmd1bWVudEV4Y2VwdGlvbignSW52YWxpZCBwcmVmaXgsIG11c3QgYmUgR01ULCBVVEMgb3IgVVQ6ICcgKyBwcmVmaXgpO1xuICB9O1xuXG4gIFpvbmVJZEZhY3RvcnkuZnJvbSA9IGZ1bmN0aW9uIGZyb20odGVtcG9yYWwpIHtcbiAgICByZXF1aXJlTm9uTnVsbCh0ZW1wb3JhbCwgJ3RlbXBvcmFsJyk7XG4gICAgdmFyIG9iaiA9IHRlbXBvcmFsLnF1ZXJ5KFRlbXBvcmFsUXVlcmllcy56b25lKCkpO1xuXG4gICAgaWYgKG9iaiA9PSBudWxsKSB7XG4gICAgICB0aHJvdyBuZXcgRGF0ZVRpbWVFeGNlcHRpb24oJ1VuYWJsZSB0byBvYnRhaW4gWm9uZUlkIGZyb20gVGVtcG9yYWxBY2Nlc3NvcjogJyArIHRlbXBvcmFsICsgJywgdHlwZSAnICsgKHRlbXBvcmFsLmNvbnN0cnVjdG9yICE9IG51bGwgPyB0ZW1wb3JhbC5jb25zdHJ1Y3Rvci5uYW1lIDogJycpKTtcbiAgICB9XG5cbiAgICByZXR1cm4gb2JqO1xuICB9O1xuXG4gIHJldHVybiBab25lSWRGYWN0b3J5O1xufSgpO1xudmFyIFNZU1RFTV9ERUZBVUxUX1pPTkVfSURfSU5TVEFOQ0UgPSBudWxsO1xuZnVuY3Rpb24gX2luaXQkbigpIHtcbiAgU1lTVEVNX0RFRkFVTFRfWk9ORV9JRF9JTlNUQU5DRSA9IG5ldyBTeXN0ZW1EZWZhdWx0Wm9uZUlkKCk7XG4gIFpvbmVJZC5zeXN0ZW1EZWZhdWx0ID0gWm9uZUlkRmFjdG9yeS5zeXN0ZW1EZWZhdWx0O1xuICBab25lSWQuZ2V0QXZhaWxhYmxlWm9uZUlkcyA9IFpvbmVJZEZhY3RvcnkuZ2V0QXZhaWxhYmxlWm9uZUlkcztcbiAgWm9uZUlkLm9mID0gWm9uZUlkRmFjdG9yeS5vZjtcbiAgWm9uZUlkLm9mT2Zmc2V0ID0gWm9uZUlkRmFjdG9yeS5vZk9mZnNldDtcbiAgWm9uZUlkLmZyb20gPSBab25lSWRGYWN0b3J5LmZyb207XG4gIFpvbmVPZmZzZXQuZnJvbSA9IFpvbmVJZEZhY3RvcnkuZnJvbTtcbiAgWm9uZUlkLlNZU1RFTSA9IFNZU1RFTV9ERUZBVUxUX1pPTkVfSURfSU5TVEFOQ0U7XG4gIFpvbmVJZC5VVEMgPSBab25lT2Zmc2V0Lm9mVG90YWxTZWNvbmRzKDApO1xufVxuXG4vKlxuICogQGNvcHlyaWdodCAoYykgMjAxNiwgUGhpbGlwcCBUaMO8cnfDpGNodGVyICYgUGF0dHJpY2sgSMO8cGVyXG4gKiBAbGljZW5zZSBCU0QtMy1DbGF1c2UgKHNlZSBMSUNFTlNFIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlKVxuICovXG52YXIgaXNJbml0ID0gZmFsc2U7XG5cbmZ1bmN0aW9uIGluaXQoKSB7XG4gIGlmIChpc0luaXQpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBpc0luaXQgPSB0cnVlO1xuICBfaW5pdCQxKCk7XG4gIF9pbml0KCk7XG4gIF9pbml0JDIoKTtcbiAgX2luaXQkMygpO1xuICBfaW5pdCRrKCk7XG4gIF9pbml0JDgoKTtcbiAgX2luaXQkbSgpO1xuICBfaW5pdCQ0KCk7XG4gIF9pbml0JGwoKTtcbiAgX2luaXQkaSgpO1xuICBfaW5pdCRqKCk7XG4gIF9pbml0JGQoKTtcbiAgX2luaXQkNSgpO1xuICBfaW5pdCRjKCk7XG4gIF9pbml0JGIoKTtcbiAgX2luaXQkNigpO1xuICBfaW5pdCQ3KCk7XG4gIF9pbml0JGcoKTtcbiAgX2luaXQkbigpO1xuICBfaW5pdCRlKCk7XG4gIF9pbml0JGEoKTtcbiAgX2luaXQkOSgpO1xuICBfaW5pdCRoKCk7XG4gIF9pbml0JGYoKTtcbn1cblxuaW5pdCgpO1xuXG4vKlxuICogQGNvcHlyaWdodCAoYykgMjAxNiwgUGhpbGlwcCBUaMO8cnfDpGNodGVyICYgUGF0dHJpY2sgSMO8cGVyXG4gKiBAbGljZW5zZSBCU0QtMy1DbGF1c2UgKHNlZSBMSUNFTlNFIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlKVxuICovXG5cbnZhciBUb05hdGl2ZUpzQ29udmVydGVyID0gZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBUb05hdGl2ZUpzQ29udmVydGVyKHRlbXBvcmFsLCB6b25lKSB7XG4gICAgdmFyIHpvbmVkRGF0ZVRpbWU7XG5cbiAgICBpZiAodGVtcG9yYWwgaW5zdGFuY2VvZiBMb2NhbERhdGUpIHtcbiAgICAgIHpvbmUgPSB6b25lID09IG51bGwgPyBab25lSWQuc3lzdGVtRGVmYXVsdCgpIDogem9uZTtcbiAgICAgIHpvbmVkRGF0ZVRpbWUgPSB0ZW1wb3JhbC5hdFN0YXJ0T2ZEYXkoem9uZSk7XG4gICAgfSBlbHNlIGlmICh0ZW1wb3JhbCBpbnN0YW5jZW9mIExvY2FsRGF0ZVRpbWUpIHtcbiAgICAgIHpvbmUgPSB6b25lID09IG51bGwgPyBab25lSWQuc3lzdGVtRGVmYXVsdCgpIDogem9uZTtcbiAgICAgIHpvbmVkRGF0ZVRpbWUgPSB0ZW1wb3JhbC5hdFpvbmUoem9uZSk7XG4gICAgfSBlbHNlIGlmICh0ZW1wb3JhbCBpbnN0YW5jZW9mIFpvbmVkRGF0ZVRpbWUpIHtcbiAgICAgIGlmICh6b25lID09IG51bGwpIHtcbiAgICAgICAgem9uZWREYXRlVGltZSA9IHRlbXBvcmFsO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgem9uZWREYXRlVGltZSA9IHRlbXBvcmFsLndpdGhab25lU2FtZUluc3RhbnQoem9uZSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBJbGxlZ2FsQXJndW1lbnRFeGNlcHRpb24oJ3Vuc3VwcG9ydGVkIGluc3RhbmNlIGZvciBjb252ZXJ0IG9wZXJhdGlvbjonICsgdGVtcG9yYWwpO1xuICAgIH1cblxuICAgIHRoaXMuaW5zdGFudCA9IHpvbmVkRGF0ZVRpbWUudG9JbnN0YW50KCk7XG4gIH1cblxuICB2YXIgX3Byb3RvID0gVG9OYXRpdmVKc0NvbnZlcnRlci5wcm90b3R5cGU7XG5cbiAgX3Byb3RvLnRvRGF0ZSA9IGZ1bmN0aW9uIHRvRGF0ZSgpIHtcbiAgICByZXR1cm4gbmV3IERhdGUodGhpcy5pbnN0YW50LnRvRXBvY2hNaWxsaSgpKTtcbiAgfTtcblxuICBfcHJvdG8udG9FcG9jaE1pbGxpID0gZnVuY3Rpb24gdG9FcG9jaE1pbGxpKCkge1xuICAgIHJldHVybiB0aGlzLmluc3RhbnQudG9FcG9jaE1pbGxpKCk7XG4gIH07XG5cbiAgcmV0dXJuIFRvTmF0aXZlSnNDb252ZXJ0ZXI7XG59KCk7XG5cbmZ1bmN0aW9uIGNvbnZlcnQodGVtcG9yYWwsIHpvbmUpIHtcbiAgcmV0dXJuIG5ldyBUb05hdGl2ZUpzQ29udmVydGVyKHRlbXBvcmFsLCB6b25lKTtcbn1cblxudmFyIE5hdGl2ZUpzVGVtcG9yYWwgPSBmdW5jdGlvbiAoX1RlbXBvcmFsQWNjZXNzb3IpIHtcbiAgX2luaGVyaXRzTG9vc2UoTmF0aXZlSnNUZW1wb3JhbCwgX1RlbXBvcmFsQWNjZXNzb3IpO1xuXG4gIGZ1bmN0aW9uIE5hdGl2ZUpzVGVtcG9yYWwoZGF0ZSwgem9uZSkge1xuICAgIHZhciBfdGhpcztcblxuICAgIGlmICh6b25lID09PSB2b2lkIDApIHtcbiAgICAgIHpvbmUgPSBab25lSWQuc3lzdGVtRGVmYXVsdCgpO1xuICAgIH1cblxuICAgIF90aGlzID0gX1RlbXBvcmFsQWNjZXNzb3IuY2FsbCh0aGlzKSB8fCB0aGlzO1xuICAgIF90aGlzLl96b25lID0gem9uZTtcblxuICAgIGlmIChkYXRlIGluc3RhbmNlb2YgRGF0ZSkge1xuICAgICAgX3RoaXMuX2Vwb2NoTWlsbGkgPSBkYXRlLmdldFRpbWUoKTtcbiAgICAgIHJldHVybiBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzKTtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBkYXRlLnRvRGF0ZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkYXRlLnRvRGF0ZSgpIGluc3RhbmNlb2YgRGF0ZSkge1xuICAgICAgX3RoaXMuX2Vwb2NoTWlsbGkgPSBkYXRlLnRvRGF0ZSgpLmdldFRpbWUoKTtcbiAgICAgIHJldHVybiBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzKTtcbiAgICB9XG5cbiAgICBhc3NlcnQoZmFsc2UsICdkYXRlIG11c3QgYmUgZWl0aGVyIGEgamF2YXNjcmlwdCBkYXRlIG9yIGEgbW9tZW50Jyk7XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG5cbiAgdmFyIF9wcm90byA9IE5hdGl2ZUpzVGVtcG9yYWwucHJvdG90eXBlO1xuXG4gIF9wcm90by5xdWVyeSA9IGZ1bmN0aW9uIHF1ZXJ5KF9xdWVyeSkge1xuICAgIHJlcXVpcmVOb25OdWxsKF9xdWVyeSwgJ3F1ZXJ5Jyk7XG5cbiAgICBpZiAoX3F1ZXJ5ID09PSBUZW1wb3JhbFF1ZXJpZXMubG9jYWxEYXRlKCkpIHtcbiAgICAgIHJldHVybiBMb2NhbERhdGUub2ZJbnN0YW50KEluc3RhbnQub2ZFcG9jaE1pbGxpKHRoaXMuX2Vwb2NoTWlsbGkpLCB0aGlzLl96b25lKTtcbiAgICB9IGVsc2UgaWYgKF9xdWVyeSA9PT0gVGVtcG9yYWxRdWVyaWVzLmxvY2FsVGltZSgpKSB7XG4gICAgICByZXR1cm4gTG9jYWxUaW1lLm9mSW5zdGFudChJbnN0YW50Lm9mRXBvY2hNaWxsaSh0aGlzLl9lcG9jaE1pbGxpKSwgdGhpcy5fem9uZSk7XG4gICAgfSBlbHNlIGlmIChfcXVlcnkgPT09IFRlbXBvcmFsUXVlcmllcy56b25lKCkpIHtcbiAgICAgIHJldHVybiB0aGlzLl96b25lO1xuICAgIH1cblxuICAgIHJldHVybiBfVGVtcG9yYWxBY2Nlc3Nvci5wcm90b3R5cGUucXVlcnkuY2FsbCh0aGlzLCBfcXVlcnkpO1xuICB9O1xuXG4gIF9wcm90by5nZXQgPSBmdW5jdGlvbiBnZXQoZmllbGQpIHtcbiAgICByZXR1cm4gdGhpcy5nZXRMb25nKGZpZWxkKTtcbiAgfTtcblxuICBfcHJvdG8uZ2V0TG9uZyA9IGZ1bmN0aW9uIGdldExvbmcoZmllbGQpIHtcbiAgICByZXF1aXJlTm9uTnVsbChmaWVsZCwgJ2ZpZWxkJyk7XG5cbiAgICBpZiAoZmllbGQgaW5zdGFuY2VvZiBDaHJvbm9GaWVsZCkge1xuICAgICAgc3dpdGNoIChmaWVsZCkge1xuICAgICAgICBjYXNlIENocm9ub0ZpZWxkLk5BTk9fT0ZfU0VDT05EOlxuICAgICAgICAgIHJldHVybiBNYXRoVXRpbC5mbG9vck1vZCh0aGlzLl9lcG9jaE1pbGxpLCAxMDAwKSAqIDEwMDAwMDA7XG5cbiAgICAgICAgY2FzZSBDaHJvbm9GaWVsZC5JTlNUQU5UX1NFQ09ORFM6XG4gICAgICAgICAgcmV0dXJuIE1hdGhVdGlsLmZsb29yRGl2KHRoaXMuX2Vwb2NoTWlsbGksIDEwMDApO1xuICAgICAgfVxuXG4gICAgICB0aHJvdyBuZXcgVW5zdXBwb3J0ZWRUZW1wb3JhbFR5cGVFeGNlcHRpb24oJ1Vuc3VwcG9ydGVkIGZpZWxkOiAnICsgZmllbGQpO1xuICAgIH1cblxuICAgIHJldHVybiBmaWVsZC5nZXRGcm9tKHRoaXMpO1xuICB9O1xuXG4gIF9wcm90by5pc1N1cHBvcnRlZCA9IGZ1bmN0aW9uIGlzU3VwcG9ydGVkKGZpZWxkKSB7XG4gICAgcmV0dXJuIGZpZWxkID09PSBDaHJvbm9GaWVsZC5JTlNUQU5UX1NFQ09ORFMgfHwgZmllbGQgPT09IENocm9ub0ZpZWxkLk5BTk9fT0ZfU0VDT05EO1xuICB9O1xuXG4gIHJldHVybiBOYXRpdmVKc1RlbXBvcmFsO1xufShUZW1wb3JhbEFjY2Vzc29yKTtcblxuZnVuY3Rpb24gbmF0aXZlSnMoZGF0ZSwgem9uZSkge1xuICByZXR1cm4gbmV3IE5hdGl2ZUpzVGVtcG9yYWwoZGF0ZSwgem9uZSk7XG59XG5cbmZ1bmN0aW9uIGJpbmRVc2UoanNKb2RhKSB7XG4gIHZhciB1c2VkID0gW107XG4gIHJldHVybiBmdW5jdGlvbiB1c2UoZm4pIHtcbiAgICBpZiAoIX51c2VkLmluZGV4T2YoZm4pKSB7XG4gICAgICBmbihqc0pvZGEpO1xuICAgICAgdXNlZC5wdXNoKGZuKTtcbiAgICB9XG5cbiAgICByZXR1cm4ganNKb2RhO1xuICB9O1xufVxuXG4vKipcbiAqIEBjb3B5cmlnaHQgKGMpIDIwMTYsIFBoaWxpcHAgVGjDvHJ3w6RjaHRlciAmIFBhdHRyaWNrIEjDvHBlclxuICogQGxpY2Vuc2UgQlNELTMtQ2xhdXNlIChzZWUgTElDRU5TRSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZSlcbiAqL1xudmFyIF8gPSB7XG4gIGFzc2VydDogYXNzZXJ0JDEsXG4gIERhdGVUaW1lQnVpbGRlcjogRGF0ZVRpbWVCdWlsZGVyLFxuICBEYXRlVGltZVBhcnNlQ29udGV4dDogRGF0ZVRpbWVQYXJzZUNvbnRleHQsXG4gIERhdGVUaW1lUHJpbnRDb250ZXh0OiBEYXRlVGltZVByaW50Q29udGV4dCxcbiAgTWF0aFV0aWw6IE1hdGhVdGlsLFxuICBTdHJpbmdVdGlsOiBTdHJpbmdVdGlsLFxuICBTdHJpbmdCdWlsZGVyOiBTdHJpbmdCdWlsZGVyXG59O1xudmFyIGpzSm9kYUV4cG9ydHMgPSB7XG4gIF86IF8sXG4gIGNvbnZlcnQ6IGNvbnZlcnQsXG4gIG5hdGl2ZUpzOiBuYXRpdmVKcyxcbiAgQXJpdGhtZXRpY0V4Y2VwdGlvbjogQXJpdGhtZXRpY0V4Y2VwdGlvbixcbiAgRGF0ZVRpbWVFeGNlcHRpb246IERhdGVUaW1lRXhjZXB0aW9uLFxuICBEYXRlVGltZVBhcnNlRXhjZXB0aW9uOiBEYXRlVGltZVBhcnNlRXhjZXB0aW9uLFxuICBJbGxlZ2FsQXJndW1lbnRFeGNlcHRpb246IElsbGVnYWxBcmd1bWVudEV4Y2VwdGlvbixcbiAgSWxsZWdhbFN0YXRlRXhjZXB0aW9uOiBJbGxlZ2FsU3RhdGVFeGNlcHRpb24sXG4gIFVuc3VwcG9ydGVkVGVtcG9yYWxUeXBlRXhjZXB0aW9uOiBVbnN1cHBvcnRlZFRlbXBvcmFsVHlwZUV4Y2VwdGlvbixcbiAgTnVsbFBvaW50ZXJFeGNlcHRpb246IE51bGxQb2ludGVyRXhjZXB0aW9uLFxuICBDbG9jazogQ2xvY2ssXG4gIERheU9mV2VlazogRGF5T2ZXZWVrLFxuICBEdXJhdGlvbjogRHVyYXRpb24sXG4gIEluc3RhbnQ6IEluc3RhbnQsXG4gIExvY2FsRGF0ZTogTG9jYWxEYXRlLFxuICBMb2NhbFRpbWU6IExvY2FsVGltZSxcbiAgTG9jYWxEYXRlVGltZTogTG9jYWxEYXRlVGltZSxcbiAgT2Zmc2V0VGltZTogT2Zmc2V0VGltZSxcbiAgT2Zmc2V0RGF0ZVRpbWU6IE9mZnNldERhdGVUaW1lLFxuICBNb250aDogTW9udGgsXG4gIE1vbnRoRGF5OiBNb250aERheSxcbiAgUGVyaW9kOiBQZXJpb2QsXG4gIFllYXI6IFllYXIsXG4gIFllYXJDb25zdGFudHM6IFllYXJDb25zdGFudHMsXG4gIFllYXJNb250aDogWWVhck1vbnRoLFxuICBab25lZERhdGVUaW1lOiBab25lZERhdGVUaW1lLFxuICBab25lT2Zmc2V0OiBab25lT2Zmc2V0LFxuICBab25lSWQ6IFpvbmVJZCxcbiAgWm9uZVJlZ2lvbjogWm9uZVJlZ2lvbixcbiAgWm9uZU9mZnNldFRyYW5zaXRpb246IFpvbmVPZmZzZXRUcmFuc2l0aW9uLFxuICBab25lUnVsZXM6IFpvbmVSdWxlcyxcbiAgWm9uZVJ1bGVzUHJvdmlkZXI6IFpvbmVSdWxlc1Byb3ZpZGVyLFxuICBDaHJvbm9Mb2NhbERhdGU6IENocm9ub0xvY2FsRGF0ZSxcbiAgQ2hyb25vTG9jYWxEYXRlVGltZTogQ2hyb25vTG9jYWxEYXRlVGltZSxcbiAgQ2hyb25vWm9uZWREYXRlVGltZTogQ2hyb25vWm9uZWREYXRlVGltZSxcbiAgSXNvQ2hyb25vbG9neTogSXNvQ2hyb25vbG9neSxcbiAgQ2hyb25vRmllbGQ6IENocm9ub0ZpZWxkLFxuICBDaHJvbm9Vbml0OiBDaHJvbm9Vbml0LFxuICBJc29GaWVsZHM6IElzb0ZpZWxkcyxcbiAgVGVtcG9yYWw6IFRlbXBvcmFsLFxuICBUZW1wb3JhbEFjY2Vzc29yOiBUZW1wb3JhbEFjY2Vzc29yLFxuICBUZW1wb3JhbEFkanVzdGVyOiBUZW1wb3JhbEFkanVzdGVyLFxuICBUZW1wb3JhbEFkanVzdGVyczogVGVtcG9yYWxBZGp1c3RlcnMsXG4gIFRlbXBvcmFsQW1vdW50OiBUZW1wb3JhbEFtb3VudCxcbiAgVGVtcG9yYWxGaWVsZDogVGVtcG9yYWxGaWVsZCxcbiAgVGVtcG9yYWxRdWVyaWVzOiBUZW1wb3JhbFF1ZXJpZXMsXG4gIFRlbXBvcmFsUXVlcnk6IFRlbXBvcmFsUXVlcnksXG4gIFRlbXBvcmFsVW5pdDogVGVtcG9yYWxVbml0LFxuICBWYWx1ZVJhbmdlOiBWYWx1ZVJhbmdlLFxuICBEYXRlVGltZUZvcm1hdHRlcjogRGF0ZVRpbWVGb3JtYXR0ZXIsXG4gIERhdGVUaW1lRm9ybWF0dGVyQnVpbGRlcjogRGF0ZVRpbWVGb3JtYXR0ZXJCdWlsZGVyLFxuICBEZWNpbWFsU3R5bGU6IERlY2ltYWxTdHlsZSxcbiAgUmVzb2x2ZXJTdHlsZTogUmVzb2x2ZXJTdHlsZSxcbiAgU2lnblN0eWxlOiBTaWduU3R5bGUsXG4gIFRleHRTdHlsZTogVGV4dFN0eWxlXG59O1xudmFyIHVzZSA9IGJpbmRVc2UoanNKb2RhRXhwb3J0cyk7XG5qc0pvZGFFeHBvcnRzLnVzZSA9IHVzZTtcblxuZXhwb3J0IHsgQXJpdGhtZXRpY0V4Y2VwdGlvbiwgQ2hyb25vRmllbGQsIENocm9ub0xvY2FsRGF0ZSwgQ2hyb25vTG9jYWxEYXRlVGltZSwgQ2hyb25vVW5pdCwgQ2hyb25vWm9uZWREYXRlVGltZSwgQ2xvY2ssIERhdGVUaW1lRXhjZXB0aW9uLCBEYXRlVGltZUZvcm1hdHRlciwgRGF0ZVRpbWVGb3JtYXR0ZXJCdWlsZGVyLCBEYXRlVGltZVBhcnNlRXhjZXB0aW9uLCBEYXlPZldlZWssIERlY2ltYWxTdHlsZSwgRHVyYXRpb24sIElsbGVnYWxBcmd1bWVudEV4Y2VwdGlvbiwgSWxsZWdhbFN0YXRlRXhjZXB0aW9uLCBJbnN0YW50LCBJc29DaHJvbm9sb2d5LCBJc29GaWVsZHMsIExvY2FsRGF0ZSwgTG9jYWxEYXRlVGltZSwgTG9jYWxUaW1lLCBNb250aCwgTW9udGhEYXksIE51bGxQb2ludGVyRXhjZXB0aW9uLCBPZmZzZXREYXRlVGltZSwgT2Zmc2V0VGltZSwgUGVyaW9kLCBSZXNvbHZlclN0eWxlLCBTaWduU3R5bGUsIFRlbXBvcmFsLCBUZW1wb3JhbEFjY2Vzc29yLCBUZW1wb3JhbEFkanVzdGVyLCBUZW1wb3JhbEFkanVzdGVycywgVGVtcG9yYWxBbW91bnQsIFRlbXBvcmFsRmllbGQsIFRlbXBvcmFsUXVlcmllcywgVGVtcG9yYWxRdWVyeSwgVGVtcG9yYWxVbml0LCBUZXh0U3R5bGUsIFVuc3VwcG9ydGVkVGVtcG9yYWxUeXBlRXhjZXB0aW9uLCBWYWx1ZVJhbmdlLCBZZWFyLCBZZWFyQ29uc3RhbnRzLCBZZWFyTW9udGgsIFpvbmVJZCwgWm9uZU9mZnNldCwgWm9uZU9mZnNldFRyYW5zaXRpb24sIFpvbmVSZWdpb24sIFpvbmVSdWxlcywgWm9uZVJ1bGVzUHJvdmlkZXIsIFpvbmVkRGF0ZVRpbWUsIF8sIGNvbnZlcnQsIG5hdGl2ZUpzLCB1c2UgfTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../../node_modules/@js-joda/core/dist/js-joda.esm.js\n\n}");

/***/ })

}]);